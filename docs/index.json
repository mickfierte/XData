{
  "api/XData.Mapping.Dynamic.IQueryStructure.html": {
    "href": "api/XData.Mapping.Dynamic.IQueryStructure.html",
    "title": "Interface IQueryStructure | XData website",
    "keywords": "Interface IQueryStructure Dynamic query structure interface Namespace : XData.Mapping.Dynamic Assembly : XData.docfx.dll Syntax public interface IQueryStructure Methods | Improve this Doc View Source AddFilters(String, Expression<Func<IInnerFilterAdapter, IFilterDescription>>[]) Add dynamic filters Declaration IQueryStructure AddFilters(string alias, params Expression<Func<IInnerFilterAdapter, IFilterDescription>>[] filters) Parameters Type Name Description String alias Source alias Expression < Func < IInnerFilterAdapter , IFilterDescription >>[] filters Dynamic filters Returns Type Description IQueryStructure | Improve this Doc View Source Call(IDataScope, Variable[]) Dynamic procedure call with no result set Declaration IDataQuery Call(IDataScope dataScope, params Variable[] variables) Parameters Type Name Description IDataScope dataScope Data scope Variable [] variables Data object variables Returns Type Description IDataQuery Procedure call result Remarks Hint: Use variables as parameter values Hint: To pass binary parameters use Base64 string value Hint: To pass UDT parameters use Xml-serialized value of mapped type See Also GetStructure(String, String, DataStructureFlag, Variable[]) IQueryStructure IQueryDescription <T> IQueryStructureAdapter | Improve this Doc View Source Call<TResult>(IDataScope, String, Variable[]) Dynamic procedure call Declaration IDataQuery<TResult> Call<TResult>(IDataScope dataScope, string resultSetName, params Variable[] variables) where TResult : class Parameters Type Name Description IDataScope dataScope Data scope String resultSetName Base result set name Variable [] variables Data object variables Returns Type Description IDataQuery <TResult> Procedure call result Type Parameters Name Description TResult Dynamic query result type Remarks Hint: Use variables as parameter values Hint: To pass binary parameters use Base64 string value Hint: To pass UDT parameters use Xml-serialized value of mapped type See Also GetStructure(String, String, DataStructureFlag, Variable[]) IQueryStructure IQueryDescription <T> IQueryStructureAdapter | Improve this Doc View Source Column<TResult>(String, Expression<Func<IQueryStructureAdapter, TResult>>) Dynamic query hidden property mapping Declaration IQueryStructure Column<TResult>(string name, Expression<Func<IQueryStructureAdapter, TResult>> mapper) Parameters Type Name Description String name Hidden property name Expression < Func < IQueryStructureAdapter , TResult>> mapper Property mapping expression Returns Type Description IQueryStructure Query structure Type Parameters Name Description TResult See Also GetStructure(String, String, DataStructureFlag, Variable[]) IQueryStructure IQueryStructureAdapter | Improve this Doc View Source DataTable(String, String, Expression<Func<IInnerFilterAdapter, IFilterDescription>>[]) Dynamic query table mapping Declaration IQueryStructure DataTable(string name, string alias, params Expression<Func<IInnerFilterAdapter, IFilterDescription>>[] filters) Parameters Type Name Description String name Table name String alias Table alias Expression < Func < IInnerFilterAdapter , IFilterDescription >>[] filters Filters and links applied to table Returns Type Description IQueryStructure Query structure See Also GetStructure(String, String, DataStructureFlag, Variable[]) IQueryStructure IFilterDescription | Improve this Doc View Source Distinct() Dynamic query distinct modificator Declaration IQueryStructure Distinct() Returns Type Description IQueryStructure Query structure | Improve this Doc View Source Hint(String, String, HintType) Dynamic query data source hint Declaration IQueryStructure Hint(string alias, string hint, HintType hintType = HintType.Select) Parameters Type Name Description String alias Data source alias String hint Hint HintType hintType Hint type Returns Type Description IQueryStructure Query structure See Also GetStructure(String, String, DataStructureFlag, Variable[]) | Improve this Doc View Source InnerView(String, Type, Expression<Func<ISubqueryLinkAdapter, IFilterDescription>>[]) Dynamic query inner view mapping Declaration IQueryStructure InnerView(string alias, Type innerViewType, params Expression<Func<ISubqueryLinkAdapter, IFilterDescription>>[] filters) Parameters Type Name Description String alias Inner view alias Type innerViewType Inner view statically mapped type Expression < Func < ISubqueryLinkAdapter , IFilterDescription >>[] filters Filters and links applied to inner view Returns Type Description IQueryStructure Query structure See Also GetStructure(String, String, DataStructureFlag, Variable[]) IQueryStructure IFilterDescription | Improve this Doc View Source InnerView<TInnerView>(String, Expression<Func<ISubqueryLinkAdapter<TInnerView>, IFilterDescription>>[]) Dynamic query inner view mapping Declaration IQueryStructure InnerView<TInnerView>(string alias, params Expression<Func<ISubqueryLinkAdapter<TInnerView>, IFilterDescription>>[] filters) where TInnerView : class Parameters Type Name Description String alias Inner view alias Expression < Func < ISubqueryLinkAdapter <TInnerView>, IFilterDescription >>[] filters Filters and links applied to inner view Returns Type Description IQueryStructure Query structure Type Parameters Name Description TInnerView Inner view statically mapped type See Also GetStructure(String, String, DataStructureFlag, Variable[]) IQueryStructure IFilterDescription | Improve this Doc View Source InnerView<TInnerView>(String, IQueryDescription<TInnerView>, Expression<Func<ISubqueryLinkAdapter<TInnerView>, IFilterDescription>>[]) Dynamic query inner view mapping Declaration IQueryStructure InnerView<TInnerView>(string alias, IQueryDescription<TInnerView> sub, params Expression<Func<ISubqueryLinkAdapter<TInnerView>, IFilterDescription>>[] filters) where TInnerView : class Parameters Type Name Description String alias Inner view alias IQueryDescription <TInnerView> sub Inner view query structure Expression < Func < ISubqueryLinkAdapter <TInnerView>, IFilterDescription >>[] filters Filters and links applied to inner view Returns Type Description IQueryStructure Query structure Type Parameters Name Description TInnerView See Also GetStructure(String, String, DataStructureFlag, Variable[]) IQueryStructure IQueryDescription IFilterDescription | Improve this Doc View Source Limit(Int32) Dynamic query limit count modificator Declaration IQueryStructure Limit(int count) Parameters Type Name Description Int32 count Limit records count Returns Type Description IQueryStructure Query structure | Improve this Doc View Source Map<TResult>(Expression<Func<IRepositoryStructureAdapter<TResult>, TResult>>, Expression<Func<IRepositoryStructureAdapter<TResult>, IExternalLinkDefinition>>[]) Dynamic repository mapping Declaration IRepositoryDescription<TResult> Map<TResult>(Expression<Func<IRepositoryStructureAdapter<TResult>, TResult>> mapper, params Expression<Func<IRepositoryStructureAdapter<TResult>, IExternalLinkDefinition>>[] externalLinks) where TResult : class, IDataObject, new() Parameters Type Name Description Expression < Func < IRepositoryStructureAdapter <TResult>, TResult>> mapper Mapping expression Expression < Func < IRepositoryStructureAdapter <TResult>, IExternalLinkDefinition >>[] externalLinks External link descriptions Returns Type Description IRepositoryDescription <TResult> Dynamic repository description Type Parameters Name Description TResult Dynamic repository type See Also GetStructure(String, String, DataStructureFlag, Variable[]) IQueryStructure IQueryDescription <T> IQueryStructureAdapter | Improve this Doc View Source Parameter<T>(String, Int32, String, DbType, Expression<Func<IProcedureParameterAdapter, IProcedureParameterFlag>>[]) Dynamic query procedure parameter mapping Declaration IQueryStructure Parameter<T>(string alias, int order, string binding, DbType type, params Expression<Func<IProcedureParameterAdapter, IProcedureParameterFlag>>[] attributes) Parameters Type Name Description String alias Procedure alias Int32 order Parameter order String binding Parameter value binding DbType type Parameter SQL data type Expression < Func < IProcedureParameterAdapter , IProcedureParameterFlag >>[] attributes Parameter mapping attributes Returns Type Description IQueryStructure Query structure Type Parameters Name Description T Parameter data type | Improve this Doc View Source Procedure(String, String, ProcedureType, Expression<Func<IInnerFilterAdapter, IFilterDescription>>[]) Dynamic query procedure mapping Declaration IQueryStructure Procedure(string alias, string name, ProcedureType type, params Expression<Func<IInnerFilterAdapter, IFilterDescription>>[] filters) Parameters Type Name Description String alias Procedure alias String name Procedure name ProcedureType type Procedure type Expression < Func < IInnerFilterAdapter , IFilterDescription >>[] filters Filters and links applied to table Returns Type Description IQueryStructure Query structure See Also GetStructure(String, String, DataStructureFlag, Variable[]) IQueryStructure IFilterDescription | Improve this Doc View Source Return<T>(String, String, Int32, Expression<Func<IQueryStructureAdapter, T>>) Dynamic query procedure result set mapping Declaration IQueryStructure Return<T>(string alias, string name, int order, Expression<Func<IQueryStructureAdapter, T>> mapper = null) where T : class Parameters Type Name Description String alias Procedure alias String name Result set name Int32 order Result set order Expression < Func < IQueryStructureAdapter , T>> mapper Result set mapper Returns Type Description IQueryStructure Query structure Type Parameters Name Description T Parameter data type | Improve this Doc View Source Select<TResult>() Dynamic query result mapping using statically mapped data Declaration IQueryDescription<TResult> Select<TResult>() where TResult : class, IDataObject, new() Returns Type Description IQueryDescription <TResult> Dynamic query description Type Parameters Name Description TResult Dynamic query result type See Also GetStructure(String, String, DataStructureFlag, Variable[]) IQueryStructure IQueryDescription <T> IQueryStructureAdapter | Improve this Doc View Source Select<TResult>(Expression<Func<IQueryStructureAdapter, TResult>>) Dynamic query result mapping Declaration IQueryDescription<TResult> Select<TResult>(Expression<Func<IQueryStructureAdapter, TResult>> mapper) where TResult : class Parameters Type Name Description Expression < Func < IQueryStructureAdapter , TResult>> mapper Mapping expression Returns Type Description IQueryDescription <TResult> Dynamic query description Type Parameters Name Description TResult Dynamic query result type See Also GetStructure(String, String, DataStructureFlag, Variable[]) IQueryStructure IQueryDescription <T> IQueryStructureAdapter | Improve this Doc View Source Skip(Int32) Dynamic query skip count modificator Declaration IQueryStructure Skip(int count) Parameters Type Name Description Int32 count Skip records count Returns Type Description IQueryStructure Query structure | Improve this Doc View Source Subquery(String, Type, String, DataGrouping, Expression<Func<ISubqueryLinkAdapter, IFilterDescription>>[]) Dynamic query subquery mapping Declaration IQueryStructure Subquery(string alias, Type subqueryType, string property, DataGrouping grouping = DataGrouping.None, params Expression<Func<ISubqueryLinkAdapter, IFilterDescription>>[] filters) Parameters Type Name Description String alias Subquery alias Type subqueryType Subquery statically mapped type String property Subquery selected property DataGrouping grouping Subquery selected property aggregate function Expression < Func < ISubqueryLinkAdapter , IFilterDescription >>[] filters Filters and links applied to subquery Returns Type Description IQueryStructure Query structure See Also GetStructure(String, String, DataStructureFlag, Variable[]) IQueryStructure IFilterDescription | Improve this Doc View Source Subquery<TSubquery>(String, Expression<Func<TSubquery, Object>>, DataGrouping, Expression<Func<ISubqueryLinkAdapter<TSubquery>, IFilterDescription>>[]) Dynamic query subquery mapping Declaration IQueryStructure Subquery<TSubquery>(string alias, Expression<Func<TSubquery, object>> property, DataGrouping grouping = DataGrouping.None, params Expression<Func<ISubqueryLinkAdapter<TSubquery>, IFilterDescription>>[] filters) where TSubquery : class Parameters Type Name Description String alias Subquery alias Expression < Func <TSubquery, Object >> property Subquery selected property expression DataGrouping grouping Subquery selected property aggregate function Expression < Func < ISubqueryLinkAdapter <TSubquery>, IFilterDescription >>[] filters Filters and links applied to subquery Returns Type Description IQueryStructure Query structure Type Parameters Name Description TSubquery Subquery statically mapped type See Also GetStructure(String, String, DataStructureFlag, Variable[]) IQueryStructure IFilterDescription | Improve this Doc View Source Subquery<TSubquery>(String, IQueryDescription<TSubquery>, String, DataGrouping, Expression<Func<ISubqueryLinkAdapter<TSubquery>, IFilterDescription>>[]) Dynamic query subquery mapping Declaration IQueryStructure Subquery<TSubquery>(string alias, IQueryDescription<TSubquery> sub, string property, DataGrouping grouping = DataGrouping.None, params Expression<Func<ISubqueryLinkAdapter<TSubquery>, IFilterDescription>>[] filters) where TSubquery : class Parameters Type Name Description String alias Subquery alias IQueryDescription <TSubquery> sub Subquery query structure String property Subquery selected property DataGrouping grouping Subquery selected property aggregate function Expression < Func < ISubqueryLinkAdapter <TSubquery>, IFilterDescription >>[] filters Filters and links applied to subquery Returns Type Description IQueryStructure Query structure Type Parameters Name Description TSubquery See Also GetStructure(String, String, DataStructureFlag, Variable[]) IQueryStructure IQueryDescription DataGrouping IFilterDescription | Improve this Doc View Source TempTable(String, String, Expression<Func<IInnerFilterAdapter, IFilterDescription>>[]) Dynamic query temporary table mapping Declaration IQueryStructure TempTable(string name, string alias, params Expression<Func<IInnerFilterAdapter, IFilterDescription>>[] filters) Parameters Type Name Description String name Temporary table data variable name String alias Temporary table data source alias Expression < Func < IInnerFilterAdapter , IFilterDescription >>[] filters Filters and links applied to temporary table data source Returns Type Description IQueryStructure Query structure Remarks Data passed to query as variable with name equals name of temporary table data source Variable value must to be DataTable See Also GetStructure(String, String, DataStructureFlag, Variable[]) IQueryStructure IFilterDescription | Improve this Doc View Source With<TRoot>(String, IQueryDescription<TRoot>, Expression<Func<IQueryWithAdapter<TRoot>, IQueryWithFlag>>[]) Dynamic query Common-Table-Expression (WITH) subquery mapping Declaration IQueryStructure With<TRoot>(string alias, IQueryDescription<TRoot> sub, params Expression<Func<IQueryWithAdapter<TRoot>, IQueryWithFlag>>[] attributes) where TRoot : class Parameters Type Name Description String alias Common-Table-Expression (WITH) subquery alias IQueryDescription <TRoot> sub Common-Table-Expression (WITH) initial subquery description Expression < Func < IQueryWithAdapter <TRoot>, IQueryWithFlag >>[] attributes Common-Table-Expression (WITH) attributes Returns Type Description IQueryStructure Query structure Type Parameters Name Description TRoot Common-Table-Expression (WITH) initial subquery mapped type | Improve this Doc View Source XmlSource(String, String, String, Expression<Func<IInnerFilterAdapter, IFilterDescription>>[]) Dynamic query XML data source mapping Declaration IQueryStructure XmlSource(string name, string alias, string xmlRoot, params Expression<Func<IInnerFilterAdapter, IFilterDescription>>[] filters) Parameters Type Name Description String name XML data variable name String alias XML data source alias String xmlRoot XML data root XPath expression Expression < Func < IInnerFilterAdapter , IFilterDescription >>[] filters Filters and links applied to XML data source Returns Type Description IQueryStructure Query structure Remarks XML data passed to query as variable with name equals name of XML data source Variable value must to be a String See Also GetStructure(String, String, DataStructureFlag, Variable[]) IQueryStructure IFilterDescription Extension Methods SerializationExtensions.ToXml<T>(T) CollectionsExtensions.SetValue<TKey, T>(TKey, T) CollectionsExtensions.AsEnum<T>(T) DataObjectQueryableExtensions.CompareVariable(Object, FilterOperation, String) Processing.Do<T>(T, Action<IProcess<T>>[]) TypeExtensions.TryConvert<T, TResult>(T, Func<T, TResult>) TypeExtensions.TryConvert<T, TResult>(T, Func<T, TResult>, TResult) TypeExtensions.ChangeType<T>(Object) TypeExtensions.ChangeType(Object, Type) TypeExtensions.InvokeMethod<TRet>(Object, Type[], Expression<Func<TRet>>, BindingFlags) TypeExtensions.InvokeMethod(Object, Type[], Expression<Action>, BindingFlags) TypeExtensions.InvokeMethod<TRet>(Object, Expression<Func<TRet>>, BindingFlags) TypeExtensions.InvokeMethod(Object, Expression<Action>, BindingFlags) SqlBlockExtensions.SetExpression<TTag, TResult>(TTag, Expression<Func<IBlockQueryAdapter, TResult>>) QueryDescriptionExtensions.SetExpression<TTag, TResult>(TTag, Expression<Func<IQueryStructureAdapter, TResult>>) See Also GetStructure(String, String, DataStructureFlag, Variable[])"
  },
  "api/XData.Mapping.Dynamic.IQueryDescription.html": {
    "href": "api/XData.Mapping.Dynamic.IQueryDescription.html",
    "title": "Interface IQueryDescription | XData website",
    "keywords": "Interface IQueryDescription Dynamic query description basic interface Namespace : XData.Mapping.Dynamic Assembly : XData.docfx.dll Syntax public interface IQueryDescription Properties | Improve this Doc View Source Type Dynamic query description element type Declaration Type Type { get; } Property Value Type Description Type Extension Methods SerializationExtensions.ToXml<T>(T) CollectionsExtensions.SetValue<TKey, T>(TKey, T) CollectionsExtensions.AsEnum<T>(T) DataObjectQueryableExtensions.CompareVariable(Object, FilterOperation, String) Processing.Do<T>(T, Action<IProcess<T>>[]) TypeExtensions.TryConvert<T, TResult>(T, Func<T, TResult>) TypeExtensions.TryConvert<T, TResult>(T, Func<T, TResult>, TResult) TypeExtensions.ChangeType<T>(Object) TypeExtensions.ChangeType(Object, Type) TypeExtensions.InvokeMethod<TRet>(Object, Type[], Expression<Func<TRet>>, BindingFlags) TypeExtensions.InvokeMethod(Object, Type[], Expression<Action>, BindingFlags) TypeExtensions.InvokeMethod<TRet>(Object, Expression<Func<TRet>>, BindingFlags) TypeExtensions.InvokeMethod(Object, Expression<Action>, BindingFlags) SqlBlockExtensions.SetExpression<TTag, TResult>(TTag, Expression<Func<IBlockQueryAdapter, TResult>>) QueryDescriptionExtensions.SetExpression<TTag, TResult>(TTag, Expression<Func<IQueryStructureAdapter, TResult>>)"
  },
  "api/XData.Mapping.Dynamic.IQueryDescription-1.html": {
    "href": "api/XData.Mapping.Dynamic.IQueryDescription-1.html",
    "title": "Interface IQueryDescription<T> | XData website",
    "keywords": "Interface IQueryDescription<T> Dynamic query description with result type specified interface Inherited Members IQueryDescription.Type Namespace : XData.Mapping.Dynamic Assembly : XData.docfx.dll Syntax public interface IQueryDescription<out T> : IQueryDescription Type Parameters Name Description T Query description element type Methods | Improve this Doc View Source AsQuery(IDataScope, Variable[]) Returns queryable data source based on description Declaration IDataQuery<T> AsQuery(IDataScope dataScope, params Variable[] variables) Parameters Type Name Description IDataScope dataScope Data scope Variable [] variables Object variables values Returns Type Description IDataQuery <T> Data source Extension Methods SerializationExtensions.ToXml<T>(T) CollectionsExtensions.SetValue<TKey, T>(TKey, T) CollectionsExtensions.AsEnum<T>(T) DataObjectQueryableExtensions.CompareVariable(Object, FilterOperation, String) Processing.Do<T>(T, Action<IProcess<T>>[]) TypeExtensions.TryConvert<T, TResult>(T, Func<T, TResult>) TypeExtensions.TryConvert<T, TResult>(T, Func<T, TResult>, TResult) TypeExtensions.ChangeType<T>(Object) TypeExtensions.ChangeType(Object, Type) TypeExtensions.InvokeMethod<TRet>(Object, Type[], Expression<Func<TRet>>, BindingFlags) TypeExtensions.InvokeMethod(Object, Type[], Expression<Action>, BindingFlags) TypeExtensions.InvokeMethod<TRet>(Object, Expression<Func<TRet>>, BindingFlags) TypeExtensions.InvokeMethod(Object, Expression<Action>, BindingFlags) SqlBlockExtensions.SetExpression<TTag, TResult>(TTag, Expression<Func<IBlockQueryAdapter, TResult>>) QueryDescriptionExtensions.SetExpression<TTag, TResult>(TTag, Expression<Func<IQueryStructureAdapter, TResult>>)"
  },
  "api/XData.Json.JsonDataObjectConverter-1.html": {
    "href": "api/XData.Json.JsonDataObjectConverter-1.html",
    "title": "Class JsonDataObjectConverter<T> | XData website",
    "keywords": "Class JsonDataObjectConverter<T> Inheritance Object Newtonsoft.Json.JsonConverter JsonDataObjectConverter<T> Inherited Members Newtonsoft.Json.JsonConverter.GetSchema() Newtonsoft.Json.JsonConverter.CanRead Newtonsoft.Json.JsonConverter.CanWrite Object.Equals(Object) Object.Equals(Object, Object) Object.GetHashCode() Object.GetType() Object.MemberwiseClone() Object.ReferenceEquals(Object, Object) Object.ToString() Namespace : XData.Json Assembly : XData.docfx.dll Syntax public class JsonDataObjectConverter<T> : JsonConverter where T : class, IDataObject Type Parameters Name Description T Methods | Improve this Doc View Source CanConvert(Type) Declaration public override bool CanConvert(Type objectType) Parameters Type Name Description Type objectType Returns Type Description Boolean Overrides Newtonsoft.Json.JsonConverter.CanConvert(System.Type) | Improve this Doc View Source ReadJson(JsonReader, Type, Object, JsonSerializer) Declaration public override object ReadJson(JsonReader reader, Type objectType, object existingValue, JsonSerializer serializer) Parameters Type Name Description Newtonsoft.Json.JsonReader reader Type objectType Object existingValue Newtonsoft.Json.JsonSerializer serializer Returns Type Description Object Overrides Newtonsoft.Json.JsonConverter.ReadJson(Newtonsoft.Json.JsonReader, System.Type, System.Object, Newtonsoft.Json.JsonSerializer) | Improve this Doc View Source WriteJson(JsonWriter, Object, JsonSerializer) Declaration public override void WriteJson(JsonWriter writer, object value, JsonSerializer serializer) Parameters Type Name Description Newtonsoft.Json.JsonWriter writer Object value Newtonsoft.Json.JsonSerializer serializer Overrides Newtonsoft.Json.JsonConverter.WriteJson(Newtonsoft.Json.JsonWriter, System.Object, Newtonsoft.Json.JsonSerializer) Extension Methods SerializationExtensions.ToXml<T>(T) CollectionsExtensions.SetValue<TKey, T>(TKey, T) CollectionsExtensions.AsEnum<T>(T) DataObjectQueryableExtensions.CompareVariable(Object, FilterOperation, String) Processing.Do<T>(T, Action<IProcess<T>>[]) TypeExtensions.TryConvert<T, TResult>(T, Func<T, TResult>) TypeExtensions.TryConvert<T, TResult>(T, Func<T, TResult>, TResult) TypeExtensions.ChangeType<T>(Object) TypeExtensions.ChangeType(Object, Type) TypeExtensions.InvokeMethod<TRet>(Object, Type[], Expression<Func<TRet>>, BindingFlags) TypeExtensions.InvokeMethod(Object, Type[], Expression<Action>, BindingFlags) TypeExtensions.InvokeMethod<TRet>(Object, Expression<Func<TRet>>, BindingFlags) TypeExtensions.InvokeMethod(Object, Expression<Action>, BindingFlags) SqlBlockExtensions.SetExpression<TTag, TResult>(TTag, Expression<Func<IBlockQueryAdapter, TResult>>) QueryDescriptionExtensions.SetExpression<TTag, TResult>(TTag, Expression<Func<IQueryStructureAdapter, TResult>>)"
  },
  "api/XData.Json.HideFlags.html": {
    "href": "api/XData.Json.HideFlags.html",
    "title": "Enum HideFlags | XData website",
    "keywords": "Enum HideFlags Serialization hide flag for properties Namespace : XData.Json Assembly : XData.docfx.dll Syntax [Flags] public enum HideFlags Fields Name Description Columns Hide all columns ReadOnly Hide all Read only properties Extension Methods SerializationExtensions.ToXml<HideFlags>() CollectionsExtensions.SetValue<HideFlags, T>(T) CollectionsExtensions.AsEnum<HideFlags>() DataObjectQueryableExtensions.CompareVariable(FilterOperation, String) Processing.Do<HideFlags>(Action<IProcess<HideFlags>>[]) TypeExtensions.ChangeType<T>() TypeExtensions.ChangeType(Type) TypeExtensions.InvokeMethod<TRet>(Type[], Expression<Func<TRet>>, BindingFlags) TypeExtensions.InvokeMethod(Type[], Expression<Action>, BindingFlags) TypeExtensions.InvokeMethod<TRet>(Expression<Func<TRet>>, BindingFlags) TypeExtensions.InvokeMethod(Expression<Action>, BindingFlags) TypeExtensions.ConvertTo<T>() TypeExtensions.EqualValue(Enum) SqlBlockExtensions.SetExpression<HideFlags, TResult>(Expression<Func<IBlockQueryAdapter, TResult>>) QueryDescriptionExtensions.SetExpression<HideFlags, TResult>(Expression<Func<IQueryStructureAdapter, TResult>>)"
  },
  "api/XData.IWorkSet.html": {
    "href": "api/XData.IWorkSet.html",
    "title": "Interface IWorkSet | XData website",
    "keywords": "Interface IWorkSet Basic work set interface Inherited Members IDisposable.Dispose() Namespace : XData Assembly : XData.WorkSet.docfx.dll Syntax public interface IWorkSet : IDisposable Properties | Improve this Doc View Source DbLayer Data scope layer Declaration Guid DbLayer { get; } Property Value Type Description Guid | Improve this Doc View Source Name Work set name Declaration string Name { get; } Property Value Type Description String | Improve this Doc View Source Type Work set type Declaration Type Type { get; } Property Value Type Description Type Methods | Improve this Doc View Source Clear() Clear work set objects Declaration void Clear() | Improve this Doc View Source Submit() Submit work set objects Declaration bool Submit() Returns Type Description Boolean Success flag Extension Methods SerializationExtensions.ToXml<T>(T) CollectionsExtensions.SetValue<TKey, T>(TKey, T) CollectionsExtensions.AsEnum<T>(T) DataObjectQueryableExtensions.CompareVariable(Object, FilterOperation, String) Processing.Do<T>(T, Action<IProcess<T>>[]) TypeExtensions.TryConvert<T, TResult>(T, Func<T, TResult>) TypeExtensions.TryConvert<T, TResult>(T, Func<T, TResult>, TResult) TypeExtensions.ChangeType<T>(Object) TypeExtensions.ChangeType(Object, Type) TypeExtensions.InvokeMethod<TRet>(Object, Type[], Expression<Func<TRet>>, BindingFlags) TypeExtensions.InvokeMethod(Object, Type[], Expression<Action>, BindingFlags) TypeExtensions.InvokeMethod<TRet>(Object, Expression<Func<TRet>>, BindingFlags) TypeExtensions.InvokeMethod(Object, Expression<Action>, BindingFlags) SqlBlockExtensions.SetExpression<TTag, TResult>(TTag, Expression<Func<IBlockQueryAdapter, TResult>>) QueryDescriptionExtensions.SetExpression<TTag, TResult>(TTag, Expression<Func<IQueryStructureAdapter, TResult>>) See Also IWorkSet <T>"
  },
  "api/XData.Mapping.Dynamic.IInnerFilterAdapter.html": {
    "href": "api/XData.Mapping.Dynamic.IInnerFilterAdapter.html",
    "title": "Interface IInnerFilterAdapter | XData website",
    "keywords": "Interface IInnerFilterAdapter Inner filter description adapter Inherited Members IFilterAdapter.Combination(String, Combination, String) IFilterAdapter.Combination(String, Combination) Namespace : XData.Mapping.Dynamic Assembly : XData.docfx.dll Syntax public interface IInnerFilterAdapter : IFilterAdapter Methods | Improve this Doc View Source ConstFilter(String, String, Object) Constant valued filter description Declaration IFilterDescription ConstFilter(string name, string field, object constantValue) Parameters Type Name Description String name Filter name String field Field name to filter on Object constantValue Constant value Returns Type Description IFilterDescription Filter description | Improve this Doc View Source ConstFilter(String, String, FilterConstantType) Constant valued filter description Declaration IFilterDescription ConstFilter(string name, string field, FilterConstantType constantType) Parameters Type Name Description String name Filter name String field Field name to filter on FilterConstantType constantType Constant type Returns Type Description IFilterDescription Filter description | Improve this Doc View Source ConstFilter(String, String, FilterConstantType, Object) Constant valued filter description Declaration IFilterDescription ConstFilter(string name, string field, FilterConstantType constantType, object constantValue) Parameters Type Name Description String name Filter name String field Field name to filter on FilterConstantType constantType Constant type Object constantValue Constant value Returns Type Description IFilterDescription Filter description | Improve this Doc View Source ConstFilter(String, String, FilterConstantType, Object, FilterNullable) Constant valued filter description Declaration IFilterDescription ConstFilter(string name, string field, FilterConstantType constantType, object constantValue, FilterNullable nullable) Parameters Type Name Description String name Filter name String field Field name to filter on FilterConstantType constantType Constant type Object constantValue Constant value FilterNullable nullable Filter null value handling mode Returns Type Description IFilterDescription Filter description | Improve this Doc View Source DictFilter(String, String, String, String) Dictionary code filter description Declaration IFilterDescription DictFilter(string dictTable, string dictId, string dictCode, string dictValue) Parameters Type Name Description String dictTable Dictionary table name String dictId Dictionary table identity column String dictCode Dictionary table code column String dictValue Dictionary code value to filter on Returns Type Description IFilterDescription Filter description | Improve this Doc View Source DictFilter(String, String, String, String, Boolean) Dictionary code filter description Declaration IFilterDescription DictFilter(string dictTable, string dictId, string dictCode, string dictValue, bool valueIsVariable) Parameters Type Name Description String dictTable Dictionary table name String dictId Dictionary table identity column String dictCode Dictionary table code column String dictValue Dictionary code value to filter on Boolean valueIsVariable Dictionary code value is a variable name flag Returns Type Description IFilterDescription Filter description | Improve this Doc View Source DictFilter(String, String, String, String, String) Dictionary code filter description Declaration IFilterDescription DictFilter(string dictTable, string dictId, string dictCode, string dictValue, string field) Parameters Type Name Description String dictTable Dictionary table name String dictId Dictionary table identity column String dictCode Dictionary table code column String dictValue Dictionary code value to filter on String field Field name to filter on Returns Type Description IFilterDescription Filter description | Improve this Doc View Source DictFilter(String, String, String, String, String, Boolean) Dictionary code filter description Declaration IFilterDescription DictFilter(string dictTable, string dictId, string dictCode, string dictValue, string field, bool valueIsVariable) Parameters Type Name Description String dictTable Dictionary table name String dictId Dictionary table identity column String dictCode Dictionary table code column String dictValue Dictionary code value to filter on String field Field name to filter on Boolean valueIsVariable Dictionary code value is a variable name flag Returns Type Description IFilterDescription Filter description | Improve this Doc View Source ExprFilter(String, String) Expression filter description Declaration IFilterDescription ExprFilter(string field, string exprText) Parameters Type Name Description String field Field name to filter on String exprText SQL expression text Returns Type Description IFilterDescription Filter description | Improve this Doc View Source ExprFilter<T>(String, Expression<Func<IQueryStructureAdapter, T>>) Expression filter description Declaration IFilterDescription ExprFilter<T>(string field, Expression<Func<IQueryStructureAdapter, T>> expression) Parameters Type Name Description String field Field name to filter on Expression < Func < IQueryStructureAdapter , T>> expression SQL expression description Returns Type Description IFilterDescription Filter description Type Parameters Name Description T | Improve this Doc View Source Link(String, String) Inner link filter description Declaration IFilterDescription Link(string linkedAlias, string linkedField) Parameters Type Name Description String linkedAlias Linked source alias String linkedField Linked source field name to link Returns Type Description IFilterDescription Filter description | Improve this Doc View Source Link(String, String, String) Inner link filter description Declaration IFilterDescription Link(string linkedAlias, string linkedField, string field) Parameters Type Name Description String linkedAlias Linked source alias String linkedField Linked source field name to link String field Current field name to link Returns Type Description IFilterDescription Filter description | Improve this Doc View Source RangeFilter(String, Object[]) Range filter description Declaration IFilterDescription RangeFilter(string field, params object[] range) Parameters Type Name Description String field Field name to filter on Object [] range Values range Returns Type Description IFilterDescription Filter description | Improve this Doc View Source SubqueryFilter(String, String) Subquery filter (exists, not exists, in select, not in select) description Declaration IFilterDescription SubqueryFilter(string field, string subqueryAlias) Parameters Type Name Description String field Field name to filter on String subqueryAlias Subquery alias Returns Type Description IFilterDescription Filter description Extension Methods SerializationExtensions.ToXml<T>(T) CollectionsExtensions.SetValue<TKey, T>(TKey, T) CollectionsExtensions.AsEnum<T>(T) DataObjectQueryableExtensions.CompareVariable(Object, FilterOperation, String) Processing.Do<T>(T, Action<IProcess<T>>[]) TypeExtensions.TryConvert<T, TResult>(T, Func<T, TResult>) TypeExtensions.TryConvert<T, TResult>(T, Func<T, TResult>, TResult) TypeExtensions.ChangeType<T>(Object) TypeExtensions.ChangeType(Object, Type) TypeExtensions.InvokeMethod<TRet>(Object, Type[], Expression<Func<TRet>>, BindingFlags) TypeExtensions.InvokeMethod(Object, Type[], Expression<Action>, BindingFlags) TypeExtensions.InvokeMethod<TRet>(Object, Expression<Func<TRet>>, BindingFlags) TypeExtensions.InvokeMethod(Object, Expression<Action>, BindingFlags) SqlBlockExtensions.SetExpression<TTag, TResult>(TTag, Expression<Func<IBlockQueryAdapter, TResult>>) QueryDescriptionExtensions.SetExpression<TTag, TResult>(TTag, Expression<Func<IQueryStructureAdapter, TResult>>)"
  },
  "api/XData.Json.LinkMode.html": {
    "href": "api/XData.Json.LinkMode.html",
    "title": "Enum LinkMode | XData website",
    "keywords": "Enum LinkMode Link serialization mode Namespace : XData.Json Assembly : XData.docfx.dll Syntax public enum LinkMode Fields Name Description Default Default link mode Source Link is serialized as limited Source object only Value Link is serialized as Value only Extension Methods SerializationExtensions.ToXml<LinkMode>() CollectionsExtensions.SetValue<LinkMode, T>(T) CollectionsExtensions.AsEnum<LinkMode>() DataObjectQueryableExtensions.CompareVariable(FilterOperation, String) Processing.Do<LinkMode>(Action<IProcess<LinkMode>>[]) TypeExtensions.ChangeType<T>() TypeExtensions.ChangeType(Type) TypeExtensions.InvokeMethod<TRet>(Type[], Expression<Func<TRet>>, BindingFlags) TypeExtensions.InvokeMethod(Type[], Expression<Action>, BindingFlags) TypeExtensions.InvokeMethod<TRet>(Expression<Func<TRet>>, BindingFlags) TypeExtensions.InvokeMethod(Expression<Action>, BindingFlags) TypeExtensions.ConvertTo<T>() TypeExtensions.EqualValue(Enum) SqlBlockExtensions.SetExpression<LinkMode, TResult>(Expression<Func<IBlockQueryAdapter, TResult>>) QueryDescriptionExtensions.SetExpression<LinkMode, TResult>(Expression<Func<IQueryStructureAdapter, TResult>>)"
  },
  "api/XData.Json.JsonSettings-1.html": {
    "href": "api/XData.Json.JsonSettings-1.html",
    "title": "Class JsonSettings<T> | XData website",
    "keywords": "Class JsonSettings<T> JSON serialization settings Inheritance Object JsonSettings<T> Inherited Members Object.Equals(Object) Object.Equals(Object, Object) Object.GetHashCode() Object.GetType() Object.MemberwiseClone() Object.ReferenceEquals(Object, Object) Object.ToString() Namespace : XData.Json Assembly : XData.docfx.dll Syntax public class JsonSettings<T> where T : class, IDataObject, new() Type Parameters Name Description T Object type Constructors | Improve this Doc View Source JsonSettings() Declaration public JsonSettings() Methods | Improve this Doc View Source DeleteFlag<TChild>(Expression<Func<T, TChild[]>>, Expression<Func<TChild, Boolean>>) Delete child flag Declaration public JsonSettings<T> DeleteFlag<TChild>(Expression<Func<T, TChild[]>> child, Expression<Func<TChild, bool>> property) where TChild : class, IDataObject, new() Parameters Type Name Description Expression < Func <T, TChild[]>> child Child instance Expression < Func <TChild, Boolean >> property Delete child flag property Returns Type Description JsonSettings <T> JSON settings Type Parameters Name Description TChild | Improve this Doc View Source DeleteFlag<TChild>(Expression<Func<T, TChild>>, Expression<Func<TChild, Boolean>>) Delete child flag Declaration public JsonSettings<T> DeleteFlag<TChild>(Expression<Func<T, TChild>> child, Expression<Func<TChild, bool>> property) where TChild : class, IDataObject, new() Parameters Type Name Description Expression < Func <T, TChild>> child Child instance Expression < Func <TChild, Boolean >> property Delete child flag property Returns Type Description JsonSettings <T> JSON settings Type Parameters Name Description TChild | Improve this Doc View Source Hide() Hide properties from serialization Declaration public JsonSettings<T> Hide() Returns Type Description JsonSettings <T> JSON settings | Improve this Doc View Source Hide(Expression<Func<T, Object>>[]) Allow properties serialization Declaration public JsonSettings<T> Hide(params Expression<Func<T, object>>[] properties) Parameters Type Name Description Expression < Func <T, Object >>[] properties Properties extensions Returns Type Description JsonSettings <T> JSON settings | Improve this Doc View Source Hide(String[]) Hide properties from serialization Declaration public JsonSettings<T> Hide(params string[] properties) Parameters Type Name Description String [] properties Properties names Returns Type Description JsonSettings <T> JSON settings | Improve this Doc View Source Hide(HideFlags) Allow properties serialization Declaration public JsonSettings<T> Hide(HideFlags flags) Parameters Type Name Description HideFlags flags Hide all properties corresponding flags Returns Type Description JsonSettings <T> JSON settings | Improve this Doc View Source LinkMode(LinkMode) Link serialization mode Declaration public JsonSettings<T> LinkMode(LinkMode mode) Parameters Type Name Description LinkMode mode Link serialization mode Returns Type Description JsonSettings <T> JSON settings | Improve this Doc View Source LinkMode(LinkMode, Expression<Func<T, Object>>[]) Link serialization mode Declaration public JsonSettings<T> LinkMode(LinkMode mode, params Expression<Func<T, object>>[] properties) Parameters Type Name Description LinkMode mode Link serialization mode Expression < Func <T, Object >>[] properties Properties extensions Returns Type Description JsonSettings <T> JSON settings | Improve this Doc View Source LinkMode(LinkMode, String[]) Link serialization mode Declaration public JsonSettings<T> LinkMode(LinkMode mode, params string[] properties) Parameters Type Name Description LinkMode mode Link serialization mode String [] properties Properties names Returns Type Description JsonSettings <T> JSON settings | Improve this Doc View Source LoadLob() Load large objects Declaration public JsonSettings<T> LoadLob() Returns Type Description JsonSettings <T> JSON settings | Improve this Doc View Source LoadLob(Expression<Func<T, Object>>[]) Load large objects Declaration public JsonSettings<T> LoadLob(params Expression<Func<T, object>>[] properties) Parameters Type Name Description Expression < Func <T, Object >>[] properties Properties extensions Returns Type Description JsonSettings <T> JSON settings | Improve this Doc View Source LoadLob(String[]) Load large objects Declaration public JsonSettings<T> LoadLob(params string[] properties) Parameters Type Name Description String [] properties Properties names Returns Type Description JsonSettings <T> JSON settings | Improve this Doc View Source Show() Allow properties serialization Declaration public JsonSettings<T> Show() Returns Type Description JsonSettings <T> JSON settings | Improve this Doc View Source Show(Expression<Func<T, Object>>[]) Allow properties serialization Declaration public JsonSettings<T> Show(params Expression<Func<T, object>>[] properties) Parameters Type Name Description Expression < Func <T, Object >>[] properties Properties extensions Returns Type Description JsonSettings <T> JSON settings | Improve this Doc View Source Show(String[]) Allow properties serialization Declaration public JsonSettings<T> Show(params string[] properties) Parameters Type Name Description String [] properties Properties names Returns Type Description JsonSettings <T> JSON settings Extension Methods SerializationExtensions.ToXml<T>(T) CollectionsExtensions.SetValue<TKey, T>(TKey, T) CollectionsExtensions.AsEnum<T>(T) DataObjectQueryableExtensions.CompareVariable(Object, FilterOperation, String) Processing.Do<T>(T, Action<IProcess<T>>[]) TypeExtensions.TryConvert<T, TResult>(T, Func<T, TResult>) TypeExtensions.TryConvert<T, TResult>(T, Func<T, TResult>, TResult) TypeExtensions.ChangeType<T>(Object) TypeExtensions.ChangeType(Object, Type) TypeExtensions.InvokeMethod<TRet>(Object, Type[], Expression<Func<TRet>>, BindingFlags) TypeExtensions.InvokeMethod(Object, Type[], Expression<Action>, BindingFlags) TypeExtensions.InvokeMethod<TRet>(Object, Expression<Func<TRet>>, BindingFlags) TypeExtensions.InvokeMethod(Object, Expression<Action>, BindingFlags) SqlBlockExtensions.SetExpression<TTag, TResult>(TTag, Expression<Func<IBlockQueryAdapter, TResult>>) QueryDescriptionExtensions.SetExpression<TTag, TResult>(TTag, Expression<Func<IQueryStructureAdapter, TResult>>)"
  },
  "api/XData.Interfaces.IProxy.html": {
    "href": "api/XData.Interfaces.IProxy.html",
    "title": "Interface IProxy | XData website",
    "keywords": "Interface IProxy Data object proxy interface Inherited Members IDisposable.Dispose() Namespace : XData.Interfaces Assembly : XData.docfx.dll Syntax public interface IProxy : IDisposable Methods | Improve this Doc View Source Close(Guid) Close proxy Declaration void Close(Guid layer) Parameters Type Name Description Guid layer Layer to close (Specify Guid.Empty to close all layers) Extension Methods SerializationExtensions.ToXml<T>(T) CollectionsExtensions.SetValue<TKey, T>(TKey, T) CollectionsExtensions.AsEnum<T>(T) DataObjectQueryableExtensions.CompareVariable(Object, FilterOperation, String) Processing.Do<T>(T, Action<IProcess<T>>[]) TypeExtensions.TryConvert<T, TResult>(T, Func<T, TResult>) TypeExtensions.TryConvert<T, TResult>(T, Func<T, TResult>, TResult) TypeExtensions.ChangeType<T>(Object) TypeExtensions.ChangeType(Object, Type) TypeExtensions.InvokeMethod<TRet>(Object, Type[], Expression<Func<TRet>>, BindingFlags) TypeExtensions.InvokeMethod(Object, Type[], Expression<Action>, BindingFlags) TypeExtensions.InvokeMethod<TRet>(Object, Expression<Func<TRet>>, BindingFlags) TypeExtensions.InvokeMethod(Object, Expression<Action>, BindingFlags) SqlBlockExtensions.SetExpression<TTag, TResult>(TTag, Expression<Func<IBlockQueryAdapter, TResult>>) QueryDescriptionExtensions.SetExpression<TTag, TResult>(TTag, Expression<Func<IQueryStructureAdapter, TResult>>) See Also Proxy"
  },
  "api/XData.Mapping.Dynamic.ISubqueryLinkAdapter-2.html": {
    "href": "api/XData.Mapping.Dynamic.ISubqueryLinkAdapter-2.html",
    "title": "Interface ISubqueryLinkAdapter<T, TDObj> | XData website",
    "keywords": "Interface ISubqueryLinkAdapter<T, TDObj> Subquery link filter description adapter Inherited Members ISubqueryLinkAdapter<T>.SubqueryLink(Expression<Func<T, Object>>) ISubqueryLinkAdapter<T>.SubqueryLink(Expression<Func<T, Object>>, String) ISubqueryLinkAdapter.SubqueryLink(String) ISubqueryLinkAdapter.SubqueryLink(String, String) IFilterAdapter.Combination(String, Combination, String) IFilterAdapter.Combination(String, Combination) Namespace : XData.Mapping.Dynamic Assembly : XData.docfx.dll Syntax public interface ISubqueryLinkAdapter<T, TDObj> : ISubqueryLinkAdapter<T>, ISubqueryLinkAdapter, IFilterAdapter where T : class where TDObj : class Type Parameters Name Description T Repository data object type TDObj Subquery mapped type Methods | Improve this Doc View Source SubqueryLink(Expression<Func<TDObj, Object>>) Subquery link filter description Declaration IFilterDescription SubqueryLink(Expression<Func<TDObj, object>> subqueryProperty) Parameters Type Name Description Expression < Func <TDObj, Object >> subqueryProperty Subquery property name expression to link with Returns Type Description IFilterDescription Filter description | Improve this Doc View Source SubqueryLink(Expression<Func<TDObj, Object>>, Expression<Func<T, Object>>) Subquery link filter description Declaration IFilterDescription SubqueryLink(Expression<Func<TDObj, object>> subqueryProperty, Expression<Func<T, object>> property) Parameters Type Name Description Expression < Func <TDObj, Object >> subqueryProperty Subquery property name expression to link with Expression < Func <T, Object >> property Base query property name expression to link with Returns Type Description IFilterDescription Filter description | Improve this Doc View Source SubqueryLink(Expression<Func<TDObj, Object>>, String) Subquery link filter description Declaration IFilterDescription SubqueryLink(Expression<Func<TDObj, object>> subqueryProperty, string property) Parameters Type Name Description Expression < Func <TDObj, Object >> subqueryProperty Subquery property name expression to link with String property Base query property name to link with Returns Type Description IFilterDescription Filter description Extension Methods SerializationExtensions.ToXml<T>(T) CollectionsExtensions.SetValue<TKey, T>(TKey, T) CollectionsExtensions.AsEnum<T>(T) DataObjectQueryableExtensions.CompareVariable(Object, FilterOperation, String) Processing.Do<T>(T, Action<IProcess<T>>[]) TypeExtensions.TryConvert<T, TResult>(T, Func<T, TResult>) TypeExtensions.TryConvert<T, TResult>(T, Func<T, TResult>, TResult) TypeExtensions.ChangeType<T>(Object) TypeExtensions.ChangeType(Object, Type) TypeExtensions.InvokeMethod<TRet>(Object, Type[], Expression<Func<TRet>>, BindingFlags) TypeExtensions.InvokeMethod(Object, Type[], Expression<Action>, BindingFlags) TypeExtensions.InvokeMethod<TRet>(Object, Expression<Func<TRet>>, BindingFlags) TypeExtensions.InvokeMethod(Object, Expression<Action>, BindingFlags) SqlBlockExtensions.SetExpression<TTag, TResult>(TTag, Expression<Func<IBlockQueryAdapter, TResult>>) QueryDescriptionExtensions.SetExpression<TTag, TResult>(TTag, Expression<Func<IQueryStructureAdapter, TResult>>)"
  },
  "api/XData.Mapping.Dynamic.IExternalLinkAdapter-2.html": {
    "href": "api/XData.Mapping.Dynamic.IExternalLinkAdapter-2.html",
    "title": "Interface IExternalLinkAdapter<T, TChild> | XData website",
    "keywords": "Interface IExternalLinkAdapter<T, TChild> External link mapping adapter Namespace : XData.Mapping.Dynamic Assembly : XData.docfx.dll Syntax public interface IExternalLinkAdapter<T, TChild> where T : class, ISqlObject, new() where TChild : class, ISqlObject, new() Type Parameters Name Description T Parent date object type TChild Child date object type Methods | Improve this Doc View Source DirectLink() External link direct link flag Declaration IExternalLinkFlag DirectLink() Returns Type Description IExternalLinkFlag External link flag See Also ShowSubtree | Improve this Doc View Source Filter(Expression<Func<TChild, RuntimeFilter>>) External link runtime filter Declaration IExternalLinkFlag Filter(Expression<Func<TChild, RuntimeFilter>> filter) Parameters Type Name Description Expression < Func <TChild, RuntimeFilter >> filter Runtime filter Returns Type Description IExternalLinkFlag External link flag | Improve this Doc View Source FilterCombination(String) External link filter combination flag Declaration IExternalLinkFlag FilterCombination(string combinationName) Parameters Type Name Description String combinationName Filter combination name Returns Type Description IExternalLinkFlag | Improve this Doc View Source MasterRefresh() External link master refresh flag Declaration IExternalLinkFlag MasterRefresh() Returns Type Description IExternalLinkFlag External link flag | Improve this Doc View Source Nullable(FilterNullable) External link filter null value assignment mode flag Declaration IExternalLinkFlag Nullable(FilterNullable nullable) Parameters Type Name Description FilterNullable nullable Filter null value assignment mode Returns Type Description IExternalLinkFlag External link flag See Also FilterNullable | Improve this Doc View Source Operation(FilterOperation) External link filter operation flag Declaration IExternalLinkFlag Operation(FilterOperation operation) Parameters Type Name Description FilterOperation operation Filter operation Returns Type Description IExternalLinkFlag External link flag See Also FilterOperation | Improve this Doc View Source PrimaryFilter() External link optional filter flag Declaration IExternalLinkFlag PrimaryFilter() Returns Type Description IExternalLinkFlag External link flag See Also IOptionalFilter | Improve this Doc View Source Property(Expression<Func<TChild, Object>>) External link child property Declaration IExternalLinkFlag Property(Expression<Func<TChild, object>> property) Parameters Type Name Description Expression < Func <TChild, Object >> property Child type property Returns Type Description IExternalLinkFlag External link flag | Improve this Doc View Source Property(String) External link child property Declaration IExternalLinkFlag Property(string property) Parameters Type Name Description String property Child type property Returns Type Description IExternalLinkFlag External link flag | Improve this Doc View Source Property<TChildInner>(Expression<Func<TChildInner, Object>>) External link child property Declaration IExternalLinkFlag Property<TChildInner>(Expression<Func<TChildInner, object>> property) Parameters Type Name Description Expression < Func <TChildInner, Object >> property Child inner type property Returns Type Description IExternalLinkFlag External link flag Type Parameters Name Description TChildInner Child inner type | Improve this Doc View Source Property<TChildInner>(String) External link child property Declaration IExternalLinkFlag Property<TChildInner>(string property) Parameters Type Name Description String property Child inner type property Returns Type Description IExternalLinkFlag External link flag Type Parameters Name Description TChildInner Child inner type | Improve this Doc View Source TreeFilter() External link filter tree root condition (START WITH) flag Declaration IExternalLinkFlag TreeFilter() Returns Type Description IExternalLinkFlag External link flag Extension Methods SerializationExtensions.ToXml<T>(T) CollectionsExtensions.SetValue<TKey, T>(TKey, T) CollectionsExtensions.AsEnum<T>(T) DataObjectQueryableExtensions.CompareVariable(Object, FilterOperation, String) Processing.Do<T>(T, Action<IProcess<T>>[]) TypeExtensions.TryConvert<T, TResult>(T, Func<T, TResult>) TypeExtensions.TryConvert<T, TResult>(T, Func<T, TResult>, TResult) TypeExtensions.ChangeType<T>(Object) TypeExtensions.ChangeType(Object, Type) TypeExtensions.InvokeMethod<TRet>(Object, Type[], Expression<Func<TRet>>, BindingFlags) TypeExtensions.InvokeMethod(Object, Type[], Expression<Action>, BindingFlags) TypeExtensions.InvokeMethod<TRet>(Object, Expression<Func<TRet>>, BindingFlags) TypeExtensions.InvokeMethod(Object, Expression<Action>, BindingFlags) SqlBlockExtensions.SetExpression<TTag, TResult>(TTag, Expression<Func<IBlockQueryAdapter, TResult>>) QueryDescriptionExtensions.SetExpression<TTag, TResult>(TTag, Expression<Func<IQueryStructureAdapter, TResult>>)"
  },
  "api/XData.Mapping.Dynamic.IExpressionPropertyAdapter.html": {
    "href": "api/XData.Mapping.Dynamic.IExpressionPropertyAdapter.html",
    "title": "Interface IExpressionPropertyAdapter | XData website",
    "keywords": "Interface IExpressionPropertyAdapter SQL expression property mapping adapter Inherited Members IPropertyMappingAdapter.Key() IPropertyMappingAdapter.Group(DataGrouping) IPropertyMappingAdapter.Group(Int32) IPropertyMappingAdapter.Hidden() IPropertyMappingAdapter.OrderBy(Int32, Boolean) IPropertyMappingAdapter.OrderBy(Int32) Namespace : XData.Mapping.Dynamic Assembly : XData.docfx.dll Syntax public interface IExpressionPropertyAdapter : IPropertyMappingAdapter Methods | Improve this Doc View Source Exists() SQL subquery expression exists operation Declaration IStructureFlag Exists() Returns Type Description IStructureFlag SQL expression mapping flag | Improve this Doc View Source Exists(ExistsOperation) SQL subquery expression exists operation Declaration IStructureFlag Exists(ExistsOperation exists) Parameters Type Name Description ExistsOperation exists Exists operation Returns Type Description IStructureFlag SQL expression mapping flag | Improve this Doc View Source NativeSqlType(String) SQL expression result native SQL type name Declaration IStructureFlag NativeSqlType(string nativeSqlType) Parameters Type Name Description String nativeSqlType Native SQL type name Returns Type Description IStructureFlag SQL expression mapping flag | Improve this Doc View Source Size(Int32) Size of SQL expression result value Declaration IStructureFlag Size(int size) Parameters Type Name Description Int32 size Size Returns Type Description IStructureFlag SQL expression mapping flag | Improve this Doc View Source Size(Int32, Int32) Size of SQL expression result value Declaration IStructureFlag Size(int size, int scale) Parameters Type Name Description Int32 size Size Int32 scale Scale Returns Type Description IStructureFlag SQL expression mapping flag Extension Methods SerializationExtensions.ToXml<T>(T) CollectionsExtensions.SetValue<TKey, T>(TKey, T) CollectionsExtensions.AsEnum<T>(T) DataObjectQueryableExtensions.CompareVariable(Object, FilterOperation, String) Processing.Do<T>(T, Action<IProcess<T>>[]) TypeExtensions.TryConvert<T, TResult>(T, Func<T, TResult>) TypeExtensions.TryConvert<T, TResult>(T, Func<T, TResult>, TResult) TypeExtensions.ChangeType<T>(Object) TypeExtensions.ChangeType(Object, Type) TypeExtensions.InvokeMethod<TRet>(Object, Type[], Expression<Func<TRet>>, BindingFlags) TypeExtensions.InvokeMethod(Object, Type[], Expression<Action>, BindingFlags) TypeExtensions.InvokeMethod<TRet>(Object, Expression<Func<TRet>>, BindingFlags) TypeExtensions.InvokeMethod(Object, Expression<Action>, BindingFlags) SqlBlockExtensions.SetExpression<TTag, TResult>(TTag, Expression<Func<IBlockQueryAdapter, TResult>>) QueryDescriptionExtensions.SetExpression<TTag, TResult>(TTag, Expression<Func<IQueryStructureAdapter, TResult>>)"
  },
  "api/XData.Mapping.DictionaryFilterAttribute.html": {
    "href": "api/XData.Mapping.DictionaryFilterAttribute.html",
    "title": "Class DictionaryFilterAttribute | XData website",
    "keywords": "Class DictionaryFilterAttribute Data object dictionary filter attribute Inheritance Object Attribute FilterBaseAttribute FilterAttribute DictionaryFilterAttribute Inherited Members FilterAttribute.Source FilterAttribute.FieldName FilterAttribute.Operation FilterAttribute.Combination Attribute.Equals(Object) Attribute.GetCustomAttribute(Assembly, Type) Attribute.GetCustomAttribute(Assembly, Type, Boolean) Attribute.GetCustomAttribute(MemberInfo, Type) Attribute.GetCustomAttribute(MemberInfo, Type, Boolean) Attribute.GetCustomAttribute(Module, Type) Attribute.GetCustomAttribute(Module, Type, Boolean) Attribute.GetCustomAttribute(ParameterInfo, Type) Attribute.GetCustomAttribute(ParameterInfo, Type, Boolean) Attribute.GetCustomAttributes(Assembly) Attribute.GetCustomAttributes(Assembly, Boolean) Attribute.GetCustomAttributes(Assembly, Type) Attribute.GetCustomAttributes(Assembly, Type, Boolean) Attribute.GetCustomAttributes(MemberInfo) Attribute.GetCustomAttributes(MemberInfo, Boolean) Attribute.GetCustomAttributes(MemberInfo, Type) Attribute.GetCustomAttributes(MemberInfo, Type, Boolean) Attribute.GetCustomAttributes(Module) Attribute.GetCustomAttributes(Module, Boolean) Attribute.GetCustomAttributes(Module, Type) Attribute.GetCustomAttributes(Module, Type, Boolean) Attribute.GetCustomAttributes(ParameterInfo) Attribute.GetCustomAttributes(ParameterInfo, Boolean) Attribute.GetCustomAttributes(ParameterInfo, Type) Attribute.GetCustomAttributes(ParameterInfo, Type, Boolean) Attribute.GetHashCode() Attribute.IsDefaultAttribute() Attribute.IsDefined(Assembly, Type) Attribute.IsDefined(Assembly, Type, Boolean) Attribute.IsDefined(MemberInfo, Type) Attribute.IsDefined(MemberInfo, Type, Boolean) Attribute.IsDefined(Module, Type) Attribute.IsDefined(Module, Type, Boolean) Attribute.IsDefined(ParameterInfo, Type) Attribute.IsDefined(ParameterInfo, Type, Boolean) Attribute.Match(Object) Object.Equals(Object, Object) Object.GetType() Object.MemberwiseClone() Object.ReferenceEquals(Object, Object) Object.ToString() Namespace : XData.Mapping Assembly : XData.docfx.dll Syntax [AttributeUsage(AttributeTargets.Class, AllowMultiple = true)] public sealed class DictionaryFilterAttribute : FilterAttribute Remarks Filter by dictionary code (example: doc_type_id = (select doc_type_id from t_doc_type where code = 'INVOICE') ) WARNING! Dictionary restricted by single valued primary key! WARNING! Dictionary code mast be unique! Examples DictionaryFilter(\"T_DOC_TYPE\", \"doc_type_id\", \"code\", \"INVOICE\", \"D\") Constructors | Improve this Doc View Source DictionaryFilterAttribute(String, String, String, String, String, String) Dictionary filter attribute Declaration public DictionaryFilterAttribute(string dictionaryTable, string dictionaryIdField, string dictionaryCodeField, string dictionaryValue, string source, string fieldName = \"\") Parameters Type Name Description String dictionaryTable Dictionary table name String dictionaryIdField Dictionary id field String dictionaryCodeField Dictionary code field String dictionaryValue Dictionary code value String source Filter source alias String fieldName Filter field name Exceptions Type Condition XDataRuntimeException Dictionary table name cannot be null or empty string XDataRuntimeException Dictionary id field cannot be null or empty string XDataRuntimeException Dictionary code field cannot be null or empty string XDataRuntimeException Dictionary code value cannot be null or empty string Properties | Improve this Doc View Source DictionaryCode Dictionary code field Declaration public string DictionaryCode { get; } Property Value Type Description String | Improve this Doc View Source DictionaryId Dictionary id field Declaration public string DictionaryId { get; } Property Value Type Description String | Improve this Doc View Source DictionaryTable Dictionary table name Declaration public string DictionaryTable { get; } Property Value Type Description String | Improve this Doc View Source DictionaryValue Dictionary code value Declaration public string DictionaryValue { get; } Property Value Type Description String | Improve this Doc View Source FilterType Filter type Declaration public override FilterType FilterType { get; } Property Value Type Description FilterType Dictionary Overrides FilterBaseAttribute.FilterType | Improve this Doc View Source IsVariableValue Variable name as filter value Declaration public bool IsVariableValue { get; set; } Property Value Type Description Boolean Remarks If true DictionaryValue contains data object variable name which value will be compared with Dictionary code | Improve this Doc View Source TypeId When implemented in a derived class, gets a unique identifier for this Attribute . Declaration public override object TypeId { get; } Property Value Type Description Object An Object that is a unique identifier for the attribute. Overrides Attribute.TypeId Extension Methods SerializationExtensions.ToXml<T>(T) CollectionsExtensions.SetValue<TKey, T>(TKey, T) CollectionsExtensions.AsEnum<T>(T) DataObjectQueryableExtensions.CompareVariable(Object, FilterOperation, String) Processing.Do<T>(T, Action<IProcess<T>>[]) TypeExtensions.TryConvert<T, TResult>(T, Func<T, TResult>) TypeExtensions.TryConvert<T, TResult>(T, Func<T, TResult>, TResult) TypeExtensions.ChangeType<T>(Object) TypeExtensions.ChangeType(Object, Type) TypeExtensions.InvokeMethod<TRet>(Object, Type[], Expression<Func<TRet>>, BindingFlags) TypeExtensions.InvokeMethod(Object, Type[], Expression<Action>, BindingFlags) TypeExtensions.InvokeMethod<TRet>(Object, Expression<Func<TRet>>, BindingFlags) TypeExtensions.InvokeMethod(Object, Expression<Action>, BindingFlags) SqlBlockExtensions.SetExpression<TTag, TResult>(TTag, Expression<Func<IBlockQueryAdapter, TResult>>) QueryDescriptionExtensions.SetExpression<TTag, TResult>(TTag, Expression<Func<IQueryStructureAdapter, TResult>>) See Also Dictionary"
  },
  "api/XData.Interfaces.ISqlBuilder.html": {
    "href": "api/XData.Interfaces.ISqlBuilder.html",
    "title": "Interface ISqlBuilder | XData website",
    "keywords": "Interface ISqlBuilder SQL builder interface Namespace : XData.Interfaces Assembly : XData.docfx.dll Syntax public interface ISqlBuilder Properties | Improve this Doc View Source DialectOptions Dialect options WARNING! Mast to be filled in constructor! Declaration DialectOptions DialectOptions { get; } Property Value Type Description DialectOptions | Improve this Doc View Source Item[Enum] Predefined queries Declaration Query this[Enum i] { get; } Parameters Type Name Description Enum i Query enumerated index Property Value Type Description Query Query | Improve this Doc View Source ParameterPrefix Parameter prefix in SQL dialect Declaration string ParameterPrefix { get; } Property Value Type Description String | Improve this Doc View Source SqlTypes List of supported SQL types WARNING! Mast to be filled in constructor! Declaration DbType[] SqlTypes { get; } Property Value Type Description DbType [] | Improve this Doc View Source SqlTypeSizes List of supported type size applicable WARNING! Mast to be filled in constructor! Declaration Dictionary<string, SqlTypeSize> SqlTypeSizes { get; } Property Value Type Description Dictionary < String , SqlTypeSize > | Improve this Doc View Source TypeNames List of supported column type names WARNING! Mast to be filled in constructor! Declaration string[] TypeNames { get; } Property Value Type Description String [] | Improve this Doc View Source TypeSynonyms List of supported type synonyms WARNING! Mast to be filled in constructor! Declaration string[] TypeSynonyms { get; } Property Value Type Description String [] Methods | Improve this Doc View Source ExtractXmlQuery(String, String, String[], IComparable[], String, KeyValuePair<String, String>[]) Returns query to extract XML data by XPath expression Declaration Query ExtractXmlQuery(string table, string column, string[] tablePrimaryKey, IComparable[] primaryKeyValue, string path, params KeyValuePair<string, string>[] namespaces) Parameters Type Name Description String table Table name String column XML column name String [] tablePrimaryKey Table primary key columns IComparable [] primaryKeyValue Table primary key values String path XPath expression KeyValuePair < String , String >[] namespaces XPath namespaces Returns Type Description Query XPath result | Improve this Doc View Source GetAcquireBlobQuery(String, String, IEnumerable<String>, IComparable[], String) Returns query to acquire blob data Declaration Query GetAcquireBlobQuery(string table, string column, IEnumerable<string> tablePrimaryKey, IComparable[] primaryKeyValue, string nativeSqlType = null) Parameters Type Name Description String table Table name String column Blob column name IEnumerable < String > tablePrimaryKey Table primary key columns IComparable [] primaryKeyValue Table primary key values String nativeSqlType Native SQL type name Returns Type Description Query Query | Improve this Doc View Source GetAcquireXmlQuery(String, String, String[], IComparable[]) Returns query to acquire XML data Declaration Query GetAcquireXmlQuery(string table, string column, string[] tablePrimaryKey, IComparable[] primaryKeyValue) Parameters Type Name Description String table Table name String column XML column name String [] tablePrimaryKey Table primary key columns IComparable [] primaryKeyValue Table primary key values Returns Type Description Query Query | Improve this Doc View Source GetAllQuery(IDataStructure) Returns query to check compliance of all repository objects Hint: Used in XData LINQ expressions Declaration Query GetAllQuery(IDataStructure structure) Parameters Type Name Description IDataStructure structure Structure metadata Returns Type Description Query Query | Improve this Doc View Source GetAnyQuery(IDataStructure) Returns query to check existence of repository objects Hint: Used in XData LINQ expressions Declaration Query GetAnyQuery(IDataStructure structure) Parameters Type Name Description IDataStructure structure Structure metadata Returns Type Description Query Query | Improve this Doc View Source GetBlobSizeQuery(String, String, String[], IComparable[]) Returns query to get Large Object size Declaration Query GetBlobSizeQuery(string table, string column, string[] tablePrimaryKey, IComparable[] primaryKeyValue) Parameters Type Name Description String table Table name contained LOB String column LOB column name String [] tablePrimaryKey Primary key column names IComparable [] primaryKeyValue Primary key values Returns Type Description Query Query to get Large Object size | Improve this Doc View Source GetCall(IDataStructure, String) Returns stored procedure call definition Declaration StoredProcedure GetCall(IDataStructure dataStructure, string userName) Parameters Type Name Description IDataStructure dataStructure Structure String userName User name Returns Type Description StoredProcedure Stored procedure definition | Improve this Doc View Source GetClearQuery(IDataStructure) Returns query to clear all repository objects Declaration Query GetClearQuery(IDataStructure structure) Parameters Type Name Description IDataStructure structure Structure metadata Returns Type Description Query Query | Improve this Doc View Source GetCountQuery(IDataStructure) Returns query to select count of data objects in repository Declaration Query GetCountQuery(IDataStructure structure) Parameters Type Name Description IDataStructure structure Structure metadata Returns Type Description Query Query | Improve this Doc View Source GetDeleteQuery(IDataStructure, IDataObject, String, Boolean) Returns query to delete data object Declaration Query GetDeleteQuery(IDataStructure structure, IDataObject data, string userName, bool ignoreConcurrency = true) Parameters Type Name Description IDataStructure structure Structure metadata IDataObject data Data object instance String userName User name Boolean ignoreConcurrency Ignore concurrency flag Returns Type Description Query Query | Improve this Doc View Source GetInsertQuery(IDataStructure, IDataObject, String, Boolean) Returns query to insert data object Declaration Query GetInsertQuery(IDataStructure structure, IDataObject data, string userName, bool ignoreConcurrency = true) Parameters Type Name Description IDataStructure structure Structure metadata IDataObject data Data object instance String userName User name Boolean ignoreConcurrency Ignore concurrency flag Returns Type Description Query Query | Improve this Doc View Source GetLockQuery(IDataStructure) Returns query to lock single data object Declaration Query GetLockQuery(IDataStructure structure) Parameters Type Name Description IDataStructure structure Structure metadata Returns Type Description Query Query | Improve this Doc View Source GetParameterName(String) Formats field name as parameter name Declaration string GetParameterName(string fieldName) Parameters Type Name Description String fieldName Field name Returns Type Description String Parameter name | Improve this Doc View Source GetRefreshQuery(IDataStructure) Returns query to refresh single data object Declaration Query GetRefreshQuery(IDataStructure structure) Parameters Type Name Description IDataStructure structure Structure metadata Returns Type Description Query Query | Improve this Doc View Source GetSafeConvertExpression(Type, Expression, Expression) Safe convert expression Declaration Expression GetSafeConvertExpression(Type type, Expression dataRow, Expression fieldName) Parameters Type Name Description Type type Type of expression Expression dataRow Data row expression Expression fieldName Field name expression Returns Type Description Expression Expression | Improve this Doc View Source GetSaveBlobQuery(String, String, IEnumerable<String>, IComparable[], ref Byte[], String) Returns query to save blob data Declaration Query GetSaveBlobQuery(string table, string column, IEnumerable<string> tablePrimaryKey, IComparable[] primaryKeyValue, ref byte[] body, string nativeSqlType = null) Parameters Type Name Description String table Table name String column Blob column name IEnumerable < String > tablePrimaryKey Table primary key columns IComparable [] primaryKeyValue Table primary key values Byte [] body Blob body String nativeSqlType Native SQL type name Returns Type Description Query Query | Improve this Doc View Source GetSaveXmlQuery(String, String, String[], IComparable[], ref String) Returns query to save XML data Declaration Query GetSaveXmlQuery(string table, string column, string[] tablePrimaryKey, IComparable[] primaryKeyValue, ref string body) Parameters Type Name Description String table Table name String column XML column name String [] tablePrimaryKey Table primary key columns IComparable [] primaryKeyValue Table primary key values String body Blob body Returns Type Description Query Query | Improve this Doc View Source GetSelectQuery(IDataStructure, Boolean, Boolean) Returns query to select data objects Declaration Query GetSelectQuery(IDataStructure structure, bool markProperties = false, bool doNotSkip = false) Parameters Type Name Description IDataStructure structure Structure metadata Boolean markProperties Mark properties with comments Boolean doNotSkip Don't skip sources Returns Type Description Query Query | Improve this Doc View Source GetUpdateQuery(IDataStructure, IDataObject, String, Boolean) Returns query to update data object Declaration Query GetUpdateQuery(IDataStructure structure, IDataObject data, string userName, bool ignoreConcurrency = true) Parameters Type Name Description IDataStructure structure Structure metadata IDataObject data Data object instance String userName User name Boolean ignoreConcurrency Ignore concurrency flag Returns Type Description Query Query | Improve this Doc View Source Init(String, IConfiguration, String) SQL builder initialization Declaration void Init(string context, IConfiguration config, string sequence) Parameters Type Name Description String context IConfiguration config String sequence | Improve this Doc View Source SetQueryParameterValues(ref Query, SortedList<String, Object>) Set query parameter values Declaration void SetQueryParameterValues(ref Query query, SortedList<string, object> paramValues) Parameters Type Name Description Query query Query SortedList < String , Object > paramValues Parameter values Extension Methods SerializationExtensions.ToXml<T>(T) CollectionsExtensions.SetValue<TKey, T>(TKey, T) CollectionsExtensions.AsEnum<T>(T) DataObjectQueryableExtensions.CompareVariable(Object, FilterOperation, String) Processing.Do<T>(T, Action<IProcess<T>>[]) TypeExtensions.TryConvert<T, TResult>(T, Func<T, TResult>) TypeExtensions.TryConvert<T, TResult>(T, Func<T, TResult>, TResult) TypeExtensions.ChangeType<T>(Object) TypeExtensions.ChangeType(Object, Type) TypeExtensions.InvokeMethod<TRet>(Object, Type[], Expression<Func<TRet>>, BindingFlags) TypeExtensions.InvokeMethod(Object, Type[], Expression<Action>, BindingFlags) TypeExtensions.InvokeMethod<TRet>(Object, Expression<Func<TRet>>, BindingFlags) TypeExtensions.InvokeMethod(Object, Expression<Action>, BindingFlags) SqlBlockExtensions.SetExpression<TTag, TResult>(TTag, Expression<Func<IBlockQueryAdapter, TResult>>) QueryDescriptionExtensions.SetExpression<TTag, TResult>(TTag, Expression<Func<IQueryStructureAdapter, TResult>>)"
  },
  "api/XData.Database.SqlBlock.IBlockQueryDescription-1.html": {
    "href": "api/XData.Database.SqlBlock.IBlockQueryDescription-1.html",
    "title": "Interface IBlockQueryDescription<T> | XData website",
    "keywords": "Interface IBlockQueryDescription<T> SQL block query description interface Namespace : XData.Database.SqlBlock Assembly : XData.docfx.dll Syntax public interface IBlockQueryDescription<T> : IBlockQueryDescription Type Parameters Name Description T SQL block query row mapped type Extension Methods SerializationExtensions.ToXml<T>(T) CollectionsExtensions.SetValue<TKey, T>(TKey, T) CollectionsExtensions.AsEnum<T>(T) DataObjectQueryableExtensions.CompareVariable(Object, FilterOperation, String) Processing.Do<T>(T, Action<IProcess<T>>[]) TypeExtensions.TryConvert<T, TResult>(T, Func<T, TResult>) TypeExtensions.TryConvert<T, TResult>(T, Func<T, TResult>, TResult) TypeExtensions.ChangeType<T>(Object) TypeExtensions.ChangeType(Object, Type) TypeExtensions.InvokeMethod<TRet>(Object, Type[], Expression<Func<TRet>>, BindingFlags) TypeExtensions.InvokeMethod(Object, Type[], Expression<Action>, BindingFlags) TypeExtensions.InvokeMethod<TRet>(Object, Expression<Func<TRet>>, BindingFlags) TypeExtensions.InvokeMethod(Object, Expression<Action>, BindingFlags) SqlBlockExtensions.SetExpression<TTag, TResult>(TTag, Expression<Func<IBlockQueryAdapter, TResult>>) QueryDescriptionExtensions.SetExpression<TTag, TResult>(TTag, Expression<Func<IQueryStructureAdapter, TResult>>)"
  },
  "api/XData.Database.Dialect.MergeMap.html": {
    "href": "api/XData.Database.Dialect.MergeMap.html",
    "title": "Class MergeMap | XData website",
    "keywords": "Class MergeMap Inheritance Object MergeMap Inherited Members Object.Equals(Object) Object.Equals(Object, Object) Object.GetHashCode() Object.GetType() Object.MemberwiseClone() Object.ReferenceEquals(Object, Object) Object.ToString() Namespace : XData.Database.Dialect Assembly : XData.docfx.dll Syntax public class MergeMap Properties | Improve this Doc View Source InsertValue Declaration public string InsertValue { get; set; } Property Value Type Description String | Improve this Doc View Source MergeFlag Declaration public MergeFlag MergeFlag { get; set; } Property Value Type Description MergeFlag | Improve this Doc View Source SelectField Declaration public SelectedField SelectField { get; set; } Property Value Type Description SelectedField | Improve this Doc View Source SourceField Declaration public string SourceField { get; set; } Property Value Type Description String | Improve this Doc View Source SourceValue Declaration public string SourceValue { get; set; } Property Value Type Description String | Improve this Doc View Source TargetField Declaration public string TargetField { get; set; } Property Value Type Description String Extension Methods SerializationExtensions.ToXml<T>(T) CollectionsExtensions.SetValue<TKey, T>(TKey, T) CollectionsExtensions.AsEnum<T>(T) DataObjectQueryableExtensions.CompareVariable(Object, FilterOperation, String) Processing.Do<T>(T, Action<IProcess<T>>[]) TypeExtensions.TryConvert<T, TResult>(T, Func<T, TResult>) TypeExtensions.TryConvert<T, TResult>(T, Func<T, TResult>, TResult) TypeExtensions.ChangeType<T>(Object) TypeExtensions.ChangeType(Object, Type) TypeExtensions.InvokeMethod<TRet>(Object, Type[], Expression<Func<TRet>>, BindingFlags) TypeExtensions.InvokeMethod(Object, Type[], Expression<Action>, BindingFlags) TypeExtensions.InvokeMethod<TRet>(Object, Expression<Func<TRet>>, BindingFlags) TypeExtensions.InvokeMethod(Object, Expression<Action>, BindingFlags) SqlBlockExtensions.SetExpression<TTag, TResult>(TTag, Expression<Func<IBlockQueryAdapter, TResult>>) QueryDescriptionExtensions.SetExpression<TTag, TResult>(TTag, Expression<Func<IQueryStructureAdapter, TResult>>)"
  },
  "api/XData.Database.Adapter.QueryResultBase.html": {
    "href": "api/XData.Database.Adapter.QueryResultBase.html",
    "title": "Class QueryResultBase | XData website",
    "keywords": "Class QueryResultBase SQL query result Inheritance Object QueryResultBase CallResult QueryResult Implements IEnumerable < QueryParam > IEnumerable Inherited Members Object.Equals(Object) Object.Equals(Object, Object) Object.GetHashCode() Object.GetType() Object.MemberwiseClone() Object.ReferenceEquals(Object, Object) Object.ToString() Namespace : XData.Database.Adapter Assembly : XData.docfx.dll Syntax public abstract class QueryResultBase : IEnumerable<QueryParam>, IEnumerable Constructors | Improve this Doc View Source QueryResultBase() Query result constructor Declaration protected QueryResultBase() | Improve this Doc View Source QueryResultBase(Int32, IEnumerable<QueryParam>) Query result constructor Declaration protected QueryResultBase(int affectedRows, IEnumerable<QueryParam> queryParams) Parameters Type Name Description Int32 affectedRows Affected rows count IEnumerable < QueryParam > queryParams Output parameters Properties | Improve this Doc View Source AffectedRows Count of rows affected by query Declaration public int AffectedRows { get; } Property Value Type Description Int32 | Improve this Doc View Source Item[Int32] Query parameters by index Declaration public QueryParam this[int i] { get; } Parameters Type Name Description Int32 i Parameter index Property Value Type Description QueryParam Query parameter | Improve this Doc View Source Item[String] Query parameters by name Declaration public QueryParam this[string name] { get; } Parameters Type Name Description String name Parameter name Property Value Type Description QueryParam Query parameter | Improve this Doc View Source ParamsCount Query parameters count Declaration public int ParamsCount { get; } Property Value Type Description Int32 Methods | Improve this Doc View Source GetEnumerator() Query parameters enumeration Declaration public IEnumerator<QueryParam> GetEnumerator() Returns Type Description IEnumerator < QueryParam > Query parameters enumeration | Improve this Doc View Source Init(Int32, IEnumerable<IDataParameter>) Query result initialization Declaration protected void Init(int affectedRows, IEnumerable<IDataParameter> queryParams) Parameters Type Name Description Int32 affectedRows Affected rows count IEnumerable < IDataParameter > queryParams Output parameters | Improve this Doc View Source Init(Int32, IEnumerable<QueryParam>) Query result initialization Declaration protected void Init(int affectedRows, IEnumerable<QueryParam> queryParams) Parameters Type Name Description Int32 affectedRows Affected rows count IEnumerable < QueryParam > queryParams Output parameters | Improve this Doc View Source Init(Int32, IDataParameterCollection) Query result initialization Declaration protected void Init(int affectedRows, IDataParameterCollection queryParams) Parameters Type Name Description Int32 affectedRows Affected rows count IDataParameterCollection queryParams Output parameters | Improve this Doc View Source ParamInit(IDataParameter) Output parameter initialization Declaration protected abstract QueryParam ParamInit(IDataParameter parameter) Parameters Type Name Description IDataParameter parameter Output parameter Returns Type Description QueryParam Explicit Interface Implementations | Improve this Doc View Source IEnumerable.GetEnumerator() Query parameters enumeration Declaration IEnumerator IEnumerable.GetEnumerator() Returns Type Description IEnumerator Query parameters enumeration Implements System.Collections.Generic.IEnumerable<T> System.Collections.IEnumerable Extension Methods SerializationExtensions.ToXml<T>(T) CollectionsExtensions.ToSortedSet<T>(IEnumerable<T>, IComparer<T>) CollectionsExtensions.SetValue<TKey, T>(TKey, T) CollectionsExtensions.AsEnum<T>(T) DataObjectQueryableExtensions.CompareVariable(Object, FilterOperation, String) JoinedEnumerable.Inner<TElement>(IEnumerable<TElement>) JoinedEnumerable.Outer<TElement>(IEnumerable<TElement>) JoinedEnumerable.LeftOuterJoin<TOuter, TInner, TKey, TResult>(IEnumerable<TOuter>, IEnumerable<TInner>, Func<TOuter, TKey>, Func<TInner, TKey>, Func<TOuter, TInner, TResult>, IEqualityComparer<TKey>) JoinedEnumerable.RightOuterJoin<TOuter, TInner, TKey, TResult>(IEnumerable<TOuter>, IEnumerable<TInner>, Func<TOuter, TKey>, Func<TInner, TKey>, Func<TOuter, TInner, TResult>, IEqualityComparer<TKey>) JoinedEnumerable.FullOuterJoin<TOuter, TInner, TKey, TResult>(IEnumerable<TOuter>, IEnumerable<TInner>, Func<TOuter, TKey>, Func<TInner, TKey>, Func<TOuter, TInner, TResult>, IEqualityComparer<TKey>) Processing.Do<T>(T, Action<IProcess<T>>[]) TypeExtensions.TryConvert<T, TResult>(T, Func<T, TResult>) TypeExtensions.TryConvert<T, TResult>(T, Func<T, TResult>, TResult) TypeExtensions.ChangeType<T>(Object) TypeExtensions.ChangeType(Object, Type) TypeExtensions.InvokeMethod<TRet>(Object, Type[], Expression<Func<TRet>>, BindingFlags) TypeExtensions.InvokeMethod(Object, Type[], Expression<Action>, BindingFlags) TypeExtensions.InvokeMethod<TRet>(Object, Expression<Func<TRet>>, BindingFlags) TypeExtensions.InvokeMethod(Object, Expression<Action>, BindingFlags) SqlBlockExtensions.SetExpression<TTag, TResult>(TTag, Expression<Func<IBlockQueryAdapter, TResult>>) QueryDescriptionExtensions.SetExpression<TTag, TResult>(TTag, Expression<Func<IQueryStructureAdapter, TResult>>) QueryDescriptionExtensions.ToDataSet<T>(IEnumerable<T>, String, ISqlBuilder)"
  },
  "api/XData.InvalidateObject-1.html": {
    "href": "api/XData.InvalidateObject-1.html",
    "title": "Delegate InvalidateObject<T> | XData website",
    "keywords": "Delegate InvalidateObject<T> Refresh one object event delegate type Namespace : XData Assembly : XData.docfx.dll Syntax public delegate void InvalidateObject<in T>(T obj) where T : class, IDataObject; Parameters Type Name Description T obj Object to refresh Type Parameters Name Description T Object type Extension Methods SerializationExtensions.ToXml<T>(T) CollectionsExtensions.SetValue<TKey, T>(TKey, T) CollectionsExtensions.AsEnum<T>(T) DataObjectQueryableExtensions.CompareVariable(Object, FilterOperation, String) Processing.Do<T>(T, Action<IProcess<T>>[]) TypeExtensions.TryConvert<T, TResult>(T, Func<T, TResult>) TypeExtensions.TryConvert<T, TResult>(T, Func<T, TResult>, TResult) TypeExtensions.ChangeType<T>(Object) TypeExtensions.ChangeType(Object, Type) TypeExtensions.InvokeMethod<TRet>(Object, Type[], Expression<Func<TRet>>, BindingFlags) TypeExtensions.InvokeMethod(Object, Type[], Expression<Action>, BindingFlags) TypeExtensions.InvokeMethod<TRet>(Object, Expression<Func<TRet>>, BindingFlags) TypeExtensions.InvokeMethod(Object, Expression<Action>, BindingFlags) SqlBlockExtensions.SetExpression<TTag, TResult>(TTag, Expression<Func<IBlockQueryAdapter, TResult>>) QueryDescriptionExtensions.SetExpression<TTag, TResult>(TTag, Expression<Func<IQueryStructureAdapter, TResult>>) See Also InvalidateObject OnInvalidateObject"
  },
  "api/XData.IDataScope.html": {
    "href": "api/XData.IDataScope.html",
    "title": "Interface IDataScope | XData website",
    "keywords": "Interface IDataScope XData operational scope Inherited Members IDisposable.Dispose() Namespace : XData Assembly : XData.docfx.dll Syntax public interface IDataScope : IDisposable Properties | Improve this Doc View Source DefaultContext Data scope default context Declaration string DefaultContext { get; } Property Value Type Description String | Improve this Doc View Source Layer Data scope layer identity Declaration Guid Layer { get; } Property Value Type Description Guid | Improve this Doc View Source Security Security session Declaration ISecuritySession Security { get; } Property Value Type Description ISecuritySession | Improve this Doc View Source Token Data scope cancellation token Declaration CancellationToken Token { get; } Property Value Type Description CancellationToken Methods | Improve this Doc View Source BeginTransaction(Boolean, IsolationLevel) Begins single context transaction Declaration ITransaction BeginTransaction(bool read = false, IsolationLevel isolation = IsolationLevel.ReadCommitted) Parameters Type Name Description Boolean read Read only transaction IsolationLevel isolation Transaction isolation level Returns Type Description ITransaction Transaction wrapper Exceptions Type Condition XDataConfigurationException XData configuration errors. XDataAdapterException XData adapter errors. XDataSqlException SQL exceptions while beginning transaction. See Also ITransaction IsolationLevel | Improve this Doc View Source ExecuteNonQuery(Query) Execute SQL expression custom query with no result set Declaration QueryResult ExecuteNonQuery(Query query) Parameters Type Name Description Query query Custom query Returns Type Description QueryResult Custom query affected rows and out parameters | Improve this Doc View Source ExecuteScalar<TResult>(Query) Execute SQL single value result custom query Declaration TResult ExecuteScalar<TResult>(Query query) Parameters Type Name Description Query query Custom query Returns Type Description TResult Custom query single value result Type Parameters Name Description TResult Result value type | Improve this Doc View Source FillTable(Query, CommandBehavior) Fill DataTable with custom query results Declaration DataTable FillTable(Query query, CommandBehavior behavior = CommandBehavior.Default) Parameters Type Name Description Query query Custom query CommandBehavior behavior Query command behavior Returns Type Description DataTable DataTable | Improve this Doc View Source GetContext() Returns context by name Declaration XDataContext GetContext() Returns Type Description XDataContext Context Exceptions Type Condition XDataConfigurationException XData configuration errors. XDataAdapterException XData adapter errors. | Improve this Doc View Source GetDictionaryValue<T>(Expression<Func<T, Boolean>>, String, ISecuritySession, Variable[]) Returns dictionary value by find expression and cache result Declaration T GetDictionaryValue<T>(Expression<Func<T, bool>> findExpression, string alias = null, ISecuritySession security = null, params Variable[] variables) where T : class, IDataObject, new() Parameters Type Name Description Expression < Func <T, Boolean >> findExpression Expression to find value String alias Repository alias ISecuritySession security Security session Variable [] variables Repository variables Returns Type Description T Dictionary object Type Parameters Name Description T Dictionary type Exceptions Type Condition XDataRuntimeException XDataRuntimeException No original data found for object XDataRuntimeException findExpression parameter is null | Improve this Doc View Source GetQuery<T>(TextReader, String, ISecuritySession) Get query Declaration IDataQuery<T> GetQuery<T>(TextReader reader, string alias = null, ISecuritySession security = null) where T : class, IDataObject, new() Parameters Type Name Description TextReader reader Serialized data reader String alias Base repository alias ISecuritySession security Security session Returns Type Description IDataQuery <T> Data query Type Parameters Name Description T Data object type Exceptions Type Condition XDataConfigurationException XData configuration errors. XDataAdapterException XData adapter errors. XDataAdapterException Adapter logic error. XDataRuntimeException reader parameter can not be null | Improve this Doc View Source GetRepository<T>(TextReader) Get repository Declaration IRepository<T> GetRepository<T>(TextReader reader) where T : class, IDataObject, new() Parameters Type Name Description TextReader reader Serialized data reader Returns Type Description IRepository <T> Repository Type Parameters Name Description T Data object type Exceptions Type Condition XDataConfigurationException XData configuration errors. XDataAdapterException XData adapter errors. XDataAdapterException Adapter logic error. XDataRuntimeException reader parameter can not be null | Improve this Doc View Source GetRepository<T>(String, ISecuritySession, Variable[]) Get repository Declaration IRepository<T> GetRepository<T>(string alias = null, ISecuritySession security = null, params Variable[] variables) where T : class, IDataObject, new() Parameters Type Name Description String alias Data object alias ISecuritySession security Security session Variable [] variables Data object variables Returns Type Description IRepository <T> Repository Type Parameters Name Description T Data object type Exceptions Type Condition XDataQueryStructureException no mapping found. XDataConfigurationException XData configuration errors. XDataAdapterException XData adapter errors. XDataAdapterException Custom logic error. | Improve this Doc View Source GetRepository<T>(String, Variable[]) Get repository Declaration IRepository<T> GetRepository<T>(string alias = null, params Variable[] variables) where T : class, IDataObject, new() Parameters Type Name Description String alias Data object alias Variable [] variables Data object variables Returns Type Description IRepository <T> Repository Type Parameters Name Description T Data object type Exceptions Type Condition XDataQueryStructureException no mapping found. XDataConfigurationException XData configuration errors. XDataAdapterException XData adapter errors. XDataAdapterException Custom logic error. | Improve this Doc View Source GetRepository<T>(ISecuritySession, Variable[]) Get repository Declaration IRepository<T> GetRepository<T>(ISecuritySession security = null, params Variable[] variables) where T : class, IDataObject, new() Parameters Type Name Description ISecuritySession security Security session Variable [] variables Data object variables Returns Type Description IRepository <T> Repository Type Parameters Name Description T Data object type Exceptions Type Condition XDataQueryStructureException no mapping found. XDataConfigurationException XData configuration errors. XDataAdapterException XData adapter errors. XDataAdapterException Custom logic error. | Improve this Doc View Source GetRepository<T>(Variable[]) Get repository Declaration IRepository<T> GetRepository<T>(params Variable[] variables) where T : class, IDataObject, new() Parameters Type Name Description Variable [] variables Data object variables Returns Type Description IRepository <T> Repository Type Parameters Name Description T Data object type Exceptions Type Condition XDataQueryStructureException no mapping found. XDataConfigurationException XData configuration errors. XDataAdapterException XData adapter errors. XDataAdapterException Custom logic error. | Improve this Doc View Source Reset() Reset data scope caches Declaration void Reset() Extension Methods SerializationExtensions.ToXml<T>(T) AsyncExtensions.FillTableAsync(IDataScope, Query, CommandBehavior) AsyncExtensions.ExecuteScalarAsync<TResult>(IDataScope, Query) AsyncExtensions.ExecuteNonQueryAsync(IDataScope, Query) AsyncExtensions.ExecuteSqlBlockAsync(IDataScope, Expression<SqlBlockDefinition>, Expression<Func<ISqlParamAdapter, ISqlParam>>[]) AsyncExtensions.ExecuteSqlBlockAsync(IDataScope, CancellationToken, Expression<SqlBlockDefinition>, Expression<Func<ISqlParamAdapter, ISqlParam>>[]) AsyncExtensions.GetSqlBlockDataAsync<T>(IDataScope, Expression<SqlBlockDefinition<T>>, Expression<Func<ISqlParamAdapter, ISqlParam>>[]) AsyncExtensions.GetSqlBlockDataAsync<T>(IDataScope, Func<JsonSettings<T>, JsonSettings<T>>, Expression<SqlBlockDefinition<T>>, Expression<Func<ISqlParamAdapter, ISqlParam>>[]) CollectionsExtensions.SetValue<TKey, T>(TKey, T) CollectionsExtensions.AsEnum<T>(T) DataObjectQueryableExtensions.CompareVariable(Object, FilterOperation, String) Processing.Do<T>(T, Action<IProcess<T>>[]) TypeExtensions.TryConvert<T, TResult>(T, Func<T, TResult>) TypeExtensions.TryConvert<T, TResult>(T, Func<T, TResult>, TResult) TypeExtensions.ChangeType<T>(Object) TypeExtensions.ChangeType(Object, Type) TypeExtensions.InvokeMethod<TRet>(Object, Type[], Expression<Func<TRet>>, BindingFlags) TypeExtensions.InvokeMethod(Object, Type[], Expression<Action>, BindingFlags) TypeExtensions.InvokeMethod<TRet>(Object, Expression<Func<TRet>>, BindingFlags) TypeExtensions.InvokeMethod(Object, Expression<Action>, BindingFlags) SqlBlockExtensions.ExecuteSqlBlock(IDataScope, Expression<SqlBlockDefinition>, Expression<Func<ISqlParamAdapter, ISqlParam>>[]) SqlBlockExtensions.GetSqlBlockData<T>(IDataScope, Expression<SqlBlockDefinition<T>>, Expression<Func<ISqlParamAdapter, ISqlParam>>[]) SqlBlockExtensions.SetExpression<TTag, TResult>(TTag, Expression<Func<IBlockQueryAdapter, TResult>>) QueryDescriptionExtensions.SetExpression<TTag, TResult>(TTag, Expression<Func<IQueryStructureAdapter, TResult>>)"
  },
  "api/XData.Mapping.ParameterAttribute.html": {
    "href": "api/XData.Mapping.ParameterAttribute.html",
    "title": "Class ParameterAttribute | XData website",
    "keywords": "Class ParameterAttribute SQL stored procedure/function parameter Inheritance Object Attribute ParameterAttribute Inherited Members Attribute.Equals(Object) Attribute.GetCustomAttribute(Assembly, Type) Attribute.GetCustomAttribute(Assembly, Type, Boolean) Attribute.GetCustomAttribute(MemberInfo, Type) Attribute.GetCustomAttribute(MemberInfo, Type, Boolean) Attribute.GetCustomAttribute(Module, Type) Attribute.GetCustomAttribute(Module, Type, Boolean) Attribute.GetCustomAttribute(ParameterInfo, Type) Attribute.GetCustomAttribute(ParameterInfo, Type, Boolean) Attribute.GetCustomAttributes(Assembly) Attribute.GetCustomAttributes(Assembly, Boolean) Attribute.GetCustomAttributes(Assembly, Type) Attribute.GetCustomAttributes(Assembly, Type, Boolean) Attribute.GetCustomAttributes(MemberInfo) Attribute.GetCustomAttributes(MemberInfo, Boolean) Attribute.GetCustomAttributes(MemberInfo, Type) Attribute.GetCustomAttributes(MemberInfo, Type, Boolean) Attribute.GetCustomAttributes(Module) Attribute.GetCustomAttributes(Module, Boolean) Attribute.GetCustomAttributes(Module, Type) Attribute.GetCustomAttributes(Module, Type, Boolean) Attribute.GetCustomAttributes(ParameterInfo) Attribute.GetCustomAttributes(ParameterInfo, Boolean) Attribute.GetCustomAttributes(ParameterInfo, Type) Attribute.GetCustomAttributes(ParameterInfo, Type, Boolean) Attribute.GetHashCode() Attribute.IsDefaultAttribute() Attribute.IsDefined(Assembly, Type) Attribute.IsDefined(Assembly, Type, Boolean) Attribute.IsDefined(MemberInfo, Type) Attribute.IsDefined(MemberInfo, Type, Boolean) Attribute.IsDefined(Module, Type) Attribute.IsDefined(Module, Type, Boolean) Attribute.IsDefined(ParameterInfo, Type) Attribute.IsDefined(ParameterInfo, Type, Boolean) Attribute.Match(Object) Object.Equals(Object, Object) Object.GetType() Object.MemberwiseClone() Object.ReferenceEquals(Object, Object) Object.ToString() Namespace : XData.Mapping Assembly : XData.docfx.dll Syntax [AttributeUsage(AttributeTargets.Class, AllowMultiple = true)] public sealed class ParameterAttribute : Attribute Constructors | Improve this Doc View Source ParameterAttribute(String, Int32, String, Type, DbType) Parameter attribute constructor Declaration public ParameterAttribute(string alias, int order, string binding, Type type, DbType dbType) Parameters Type Name Description String alias SQL stored procedure/function alias Int32 order Parameter order String binding Parameter to repository variable binding Type type Parameter mapped type DbType dbType Parameter database type Properties | Improve this Doc View Source DefaultType Parameter default value type Declaration public DefaultType DefaultType { get; set; } Property Value Type Description DefaultType | Improve this Doc View Source DefaultValue Parameter default value Declaration public object DefaultValue { get; set; } Property Value Type Description Object | Improve this Doc View Source Direction Parameter direction Declaration public ParameterDirection Direction { get; set; } Property Value Type Description ParameterDirection | Improve this Doc View Source IsArray User defined type (UDT) collection is VARARRAY Declaration public bool IsArray { get; set; } Property Value Type Description Boolean | Improve this Doc View Source Name Parameter name Declaration public string Name { get; set; } Property Value Type Description String | Improve this Doc View Source NativeSqlType Native SQL type name Declaration public string NativeSqlType { get; set; } Property Value Type Description String Remarks Used to specify native SQL column type when conflicted with default type mapping WARNING! May be not supported by database adapter! | Improve this Doc View Source Scale Parameter data scale (if applicable) Declaration public int Scale { get; set; } Property Value Type Description Int32 | Improve this Doc View Source Size Parameter data size (if applicable) Declaration public int Size { get; set; } Property Value Type Description Int32 | Improve this Doc View Source TypeId When implemented in a derived class, gets a unique identifier for this Attribute . Declaration public override object TypeId { get; } Property Value Type Description Object An Object that is a unique identifier for the attribute. Overrides Attribute.TypeId | Improve this Doc View Source UdtElementTypeName User defined type (UDT) element type name Declaration public string UdtElementTypeName { get; set; } Property Value Type Description String | Improve this Doc View Source UdtTypeName User defined type (UDT) name Declaration public string UdtTypeName { get; set; } Property Value Type Description String Extension Methods SerializationExtensions.ToXml<T>(T) CollectionsExtensions.SetValue<TKey, T>(TKey, T) CollectionsExtensions.AsEnum<T>(T) DataObjectQueryableExtensions.CompareVariable(Object, FilterOperation, String) Processing.Do<T>(T, Action<IProcess<T>>[]) TypeExtensions.TryConvert<T, TResult>(T, Func<T, TResult>) TypeExtensions.TryConvert<T, TResult>(T, Func<T, TResult>, TResult) TypeExtensions.ChangeType<T>(Object) TypeExtensions.ChangeType(Object, Type) TypeExtensions.InvokeMethod<TRet>(Object, Type[], Expression<Func<TRet>>, BindingFlags) TypeExtensions.InvokeMethod(Object, Type[], Expression<Action>, BindingFlags) TypeExtensions.InvokeMethod<TRet>(Object, Expression<Func<TRet>>, BindingFlags) TypeExtensions.InvokeMethod(Object, Expression<Action>, BindingFlags) SqlBlockExtensions.SetExpression<TTag, TResult>(TTag, Expression<Func<IBlockQueryAdapter, TResult>>) QueryDescriptionExtensions.SetExpression<TTag, TResult>(TTag, Expression<Func<IQueryStructureAdapter, TResult>>)"
  },
  "api/XData.Mapping.OptionalFilterAttribute.html": {
    "href": "api/XData.Mapping.OptionalFilterAttribute.html",
    "title": "Class OptionalFilterAttribute | XData website",
    "keywords": "Class OptionalFilterAttribute Base optional filter attribute Inheritance Object Attribute FilterBaseAttribute FilterAttribute OptionalFilterAttribute LinkAttribute SubqueryFilterAttribute Inherited Members FilterAttribute.Source FilterAttribute.FieldName FilterAttribute.Operation FilterAttribute.Combination FilterBaseAttribute.FilterType Attribute.Equals(Object) Attribute.GetCustomAttribute(Assembly, Type) Attribute.GetCustomAttribute(Assembly, Type, Boolean) Attribute.GetCustomAttribute(MemberInfo, Type) Attribute.GetCustomAttribute(MemberInfo, Type, Boolean) Attribute.GetCustomAttribute(Module, Type) Attribute.GetCustomAttribute(Module, Type, Boolean) Attribute.GetCustomAttribute(ParameterInfo, Type) Attribute.GetCustomAttribute(ParameterInfo, Type, Boolean) Attribute.GetCustomAttributes(Assembly) Attribute.GetCustomAttributes(Assembly, Boolean) Attribute.GetCustomAttributes(Assembly, Type) Attribute.GetCustomAttributes(Assembly, Type, Boolean) Attribute.GetCustomAttributes(MemberInfo) Attribute.GetCustomAttributes(MemberInfo, Boolean) Attribute.GetCustomAttributes(MemberInfo, Type) Attribute.GetCustomAttributes(MemberInfo, Type, Boolean) Attribute.GetCustomAttributes(Module) Attribute.GetCustomAttributes(Module, Boolean) Attribute.GetCustomAttributes(Module, Type) Attribute.GetCustomAttributes(Module, Type, Boolean) Attribute.GetCustomAttributes(ParameterInfo) Attribute.GetCustomAttributes(ParameterInfo, Boolean) Attribute.GetCustomAttributes(ParameterInfo, Type) Attribute.GetCustomAttributes(ParameterInfo, Type, Boolean) Attribute.GetHashCode() Attribute.IsDefaultAttribute() Attribute.IsDefined(Assembly, Type) Attribute.IsDefined(Assembly, Type, Boolean) Attribute.IsDefined(MemberInfo, Type) Attribute.IsDefined(MemberInfo, Type, Boolean) Attribute.IsDefined(Module, Type) Attribute.IsDefined(Module, Type, Boolean) Attribute.IsDefined(ParameterInfo, Type) Attribute.IsDefined(ParameterInfo, Type, Boolean) Attribute.Match(Object) Attribute.TypeId Object.Equals(Object, Object) Object.GetType() Object.MemberwiseClone() Object.ReferenceEquals(Object, Object) Object.ToString() Namespace : XData.Mapping Assembly : XData.docfx.dll Syntax [AttributeUsage(AttributeTargets.Class, AllowMultiple = true)] public abstract class OptionalFilterAttribute : FilterAttribute Remarks Optional filters can be used to conditionally omit parts of query If filter marked by PrimaryFilter = true has no value assigned - it cause omit it primary source from query If link marked by PrimaryFilter = true has one of sources omitted - it cause omit other source from query two If base source BaseSource is omitted - all entire query is omitted Hint: It can be used to build conditional sub queries or inner views For example: -- if filterBySomeField has PrimaryFilter flag = true, query... select ot.one_table_id, ot.name from one_table ot where ot.one_table_id in (select st.one_table_id from second_table st where st.some_field = :filterBySomeField) -- when filterBySomeField has no value assigned will be transformed into... select one_table_id, name from one_table -- bat have a full form when filterBySomeField value is assigned Constructors | Improve this Doc View Source OptionalFilterAttribute(String, String) Base optional filter attribute Declaration protected OptionalFilterAttribute(string sourceAlias, string fieldName) Parameters Type Name Description String sourceAlias Primary source alias String fieldName Primary field name Properties | Improve this Doc View Source PrimaryFilter Primary filter flag Declaration public bool PrimaryFilter { get; set; } Property Value Type Description Boolean Extension Methods SerializationExtensions.ToXml<T>(T) CollectionsExtensions.SetValue<TKey, T>(TKey, T) CollectionsExtensions.AsEnum<T>(T) DataObjectQueryableExtensions.CompareVariable(Object, FilterOperation, String) Processing.Do<T>(T, Action<IProcess<T>>[]) TypeExtensions.TryConvert<T, TResult>(T, Func<T, TResult>) TypeExtensions.TryConvert<T, TResult>(T, Func<T, TResult>, TResult) TypeExtensions.ChangeType<T>(Object) TypeExtensions.ChangeType(Object, Type) TypeExtensions.InvokeMethod<TRet>(Object, Type[], Expression<Func<TRet>>, BindingFlags) TypeExtensions.InvokeMethod(Object, Type[], Expression<Action>, BindingFlags) TypeExtensions.InvokeMethod<TRet>(Object, Expression<Func<TRet>>, BindingFlags) TypeExtensions.InvokeMethod(Object, Expression<Action>, BindingFlags) SqlBlockExtensions.SetExpression<TTag, TResult>(TTag, Expression<Func<IBlockQueryAdapter, TResult>>) QueryDescriptionExtensions.SetExpression<TTag, TResult>(TTag, Expression<Func<IQueryStructureAdapter, TResult>>) See Also LinkAttribute SubqueryLinkAttribute SubqueryFilterAttribute RuntimeFilter"
  },
  "api/XData.DataSource.Structure.ISubqueryFilter.html": {
    "href": "api/XData.DataSource.Structure.ISubqueryFilter.html",
    "title": "Interface ISubqueryFilter | XData website",
    "keywords": "Interface ISubqueryFilter Subquery filter interface Inherited Members IOptionalFilter.Primary IFilter.FilterType IFilter.SourceAlias IFilter.Field IFilter.Operation ICloneable.Clone() Namespace : XData.DataSource.Structure Assembly : XData.docfx.dll Syntax public interface ISubqueryFilter : IOptionalFilter, IFilter, ICloneable Properties | Improve this Doc View Source SubqueryAlias Subquery alias Declaration string SubqueryAlias { get; } Property Value Type Description String Extension Methods SerializationExtensions.ToXml<T>(T) CollectionsExtensions.SetValue<TKey, T>(TKey, T) CollectionsExtensions.AsEnum<T>(T) DataObjectQueryableExtensions.CompareVariable(Object, FilterOperation, String) Processing.Do<T>(T, Action<IProcess<T>>[]) TypeExtensions.TryConvert<T, TResult>(T, Func<T, TResult>) TypeExtensions.TryConvert<T, TResult>(T, Func<T, TResult>, TResult) TypeExtensions.ChangeType<T>(Object) TypeExtensions.ChangeType(Object, Type) TypeExtensions.InvokeMethod<TRet>(Object, Type[], Expression<Func<TRet>>, BindingFlags) TypeExtensions.InvokeMethod(Object, Type[], Expression<Action>, BindingFlags) TypeExtensions.InvokeMethod<TRet>(Object, Expression<Func<TRet>>, BindingFlags) TypeExtensions.InvokeMethod(Object, Expression<Action>, BindingFlags) SqlBlockExtensions.SetExpression<TTag, TResult>(TTag, Expression<Func<IBlockQueryAdapter, TResult>>) QueryDescriptionExtensions.SetExpression<TTag, TResult>(TTag, Expression<Func<IQueryStructureAdapter, TResult>>)"
  },
  "api/XData.DataSource.Structure.Hierarchy.html": {
    "href": "api/XData.DataSource.Structure.Hierarchy.html",
    "title": "Class Hierarchy | XData website",
    "keywords": "Class Hierarchy Hierarchy Inheritance Object Hierarchy Inherited Members Object.Equals(Object) Object.Equals(Object, Object) Object.GetHashCode() Object.GetType() Object.MemberwiseClone() Object.ReferenceEquals(Object, Object) Object.ToString() Namespace : XData.DataSource.Structure Assembly : XData.docfx.dll Syntax public sealed class Hierarchy Constructors | Improve this Doc View Source Hierarchy(String, String, String, String) Hierarchy constructor Declaration public Hierarchy(string name, string parent, string linkParent, string linkChild) Parameters Type Name Description String name Hierarchy table name String parent Parent link field String linkParent Hierarchy table parent link String linkChild Hierarchy table child link Properties | Improve this Doc View Source LinkChild Hierarchy table child link Declaration public string LinkChild { get; } Property Value Type Description String | Improve this Doc View Source LinkParent Hierarchy table parent link Declaration public string LinkParent { get; } Property Value Type Description String | Improve this Doc View Source Name Hierarchy table name Declaration public string Name { get; } Property Value Type Description String | Improve this Doc View Source Parent Parent link field Declaration public string Parent { get; } Property Value Type Description String Extension Methods SerializationExtensions.ToXml<T>(T) CollectionsExtensions.SetValue<TKey, T>(TKey, T) CollectionsExtensions.AsEnum<T>(T) DataObjectQueryableExtensions.CompareVariable(Object, FilterOperation, String) Processing.Do<T>(T, Action<IProcess<T>>[]) TypeExtensions.TryConvert<T, TResult>(T, Func<T, TResult>) TypeExtensions.TryConvert<T, TResult>(T, Func<T, TResult>, TResult) TypeExtensions.ChangeType<T>(Object) TypeExtensions.ChangeType(Object, Type) TypeExtensions.InvokeMethod<TRet>(Object, Type[], Expression<Func<TRet>>, BindingFlags) TypeExtensions.InvokeMethod(Object, Type[], Expression<Action>, BindingFlags) TypeExtensions.InvokeMethod<TRet>(Object, Expression<Func<TRet>>, BindingFlags) TypeExtensions.InvokeMethod(Object, Expression<Action>, BindingFlags) SqlBlockExtensions.SetExpression<TTag, TResult>(TTag, Expression<Func<IBlockQueryAdapter, TResult>>) QueryDescriptionExtensions.SetExpression<TTag, TResult>(TTag, Expression<Func<IQueryStructureAdapter, TResult>>)"
  },
  "api/XData.Database.Dialect.XConnectionInfo.html": {
    "href": "api/XData.Database.Dialect.XConnectionInfo.html",
    "title": "Class XConnectionInfo | XData website",
    "keywords": "Class XConnectionInfo Context connection info Inheritance Object XConnectionInfo Inherited Members Object.Equals(Object) Object.Equals(Object, Object) Object.GetHashCode() Object.GetType() Object.MemberwiseClone() Object.ReferenceEquals(Object, Object) Object.ToString() Namespace : XData.Database.Dialect Assembly : XData.docfx.dll Syntax public class XConnectionInfo Properties | Improve this Doc View Source DbLogin Database user login Declaration public string DbLogin { get; } Property Value Type Description String | Improve this Doc View Source IntegratedSecurity Integrated security flag Declaration public bool IntegratedSecurity { get; } Property Value Type Description Boolean | Improve this Doc View Source Schema Database name or schema name Declaration public string Schema { get; } Property Value Type Description String | Improve this Doc View Source Server Database server name Declaration public string Server { get; } Property Value Type Description String Extension Methods SerializationExtensions.ToXml<T>(T) CollectionsExtensions.SetValue<TKey, T>(TKey, T) CollectionsExtensions.AsEnum<T>(T) DataObjectQueryableExtensions.CompareVariable(Object, FilterOperation, String) Processing.Do<T>(T, Action<IProcess<T>>[]) TypeExtensions.TryConvert<T, TResult>(T, Func<T, TResult>) TypeExtensions.TryConvert<T, TResult>(T, Func<T, TResult>, TResult) TypeExtensions.ChangeType<T>(Object) TypeExtensions.ChangeType(Object, Type) TypeExtensions.InvokeMethod<TRet>(Object, Type[], Expression<Func<TRet>>, BindingFlags) TypeExtensions.InvokeMethod(Object, Type[], Expression<Action>, BindingFlags) TypeExtensions.InvokeMethod<TRet>(Object, Expression<Func<TRet>>, BindingFlags) TypeExtensions.InvokeMethod(Object, Expression<Action>, BindingFlags) SqlBlockExtensions.SetExpression<TTag, TResult>(TTag, Expression<Func<IBlockQueryAdapter, TResult>>) QueryDescriptionExtensions.SetExpression<TTag, TResult>(TTag, Expression<Func<IQueryStructureAdapter, TResult>>)"
  },
  "api/XData.Database.Adapter.html": {
    "href": "api/XData.Database.Adapter.html",
    "title": "Namespace XData.Database.Adapter | XData website",
    "keywords": "Namespace XData.Database.Adapter Classes BaseDatabaseAdapter<TConnection, TParameter> Database adapter base class CallResult Stored procedure call result DatabaseAdapterAttribute Database adapter attribute Query SQL query QueryParam SQL query parameter QueryResult SQL query result QueryResultBase SQL query result StoredProcedure SQL stored procedure UdtSqlType User defined type (UDT) description Interfaces IDatabaseAdapter Database adapter basic interface IDatabaseAdapterMetadata Database adapter description interface"
  },
  "api/XData.Mapping.Dynamic.IRepositoryStructureAdapter-1.html": {
    "href": "api/XData.Mapping.Dynamic.IRepositoryStructureAdapter-1.html",
    "title": "Interface IRepositoryStructureAdapter<T> | XData website",
    "keywords": "Interface IRepositoryStructureAdapter<T> Repository structure mapping adapter interface Inherited Members IRepositoryStructureAdapter.Expr<TValue>(String, DataExpressionType, String, DbType, Expression<Func<IRepositoryExpressionMappingAdapter, IStructureFlag>>[]) IRepositoryStructureAdapter.Expr<TValue>(String, Expression<Func<IQueryStructureAdapter, TValue>>, DbType, Expression<Func<IRepositoryExpressionMappingAdapter, IStructureFlag>>[]) IRepositoryStructureAdapter.Ref<TValue>(String, String, Expression<Func<IRepositoryReadOnlyPropertyMappingAdapter, IStructureFlag>>[]) IRepositoryStructureAdapter.Ref<TValue, TInnerView>(String, Expression<Func<TInnerView, Object>>, Expression<Func<IRepositoryReadOnlyPropertyMappingAdapter, IStructureFlag>>[]) Namespace : XData.Mapping.Dynamic Assembly : XData.docfx.dll Syntax public interface IRepositoryStructureAdapter<T> : IRepositoryStructureAdapter where T : class, ISqlObject, new() Type Parameters Name Description T Methods | Improve this Doc View Source Field<TValue>(Expression<Func<IRepositoryPropertyMappingAdapter<T, TValue>, IStructureFlag>>[]) Field mapping Declaration TValue Field<TValue>(params Expression<Func<IRepositoryPropertyMappingAdapter<T, TValue>, IStructureFlag>>[] attributes) Parameters Type Name Description Expression < Func < IRepositoryPropertyMappingAdapter <T, TValue>, IStructureFlag >>[] attributes Property mapping attributes Returns Type Description TValue Field value Type Parameters Name Description TValue Field type Remarks WARNING! Can be used in dynamic query mapping only! See Also Select<TResult>(Expression<Func<IQueryStructureAdapter, TResult>>) | Improve this Doc View Source Field<TValue>(String, Expression<Func<IRepositoryPropertyMappingAdapter<T, TValue>, IStructureFlag>>[]) Field mapping Declaration TValue Field<TValue>(string fieldName, params Expression<Func<IRepositoryPropertyMappingAdapter<T, TValue>, IStructureFlag>>[] attributes) Parameters Type Name Description String fieldName Field name Expression < Func < IRepositoryPropertyMappingAdapter <T, TValue>, IStructureFlag >>[] attributes Property mapping attributes Returns Type Description TValue Field value Type Parameters Name Description TValue Field type Remarks WARNING! Can be used in dynamic query mapping only! See Also Select<TResult>(Expression<Func<IQueryStructureAdapter, TResult>>) | Improve this Doc View Source Field<TValue>(String, String, Expression<Func<IRepositoryPropertyMappingAdapter<T, TValue>, IStructureFlag>>[]) Field mapping Declaration TValue Field<TValue>(string sourceAlias, string fieldName, params Expression<Func<IRepositoryPropertyMappingAdapter<T, TValue>, IStructureFlag>>[] attributes) Parameters Type Name Description String sourceAlias Source alias String fieldName Field name Expression < Func < IRepositoryPropertyMappingAdapter <T, TValue>, IStructureFlag >>[] attributes Property mapping attributes Returns Type Description TValue Field value Type Parameters Name Description TValue Field type Remarks WARNING! Can be used in dynamic query mapping only! See Also Select<TResult>(Expression<Func<IQueryStructureAdapter, TResult>>) | Improve this Doc View Source Link<TValue, TSource>(String, Expression<Func<ILinkPropertyMappingAdapter<T>, IStructureFlag>>[]) Link property mapping Declaration Link<TValue, TSource> Link<TValue, TSource>(string sourceAlias, params Expression<Func<ILinkPropertyMappingAdapter<T>, IStructureFlag>>[] attributes) where TValue : IComparable<TValue> where TSource : class, IDataObject, new() Parameters Type Name Description String sourceAlias Property source alias Expression < Func < ILinkPropertyMappingAdapter <T>, IStructureFlag >>[] attributes Property mapping attributes Returns Type Description Link <TValue, TSource> Link property Type Parameters Name Description TValue Link value type TSource Link source type | Improve this Doc View Source Link<TValue, TSource>(String, String, Expression<Func<ILinkPropertyMappingAdapter<T>, IStructureFlag>>[]) Link property mapping Declaration Link<TValue, TSource> Link<TValue, TSource>(string sourceAlias, string fieldName, params Expression<Func<ILinkPropertyMappingAdapter<T>, IStructureFlag>>[] attributes) where TValue : IComparable<TValue> where TSource : class, IDataObject, new() Parameters Type Name Description String sourceAlias Property source alias String fieldName Property field name Expression < Func < ILinkPropertyMappingAdapter <T>, IStructureFlag >>[] attributes Property mapping attributes Returns Type Description Link <TValue, TSource> Link property Type Parameters Name Description TValue Link value type TSource Link source type | Improve this Doc View Source Lob(String, Expression<Func<IRepositoryReadOnlyPropertyMappingAdapter, IStructureFlag>>[]) Lob property mapping Declaration Lob Lob(string sourceAlias, params Expression<Func<IRepositoryReadOnlyPropertyMappingAdapter, IStructureFlag>>[] attributes) Parameters Type Name Description String sourceAlias Property source alias Expression < Func < IRepositoryReadOnlyPropertyMappingAdapter , IStructureFlag >>[] attributes Property mapping attributes Returns Type Description Lob Lob property | Improve this Doc View Source Lob(String, String, Expression<Func<IRepositoryReadOnlyPropertyMappingAdapter, IStructureFlag>>[]) Lob property mapping Declaration Lob Lob(string sourceAlias, string fieldName, params Expression<Func<IRepositoryReadOnlyPropertyMappingAdapter, IStructureFlag>>[] attributes) Parameters Type Name Description String sourceAlias Property source alias String fieldName Property field name Expression < Func < IRepositoryReadOnlyPropertyMappingAdapter , IStructureFlag >>[] attributes Property mapping attributes Returns Type Description Lob Lob property | Improve this Doc View Source Xml(String, Expression<Func<IRepositoryReadOnlyPropertyMappingAdapter, IStructureFlag>>[]) Xml property mapping Declaration Xml Xml(string sourceAlias, params Expression<Func<IRepositoryReadOnlyPropertyMappingAdapter, IStructureFlag>>[] attributes) Parameters Type Name Description String sourceAlias Property source alias Expression < Func < IRepositoryReadOnlyPropertyMappingAdapter , IStructureFlag >>[] attributes Property mapping attributes Returns Type Description Xml Xml property | Improve this Doc View Source Xml(String, String, Expression<Func<IRepositoryReadOnlyPropertyMappingAdapter, IStructureFlag>>[]) Xml property mapping Declaration Xml Xml(string sourceAlias, string fieldName, params Expression<Func<IRepositoryReadOnlyPropertyMappingAdapter, IStructureFlag>>[] attributes) Parameters Type Name Description String sourceAlias Property source alias String fieldName Property field name Expression < Func < IRepositoryReadOnlyPropertyMappingAdapter , IStructureFlag >>[] attributes Property mapping attributes Returns Type Description Xml Xml property Extension Methods SerializationExtensions.ToXml<T>(T) CollectionsExtensions.SetValue<TKey, T>(TKey, T) CollectionsExtensions.AsEnum<T>(T) DataObjectQueryableExtensions.CompareVariable(Object, FilterOperation, String) Processing.Do<T>(T, Action<IProcess<T>>[]) TypeExtensions.TryConvert<T, TResult>(T, Func<T, TResult>) TypeExtensions.TryConvert<T, TResult>(T, Func<T, TResult>, TResult) TypeExtensions.ChangeType<T>(Object) TypeExtensions.ChangeType(Object, Type) TypeExtensions.InvokeMethod<TRet>(Object, Type[], Expression<Func<TRet>>, BindingFlags) TypeExtensions.InvokeMethod(Object, Type[], Expression<Action>, BindingFlags) TypeExtensions.InvokeMethod<TRet>(Object, Expression<Func<TRet>>, BindingFlags) TypeExtensions.InvokeMethod(Object, Expression<Action>, BindingFlags) SqlBlockExtensions.SetExpression<TTag, TResult>(TTag, Expression<Func<IBlockQueryAdapter, TResult>>) QueryDescriptionExtensions.SetExpression<TTag, TResult>(TTag, Expression<Func<IQueryStructureAdapter, TResult>>)"
  },
  "api/XData.Mapping.Dynamic.IRepositoryStructureAdapter.html": {
    "href": "api/XData.Mapping.Dynamic.IRepositoryStructureAdapter.html",
    "title": "Interface IRepositoryStructureAdapter | XData website",
    "keywords": "Interface IRepositoryStructureAdapter Repository structure adapter Namespace : XData.Mapping.Dynamic Assembly : XData.docfx.dll Syntax public interface IRepositoryStructureAdapter Methods | Improve this Doc View Source Expr<TValue>(String, Expression<Func<IQueryStructureAdapter, TValue>>, DbType, Expression<Func<IRepositoryExpressionMappingAdapter, IStructureFlag>>[]) SQL expression mapping Declaration TValue Expr<TValue>(string fieldName, Expression<Func<IQueryStructureAdapter, TValue>> expr, DbType dbType, params Expression<Func<IRepositoryExpressionMappingAdapter, IStructureFlag>>[] attributes) Parameters Type Name Description String fieldName Expression field name Expression < Func < IQueryStructureAdapter , TValue>> expr Expression DbType dbType Expression database type Expression < Func < IRepositoryExpressionMappingAdapter , IStructureFlag >>[] attributes Property mapping attributes Returns Type Description TValue Expression value Type Parameters Name Description TValue Expression result type Remarks WARNING! Can be used in dynamic query mapping only! See Also DataExpressionType DbType Select<TResult>(Expression<Func<IQueryStructureAdapter, TResult>>) | Improve this Doc View Source Expr<TValue>(String, DataExpressionType, String, DbType, Expression<Func<IRepositoryExpressionMappingAdapter, IStructureFlag>>[]) SQL expression mapping Declaration TValue Expr<TValue>(string fieldName, DataExpressionType type, string exprText, DbType dbType, params Expression<Func<IRepositoryExpressionMappingAdapter, IStructureFlag>>[] attributes) Parameters Type Name Description String fieldName Expression field name DataExpressionType type Expression source type String exprText Expression text DbType dbType Expression database type Expression < Func < IRepositoryExpressionMappingAdapter , IStructureFlag >>[] attributes Property mapping attributes Returns Type Description TValue Expression value Type Parameters Name Description TValue Expression result type Remarks WARNING! Can be used in dynamic query mapping only! See Also DataExpressionType DbType Select<TResult>(Expression<Func<IQueryStructureAdapter, TResult>>) | Improve this Doc View Source Ref<TValue>(String, String, Expression<Func<IRepositoryReadOnlyPropertyMappingAdapter, IStructureFlag>>[]) Inner view property reference mapping Declaration TValue Ref<TValue>(string sourceAlias, string property, params Expression<Func<IRepositoryReadOnlyPropertyMappingAdapter, IStructureFlag>>[] attributes) Parameters Type Name Description String sourceAlias Referenced property subquery alias String property Referenced property name Expression < Func < IRepositoryReadOnlyPropertyMappingAdapter , IStructureFlag >>[] attributes Property mapping attributes Returns Type Description TValue Referenced property value Type Parameters Name Description TValue Referenced property type Remarks WARNING! Can be used in dynamic query mapping only! See Also Select<TResult>(Expression<Func<IQueryStructureAdapter, TResult>>) | Improve this Doc View Source Ref<TValue, TInnerView>(String, Expression<Func<TInnerView, Object>>, Expression<Func<IRepositoryReadOnlyPropertyMappingAdapter, IStructureFlag>>[]) Inner view property reference mapping Declaration TValue Ref<TValue, TInnerView>(string sourceAlias, Expression<Func<TInnerView, object>> property, params Expression<Func<IRepositoryReadOnlyPropertyMappingAdapter, IStructureFlag>>[] attributes) where TInnerView : class Parameters Type Name Description String sourceAlias Referenced property subquery alias Expression < Func <TInnerView, Object >> property Referenced property name Expression < Func < IRepositoryReadOnlyPropertyMappingAdapter , IStructureFlag >>[] attributes Property mapping attributes Returns Type Description TValue Referenced property value Type Parameters Name Description TValue Referenced property type TInnerView Referenced inner view type Remarks WARNING! Can be used in dynamic query mapping only! See Also Select<TResult>(Expression<Func<IQueryStructureAdapter, TResult>>) Extension Methods SerializationExtensions.ToXml<T>(T) CollectionsExtensions.SetValue<TKey, T>(TKey, T) CollectionsExtensions.AsEnum<T>(T) DataObjectQueryableExtensions.CompareVariable(Object, FilterOperation, String) Processing.Do<T>(T, Action<IProcess<T>>[]) TypeExtensions.TryConvert<T, TResult>(T, Func<T, TResult>) TypeExtensions.TryConvert<T, TResult>(T, Func<T, TResult>, TResult) TypeExtensions.ChangeType<T>(Object) TypeExtensions.ChangeType(Object, Type) TypeExtensions.InvokeMethod<TRet>(Object, Type[], Expression<Func<TRet>>, BindingFlags) TypeExtensions.InvokeMethod(Object, Type[], Expression<Action>, BindingFlags) TypeExtensions.InvokeMethod<TRet>(Object, Expression<Func<TRet>>, BindingFlags) TypeExtensions.InvokeMethod(Object, Expression<Action>, BindingFlags) SqlBlockExtensions.SetExpression<TTag, TResult>(TTag, Expression<Func<IBlockQueryAdapter, TResult>>) QueryDescriptionExtensions.SetExpression<TTag, TResult>(TTag, Expression<Func<IQueryStructureAdapter, TResult>>)"
  },
  "api/XData.Mapping.DataSourceAttribute.html": {
    "href": "api/XData.Mapping.DataSourceAttribute.html",
    "title": "Class DataSourceAttribute | XData website",
    "keywords": "Class DataSourceAttribute Base data object source attribute Inheritance Object Attribute DataSourceAttribute DataTableAttribute InnerViewAttribute ProcedureAttribute SubqueryAttribute WithAttribute Inherited Members Attribute.Equals(Object) Attribute.GetCustomAttribute(Assembly, Type) Attribute.GetCustomAttribute(Assembly, Type, Boolean) Attribute.GetCustomAttribute(MemberInfo, Type) Attribute.GetCustomAttribute(MemberInfo, Type, Boolean) Attribute.GetCustomAttribute(Module, Type) Attribute.GetCustomAttribute(Module, Type, Boolean) Attribute.GetCustomAttribute(ParameterInfo, Type) Attribute.GetCustomAttribute(ParameterInfo, Type, Boolean) Attribute.GetCustomAttributes(Assembly) Attribute.GetCustomAttributes(Assembly, Boolean) Attribute.GetCustomAttributes(Assembly, Type) Attribute.GetCustomAttributes(Assembly, Type, Boolean) Attribute.GetCustomAttributes(MemberInfo) Attribute.GetCustomAttributes(MemberInfo, Boolean) Attribute.GetCustomAttributes(MemberInfo, Type) Attribute.GetCustomAttributes(MemberInfo, Type, Boolean) Attribute.GetCustomAttributes(Module) Attribute.GetCustomAttributes(Module, Boolean) Attribute.GetCustomAttributes(Module, Type) Attribute.GetCustomAttributes(Module, Type, Boolean) Attribute.GetCustomAttributes(ParameterInfo) Attribute.GetCustomAttributes(ParameterInfo, Boolean) Attribute.GetCustomAttributes(ParameterInfo, Type) Attribute.GetCustomAttributes(ParameterInfo, Type, Boolean) Attribute.GetHashCode() Attribute.IsDefaultAttribute() Attribute.IsDefined(Assembly, Type) Attribute.IsDefined(Assembly, Type, Boolean) Attribute.IsDefined(MemberInfo, Type) Attribute.IsDefined(MemberInfo, Type, Boolean) Attribute.IsDefined(Module, Type) Attribute.IsDefined(Module, Type, Boolean) Attribute.IsDefined(ParameterInfo, Type) Attribute.IsDefined(ParameterInfo, Type, Boolean) Attribute.Match(Object) Attribute.TypeId Object.Equals(Object, Object) Object.GetType() Object.MemberwiseClone() Object.ReferenceEquals(Object, Object) Object.ToString() Namespace : XData.Mapping Assembly : XData.docfx.dll Syntax [AttributeUsage(AttributeTargets.Class, AllowMultiple = true)] public abstract class DataSourceAttribute : Attribute Properties | Improve this Doc View Source Alias Data source alias Declaration public abstract string Alias { get; protected set; } Property Value Type Description String | Improve this Doc View Source Type Data source type Declaration public abstract DataSourceType Type { get; } Property Value Type Description DataSourceType Extension Methods SerializationExtensions.ToXml<T>(T) CollectionsExtensions.SetValue<TKey, T>(TKey, T) CollectionsExtensions.AsEnum<T>(T) DataObjectQueryableExtensions.CompareVariable(Object, FilterOperation, String) Processing.Do<T>(T, Action<IProcess<T>>[]) TypeExtensions.TryConvert<T, TResult>(T, Func<T, TResult>) TypeExtensions.TryConvert<T, TResult>(T, Func<T, TResult>, TResult) TypeExtensions.ChangeType<T>(Object) TypeExtensions.ChangeType(Object, Type) TypeExtensions.InvokeMethod<TRet>(Object, Type[], Expression<Func<TRet>>, BindingFlags) TypeExtensions.InvokeMethod(Object, Type[], Expression<Action>, BindingFlags) TypeExtensions.InvokeMethod<TRet>(Object, Expression<Func<TRet>>, BindingFlags) TypeExtensions.InvokeMethod(Object, Expression<Action>, BindingFlags) SqlBlockExtensions.SetExpression<TTag, TResult>(TTag, Expression<Func<IBlockQueryAdapter, TResult>>) QueryDescriptionExtensions.SetExpression<TTag, TResult>(TTag, Expression<Func<IQueryStructureAdapter, TResult>>)"
  },
  "api/XData.Mapping.DataObjectAttribute.html": {
    "href": "api/XData.Mapping.DataObjectAttribute.html",
    "title": "Class DataObjectAttribute | XData website",
    "keywords": "Class DataObjectAttribute Data object metadata attribute Inheritance Object Attribute DataObjectAttribute Inherited Members Attribute.Equals(Object) Attribute.GetCustomAttribute(Assembly, Type) Attribute.GetCustomAttribute(Assembly, Type, Boolean) Attribute.GetCustomAttribute(MemberInfo, Type) Attribute.GetCustomAttribute(MemberInfo, Type, Boolean) Attribute.GetCustomAttribute(Module, Type) Attribute.GetCustomAttribute(Module, Type, Boolean) Attribute.GetCustomAttribute(ParameterInfo, Type) Attribute.GetCustomAttribute(ParameterInfo, Type, Boolean) Attribute.GetCustomAttributes(Assembly) Attribute.GetCustomAttributes(Assembly, Boolean) Attribute.GetCustomAttributes(Assembly, Type) Attribute.GetCustomAttributes(Assembly, Type, Boolean) Attribute.GetCustomAttributes(MemberInfo) Attribute.GetCustomAttributes(MemberInfo, Boolean) Attribute.GetCustomAttributes(MemberInfo, Type) Attribute.GetCustomAttributes(MemberInfo, Type, Boolean) Attribute.GetCustomAttributes(Module) Attribute.GetCustomAttributes(Module, Boolean) Attribute.GetCustomAttributes(Module, Type) Attribute.GetCustomAttributes(Module, Type, Boolean) Attribute.GetCustomAttributes(ParameterInfo) Attribute.GetCustomAttributes(ParameterInfo, Boolean) Attribute.GetCustomAttributes(ParameterInfo, Type) Attribute.GetCustomAttributes(ParameterInfo, Type, Boolean) Attribute.GetHashCode() Attribute.IsDefaultAttribute() Attribute.IsDefined(Assembly, Type) Attribute.IsDefined(Assembly, Type, Boolean) Attribute.IsDefined(MemberInfo, Type) Attribute.IsDefined(MemberInfo, Type, Boolean) Attribute.IsDefined(Module, Type) Attribute.IsDefined(Module, Type, Boolean) Attribute.IsDefined(ParameterInfo, Type) Attribute.IsDefined(ParameterInfo, Type, Boolean) Attribute.Match(Object) Attribute.TypeId Object.Equals(Object, Object) Object.GetType() Object.MemberwiseClone() Object.ReferenceEquals(Object, Object) Object.ToString() Namespace : XData.Mapping Assembly : XData.docfx.dll Syntax [AttributeUsage(AttributeTargets.Class)] public sealed class DataObjectAttribute : Attribute Remarks WARNING! Required attribute! Constructors | Improve this Doc View Source DataObjectAttribute(String) Data object metadata attribute Declaration public DataObjectAttribute(string baseSource = \"\") Parameters Type Name Description String baseSource Base table alias Remarks If Base table is empty - data object has no base table. WARNING! None based data objects are read only and can not contain any table! | Improve this Doc View Source DataObjectAttribute(Type) Data object metadata attribute Declaration public DataObjectAttribute(Type baseMappingType) Parameters Type Name Description Type baseMappingType Base mapping type Properties | Improve this Doc View Source BaseMappingType Base mapping type Declaration public Type BaseMappingType { get; } Property Value Type Description Type | Improve this Doc View Source BaseSource Base table alias Declaration public string BaseSource { get; } Property Value Type Description String Remarks Base table is modification allowed data source subtree root of data object See Also Alias Parent | Improve this Doc View Source Context Context alias Declaration public string Context { get; set; } Property Value Type Description String See Also Context | Improve this Doc View Source Distinct Distinct flag Declaration public bool Distinct { get; set; } Property Value Type Description Boolean | Improve this Doc View Source Flags Combination of DataObjectFlag values Declaration public DataStructureFlag Flags { get; set; } Property Value Type Description DataStructureFlag See Also DataStructureFlag | Improve this Doc View Source Limit Limit records Declaration public int Limit { get; set; } Property Value Type Description Int32 | Improve this Doc View Source LogicAssemblyNames Data logic assembly name Declaration public string[] LogicAssemblyNames { get; set; } Property Value Type Description String [] Remarks NOTE: Used when no IoC Container available. Otherwise register logic modules through container See Also IDataLogic <T> | Improve this Doc View Source Skip Skip records Declaration public int Skip { get; set; } Property Value Type Description Int32 Extension Methods SerializationExtensions.ToXml<T>(T) CollectionsExtensions.SetValue<TKey, T>(TKey, T) CollectionsExtensions.AsEnum<T>(T) DataObjectQueryableExtensions.CompareVariable(Object, FilterOperation, String) Processing.Do<T>(T, Action<IProcess<T>>[]) TypeExtensions.TryConvert<T, TResult>(T, Func<T, TResult>) TypeExtensions.TryConvert<T, TResult>(T, Func<T, TResult>, TResult) TypeExtensions.ChangeType<T>(Object) TypeExtensions.ChangeType(Object, Type) TypeExtensions.InvokeMethod<TRet>(Object, Type[], Expression<Func<TRet>>, BindingFlags) TypeExtensions.InvokeMethod(Object, Type[], Expression<Action>, BindingFlags) TypeExtensions.InvokeMethod<TRet>(Object, Expression<Func<TRet>>, BindingFlags) TypeExtensions.InvokeMethod(Object, Expression<Action>, BindingFlags) SqlBlockExtensions.SetExpression<TTag, TResult>(TTag, Expression<Func<IBlockQueryAdapter, TResult>>) QueryDescriptionExtensions.SetExpression<TTag, TResult>(TTag, Expression<Func<IQueryStructureAdapter, TResult>>)"
  },
  "api/XData.Mapping.ConstantFilterAttribute.html": {
    "href": "api/XData.Mapping.ConstantFilterAttribute.html",
    "title": "Class ConstantFilterAttribute | XData website",
    "keywords": "Class ConstantFilterAttribute Data object constant value filter attribute Inheritance Object Attribute FilterBaseAttribute FilterAttribute ConstantFilterAttribute Inherited Members FilterAttribute.Source FilterAttribute.FieldName FilterAttribute.Operation FilterAttribute.Combination Attribute.Equals(Object) Attribute.GetCustomAttribute(Assembly, Type) Attribute.GetCustomAttribute(Assembly, Type, Boolean) Attribute.GetCustomAttribute(MemberInfo, Type) Attribute.GetCustomAttribute(MemberInfo, Type, Boolean) Attribute.GetCustomAttribute(Module, Type) Attribute.GetCustomAttribute(Module, Type, Boolean) Attribute.GetCustomAttribute(ParameterInfo, Type) Attribute.GetCustomAttribute(ParameterInfo, Type, Boolean) Attribute.GetCustomAttributes(Assembly) Attribute.GetCustomAttributes(Assembly, Boolean) Attribute.GetCustomAttributes(Assembly, Type) Attribute.GetCustomAttributes(Assembly, Type, Boolean) Attribute.GetCustomAttributes(MemberInfo) Attribute.GetCustomAttributes(MemberInfo, Boolean) Attribute.GetCustomAttributes(MemberInfo, Type) Attribute.GetCustomAttributes(MemberInfo, Type, Boolean) Attribute.GetCustomAttributes(Module) Attribute.GetCustomAttributes(Module, Boolean) Attribute.GetCustomAttributes(Module, Type) Attribute.GetCustomAttributes(Module, Type, Boolean) Attribute.GetCustomAttributes(ParameterInfo) Attribute.GetCustomAttributes(ParameterInfo, Boolean) Attribute.GetCustomAttributes(ParameterInfo, Type) Attribute.GetCustomAttributes(ParameterInfo, Type, Boolean) Attribute.GetHashCode() Attribute.IsDefaultAttribute() Attribute.IsDefined(Assembly, Type) Attribute.IsDefined(Assembly, Type, Boolean) Attribute.IsDefined(MemberInfo, Type) Attribute.IsDefined(MemberInfo, Type, Boolean) Attribute.IsDefined(Module, Type) Attribute.IsDefined(Module, Type, Boolean) Attribute.IsDefined(ParameterInfo, Type) Attribute.IsDefined(ParameterInfo, Type, Boolean) Attribute.Match(Object) Object.Equals(Object, Object) Object.GetType() Object.MemberwiseClone() Object.ReferenceEquals(Object, Object) Object.ToString() Namespace : XData.Mapping Assembly : XData.docfx.dll Syntax [AttributeUsage(AttributeTargets.Class, AllowMultiple = true)] public sealed class ConstantFilterAttribute : FilterAttribute Remarks Filter value can be constant, data object variable value (see Variables ), current date or time Constructors | Improve this Doc View Source ConstantFilterAttribute(String, String, String, Object) Constant filter attribute Declaration public ConstantFilterAttribute(string name, string source, string fieldName, object constant) Parameters Type Name Description String name Filter name String source Filter source alias String fieldName Filter field name Object constant Filter value Exceptions Type Condition XDataRuntimeException Filter name cannot be null or empty string Properties | Improve this Doc View Source ConstantType Filter value type Declaration public FilterConstantType ConstantType { get; set; } Property Value Type Description FilterConstantType See Also FilterConstantType | Improve this Doc View Source ConstantValue Filter value Declaration public object ConstantValue { get; } Property Value Type Description Object See Also ConstantType FilterConstantType | Improve this Doc View Source FilterType Filter type Declaration public override FilterType FilterType { get; } Property Value Type Description FilterType Constant Overrides FilterBaseAttribute.FilterType | Improve this Doc View Source Name Filter parameter name Declaration public string Name { get; } Property Value Type Description String Remarks No Sql parameter prefix needed | Improve this Doc View Source Nullable Filter null value handling mode Declaration public FilterNullable Nullable { get; set; } Property Value Type Description FilterNullable See Also FilterConstantType | Improve this Doc View Source TypeId When implemented in a derived class, gets a unique identifier for this Attribute . Declaration public override object TypeId { get; } Property Value Type Description Object An Object that is a unique identifier for the attribute. Overrides Attribute.TypeId Extension Methods SerializationExtensions.ToXml<T>(T) CollectionsExtensions.SetValue<TKey, T>(TKey, T) CollectionsExtensions.AsEnum<T>(T) DataObjectQueryableExtensions.CompareVariable(Object, FilterOperation, String) Processing.Do<T>(T, Action<IProcess<T>>[]) TypeExtensions.TryConvert<T, TResult>(T, Func<T, TResult>) TypeExtensions.TryConvert<T, TResult>(T, Func<T, TResult>, TResult) TypeExtensions.ChangeType<T>(Object) TypeExtensions.ChangeType(Object, Type) TypeExtensions.InvokeMethod<TRet>(Object, Type[], Expression<Func<TRet>>, BindingFlags) TypeExtensions.InvokeMethod(Object, Type[], Expression<Action>, BindingFlags) TypeExtensions.InvokeMethod<TRet>(Object, Expression<Func<TRet>>, BindingFlags) TypeExtensions.InvokeMethod(Object, Expression<Action>, BindingFlags) SqlBlockExtensions.SetExpression<TTag, TResult>(TTag, Expression<Func<IBlockQueryAdapter, TResult>>) QueryDescriptionExtensions.SetExpression<TTag, TResult>(TTag, Expression<Func<IQueryStructureAdapter, TResult>>)"
  },
  "api/XData.Mapping.ColumnUpdateWithAttribute.html": {
    "href": "api/XData.Mapping.ColumnUpdateWithAttribute.html",
    "title": "Class ColumnUpdateWithAttribute | XData website",
    "keywords": "Class ColumnUpdateWithAttribute Column update source expression attribute Inheritance Object Attribute ColumnUpdateWithAttribute Inherited Members Attribute.Equals(Object) Attribute.GetCustomAttribute(Assembly, Type) Attribute.GetCustomAttribute(Assembly, Type, Boolean) Attribute.GetCustomAttribute(MemberInfo, Type) Attribute.GetCustomAttribute(MemberInfo, Type, Boolean) Attribute.GetCustomAttribute(Module, Type) Attribute.GetCustomAttribute(Module, Type, Boolean) Attribute.GetCustomAttribute(ParameterInfo, Type) Attribute.GetCustomAttribute(ParameterInfo, Type, Boolean) Attribute.GetCustomAttributes(Assembly) Attribute.GetCustomAttributes(Assembly, Boolean) Attribute.GetCustomAttributes(Assembly, Type) Attribute.GetCustomAttributes(Assembly, Type, Boolean) Attribute.GetCustomAttributes(MemberInfo) Attribute.GetCustomAttributes(MemberInfo, Boolean) Attribute.GetCustomAttributes(MemberInfo, Type) Attribute.GetCustomAttributes(MemberInfo, Type, Boolean) Attribute.GetCustomAttributes(Module) Attribute.GetCustomAttributes(Module, Boolean) Attribute.GetCustomAttributes(Module, Type) Attribute.GetCustomAttributes(Module, Type, Boolean) Attribute.GetCustomAttributes(ParameterInfo) Attribute.GetCustomAttributes(ParameterInfo, Boolean) Attribute.GetCustomAttributes(ParameterInfo, Type) Attribute.GetCustomAttributes(ParameterInfo, Type, Boolean) Attribute.GetHashCode() Attribute.IsDefaultAttribute() Attribute.IsDefined(Assembly, Type) Attribute.IsDefined(Assembly, Type, Boolean) Attribute.IsDefined(MemberInfo, Type) Attribute.IsDefined(MemberInfo, Type, Boolean) Attribute.IsDefined(Module, Type) Attribute.IsDefined(Module, Type, Boolean) Attribute.IsDefined(ParameterInfo, Type) Attribute.IsDefined(ParameterInfo, Type, Boolean) Attribute.Match(Object) Object.Equals(Object, Object) Object.GetType() Object.MemberwiseClone() Object.ReferenceEquals(Object, Object) Object.ToString() Namespace : XData.Mapping Assembly : XData.docfx.dll Syntax [AttributeUsage(AttributeTargets.Class, AllowMultiple = true)] public sealed class ColumnUpdateWithAttribute : Attribute Remarks Used when ColumnAttribute value must to be updated with expression ( PlainSql or SubQuery ) result according ExprType Constructors | Improve this Doc View Source ColumnUpdateWithAttribute(String, String, DataExpressionType) Column update source expression attribute Declaration public ColumnUpdateWithAttribute(string propertyName, string exprText, DataExpressionType exprType = DataExpressionType.PlainSql) Parameters Type Name Description String propertyName Property name String exprText Expression text DataExpressionType exprType Expression type Exceptions Type Condition XDataRuntimeException Property name cannot be null or empty string XDataRuntimeException Expression text cannot be null or empty string Properties | Improve this Doc View Source ExprText Expression text Declaration public string ExprText { get; } Property Value Type Description String Remarks PlainSql expression text is Sql expression or SqlExpressionAttribute name SubQuery expression text is Alias WARNING! Plain Sql expressions (see ExprType ) can use specific Sql dialect features! Data mapping may be not compatible with other database engines! Use SqlExpressionAttribute instead. | Improve this Doc View Source ExprType Expression type Declaration public DataExpressionType ExprType { get; } Property Value Type Description DataExpressionType Remarks WARNING! Plain Sql expressions can use specific Sql dialect features! Data mapping may be not compatible with other database engines! See Also DataExpressionType | Improve this Doc View Source PropertyName Property name Declaration public string PropertyName { get; } Property Value Type Description String See Also ColumnAttribute | Improve this Doc View Source TypeId When implemented in a derived class, gets a unique identifier for this Attribute . Declaration public override object TypeId { get; } Property Value Type Description Object An Object that is a unique identifier for the attribute. Overrides Attribute.TypeId Extension Methods SerializationExtensions.ToXml<T>(T) CollectionsExtensions.SetValue<TKey, T>(TKey, T) CollectionsExtensions.AsEnum<T>(T) DataObjectQueryableExtensions.CompareVariable(Object, FilterOperation, String) Processing.Do<T>(T, Action<IProcess<T>>[]) TypeExtensions.TryConvert<T, TResult>(T, Func<T, TResult>) TypeExtensions.TryConvert<T, TResult>(T, Func<T, TResult>, TResult) TypeExtensions.ChangeType<T>(Object) TypeExtensions.ChangeType(Object, Type) TypeExtensions.InvokeMethod<TRet>(Object, Type[], Expression<Func<TRet>>, BindingFlags) TypeExtensions.InvokeMethod(Object, Type[], Expression<Action>, BindingFlags) TypeExtensions.InvokeMethod<TRet>(Object, Expression<Func<TRet>>, BindingFlags) TypeExtensions.InvokeMethod(Object, Expression<Action>, BindingFlags) SqlBlockExtensions.SetExpression<TTag, TResult>(TTag, Expression<Func<IBlockQueryAdapter, TResult>>) QueryDescriptionExtensions.SetExpression<TTag, TResult>(TTag, Expression<Func<IQueryStructureAdapter, TResult>>)"
  },
  "api/XData.Interfaces.html": {
    "href": "api/XData.Interfaces.html",
    "title": "Namespace XData.Interfaces | XData website",
    "keywords": "Namespace XData.Interfaces Classes AdapterConfig Adapter configuration section ContextConfig Context config section DialectConfig SQL dialect configuration section ProxyConfig Proxy configuration section Interfaces IConfiguration XData configuration ILogWriter XData log writer interface IProxy Data object proxy interface IProxyManager Proxy manager ISecuritySession Security session interface ISequenceNameRule Sequence name rule interface ISqlBuilder SQL builder interface"
  },
  "api/XData.Interfaces.ProxyConfig.html": {
    "href": "api/XData.Interfaces.ProxyConfig.html",
    "title": "Class ProxyConfig | XData website",
    "keywords": "Class ProxyConfig Proxy configuration section Inheritance Object ProxyConfig Inherited Members Object.Equals(Object) Object.Equals(Object, Object) Object.GetHashCode() Object.GetType() Object.MemberwiseClone() Object.ReferenceEquals(Object, Object) Object.ToString() Namespace : XData.Interfaces Assembly : XData.docfx.dll Syntax public sealed class ProxyConfig Remarks WARNING! All attributes are required! Examples <proxy name=\"TEST\" dialect=\"MSSQL\" endpoint=\"XAppServer\"/> Properties | Improve this Doc View Source EndpointName XData application server WCF endpoint name Declaration public string EndpointName { get; set; } Property Value Type Description String | Improve this Doc View Source Name Proxy name Declaration public string Name { get; set; } Property Value Type Description String Remarks Mast be the same as Name Extension Methods SerializationExtensions.ToXml<T>(T) CollectionsExtensions.SetValue<TKey, T>(TKey, T) CollectionsExtensions.AsEnum<T>(T) DataObjectQueryableExtensions.CompareVariable(Object, FilterOperation, String) Processing.Do<T>(T, Action<IProcess<T>>[]) TypeExtensions.TryConvert<T, TResult>(T, Func<T, TResult>) TypeExtensions.TryConvert<T, TResult>(T, Func<T, TResult>, TResult) TypeExtensions.ChangeType<T>(Object) TypeExtensions.ChangeType(Object, Type) TypeExtensions.InvokeMethod<TRet>(Object, Type[], Expression<Func<TRet>>, BindingFlags) TypeExtensions.InvokeMethod(Object, Type[], Expression<Action>, BindingFlags) TypeExtensions.InvokeMethod<TRet>(Object, Expression<Func<TRet>>, BindingFlags) TypeExtensions.InvokeMethod(Object, Expression<Action>, BindingFlags) SqlBlockExtensions.SetExpression<TTag, TResult>(TTag, Expression<Func<IBlockQueryAdapter, TResult>>) QueryDescriptionExtensions.SetExpression<TTag, TResult>(TTag, Expression<Func<IQueryStructureAdapter, TResult>>) See Also Name EndpointName"
  },
  "api/XData.IDataQuery-1.html": {
    "href": "api/XData.IDataQuery-1.html",
    "title": "Interface IDataQuery<T> | XData website",
    "keywords": "Interface IDataQuery<T> Specialized read only data source interface Inherited Members IDataQuery.Alias IDataQuery.Layer IDataQuery.Context IDataQuery.Variables IDataQuery.Keys IDataQuery.Token IDisposable.Dispose() IEnumerable<T>.GetEnumerator() IQueryable.ElementType IQueryable.Expression IQueryable.Provider Namespace : XData Assembly : XData.docfx.dll Syntax public interface IDataQuery<out T> : IDataQuery, IDisposable, IOrderedQueryable<T>, IOrderedQueryable, IQueryable<T>, IEnumerable<T>, IQueryable, IEnumerable Type Parameters Name Description T Data source type Methods | Improve this Doc View Source GetFilterValue(RuntimeFilter) Get metadata defined RuntimeFilter value Declaration object GetFilterValue(RuntimeFilter filter) Parameters Type Name Description RuntimeFilter filter Filter Returns Type Description Object Filter value Exceptions Type Condition XDataRuntimeException \"filter\" parameter is null. See Also RuntimeFilter Reset() SetFilterValue(RuntimeFilter, Object) | Improve this Doc View Source Reset() Reset repository structure and filter values Declaration IDataQuery<T> Reset() Returns Type Description IDataQuery <T> Self repository link See Also RuntimeFilter GetFilterValue(RuntimeFilter) SetFilterValue(RuntimeFilter, Object) | Improve this Doc View Source SetFilterValue(RuntimeFilter, Object) Set metadata defined RuntimeFilter value Declaration IDataQuery<T> SetFilterValue(RuntimeFilter filter, object val) Parameters Type Name Description RuntimeFilter filter Filter Object val Filter value Returns Type Description IDataQuery <T> Self repository link Remarks Hint: Set val = null to clear filter Exceptions Type Condition XDataRuntimeException \"filter\" parameter is null. See Also RuntimeFilter Reset() GetFilterValue(RuntimeFilter) Extension Methods DataObjectExtensions.GetParameter<T>(IDataQuery, String) DataObjectExtensions.GetResultSet<TRes>(IDataQuery, String) DataObjectExtensions.GetResultSet<TRes>(IDataQuery, Expression<Func<IEnumerable<TRes>>>) SerializationExtensions.ToXml<T>(T) AsyncExtensions.AllAsync<T>(IQueryable<T>, Expression<Func<T, Boolean>>) AsyncExtensions.AllAsync<T>(IQueryable<T>, Expression<Func<T, Boolean>>, CancellationToken) AsyncExtensions.AllAsync<T>(IDataQuery<T>, Expression<Func<T, Boolean>>) AsyncExtensions.AnyAsync<T>(IQueryable<T>) AsyncExtensions.AnyAsync<T>(IQueryable<T>, Expression<Func<T, Boolean>>) AsyncExtensions.AnyAsync<T>(IQueryable<T>, Expression<Func<T, Boolean>>, CancellationToken) AsyncExtensions.AnyAsync<T>(IDataQuery<T>, Expression<Func<T, Boolean>>) AsyncExtensions.AverageAsync<T>(IQueryable<T>, Expression<Func<T, Single>>) AsyncExtensions.AverageAsync<T>(IQueryable<T>, Expression<Func<T, Single>>, CancellationToken) AsyncExtensions.AverageAsync<T>(IDataQuery<T>, Expression<Func<T, Single>>) AsyncExtensions.AverageAsync<T>(IQueryable<T>, Expression<Func<T, Double>>) AsyncExtensions.AverageAsync<T>(IQueryable<T>, Expression<Func<T, Double>>, CancellationToken) AsyncExtensions.AverageAsync<T>(IDataQuery<T>, Expression<Func<T, Double>>) AsyncExtensions.AverageAsync<T>(IQueryable<T>, Expression<Func<T, Decimal>>) AsyncExtensions.AverageAsync<T>(IQueryable<T>, Expression<Func<T, Decimal>>, CancellationToken) AsyncExtensions.AverageAsync<T>(IDataQuery<T>, Expression<Func<T, Decimal>>) AsyncExtensions.AverageAsync<T>(IQueryable<T>, Expression<Func<T, Int32>>) AsyncExtensions.AverageAsync<T>(IQueryable<T>, Expression<Func<T, Int32>>, CancellationToken) AsyncExtensions.AverageAsync<T>(IDataQuery<T>, Expression<Func<T, Int32>>) AsyncExtensions.AverageAsync<T>(IQueryable<T>, Expression<Func<T, Int64>>) AsyncExtensions.AverageAsync<T>(IQueryable<T>, Expression<Func<T, Int64>>, CancellationToken) AsyncExtensions.AverageAsync<T>(IDataQuery<T>, Expression<Func<T, Int64>>) AsyncExtensions.AverageAsync<T>(IQueryable<T>, Expression<Func<T, Nullable<Single>>>) AsyncExtensions.AverageAsync<T>(IQueryable<T>, Expression<Func<T, Nullable<Single>>>, CancellationToken) AsyncExtensions.AverageAsync<T>(IDataQuery<T>, Expression<Func<T, Nullable<Single>>>) AsyncExtensions.AverageAsync<T>(IQueryable<T>, Expression<Func<T, Nullable<Double>>>) AsyncExtensions.AverageAsync<T>(IQueryable<T>, Expression<Func<T, Nullable<Double>>>, CancellationToken) AsyncExtensions.AverageAsync<T>(IDataQuery<T>, Expression<Func<T, Nullable<Double>>>) AsyncExtensions.AverageAsync<T>(IQueryable<T>, Expression<Func<T, Nullable<Decimal>>>) AsyncExtensions.AverageAsync<T>(IQueryable<T>, Expression<Func<T, Nullable<Decimal>>>, CancellationToken) AsyncExtensions.AverageAsync<T>(IDataQuery<T>, Expression<Func<T, Nullable<Decimal>>>) AsyncExtensions.AverageAsync<T>(IQueryable<T>, Expression<Func<T, Nullable<Int32>>>) AsyncExtensions.AverageAsync<T>(IQueryable<T>, Expression<Func<T, Nullable<Int32>>>, CancellationToken) AsyncExtensions.AverageAsync<T>(IDataQuery<T>, Expression<Func<T, Nullable<Int32>>>) AsyncExtensions.AverageAsync<T>(IQueryable<T>, Expression<Func<T, Nullable<Int64>>>) AsyncExtensions.AverageAsync<T>(IQueryable<T>, Expression<Func<T, Nullable<Int64>>>, CancellationToken) AsyncExtensions.AverageAsync<T>(IDataQuery<T>, Expression<Func<T, Nullable<Int64>>>) AsyncExtensions.ContainsAsync<T>(IQueryable<T>, T, Func<T, Object>[]) AsyncExtensions.ContainsAsync<T>(IQueryable<T>, T, IEqualityComparer<T>) AsyncExtensions.ContainsAsync<T>(IQueryable<T>, T, IEqualityComparer<T>, CancellationToken) AsyncExtensions.ContainsAsync<T>(IDataQuery<T>, T, IEqualityComparer<T>) AsyncExtensions.ContainsAsync<T>(IDataQuery<T>, T) AsyncExtensions.CountAsync<T>(IQueryable<T>) AsyncExtensions.CountAsync<T>(IQueryable<T>, Expression<Func<T, Boolean>>) AsyncExtensions.CountAsync<T>(IQueryable<T>, Expression<Func<T, Boolean>>, CancellationToken) AsyncExtensions.CountAsync<T>(IDataQuery<T>) AsyncExtensions.CountAsync<T>(IDataQuery<T>, Expression<Func<T, Boolean>>) AsyncExtensions.LongCountAsync<T>(IQueryable<T>) AsyncExtensions.LongCountAsync<T>(IQueryable<T>, Expression<Func<T, Boolean>>) AsyncExtensions.LongCountAsync<T>(IQueryable<T>, Expression<Func<T, Boolean>>, CancellationToken) AsyncExtensions.LongCountAsync<T>(IDataQuery<T>) AsyncExtensions.LongCountAsync<T>(IDataQuery<T>, Expression<Func<T, Boolean>>) AsyncExtensions.FirstAsync<T>(IQueryable<T>) AsyncExtensions.FirstAsync<T>(IQueryable<T>, Expression<Func<T, Boolean>>) AsyncExtensions.FirstAsync<T>(IQueryable<T>, Expression<Func<T, Boolean>>, CancellationToken) AsyncExtensions.FirstAsync<T>(IDataQuery<T>) AsyncExtensions.FirstAsync<T>(IDataQuery<T>, Expression<Func<T, Boolean>>) AsyncExtensions.FirstOrDefaultAsync<T>(IQueryable<T>) AsyncExtensions.FirstOrDefaultAsync<T>(IQueryable<T>, Expression<Func<T, Boolean>>) AsyncExtensions.FirstOrDefaultAsync<T>(IQueryable<T>, Expression<Func<T, Boolean>>, CancellationToken) AsyncExtensions.FirstOrDefaultAsync<T>(IDataQuery<T>) AsyncExtensions.FirstOrDefaultAsync<T>(IDataQuery<T>, Expression<Func<T, Boolean>>) AsyncExtensions.ForEachAsync<T>(IQueryable<T>, Func<T, Task>) AsyncExtensions.ForEachAsync<T>(IQueryable<T>, Func<T, Task>, CancellationToken) AsyncExtensions.ForEachAsync<T>(IDataQuery<T>, Func<T, Task>) AsyncExtensions.ForEachAsync<T>(IQueryable<T>, Action<T>) AsyncExtensions.ForEachAsync<T>(IQueryable<T>, Action<T>, CancellationToken) AsyncExtensions.ForEachAsync<T>(IDataQuery<T>, Action<T>) AsyncExtensions.LastAsync<T>(IQueryable<T>) AsyncExtensions.LastAsync<T>(IQueryable<T>, Expression<Func<T, Boolean>>) AsyncExtensions.LastAsync<T>(IQueryable<T>, Expression<Func<T, Boolean>>, CancellationToken) AsyncExtensions.LastAsync<T>(IDataQuery<T>) AsyncExtensions.LastAsync<T>(IDataQuery<T>, Expression<Func<T, Boolean>>) AsyncExtensions.LastOrDefaultAsync<T>(IQueryable<T>) AsyncExtensions.LastOrDefaultAsync<T>(IQueryable<T>, Expression<Func<T, Boolean>>) AsyncExtensions.LastOrDefaultAsync<T>(IQueryable<T>, Expression<Func<T, Boolean>>, CancellationToken) AsyncExtensions.LastOrDefaultAsync<T>(IDataQuery<T>) AsyncExtensions.LastOrDefaultAsync<T>(IDataQuery<T>, Expression<Func<T, Boolean>>) AsyncExtensions.MaxAsync<T, TResult>(IQueryable<T>, Expression<Func<T, TResult>>) AsyncExtensions.MaxAsync<T, TResult>(IQueryable<T>, Expression<Func<T, TResult>>, CancellationToken) AsyncExtensions.MaxAsync<T, TResult>(IDataQuery<T>, Expression<Func<T, TResult>>) AsyncExtensions.MinAsync<T, TResult>(IQueryable<T>, Expression<Func<T, TResult>>) AsyncExtensions.MinAsync<T, TResult>(IQueryable<T>, Expression<Func<T, TResult>>, CancellationToken) AsyncExtensions.MinAsync<T, TResult>(IDataQuery<T>, Expression<Func<T, TResult>>) AsyncExtensions.GetParameterAsync<T>(IDataQuery, String) AsyncExtensions.GetResultSetAsync<TRes>(IDataQuery, String) AsyncExtensions.GetResultSetAsync<TRes>(IDataQuery, Expression<Func<IEnumerable<TRes>>>) AsyncExtensions.SingleAsync<T>(IQueryable<T>) AsyncExtensions.SingleAsync<T>(IQueryable<T>, Expression<Func<T, Boolean>>) AsyncExtensions.SingleAsync<T>(IQueryable<T>, Expression<Func<T, Boolean>>, CancellationToken) AsyncExtensions.SingleAsync<T>(IDataQuery<T>) AsyncExtensions.SingleAsync<T>(IDataQuery<T>, Expression<Func<T, Boolean>>) AsyncExtensions.SingleOrDefaultAsync<T>(IQueryable<T>) AsyncExtensions.SingleOrDefaultAsync<T>(IQueryable<T>, Expression<Func<T, Boolean>>) AsyncExtensions.SingleOrDefaultAsync<T>(IQueryable<T>, Expression<Func<T, Boolean>>, CancellationToken) AsyncExtensions.SingleOrDefaultAsync<T>(IDataQuery<T>) AsyncExtensions.SingleOrDefaultAsync<T>(IDataQuery<T>, Expression<Func<T, Boolean>>) AsyncExtensions.SumAsync<T>(IQueryable<T>, Expression<Func<T, Single>>) AsyncExtensions.SumAsync<T>(IQueryable<T>, Expression<Func<T, Single>>, CancellationToken) AsyncExtensions.SumAsync<T>(IDataQuery<T>, Expression<Func<T, Single>>) AsyncExtensions.SumAsync<T>(IQueryable<T>, Expression<Func<T, Double>>) AsyncExtensions.SumAsync<T>(IQueryable<T>, Expression<Func<T, Double>>, CancellationToken) AsyncExtensions.SumAsync<T>(IDataQuery<T>, Expression<Func<T, Double>>) AsyncExtensions.SumAsync<T>(IQueryable<T>, Expression<Func<T, Decimal>>) AsyncExtensions.SumAsync<T>(IQueryable<T>, Expression<Func<T, Decimal>>, CancellationToken) AsyncExtensions.SumAsync<T>(IDataQuery<T>, Expression<Func<T, Decimal>>) AsyncExtensions.SumAsync<T>(IQueryable<T>, Expression<Func<T, Int32>>) AsyncExtensions.SumAsync<T>(IQueryable<T>, Expression<Func<T, Int32>>, CancellationToken) AsyncExtensions.SumAsync<T>(IDataQuery<T>, Expression<Func<T, Int32>>) AsyncExtensions.SumAsync<T>(IQueryable<T>, Expression<Func<T, Int64>>) AsyncExtensions.SumAsync<T>(IQueryable<T>, Expression<Func<T, Int64>>, CancellationToken) AsyncExtensions.SumAsync<T>(IDataQuery<T>, Expression<Func<T, Int64>>) AsyncExtensions.SumAsync<T>(IQueryable<T>, Expression<Func<T, Nullable<Single>>>) AsyncExtensions.SumAsync<T>(IQueryable<T>, Expression<Func<T, Nullable<Single>>>, CancellationToken) AsyncExtensions.SumAsync<T>(IDataQuery<T>, Expression<Func<T, Nullable<Single>>>) AsyncExtensions.SumAsync<T>(IQueryable<T>, Expression<Func<T, Nullable<Double>>>) AsyncExtensions.SumAsync<T>(IQueryable<T>, Expression<Func<T, Nullable<Double>>>, CancellationToken) AsyncExtensions.SumAsync<T>(IDataQuery<T>, Expression<Func<T, Nullable<Double>>>) AsyncExtensions.SumAsync<T>(IQueryable<T>, Expression<Func<T, Nullable<Decimal>>>) AsyncExtensions.SumAsync<T>(IQueryable<T>, Expression<Func<T, Nullable<Decimal>>>, CancellationToken) AsyncExtensions.SumAsync<T>(IDataQuery<T>, Expression<Func<T, Nullable<Decimal>>>) AsyncExtensions.SumAsync<T>(IQueryable<T>, Expression<Func<T, Nullable<Int32>>>) AsyncExtensions.SumAsync<T>(IQueryable<T>, Expression<Func<T, Nullable<Int32>>>, CancellationToken) AsyncExtensions.SumAsync<T>(IDataQuery<T>, Expression<Func<T, Nullable<Int32>>>) AsyncExtensions.SumAsync<T>(IQueryable<T>, Expression<Func<T, Nullable<Int64>>>) AsyncExtensions.SumAsync<T>(IQueryable<T>, Expression<Func<T, Nullable<Int64>>>, CancellationToken) AsyncExtensions.SumAsync<T>(IDataQuery<T>, Expression<Func<T, Nullable<Int64>>>) AsyncExtensions.ToArrayAsync<T>(IQueryable<T>) AsyncExtensions.ToArrayAsync<T>(IQueryable<T>, CancellationToken) AsyncExtensions.ToArrayAsync<T>(IDataQuery<T>) AsyncExtensions.ToDictionaryAsync<T, TKey, TValue>(IQueryable<T>, Func<T, TKey>, Func<T, TValue>) AsyncExtensions.ToDictionaryAsync<T, TKey, TValue>(IQueryable<T>, Func<T, TKey>, Func<T, TValue>, CancellationToken) AsyncExtensions.ToDictionaryAsync<T, TKey, TValue>(IDataQuery<T>, Func<T, TKey>, Func<T, TValue>) AsyncExtensions.ToListAsync<T>(IQueryable<T>) AsyncExtensions.ToListAsync<T>(IQueryable<T>, CancellationToken) AsyncExtensions.ToListAsync<T>(IDataQuery<T>) CollectionsExtensions.ToSortedSet<T>(IEnumerable<T>, IComparer<T>) CollectionsExtensions.SetValue<TKey, T>(TKey, T) CollectionsExtensions.AsEnum<T>(T) DataObjectQueryableExtensions.CompareVariable(Object, FilterOperation, String) JoinedEnumerable.Inner<TElement>(IEnumerable<TElement>) JoinedEnumerable.Outer<TElement>(IEnumerable<TElement>) JoinedEnumerable.LeftOuterJoin<TOuter, TInner, TKey, TResult>(IEnumerable<TOuter>, IEnumerable<TInner>, Func<TOuter, TKey>, Func<TInner, TKey>, Func<TOuter, TInner, TResult>, IEqualityComparer<TKey>) JoinedEnumerable.RightOuterJoin<TOuter, TInner, TKey, TResult>(IEnumerable<TOuter>, IEnumerable<TInner>, Func<TOuter, TKey>, Func<TInner, TKey>, Func<TOuter, TInner, TResult>, IEqualityComparer<TKey>) JoinedEnumerable.FullOuterJoin<TOuter, TInner, TKey, TResult>(IEnumerable<TOuter>, IEnumerable<TInner>, Func<TOuter, TKey>, Func<TInner, TKey>, Func<TOuter, TInner, TResult>, IEqualityComparer<TKey>) Processing.Do<T>(T, Action<IProcess<T>>[]) TypeExtensions.TryConvert<T, TResult>(T, Func<T, TResult>) TypeExtensions.TryConvert<T, TResult>(T, Func<T, TResult>, TResult) TypeExtensions.ChangeType<T>(Object) TypeExtensions.ChangeType(Object, Type) TypeExtensions.InvokeMethod<TRet>(Object, Type[], Expression<Func<TRet>>, BindingFlags) TypeExtensions.InvokeMethod(Object, Type[], Expression<Action>, BindingFlags) TypeExtensions.InvokeMethod<TRet>(Object, Expression<Func<TRet>>, BindingFlags) TypeExtensions.InvokeMethod(Object, Expression<Action>, BindingFlags) SqlBlockExtensions.SetExpression<TTag, TResult>(TTag, Expression<Func<IBlockQueryAdapter, TResult>>) QueryDescriptionExtensions.SetExpression<TTag, TResult>(TTag, Expression<Func<IQueryStructureAdapter, TResult>>) QueryDescriptionExtensions.ToDataSet<T>(IEnumerable<T>, String, ISqlBuilder)"
  },
  "api/XData.IWorkSet-1.html": {
    "href": "api/XData.IWorkSet-1.html",
    "title": "Interface IWorkSet<T> | XData website",
    "keywords": "Interface IWorkSet<T> Work set interface Inherited Members IWorkSet.Name IWorkSet.Clear() IWorkSet.Submit() IWorkSet.Type IWorkSet.DbLayer IDisposable.Dispose() Namespace : XData Assembly : XData.WorkSet.docfx.dll Syntax public interface IWorkSet<out T> : IWorkSet, IDisposable where T : class, IDataObject, new() Type Parameters Name Description T Data object type Remarks Used to create/modify complex objects Hint: UnitOfWork template Methods | Improve this Doc View Source Child<TRet>(Func<T, Boolean>, String) Find depended work set Declaration IWorkSet<TRet> Child<TRet>(Func<T, bool> predicate, string alias = null) where TRet : class, IDataObject, new() Parameters Type Name Description Func <T, Boolean > predicate Predicate to find parent object String alias (optional) Child repository alias Returns Type Description IWorkSet <TRet> Found work set Type Parameters Name Description TRet Depended object type | Improve this Doc View Source Child<TRet>(Func<T, Int32, Boolean>, Func<T, IComparable>[], String) Find depended work set (using order index) Declaration IWorkSet<TRet> Child<TRet>(Func<T, int, bool> predicate, Func<T, IComparable>[] order, string alias = null) where TRet : class, IDataObject, new() Parameters Type Name Description Func <T, Int32 , Boolean > predicate Predicate to find parent object Func <T, IComparable >[] order Order statements String alias (optional) Child repository alias Returns Type Description IWorkSet <TRet> Found work set Type Parameters Name Description TRet Depended object type | Improve this Doc View Source Child<TRet>(String) Find depended work set Declaration IWorkSet<TRet> Child<TRet>(string alias = null) where TRet : class, IDataObject, new() Parameters Type Name Description String alias (optional) Child repository alias Returns Type Description IWorkSet <TRet> Found work set Type Parameters Name Description TRet Depended object type | Improve this Doc View Source Child<TRet, TKey>(Func<T, Int32, Boolean>, Func<T, TKey>, String) Find depended work set (using order index) Declaration IWorkSet<TRet> Child<TRet, TKey>(Func<T, int, bool> predicate, Func<T, TKey> order, string alias = null) where TRet : class, IDataObject, new() where TKey : IComparable Parameters Type Name Description Func <T, Int32 , Boolean > predicate Predicate to find parent object Func <T, TKey> order Order statements String alias (optional) Child repository alias Returns Type Description IWorkSet <TRet> Found work set Type Parameters Name Description TRet Depended object type TKey Order key type | Improve this Doc View Source Get(Func<T, Boolean>, WorkState) Get single data object by predicate Declaration T Get(Func<T, bool> predicate = null, WorkState state = WorkState.Active) Parameters Type Name Description Func <T, Boolean > predicate Predicate to find specific object WorkState state Work set state Returns Type Description T Data object | Improve this Doc View Source Get(Func<T, Int32, Boolean>, Func<T, IComparable>[], WorkState) Get single data object by predicate (using order index) Declaration T Get(Func<T, int, bool> predicate, Func<T, IComparable>[] order, WorkState state = WorkState.Active) Parameters Type Name Description Func <T, Int32 , Boolean > predicate Predicate to find specific object Func <T, IComparable >[] order Order statements WorkState state Work set state Returns Type Description T Data object | Improve this Doc View Source Get<TKey>(Func<T, Int32, Boolean>, Func<T, TKey>, WorkState) Get single data object by predicate (using order index) Declaration T Get<TKey>(Func<T, int, bool> predicate, Func<T, TKey> order, WorkState state = WorkState.Active) where TKey : IComparable Parameters Type Name Description Func <T, Int32 , Boolean > predicate Predicate to find specific object Func <T, TKey> order Order statement WorkState state Work set state Returns Type Description T Data object Type Parameters Name Description TKey Order key type | Improve this Doc View Source GetKey() Get single data object key Declaration Guid? GetKey() Returns Type Description Nullable < Guid > Data object key | Improve this Doc View Source GetKey(Func<T, Boolean>, WorkState) Get single data object key by predicate Declaration Guid? GetKey(Func<T, bool> predicate, WorkState state = WorkState.Active) Parameters Type Name Description Func <T, Boolean > predicate Predicate to find specific object WorkState state Work set state Returns Type Description Nullable < Guid > Data object key | Improve this Doc View Source GetKey(Func<T, Int32, Boolean>, Func<T, IComparable>[], WorkState) Get single data object key by predicate (using order index) Declaration Guid? GetKey(Func<T, int, bool> predicate, Func<T, IComparable>[] order, WorkState state = WorkState.Active) Parameters Type Name Description Func <T, Int32 , Boolean > predicate Predicate to find specific object Func <T, IComparable >[] order Order statements WorkState state Work set state Returns Type Description Nullable < Guid > Data object key | Improve this Doc View Source GetKey(WorkState) Get single data object key Declaration Guid? GetKey(WorkState state) Parameters Type Name Description WorkState state Work set state Returns Type Description Nullable < Guid > Data object key | Improve this Doc View Source GetKey<TKey>(Func<T, Int32, Boolean>, Func<T, TKey>, WorkState) Get single data object key by predicate (using order index) Declaration Guid? GetKey<TKey>(Func<T, int, bool> predicate, Func<T, TKey> order, WorkState state = WorkState.Active) where TKey : IComparable Parameters Type Name Description Func <T, Int32 , Boolean > predicate Predicate to find specific object Func <T, TKey> order Order statement WorkState state Work set state Returns Type Description Nullable < Guid > Data object key Type Parameters Name Description TKey Order key type | Improve this Doc View Source Lock(Func<T, Boolean>) Try to obtain lock on data object Declaration bool Lock(Func<T, bool> predicate = null) Parameters Type Name Description Func <T, Boolean > predicate Predicate to find specific object Returns Type Description Boolean Lock success flag | Improve this Doc View Source Lock(Func<T, Int32, Boolean>, Func<T, IComparable>[]) Try to obtain lock on data object by predicate (using order index) Declaration bool Lock(Func<T, int, bool> predicate, Func<T, IComparable>[] order) Parameters Type Name Description Func <T, Int32 , Boolean > predicate Predicate to find specific object Func <T, IComparable >[] order Order statements Returns Type Description Boolean Lock success flag | Improve this Doc View Source Lock<TKey>(Func<T, Int32, Boolean>, Func<T, TKey>) Try to obtain lock on data object by predicate (using order index) Declaration bool Lock<TKey>(Func<T, int, bool> predicate, Func<T, TKey> order) where TKey : IComparable Parameters Type Name Description Func <T, Int32 , Boolean > predicate Predicate to find specific object Func <T, TKey> order Order statement Returns Type Description Boolean Lock success flag Type Parameters Name Description TKey Order key type | Improve this Doc View Source New(Action<T>[]) Add object to work set collection Declaration T New(params Action<T>[] init) Parameters Type Name Description Action <T>[] init Object creator Returns Type Description T Added object | Improve this Doc View Source Select(WorkState) Retrieve all objects by work set Declaration IEnumerable<T> Select(WorkState state = WorkState.Active) Parameters Type Name Description WorkState state Work set state Returns Type Description IEnumerable <T> Data object sequence | Improve this Doc View Source Select<TRet>(Func<T, TRet>, WorkState) Retrieve all objects by work set and apply selector logic to convert data Declaration IEnumerable<TRet> Select<TRet>(Func<T, TRet> selector, WorkState state = WorkState.Active) Parameters Type Name Description Func <T, TRet> selector Selector convert routine WorkState state Work set state Returns Type Description IEnumerable <TRet> Result object sequence Type Parameters Name Description TRet | Improve this Doc View Source SelectKeys(WorkState) Retrieve all keys by work set Declaration IEnumerable<Guid> SelectKeys(WorkState state = WorkState.Active) Parameters Type Name Description WorkState state Work set state Returns Type Description IEnumerable < Guid > Keys sequence Extension Methods SerializationExtensions.ToXml<T>(T) CollectionsExtensions.SetValue<TKey, T>(TKey, T) CollectionsExtensions.AsEnum<T>(T) DataObjectQueryableExtensions.CompareVariable(Object, FilterOperation, String) Processing.Do<T>(T, Action<IProcess<T>>[]) TypeExtensions.TryConvert<T, TResult>(T, Func<T, TResult>) TypeExtensions.TryConvert<T, TResult>(T, Func<T, TResult>, TResult) TypeExtensions.ChangeType<T>(Object) TypeExtensions.ChangeType(Object, Type) TypeExtensions.InvokeMethod<TRet>(Object, Type[], Expression<Func<TRet>>, BindingFlags) TypeExtensions.InvokeMethod(Object, Type[], Expression<Action>, BindingFlags) TypeExtensions.InvokeMethod<TRet>(Object, Expression<Func<TRet>>, BindingFlags) TypeExtensions.InvokeMethod(Object, Expression<Action>, BindingFlags) SqlBlockExtensions.SetExpression<TTag, TResult>(TTag, Expression<Func<IBlockQueryAdapter, TResult>>) QueryDescriptionExtensions.SetExpression<TTag, TResult>(TTag, Expression<Func<IQueryStructureAdapter, TResult>>) See Also Name Clear () Submit () Lock<TKey>(Func<T, Int32, Boolean>, Func<T, TKey>) Get(Func<T, Int32, Boolean>, Func<T, IComparable>[], WorkState) Select(WorkState) Child<TRet>(String) Child<TRet>(Func<T, Boolean>, String) Child<TRet>(Func<T, Int32, Boolean>, Func<T, IComparable>[], String) Child<TRet, TKey>(Func<T, Int32, Boolean>, Func<T, TKey>, String) New(Action<T>[]) GetKey() SelectKeys(WorkState) Work"
  },
  "api/XData.Interfaces.IConfiguration.html": {
    "href": "api/XData.Interfaces.IConfiguration.html",
    "title": "Interface IConfiguration | XData website",
    "keywords": "Interface IConfiguration XData configuration Namespace : XData.Interfaces Assembly : XData.docfx.dll Syntax public interface IConfiguration Examples <?xml version=\"1.0\" encoding=\"utf-8\" ?> <configuration> <!-- *** WARNING! configSections section with declaration of \"xdata\" is required and mast be first child section of configuration! --> <configSections> <section name=\"xdata\" type=\"System.Configuration.IgnoreSectionHandler\" /> </configSections> <!-- *** You can configure Your application to direct connect database OR use application server --> <!-- *** Endpoint required using application server only --> <!--<system.serviceModel> <client> <endpoint address=\"net.tcp://localhost:8733/AppServer/\" binding=\"netTcpBinding\" contract=\"XDataProxy.IAppServer\" name=\"XAppServer\" /> </client> </system.serviceModel>--> <!-- *** Connection strings required using direct connect only --> <connectionStrings> <add name=\"TEST\" connectionString=\"Data Source=(local);Initial Catalog=XDataTest;User Id=test;Password=test\" /> </connectionStrings> <!-- *** xdata section (see XDataConfiguration.DefaultContext, XDataConfiguration.LogWriter documentation) --> <xdata default=\"TEST\" log=\"XData.Logging.Trace.TraceWriter, XData.Logging.Trace\"> <!-- *** Specific SQL data access adapter required using direct database access (see XDataConfiguration.Adapters documentation) --> <adapter name=\"MSSQL\" file=\"C:\\Projects\\Net40\\XData\\_Debug\\XMsSqlAdapter.dll\"/> <!-- *** Specific SQL dialect adapter (see XDataConfiguration.Dialects documentation) --> <dialect name=\"MSSQL\" file=\"C:\\Projects\\Net40\\XData\\_Debug\\XMsSqlDialect.dll\"/> <!-- *** Proxy adapter required using application server only --> <!--<adapter name=\"PROXY\" file=\"C:\\XData\\XProxyAdapter.dll\"/>--> <!-- *** Context can be configured by direct or proxy adapter according Your needs (see XDataConfiguration.Contexts, ContextConfig.SequenceNameRule documentation) --> <!--<context name=\"TEST\" adapter=\"PROXY\"/>--> <context name=\"TEST\" adapter=\"MSSQL\" sequence=\"XMyCustomLib.MyDbSequence, XMyCustomLib\"/> <!-- *** Context proxy configuration required using application server only (see XDataConfiguration.ProxyList documentation) --> <!--<proxy name=\"TEST\" adapter=\"MSSQL\" endpoint=\"XAppServer\" />--> </xdata> </configuration> Properties | Improve this Doc View Source Adapters Registered adapters collection Declaration List<AdapterConfig> Adapters { get; } Property Value Type Description List < AdapterConfig > See Also AdapterConfig | Improve this Doc View Source Contexts Registered contexts collection Declaration List<ContextConfig> Contexts { get; } Property Value Type Description List < ContextConfig > See Also ContextConfig | Improve this Doc View Source DefaultContext Default context name Declaration string DefaultContext { get; } Property Value Type Description String Remarks WARNING! Required configuration attribute! See Also Context Context | Improve this Doc View Source Dialects Registered SQL dialects collection Declaration List<DialectConfig> Dialects { get; } Property Value Type Description List < DialectConfig > See Also DialectConfig | Improve this Doc View Source LifeTimeLimit XData objects lifetime limit (minutes) Declaration int LifeTimeLimit { get; } Property Value Type Description Int32 | Improve this Doc View Source LogWriter Log writer class name Declaration string LogWriter { get; } Property Value Type Description String | Improve this Doc View Source MonitoringContext Health monitoring context name Declaration string MonitoringContext { get; } Property Value Type Description String See Also Context Context | Improve this Doc View Source ProxyList Registered proxy collection Declaration List<ProxyConfig> ProxyList { get; } Property Value Type Description List < ProxyConfig > See Also ProxyConfig | Improve this Doc View Source SecurityContext Security context name Declaration string SecurityContext { get; } Property Value Type Description String See Also Context Context Extension Methods SerializationExtensions.ToXml<T>(T) CollectionsExtensions.SetValue<TKey, T>(TKey, T) CollectionsExtensions.AsEnum<T>(T) DataObjectQueryableExtensions.CompareVariable(Object, FilterOperation, String) Processing.Do<T>(T, Action<IProcess<T>>[]) TypeExtensions.TryConvert<T, TResult>(T, Func<T, TResult>) TypeExtensions.TryConvert<T, TResult>(T, Func<T, TResult>, TResult) TypeExtensions.ChangeType<T>(Object) TypeExtensions.ChangeType(Object, Type) TypeExtensions.InvokeMethod<TRet>(Object, Type[], Expression<Func<TRet>>, BindingFlags) TypeExtensions.InvokeMethod(Object, Type[], Expression<Action>, BindingFlags) TypeExtensions.InvokeMethod<TRet>(Object, Expression<Func<TRet>>, BindingFlags) TypeExtensions.InvokeMethod(Object, Expression<Action>, BindingFlags) SqlBlockExtensions.SetExpression<TTag, TResult>(TTag, Expression<Func<IBlockQueryAdapter, TResult>>) QueryDescriptionExtensions.SetExpression<TTag, TResult>(TTag, Expression<Func<IQueryStructureAdapter, TResult>>) See Also Adapters Dialects Contexts ProxyList DefaultContext LogWriter"
  },
  "api/XData.Interfaces.DialectConfig.html": {
    "href": "api/XData.Interfaces.DialectConfig.html",
    "title": "Class DialectConfig | XData website",
    "keywords": "Class DialectConfig SQL dialect configuration section Inheritance Object DialectConfig Inherited Members Object.Equals(Object) Object.Equals(Object, Object) Object.GetHashCode() Object.GetType() Object.MemberwiseClone() Object.ReferenceEquals(Object, Object) Object.ToString() Namespace : XData.Interfaces Assembly : XData.docfx.dll Syntax public sealed class DialectConfig Remarks WARNING! All attributes are required! Examples <dialect name=\"MSSQL\" file=\"C:\\XData\\XMsSqlDialect.dll\"/> Properties | Improve this Doc View Source AssemblyName Adapter assembly name Declaration public string AssemblyName { get; set; } Property Value Type Description String | Improve this Doc View Source Config Adapter configuration Declaration public IConfiguration Config { get; set; } Property Value Type Description IConfiguration | Improve this Doc View Source Name Adapter name Declaration public string Name { get; set; } Property Value Type Description String Remarks Mast be the same as DialectName Extension Methods SerializationExtensions.ToXml<T>(T) CollectionsExtensions.SetValue<TKey, T>(TKey, T) CollectionsExtensions.AsEnum<T>(T) DataObjectQueryableExtensions.CompareVariable(Object, FilterOperation, String) Processing.Do<T>(T, Action<IProcess<T>>[]) TypeExtensions.TryConvert<T, TResult>(T, Func<T, TResult>) TypeExtensions.TryConvert<T, TResult>(T, Func<T, TResult>, TResult) TypeExtensions.ChangeType<T>(Object) TypeExtensions.ChangeType(Object, Type) TypeExtensions.InvokeMethod<TRet>(Object, Type[], Expression<Func<TRet>>, BindingFlags) TypeExtensions.InvokeMethod(Object, Type[], Expression<Action>, BindingFlags) TypeExtensions.InvokeMethod<TRet>(Object, Expression<Func<TRet>>, BindingFlags) TypeExtensions.InvokeMethod(Object, Expression<Action>, BindingFlags) SqlBlockExtensions.SetExpression<TTag, TResult>(TTag, Expression<Func<IBlockQueryAdapter, TResult>>) QueryDescriptionExtensions.SetExpression<TTag, TResult>(TTag, Expression<Func<IQueryStructureAdapter, TResult>>) See Also Name AssemblyName"
  },
  "api/XData.FilterType.html": {
    "href": "api/XData.FilterType.html",
    "title": "Enum FilterType | XData website",
    "keywords": "Enum FilterType Filter type Namespace : XData Assembly : XData.docfx.dll Syntax [DataContract] public enum FilterType Fields Name Description Constant Constant value filter Dictionary Dictionary link Expression Expression filter InnerViewLink Inner view link Link Inner link Range Range filter Runtime Runtime value filter Subquery Subquery filter SubqueryLink Subquery link See Also Link SubqueryLink InnerViewLink Dictionary Constant Subquery Expression Range Runtime Extension Methods SerializationExtensions.ToXml<FilterType>() CollectionsExtensions.SetValue<FilterType, T>(T) CollectionsExtensions.AsEnum<FilterType>() DataObjectQueryableExtensions.CompareVariable(FilterOperation, String) Processing.Do<FilterType>(Action<IProcess<FilterType>>[]) TypeExtensions.ChangeType<T>() TypeExtensions.ChangeType(Type) TypeExtensions.InvokeMethod<TRet>(Type[], Expression<Func<TRet>>, BindingFlags) TypeExtensions.InvokeMethod(Type[], Expression<Action>, BindingFlags) TypeExtensions.InvokeMethod<TRet>(Expression<Func<TRet>>, BindingFlags) TypeExtensions.InvokeMethod(Expression<Action>, BindingFlags) TypeExtensions.ConvertTo<T>() TypeExtensions.EqualValue(Enum) SqlBlockExtensions.SetExpression<FilterType, TResult>(Expression<Func<IBlockQueryAdapter, TResult>>) QueryDescriptionExtensions.SetExpression<FilterType, TResult>(Expression<Func<IQueryStructureAdapter, TResult>>)"
  },
  "api/XData.Interfaces.ILogWriter.html": {
    "href": "api/XData.Interfaces.ILogWriter.html",
    "title": "Interface ILogWriter | XData website",
    "keywords": "Interface ILogWriter XData log writer interface Namespace : XData.Interfaces Assembly : XData.docfx.dll Syntax public interface ILogWriter Methods | Improve this Doc View Source Write(MessageType, String) Write message to log Declaration void Write(MessageType msgType, string msgText) Parameters Type Name Description MessageType msgType Message type String msgText Message text Extension Methods SerializationExtensions.ToXml<T>(T) CollectionsExtensions.SetValue<TKey, T>(TKey, T) CollectionsExtensions.AsEnum<T>(T) DataObjectQueryableExtensions.CompareVariable(Object, FilterOperation, String) Processing.Do<T>(T, Action<IProcess<T>>[]) TypeExtensions.TryConvert<T, TResult>(T, Func<T, TResult>) TypeExtensions.TryConvert<T, TResult>(T, Func<T, TResult>, TResult) TypeExtensions.ChangeType<T>(Object) TypeExtensions.ChangeType(Object, Type) TypeExtensions.InvokeMethod<TRet>(Object, Type[], Expression<Func<TRet>>, BindingFlags) TypeExtensions.InvokeMethod(Object, Type[], Expression<Action>, BindingFlags) TypeExtensions.InvokeMethod<TRet>(Object, Expression<Func<TRet>>, BindingFlags) TypeExtensions.InvokeMethod(Object, Expression<Action>, BindingFlags) SqlBlockExtensions.SetExpression<TTag, TResult>(TTag, Expression<Func<IBlockQueryAdapter, TResult>>) QueryDescriptionExtensions.SetExpression<TTag, TResult>(TTag, Expression<Func<IQueryStructureAdapter, TResult>>)"
  },
  "api/XData.GetLobSizeAttachedHandler.html": {
    "href": "api/XData.GetLobSizeAttachedHandler.html",
    "title": "Delegate GetLobSizeAttachedHandler | XData website",
    "keywords": "Delegate GetLobSizeAttachedHandler Get Lob size attached handler delegate Namespace : XData Assembly : XData.docfx.dll Syntax public delegate bool GetLobSizeAttachedHandler(string property, IDataObject obj, out long size); Parameters Type Name Description String property Lob property name IDataObject obj Data object Int64 size Lob body size Returns Type Description Boolean Extension Methods SerializationExtensions.ToXml<T>(T) CollectionsExtensions.SetValue<TKey, T>(TKey, T) CollectionsExtensions.AsEnum<T>(T) DataObjectQueryableExtensions.CompareVariable(Object, FilterOperation, String) Processing.Do<T>(T, Action<IProcess<T>>[]) TypeExtensions.TryConvert<T, TResult>(T, Func<T, TResult>) TypeExtensions.TryConvert<T, TResult>(T, Func<T, TResult>, TResult) TypeExtensions.ChangeType<T>(Object) TypeExtensions.ChangeType(Object, Type) TypeExtensions.InvokeMethod<TRet>(Object, Type[], Expression<Func<TRet>>, BindingFlags) TypeExtensions.InvokeMethod(Object, Type[], Expression<Action>, BindingFlags) TypeExtensions.InvokeMethod<TRet>(Object, Expression<Func<TRet>>, BindingFlags) TypeExtensions.InvokeMethod(Object, Expression<Action>, BindingFlags) SqlBlockExtensions.SetExpression<TTag, TResult>(TTag, Expression<Func<IBlockQueryAdapter, TResult>>) QueryDescriptionExtensions.SetExpression<TTag, TResult>(TTag, Expression<Func<IQueryStructureAdapter, TResult>>)"
  },
  "api/XData.GetLobAttachedHandler.html": {
    "href": "api/XData.GetLobAttachedHandler.html",
    "title": "Delegate GetLobAttachedHandler | XData website",
    "keywords": "Delegate GetLobAttachedHandler Get Lob attached handler delegate Namespace : XData Assembly : XData.docfx.dll Syntax public delegate bool GetLobAttachedHandler(string property, IDataObject obj, out byte[] body); Parameters Type Name Description String property Lob property name IDataObject obj Data object Byte [] body Lob body Returns Type Description Boolean Extension Methods SerializationExtensions.ToXml<T>(T) CollectionsExtensions.SetValue<TKey, T>(TKey, T) CollectionsExtensions.AsEnum<T>(T) DataObjectQueryableExtensions.CompareVariable(Object, FilterOperation, String) Processing.Do<T>(T, Action<IProcess<T>>[]) TypeExtensions.TryConvert<T, TResult>(T, Func<T, TResult>) TypeExtensions.TryConvert<T, TResult>(T, Func<T, TResult>, TResult) TypeExtensions.ChangeType<T>(Object) TypeExtensions.ChangeType(Object, Type) TypeExtensions.InvokeMethod<TRet>(Object, Type[], Expression<Func<TRet>>, BindingFlags) TypeExtensions.InvokeMethod(Object, Type[], Expression<Action>, BindingFlags) TypeExtensions.InvokeMethod<TRet>(Object, Expression<Func<TRet>>, BindingFlags) TypeExtensions.InvokeMethod(Object, Expression<Action>, BindingFlags) SqlBlockExtensions.SetExpression<TTag, TResult>(TTag, Expression<Func<IBlockQueryAdapter, TResult>>) QueryDescriptionExtensions.SetExpression<TTag, TResult>(TTag, Expression<Func<IQueryStructureAdapter, TResult>>)"
  },
  "api/XData.Extensions.GeneralPropertyComparer-1.html": {
    "href": "api/XData.Extensions.GeneralPropertyComparer-1.html",
    "title": "Class GeneralPropertyComparer<T> | XData website",
    "keywords": "Class GeneralPropertyComparer<T> Inheritance Object GeneralPropertyComparer<T> Implements IEqualityComparer <T> Inherited Members Object.Equals(Object) Object.Equals(Object, Object) Object.GetHashCode() Object.GetType() Object.MemberwiseClone() Object.ReferenceEquals(Object, Object) Object.ToString() Namespace : XData.Extensions Assembly : XData.docfx.dll Syntax public class GeneralPropertyComparer<T> : IEqualityComparer<T> Type Parameters Name Description T Constructors | Improve this Doc View Source GeneralPropertyComparer(Func<T, Object>[]) Declaration public GeneralPropertyComparer(Func<T, object>[] expr) Parameters Type Name Description Func <T, Object >[] expr Methods | Improve this Doc View Source Equals(T, T) Declaration public bool Equals(T left, T right) Parameters Type Name Description T left T right Returns Type Description Boolean | Improve this Doc View Source GetHashCode(T) Declaration public int GetHashCode(T obj) Parameters Type Name Description T obj Returns Type Description Int32 Implements System.Collections.Generic.IEqualityComparer<T> Extension Methods SerializationExtensions.ToXml<T>(T) CollectionsExtensions.SetValue<TKey, T>(TKey, T) CollectionsExtensions.AsEnum<T>(T) DataObjectQueryableExtensions.CompareVariable(Object, FilterOperation, String) Processing.Do<T>(T, Action<IProcess<T>>[]) TypeExtensions.TryConvert<T, TResult>(T, Func<T, TResult>) TypeExtensions.TryConvert<T, TResult>(T, Func<T, TResult>, TResult) TypeExtensions.ChangeType<T>(Object) TypeExtensions.ChangeType(Object, Type) TypeExtensions.InvokeMethod<TRet>(Object, Type[], Expression<Func<TRet>>, BindingFlags) TypeExtensions.InvokeMethod(Object, Type[], Expression<Action>, BindingFlags) TypeExtensions.InvokeMethod<TRet>(Object, Expression<Func<TRet>>, BindingFlags) TypeExtensions.InvokeMethod(Object, Expression<Action>, BindingFlags) SqlBlockExtensions.SetExpression<TTag, TResult>(TTag, Expression<Func<IBlockQueryAdapter, TResult>>) QueryDescriptionExtensions.SetExpression<TTag, TResult>(TTag, Expression<Func<IQueryStructureAdapter, TResult>>)"
  },
  "api/XData.AttachedHandlerType.html": {
    "href": "api/XData.AttachedHandlerType.html",
    "title": "Enum AttachedHandlerType | XData website",
    "keywords": "Enum AttachedHandlerType Attached event types Namespace : XData Assembly : XData.docfx.dll Syntax public enum AttachedHandlerType Fields Name Description OnClear OnClear OnExecute OnExecute OnGetLob OnGetLob OnGetLobSize OnGetLobSize OnGetXml OnGetXml OnLock OnLock OnRefresh OnRefresh OnSetLob OnSetLob OnSetXml OnSetXml OnSubmit OnSubmit OnSubmitObject OnSubmitObject OnSubmitQuery OnSubmitQuery Extension Methods SerializationExtensions.ToXml<AttachedHandlerType>() CollectionsExtensions.SetValue<AttachedHandlerType, T>(T) CollectionsExtensions.AsEnum<AttachedHandlerType>() DataObjectQueryableExtensions.CompareVariable(FilterOperation, String) Processing.Do<AttachedHandlerType>(Action<IProcess<AttachedHandlerType>>[]) TypeExtensions.ChangeType<T>() TypeExtensions.ChangeType(Type) TypeExtensions.InvokeMethod<TRet>(Type[], Expression<Func<TRet>>, BindingFlags) TypeExtensions.InvokeMethod(Type[], Expression<Action>, BindingFlags) TypeExtensions.InvokeMethod<TRet>(Expression<Func<TRet>>, BindingFlags) TypeExtensions.InvokeMethod(Expression<Action>, BindingFlags) TypeExtensions.ConvertTo<T>() TypeExtensions.EqualValue(Enum) SqlBlockExtensions.SetExpression<AttachedHandlerType, TResult>(Expression<Func<IBlockQueryAdapter, TResult>>) QueryDescriptionExtensions.SetExpression<AttachedHandlerType, TResult>(Expression<Func<IQueryStructureAdapter, TResult>>)"
  },
  "api/XData.html": {
    "href": "api/XData.html",
    "title": "Namespace XData | XData website",
    "keywords": "Namespace XData Classes Actions Standard actions used by security AttachedHandler<T> Data object level attached handler wrapper DataObjectExtensions IDataObject extension functions Log Log helper ParameterIndexer SQL procedure call out parameters indexer RepositoryAttachedHandler<T> Repository level attached handler wrapper RepositoryIndexer Data object links (parents and childs) indexer ResultSetIndexer SQL procedure call out result sets indexer RuntimeAssemblyLoader SerializationExtensions Serialization extensions SerializedData Serialized data SerializedValue Serialized data value Variable Data object repository variable VariableIndexer Data object variables indexer Work Work set helper class XDataLogic<T> XDataManager Data manager Defines user session context across (possible) multiple data sources XDataPureLinqMethodAttribute Attribute to mark XData pure LINQ methods with no realization Interfaces IDataEngine XData engine interface IDataLogic<T> Data logic interface IDataObject Data object interface IDataOptions XData options interface IDataQuery Read only data source basic interface IDataQuery<T> Specialized read only data source interface IDataScope XData operational scope IRepository Data repository (data object collection) basic interface IRepository<T> Data repository (data object collection) type specific interface ISqlObject SQL (sub)query part interface IWorkScope<T> Work set export/apply child object structure descriptor interface IWorkSet Basic work set interface IWorkSet<T> Work set interface Enums ApplyFlag Apply detached object properties flags AttachedHandlerType Attached event types Combination Filter combination logical composition CredentialsType Database credentials type DataActionType Action type DataCombination Data set combination modes DataExpressionType Expression type DataGrouping Data aggregation function DataObjectState Data object instance state DataPropertyFlag Data object property flags DataSourceType Data source type DataStructureFlag Data object structure flags DataSubmitFlag Data submit options DataTriggerFlag Data trigger result flags DataVersion Version of data DateDiffKind Date difference kind DefaultFeature Default value features DefaultType Default value type DialectOptions SQL dialect options ExistsOperation Exists subquery operation FilterConstantType ConstantFilter value mode FilterNullable Filter null value assignment mode FilterOperation Filter operation FilterType Filter type MessageType Log message type ProcedureType SQL stored procedure type WithRecursiveType Common-Table-Expression (WITH) Subquery type WorkState Work set state Delegates Calculate<T> XData LINQ-styled SQL expression delegate type ClearAttachedHandler Clear attached handler delegate CurrentObjectChanged<T> Object assigned as current event delegate type CurrentObjectChanging<T> Assigning object as current event delegate type CustomLogic<T> Custom server logic delegate type CustomMapping<T> Custom mapping delegate type ExecuteAttachedHandler<T> Execute attached handler delegate GetLobAttachedHandler Get Lob attached handler delegate GetLobSizeAttachedHandler Get Lob size attached handler delegate GetXmlAttachedHandler Get Xml attached handler delegate InitObject<T> Object instance initialization delegate type InitRepository<T> Repository initialization delegate type InvalidateObject<T> Refresh one object event delegate type InvalidateRepository<T> Refresh repository event delegate type LockAttachedHandler<T> Lock object attached handler delegate Mapping<TFrom, T> Mapping logic delegate type RefreshAttachedHandler<T> Refresh attached handler delegate RepositoryTrigger<T> RepositoryTrigger logic delegate type SetLobAttachedHandler Set Lob attached handler delegate SetXmlAttachedHandler Set Xml attached handler delegate SubmitAttachedHandler<T> Submit attached handler delegate SubmitObjectAttachedHandler<T> Submit object attached handler delegate SubmitQueryAttachedHandler<T> Lock object attached handler delegate Trigger<T> Trigger logic delegate type"
  },
  "api/XData.XDataPureLinqMethodAttribute.html": {
    "href": "api/XData.XDataPureLinqMethodAttribute.html",
    "title": "Class XDataPureLinqMethodAttribute | XData website",
    "keywords": "Class XDataPureLinqMethodAttribute Attribute to mark XData pure LINQ methods with no realization Inheritance Object Attribute XDataPureLinqMethodAttribute Inherited Members Attribute.Equals(Object) Attribute.GetCustomAttribute(Assembly, Type) Attribute.GetCustomAttribute(Assembly, Type, Boolean) Attribute.GetCustomAttribute(MemberInfo, Type) Attribute.GetCustomAttribute(MemberInfo, Type, Boolean) Attribute.GetCustomAttribute(Module, Type) Attribute.GetCustomAttribute(Module, Type, Boolean) Attribute.GetCustomAttribute(ParameterInfo, Type) Attribute.GetCustomAttribute(ParameterInfo, Type, Boolean) Attribute.GetCustomAttributes(Assembly) Attribute.GetCustomAttributes(Assembly, Boolean) Attribute.GetCustomAttributes(Assembly, Type) Attribute.GetCustomAttributes(Assembly, Type, Boolean) Attribute.GetCustomAttributes(MemberInfo) Attribute.GetCustomAttributes(MemberInfo, Boolean) Attribute.GetCustomAttributes(MemberInfo, Type) Attribute.GetCustomAttributes(MemberInfo, Type, Boolean) Attribute.GetCustomAttributes(Module) Attribute.GetCustomAttributes(Module, Boolean) Attribute.GetCustomAttributes(Module, Type) Attribute.GetCustomAttributes(Module, Type, Boolean) Attribute.GetCustomAttributes(ParameterInfo) Attribute.GetCustomAttributes(ParameterInfo, Boolean) Attribute.GetCustomAttributes(ParameterInfo, Type) Attribute.GetCustomAttributes(ParameterInfo, Type, Boolean) Attribute.GetHashCode() Attribute.IsDefaultAttribute() Attribute.IsDefined(Assembly, Type) Attribute.IsDefined(Assembly, Type, Boolean) Attribute.IsDefined(MemberInfo, Type) Attribute.IsDefined(MemberInfo, Type, Boolean) Attribute.IsDefined(Module, Type) Attribute.IsDefined(Module, Type, Boolean) Attribute.IsDefined(ParameterInfo, Type) Attribute.IsDefined(ParameterInfo, Type, Boolean) Attribute.Match(Object) Attribute.TypeId Object.Equals(Object, Object) Object.GetType() Object.MemberwiseClone() Object.ReferenceEquals(Object, Object) Object.ToString() Namespace : XData Assembly : XData.docfx.dll Syntax [AttributeUsage(AttributeTargets.Method)] public class XDataPureLinqMethodAttribute : Attribute Extension Methods SerializationExtensions.ToXml<T>(T) CollectionsExtensions.SetValue<TKey, T>(TKey, T) CollectionsExtensions.AsEnum<T>(T) DataObjectQueryableExtensions.CompareVariable(Object, FilterOperation, String) Processing.Do<T>(T, Action<IProcess<T>>[]) TypeExtensions.TryConvert<T, TResult>(T, Func<T, TResult>) TypeExtensions.TryConvert<T, TResult>(T, Func<T, TResult>, TResult) TypeExtensions.ChangeType<T>(Object) TypeExtensions.ChangeType(Object, Type) TypeExtensions.InvokeMethod<TRet>(Object, Type[], Expression<Func<TRet>>, BindingFlags) TypeExtensions.InvokeMethod(Object, Type[], Expression<Action>, BindingFlags) TypeExtensions.InvokeMethod<TRet>(Object, Expression<Func<TRet>>, BindingFlags) TypeExtensions.InvokeMethod(Object, Expression<Action>, BindingFlags) SqlBlockExtensions.SetExpression<TTag, TResult>(TTag, Expression<Func<IBlockQueryAdapter, TResult>>) QueryDescriptionExtensions.SetExpression<TTag, TResult>(TTag, Expression<Func<IQueryStructureAdapter, TResult>>)"
  },
  "api/XData.XDataManager.html": {
    "href": "api/XData.XDataManager.html",
    "title": "Class XDataManager | XData website",
    "keywords": "Class XDataManager Data manager Defines user session context across (possible) multiple data sources Inheritance Object XDataManager Inherited Members Object.Equals(Object) Object.Equals(Object, Object) Object.GetHashCode() Object.GetType() Object.MemberwiseClone() Object.ReferenceEquals(Object, Object) Object.ToString() Namespace : XData Assembly : XData.docfx.dll Syntax public static class XDataManager Fields | Improve this Doc View Source Resources Declaration public static dynamic Resources Field Value Type Description Object Properties | Improve this Doc View Source Configuration Declaration public static IConfiguration Configuration { get; } Property Value Type Description IConfiguration | Improve this Doc View Source Credentials Declaration public static Dictionary<string, Dictionary<CredentialsType, string>> Credentials { get; set; } Property Value Type Description Dictionary < String , Dictionary < CredentialsType , String >> Methods | Improve this Doc View Source AddXData(IServiceCollection, Func<IDataOptions, IDataOptions>) XData initialization Declaration public static IServiceCollection AddXData(this IServiceCollection services, Func<IDataOptions, IDataOptions> options = null) Parameters Type Name Description IServiceCollection services Services collection Func < IDataOptions , IDataOptions > options XData engine options Returns Type Description IServiceCollection XData engine interface | Improve this Doc View Source GetConcurrencyErrorId(String) Returns concurrency error id for context Declaration public static int GetConcurrencyErrorId(string context) Parameters Type Name Description String context Context name Returns Type Description Int32 Concurrency error id | Improve this Doc View Source UseXData(IApplicationBuilder) XData initialization Declaration public static IApplicationBuilder UseXData(this IApplicationBuilder builder) Parameters Type Name Description IApplicationBuilder builder Application builder interface Returns Type Description IApplicationBuilder Application builder interface | Improve this Doc View Source UseXData(IServiceProvider) XData initialization Declaration public static IServiceProvider UseXData(this IServiceProvider provider) Parameters Type Name Description IServiceProvider provider Service provider interface Returns Type Description IServiceProvider Service provider interface"
  },
  "api/XData.Mapping.DataTableAttribute.html": {
    "href": "api/XData.Mapping.DataTableAttribute.html",
    "title": "Class DataTableAttribute | XData website",
    "keywords": "Class DataTableAttribute Data object table attribute Inheritance Object Attribute DataSourceAttribute DataTableAttribute Inherited Members Attribute.Equals(Object) Attribute.GetCustomAttribute(Assembly, Type) Attribute.GetCustomAttribute(Assembly, Type, Boolean) Attribute.GetCustomAttribute(MemberInfo, Type) Attribute.GetCustomAttribute(MemberInfo, Type, Boolean) Attribute.GetCustomAttribute(Module, Type) Attribute.GetCustomAttribute(Module, Type, Boolean) Attribute.GetCustomAttribute(ParameterInfo, Type) Attribute.GetCustomAttribute(ParameterInfo, Type, Boolean) Attribute.GetCustomAttributes(Assembly) Attribute.GetCustomAttributes(Assembly, Boolean) Attribute.GetCustomAttributes(Assembly, Type) Attribute.GetCustomAttributes(Assembly, Type, Boolean) Attribute.GetCustomAttributes(MemberInfo) Attribute.GetCustomAttributes(MemberInfo, Boolean) Attribute.GetCustomAttributes(MemberInfo, Type) Attribute.GetCustomAttributes(MemberInfo, Type, Boolean) Attribute.GetCustomAttributes(Module) Attribute.GetCustomAttributes(Module, Boolean) Attribute.GetCustomAttributes(Module, Type) Attribute.GetCustomAttributes(Module, Type, Boolean) Attribute.GetCustomAttributes(ParameterInfo) Attribute.GetCustomAttributes(ParameterInfo, Boolean) Attribute.GetCustomAttributes(ParameterInfo, Type) Attribute.GetCustomAttributes(ParameterInfo, Type, Boolean) Attribute.GetHashCode() Attribute.IsDefaultAttribute() Attribute.IsDefined(Assembly, Type) Attribute.IsDefined(Assembly, Type, Boolean) Attribute.IsDefined(MemberInfo, Type) Attribute.IsDefined(MemberInfo, Type, Boolean) Attribute.IsDefined(Module, Type) Attribute.IsDefined(Module, Type, Boolean) Attribute.IsDefined(ParameterInfo, Type) Attribute.IsDefined(ParameterInfo, Type, Boolean) Attribute.Match(Object) Object.Equals(Object, Object) Object.GetType() Object.MemberwiseClone() Object.ReferenceEquals(Object, Object) Object.ToString() Namespace : XData.Mapping Assembly : XData.docfx.dll Syntax [AttributeUsage(AttributeTargets.Class, AllowMultiple = true)] public sealed class DataTableAttribute : DataSourceAttribute Constructors | Improve this Doc View Source DataTableAttribute(String, String) Data object table attribute Declaration public DataTableAttribute(string name, string alias) Parameters Type Name Description String name Table name String alias Table alias Exceptions Type Condition ArgumentException Table alias cannot be null or empty string XDataRuntimeException Data table alias is null or empty. Properties | Improve this Doc View Source Alias Table alias Declaration public override string Alias { get; protected set; } Property Value Type Description String Overrides DataSourceAttribute.Alias | Improve this Doc View Source Name Table name Declaration public string Name { get; } Property Value Type Description String | Improve this Doc View Source Parent Parent table alias Declaration public string Parent { get; set; } Property Value Type Description String Remarks Tables supporting updates mast be organized in update hierarchy linked by ParentAlias. Root table of update hierarchy is the data object base source (see BaseSource ) See Also Alias | Improve this Doc View Source Type Data source type Declaration public override DataSourceType Type { get; } Property Value Type Description DataSourceType Table Overrides DataSourceAttribute.Type | Improve this Doc View Source TypeId When implemented in a derived class, gets a unique identifier for this Attribute . Declaration public override object TypeId { get; } Property Value Type Description Object An Object that is a unique identifier for the attribute. Overrides Attribute.TypeId Extension Methods SerializationExtensions.ToXml<T>(T) CollectionsExtensions.SetValue<TKey, T>(TKey, T) CollectionsExtensions.AsEnum<T>(T) DataObjectQueryableExtensions.CompareVariable(Object, FilterOperation, String) Processing.Do<T>(T, Action<IProcess<T>>[]) TypeExtensions.TryConvert<T, TResult>(T, Func<T, TResult>) TypeExtensions.TryConvert<T, TResult>(T, Func<T, TResult>, TResult) TypeExtensions.ChangeType<T>(Object) TypeExtensions.ChangeType(Object, Type) TypeExtensions.InvokeMethod<TRet>(Object, Type[], Expression<Func<TRet>>, BindingFlags) TypeExtensions.InvokeMethod(Object, Type[], Expression<Action>, BindingFlags) TypeExtensions.InvokeMethod<TRet>(Object, Expression<Func<TRet>>, BindingFlags) TypeExtensions.InvokeMethod(Object, Expression<Action>, BindingFlags) SqlBlockExtensions.SetExpression<TTag, TResult>(TTag, Expression<Func<IBlockQueryAdapter, TResult>>) QueryDescriptionExtensions.SetExpression<TTag, TResult>(TTag, Expression<Func<IQueryStructureAdapter, TResult>>)"
  },
  "api/XData.InvalidateRepository-1.html": {
    "href": "api/XData.InvalidateRepository-1.html",
    "title": "Delegate InvalidateRepository<T> | XData website",
    "keywords": "Delegate InvalidateRepository<T> Refresh repository event delegate type Namespace : XData Assembly : XData.docfx.dll Syntax public delegate void InvalidateRepository<T>(IRepository<T> repository) where T : class, IDataObject; Parameters Type Name Description IRepository <T> repository Repository instance Type Parameters Name Description T Object type Extension Methods SerializationExtensions.ToXml<T>(T) CollectionsExtensions.SetValue<TKey, T>(TKey, T) CollectionsExtensions.AsEnum<T>(T) DataObjectQueryableExtensions.CompareVariable(Object, FilterOperation, String) Processing.Do<T>(T, Action<IProcess<T>>[]) TypeExtensions.TryConvert<T, TResult>(T, Func<T, TResult>) TypeExtensions.TryConvert<T, TResult>(T, Func<T, TResult>, TResult) TypeExtensions.ChangeType<T>(Object) TypeExtensions.ChangeType(Object, Type) TypeExtensions.InvokeMethod<TRet>(Object, Type[], Expression<Func<TRet>>, BindingFlags) TypeExtensions.InvokeMethod(Object, Type[], Expression<Action>, BindingFlags) TypeExtensions.InvokeMethod<TRet>(Object, Expression<Func<TRet>>, BindingFlags) TypeExtensions.InvokeMethod(Object, Expression<Action>, BindingFlags) SqlBlockExtensions.SetExpression<TTag, TResult>(TTag, Expression<Func<IBlockQueryAdapter, TResult>>) QueryDescriptionExtensions.SetExpression<TTag, TResult>(TTag, Expression<Func<IQueryStructureAdapter, TResult>>) See Also InvalidateRepository OnInvalidate"
  },
  "api/XData.Database.SqlBlock.ISetBlockAdapter.html": {
    "href": "api/XData.Database.SqlBlock.ISetBlockAdapter.html",
    "title": "Interface ISetBlockAdapter | XData website",
    "keywords": "Interface ISetBlockAdapter Set/Insert block query adapter Namespace : XData.Database.SqlBlock Assembly : XData.docfx.dll Syntax public interface ISetBlockAdapter Methods | Improve this Doc View Source Value<TValue>(Expression<Func<ISqlValueAdapter, ISqlValue<TValue>>>) Field mapping Declaration TValue Value<TValue>(Expression<Func<ISqlValueAdapter, ISqlValue<TValue>>> value) Parameters Type Name Description Expression < Func < ISqlValueAdapter , ISqlValue <TValue>>> value Property mapping value Returns Type Description TValue Field value Type Parameters Name Description TValue Field type | Improve this Doc View Source Value<TValue>(String, Expression<Func<ISqlValueAdapter, ISqlValue<TValue>>>) Field mapping Declaration TValue Value<TValue>(string fieldName, Expression<Func<ISqlValueAdapter, ISqlValue<TValue>>> value) Parameters Type Name Description String fieldName Field name Expression < Func < ISqlValueAdapter , ISqlValue <TValue>>> value Property mapping value Returns Type Description TValue Field value Type Parameters Name Description TValue Field type Extension Methods SerializationExtensions.ToXml<T>(T) CollectionsExtensions.SetValue<TKey, T>(TKey, T) CollectionsExtensions.AsEnum<T>(T) DataObjectQueryableExtensions.CompareVariable(Object, FilterOperation, String) Processing.Do<T>(T, Action<IProcess<T>>[]) TypeExtensions.TryConvert<T, TResult>(T, Func<T, TResult>) TypeExtensions.TryConvert<T, TResult>(T, Func<T, TResult>, TResult) TypeExtensions.ChangeType<T>(Object) TypeExtensions.ChangeType(Object, Type) TypeExtensions.InvokeMethod<TRet>(Object, Type[], Expression<Func<TRet>>, BindingFlags) TypeExtensions.InvokeMethod(Object, Type[], Expression<Action>, BindingFlags) TypeExtensions.InvokeMethod<TRet>(Object, Expression<Func<TRet>>, BindingFlags) TypeExtensions.InvokeMethod(Object, Expression<Action>, BindingFlags) SqlBlockExtensions.SetExpression<TTag, TResult>(TTag, Expression<Func<IBlockQueryAdapter, TResult>>) QueryDescriptionExtensions.SetExpression<TTag, TResult>(TTag, Expression<Func<IQueryStructureAdapter, TResult>>)"
  },
  "api/XData.Database.SqlBlock.IBlockQueryDescription.html": {
    "href": "api/XData.Database.SqlBlock.IBlockQueryDescription.html",
    "title": "Interface IBlockQueryDescription | XData website",
    "keywords": "Interface IBlockQueryDescription Base SQL block query description interface Namespace : XData.Database.SqlBlock Assembly : XData.docfx.dll Syntax public interface IBlockQueryDescription Extension Methods SerializationExtensions.ToXml<T>(T) CollectionsExtensions.SetValue<TKey, T>(TKey, T) CollectionsExtensions.AsEnum<T>(T) DataObjectQueryableExtensions.CompareVariable(Object, FilterOperation, String) Processing.Do<T>(T, Action<IProcess<T>>[]) TypeExtensions.TryConvert<T, TResult>(T, Func<T, TResult>) TypeExtensions.TryConvert<T, TResult>(T, Func<T, TResult>, TResult) TypeExtensions.ChangeType<T>(Object) TypeExtensions.ChangeType(Object, Type) TypeExtensions.InvokeMethod<TRet>(Object, Type[], Expression<Func<TRet>>, BindingFlags) TypeExtensions.InvokeMethod(Object, Type[], Expression<Action>, BindingFlags) TypeExtensions.InvokeMethod<TRet>(Object, Expression<Func<TRet>>, BindingFlags) TypeExtensions.InvokeMethod(Object, Expression<Action>, BindingFlags) SqlBlockExtensions.SetExpression<TTag, TResult>(TTag, Expression<Func<IBlockQueryAdapter, TResult>>) QueryDescriptionExtensions.SetExpression<TTag, TResult>(TTag, Expression<Func<IQueryStructureAdapter, TResult>>)"
  },
  "tips/container.html": {
    "href": "tips/container.html",
    "title": "Using DI container | XData website",
    "keywords": "Using DI container XData can be effectively used with any DI containers You prefer. When using the .Net Standard 2.0 version of XData, the .Net Core Dependency Abstraction technology is applied internally and can be implemented with any DI container. The IDataEngine interface is injected as dependency by calling AddXData method during ConfigureServices method of Startup module. Any trigger logic modules can be registered as singleton services in DI container as well. public void ConfigureServices(IServiceCollection services) { services.AddXData(x => x.AddDialect(Constants.DialectName, XDataAdapter.PostgreSql.Dialect) .AddAdapter(Constants.AdapterName, XDataAdapter.PostgreSql.Adapter) .AddContext(Constants.TestDb, Constants.DialectName, Constants.AdapterName, testDb, true)); ... services.AddSingleton<IDataLogic<Invoice>, InvoiceLogic>(); ... } Note The registration of logic modules must be performed using the IDataLogic<T> interface Tip The number of logic modules for each data object is not limited, but it must be kipped in mind that the order in which various handlers are called is not guaranteed If any logic module are injected through DI container UseXData method required to call during Configure method of Startup module. public void Configure(IApplicationBuilder app, IHostingEnvironment env) { ... app.UseXData(); ... } When using .Net 4.0 XData version IDataEngine interface can be obtained from container similarly. In this case, you must use an additional NuGet package XData net 4.0 Inversion of Control container package . IDataEngine must to be registered as singleton with XDataManager.InitXData method call. If any logic module are injected through DI container UseXDataDependencies extension method similar to previously reviewed before version for .Net Standard 2.0 but assigned to IDependencyResolver interface is required to call. Here is an example using Autofac but you can use any DI container implementation analogically... var builder = new ContainerBuilder(); builder.Register<IDataLogic<Invoice>>(x => new InvoiceLogic()); builder.Register(x => XDataManager.InitXData(z => z.UseConfiguration(ConfigurationManager .OpenExeConfiguration(ConfigurationUserLevel.None)))); var container = builder.Build(); using (var resolver = new AutofacApiDependencyResolver(container).UseXDataDependencies()) { using (var dataEngine = (IDataEngine)resolver.GetService(typeof(IDataEngine))) { ... Any IoC container with IDependencyResolver interface implementation is supported. If the selected container DI implementation does not support this interface, it is simple and can easily be implemented independently."
  },
  "tips/cache_lifetime.html": {
    "href": "tips/cache_lifetime.html",
    "title": "Set cache lifetime limit | XData website",
    "keywords": "Set cache lifetime limit In Web applications, one of the problems with long-lived objects is that when you close a page or browser, the server may not receive information that you need to clear certain objects. A typical solution is to set the maximum lifetime of cached information. In the case of XData, such long-lived objects can be the IDataScope data layer and Unit of Work container IWorkSet<T> . If XData is initialized, the code uses the SetLifeTmeLimit modifier when calling the AddXData method. If XData is initialized, the lifetime attribute must be specified in the xdata section in the configuration file and the value of the maximum lifetime of the cached information in minutes must be specified. Warning To work with XData version .Net 4.0 additional package XData Cache package must be used (required full Net 4.0 Framework version). Net Standard 2.0 version does not require additional packages."
  },
  "tips/attached.html": {
    "href": "tips/attached.html",
    "title": "Virtual data and attached handlers | XData website",
    "keywords": "Virtual data and attached handlers You can use XData as database mock engine. XData has feature to replace database interactions with attached handlers call. Virtual objects is attached to repository using Attach method of IRepository<T> interface. To detach virtual objects used Detach method. Multiple virtual entities can be attached to repository as new objects using AttachNewObjects method. Tip This method ( AttachNewObjects ) can be used to add multiple detached objects to real repository. Every virtual entity can override handlers attached to repository with their own realization using parameters of AttachNewObjects method or SetAttachedHandlers method call. To set repository level handlers use special overload of SetAttachedHandlers . To clear attached objects You can use ClearAttachedObjects method. To help wrap handlers to abstract AttachedHandler<T> class and unwrap it back to specialized handlers XData has a wrapper class RepositoryAttachedHandler . Attached handlers can have followed types (see AttachedHandlerType ): OnClear - ( ClearAttachedHandler ) handler called instead of Clear OnExecute - ( ExecuteAttachedHandler<T> ) handler called instead of Execute OnGetLob - ( GetLobAttachedHandler ) handler called instead of requesting LOB data OnGetLobSize - ( GetLobSizeAttachedHandler ) handler called instead of requesting LOB size OnGetXml - ( GetXmlAttachedHandler ) handler called instead of requesting XML data OnLock - ( LockAttachedHandler<T> ) handler called instead of Lock OnRefresh - ( RefreshAttachedHandler<T> ) handler called instead of refreshing data OnSetLob - ( SetLobAttachedHandler ) handler called instead of saving LOB data OnSetXml - ( SetXmlAttachedHandler ) handler called instead of saving XML data OnSubmit - ( SubmitAttachedHandler<T> ) handler called instead of Submit multiple objects OnSubmitObject - ( SubmitObjectAttachedHandler<T> ) handler called instead of submitting single object OnSubmitQuery - ( SubmitQueryAttachedHandler<T> ) handler called instead of submitting query generation"
  },
  "tips/async.html": {
    "href": "tips/async.html",
    "title": "Asynchronous wrapped operations | XData website",
    "keywords": "Asynchronous wrapped operations Warning Only .Net Core Standard 2.0 version supported asynchronous wrapped operations To access data with XData inside async methods it's handy to use asynchronous wrappers declared inside XData.Async extension methods as illustrated in followed example: using XData.Async; ... IDataEngine _dataEngine; ... internal async Task<DocType[]> TestArrayAsync(CancellationToken cancellationToken) { using (var dataScope = dataEngine.NewDataScope(\"TEST_POSTGRE_NPG\", cancellationToken)) { return await dataScope.GetRepository<DocType>().ToArrayAsync(); } } Using asynchronously disposable objects requires an additional package XData net standard 2.0 Asynchronous Disposable support package and supporting of .Net Standard 2.1 specification To get asynchronous disposable version of... IDataScope use NewDataScopeAsync or GetDataScopeAsync extension methods of IDataEngine . ITransaction use BeginTransactionAsync extension methods of IDataScope . using XData.Async; using XData.AsyncDisposable; ... IDataEngine _dataEngine; ... internal async Task<DocType[]> TestArrayAsync(CancellationToken cancellationToken) { await using var dataScope = _dataEngine.NewDataScopeAsync(\"TEST_POSTGRE_NPG\", cancellationToken); return await dataScope.GetRepository<DocType>().ToArrayAsync(); }"
  },
  "tips/add_filters.html": {
    "href": "tips/add_filters.html",
    "title": "Reuse mapping in dynamic query | XData website",
    "keywords": "Reuse mapping in dynamic query Already declared mappings can be reused in dynamic query construction with generic GetStructure method overload. See the example below to understand how it works: using (var dataScope = DataEngine.NewDataScope()) { var user = dataScope.GetRepository<User>().SingleOrDefault(x => x.UserId.ToString() == userId); if (user == null) throw new Exception(\"User not found!\"); // prepare enum values expression array to *Case* expression based on AppType enum var enumValues = typeof(AppType).GetEnumKeyValuePairs() .Select(i => i.Key.SetExpression(x => i.Value)) .ToArray(); // reuse *UserRole* mapping adding filter by *user_id* column and redefine select output var roleClaims = XDataMapping.GetStructure<UserRole>().AddFilters(\"UR\", x => x.ConstFilter(\"FilterByUserId\", \"user_id\", userId.ToString())) .Column(\"UserId\", x => x.Field<Guid>(\"UR\", string.Empty)) .Select(x => new UserClaim { // set negative id to preserve key uniqueness after appling *Union* operation using expression field Id = x.Expr(\"id\", z => -1 * z.Field<long>(\"R\", \"role_id\"), DbType.Int64), Type = x.Expr(\"role\", z => \"role\", DbType.String), // construct role name based by *app_type* enum field and role name using SQL *Case* expression Value = x.Expr(\"val\", z => z.Case(y => y.Field<long>(\"R\", \"app_type\"), y => \"\", enumValues) + \".\" + x.Field<string>(\"R\", \"role\"), DbType.String) }).AsQuery(dataScope); user.Applications = apps.SetFilterValue(x => UserId, userId).ToArray(); user.Roles = dataScope.GetRepository<UserRole>().SetFilterValue(x => UserId, userId).ToArray(); // Combine simple claims and synthetic role claims user.Claims = dataScope.GetRepository<UserClaim>() .SetFilterValue(x => UserId, userId) .Union(roleClaims).ToArray(); return user; }"
  },
  "quick_start/inheritance/alt_hierarchy.html": {
    "href": "quick_start/inheritance/alt_hierarchy.html",
    "title": "Using alternative hierarchy for mapping | XData website",
    "keywords": "Using alternative hierarchy for mapping 1) If you add another financial document, it will be convenient to isolate the description of the subquery to calculate the amount of the document in a separate intermediate class. * Once again, it is necessary to recall that the example is synthetic and is intended only to explain the topic of the lesson on very simple concepts. Believe me, when mapping becomes so large, when this technique becomes effective, the idea sinks in detail. And perhaps specifically this intermediate class could also be distinguished in the main hierarchy of classes, but for training purposes we omit this... using System.Linq.Expressions; using XData; using XData.Mapping.Dynamic; namespace <..Your namespace..>.Models { public class FinanceDoc : ISqlObject { public decimal Amount {get; set;} private static Expression<CustomMapping<FinanceDoc>> _ = () => XDataMapping.UseMapping<FinanceDoc, Doc>() .Subquery<DocSpecAmount>(\"A\", x => x.GetProperty(\"Amount\"), DataGrouping.Sum, x => x.SubqueryLink(\"DocId\")) .ReadOnlyProperty(x => x.Amount, x => x.Expr<decimal?>(null, DataExpressionType.SubQuery, \"A\", DbType.Decimal, z => z.Size(17, 5))) .Map(); } } 2) And rewrite mapping for Invoice using System.Linq.Expressions; using XData; using XData.Mapping.Dynamic; namespace <..Your namespace..>.Models { public partial class Invoice : Doc { private static Expression<CustomMapping<Invoice>> _ = () => XDataMapping.UseMapping<Invoice, FinanceDoc>() .Map(); } } 3) Note that we used another overload of the XDataMapping.UseMapping method and despite the fact that the main inheritance hierarchy remains as convenient for the application, the mapping will be built taking into account an alternative hierarchy."
  },
  "quick_start/calculated/sql_expr.html": {
    "href": "quick_start/calculated/sql_expr.html",
    "title": "Calculate using SQL expressions mapping | XData website",
    "keywords": "Calculate using SQL expressions mapping XData supports several mapping methods for SQL expressions: mapping to one field subquery result , to LINQ-style expression mapped to SQL, to SQL plain text . Consider each of these methods and remove their advantages in various situations... Here we will consider options when a field value can be obtained using SQL language tools. We will consider the option when we need some algorithmic logic to calculate the field value in the next part of the lesson... Calculate using subquery SQL expressions Yes This method is suitable if the data for the calculation can be obtained using a subquery. No It is too complicated for calculations based on scalar functions, including those built into the DBMS (consider other methods from this section). No It does not work if a subquery returns more than one field or more than one row (consider using an inner view ). No It does not work for table valued functions (consider using an table valued function ). We used this method several times earlier in previous lessons. To calculate a field value based on a subquery: 1) Add a read-only property to the object public string ExecName => this.GetProperty(x => x.ExecName); 2) Describe the subquery, while we can describe the subquery in a separate class and then we can also use the described subquery in another mapping using Subquery method... //subquery define public class DocPropertyValue : ISqlObject { [UsedImplicitly] private static Expression<CustomMapping<DocPropertyValue>> _ = () => XDataMapping.CustomMapping<DocPropertyValue>() .DataTable(\"public.t_param\", \"P\", x => x.ConstFilter(\"ParamCode\", \"param_code\", FilterConstantType.Variable, \"ParamCode\")) .DataTable(\"bids.t_doc_param\", \"V\", x => x.Link(\"P\", \"param_id\").SetOperation(FilterOperation.OuterJoin), x => x.ConstFilter(\"ParamActual\", \"version_state\", VersionState.Actual)) .Column(\"DocId\", x => x.Field<long>(\"V\", string.Empty, z => z.Hidden())) .Column(\"ParamValue\", x => x.Field<string>(\"V\", string.Empty, z => z.Hidden())) .Map().SetBaseTable(\"P\"); } ... //define subquery .Subquery<DocPropertyValue>(\"EN\", x => x.GetProperty(\"ParamValue\"), DataGrouping.None, new[] { \"ParamCode\".SetVar(\"EXEC_FIO\") }, x => x.SubqueryLink(\"DocId\")) ...or describe it directly in the mapping of the main data object . //define subquery .Subquery(\"EN\", XDataMapping.GetStructure(\"P\") .DataTable(\"public.t_param\", \"P\", x => x.ConstFilter(\"ParamCode\", \"param_code\", FilterConstantType.Variable, \"EXEC_FIO\")) .DataTable(\"bids.t_doc_param\", \"V\", x => x.Link(\"P\", \"param_id\").SetOperation(FilterOperation.OuterJoin), x => x.ConstFilter(\"ParamActual\", \"version_state\", VersionState.Actual)) .Column(\"DocId\", x => x.Field<long>(\"V\", string.Empty, z => z.Hidden())) .Map(x => { ParamValue = x.Field<string>(\"V\", string.Empty) }), \"ParamValue\", DataGrouping.None, x => x.SubqueryLink(\"DocId\")) 3) Describe a property using a subquery described previously. .ReadOnlyProperty(x => x.ExecName, x => x.Expr<string>(null, DataExpressionType.SubQuery, \"EN\", DbType.String, z => z.Size(1024))) This uses the overload of the Expr method. The first parameter is used to indicate the field name in the resulting query. Note that the table is not used for expressions (more precisely, a virtual data source is used). Since the expression has the name of a property matching in the mapping, we can omit the field name by explicitly specifying null or string.Empty as the value. In this case, the name of the field will be substituted according to the rule used by default ( exec_name ). The second parameter indicates the type of SQL expression description. In this example, we are using DataExpressionType.SubQuery - which means using a subquery expression as the SQL source. Other types of descriptions will be discussed below. The next parameter is the actual text of the expression, and in the case of a subquery, the value of this parameter must be an alias of the subquery. Next is the value type of the expression field (in this example, this is a string). And then comes the parameter - an array of modifiers with the help of which the mapping-expression-field details are specified. The example uses the Size modifier with which we specify the maximum length of the expression string. Other modifiers for expressions can be found here and here . Calculate using LINQ-style SQL expressions Yes This method is suitable if the data for the calculation can be obtained using scalar functions, including those built into the DBMS. Yes It is suitable if the expression is a selection based on the data of the current fetch. No It does not work for table valued functions (consider using an table valued function ). No The method does not allow the use of specific language constructs that are not supported by XData. 1) SQL expression based on scalar function call... ... coalesce(DOC.state, 0) as state ... mapped as... .ReadOnlyProperty(x => x.State, x => x.Expr(null, z => z.SqlFn<Common.DocState>(\"coalesce\", a => a.CastTo<Common.DocState>().Field<int?>(\"DOC\", \"state\"), a => Common.DocState.Absent), DbType.Int32)) Here we use the other overload of the Expr method. The first parameter is the same (field name) The second parameter is a description of the expression. In this example, the SqlFn method is used as the basis for describing the SQL expression, with which you can describe the call of a scalar function built into the DBMS or declared in the database by the developer. The typing parameter of the SqlFn method indicates the type of the result of the expression (in this example, an DocState enum). The first parameter is the name of the SQL function. The rest are the values that will be passed to it as parameters. An interesting point here is to use the CastTo method to cast the type of source information to the resulting type at the time of mapping transformation. The third parameter is the type of the expression field ( int ). 2) SQL expression based on switch case expression... ... case DOC.state when null then null when 1 then null else DOC.version_time end as state_date ... mapped as... .ReadOnlyProperty(x => x.StateDate, x => x.Expr(null, z => z.Case(y => y.Field<int?>(\"DOC\", \"state\"), a => a.Field<DateTime?>(\"DOC\", \"version_time\"), new int?().SetExpression(a => new DateTime?()), new int?(1).SetExpression(a => new DateTime?())), DbType.DateTime)) Here you need to pay attention to the Case method used to describe switch case expression. And especially on the order of parameters. The first parameter is the field / expression used as the option selection key. But the second parameter is the value if the value does not meet any condition. The fact is that there can be several parameters describing the options of values and it is convenient to describe them in the form of an params array. And the value of else is one. The last parameter is a description of the value options. Each variant is described using the SetExpression method and the object is the value of the variant (in the example, there is an empty null value and a constant), and the parameter is the result of switch case expression. Similarly, there are methods to facilitate the description of SQL statements: DateDiff and HasFlag . Their study is recommended for self-study. There are no specifics regarding the options already considered in their use. 3)Interpretation of simple expressions in SQL. All basic (embedded in the csharp language) operations and functions (*) of working with dates and strings are supported. Based on the examples discussed earlier, the following should not cause difficulties in understanding ... .ReadOnlyProperty(x => x.Bids, x => x.Expr(\"bids\", a => a.Field<string>(\"B\", \"app_type\") != null, DbType.Boolean)) .ReadOnlyProperty(x => x.Fio, x => x.Expr(\"Fio\", o => o.Field<string>(\"C\", \"surname\") + \" \" + o.Field<string>(\"C\", \"name\").Substring(0, 1) + \".\" + o.Field<string>(\"C\", \"patronymic\").Substring(0, 1) + \".\", DbType.String)) * - With the exception of string.Format - at the moment, differences in the way text information is formatted in various SQL dialects do not allow interpretation of this function. Maybe in the next versions... Calculate using plain SQL expressions Yes This method is suitable when XData cannot construct an expression, but it can nevertheless be expressed using SQL. Yes We can afford to support one particular dialect of SQL No This method is the \"refuge of last hope\" and it is not recommended to use this method if it is possible to use other methods from this article. This method allows using plain SQL inserts when describing mapping of properties to specific SQL expressions. To do this, when calling the Expr method, DataExpressionType.PlainSql is specified as the second parameter, and plain SQL expression as the third. .ReadOnlyProperty(x => x.RowNum, x => x.Expr<int>(\"RowNum\", DataExpressionType.PlainSql, \"row_number() over (order by o.sort_order, c.surname)\", DbType.Int32)) In difficult cases when you need to assemble an SQL expression from parts, you can use the SqlExpr method which allows you to use a format string and substitution from the names of the fields of query data sources and the values of variables of both ordinary and data object variables (using GetVariable method). .ReadOnlyProperty(x => x.Something, x => x.Expr(null, z => z.SqlExpr<int>(\"{0} something {1} {2}\", a => a.Field<string>(\"C\", \"name\") a => someVariable, a => a.GetVariable<int>(\"VarName\"))"
  },
  "quick_start/calculated/other.html": {
    "href": "quick_start/calculated/other.html",
    "title": "Calculate over data in other properties | XData website",
    "keywords": "Calculate over data in other properties Before considering methods for calculating property values based on complex algorithms. But in fact, most often, enough elementary calculations based on the values of other properties. The fact is that XData only works with properties that are described in mapping, but does not limit us in any way to adding properties to this object. public string FirstName { get; set; } public string LastName { get; set; } public string MiddleName { get; set; } public string Name => $\"{FirstName} {(string.IsNullOrEmpty(MiddleName) ? string.Empty : $\"{MiddleName[0].ToString()}. \")}{LastName}\"; Do not forget about KISS principle ;) and first of all consider this method of calculating the value."
  },
  "quick_start/calculated/logic.html": {
    "href": "quick_start/calculated/logic.html",
    "title": "Calculate using logic module | XData website",
    "keywords": "Calculate using logic module In the most difficult cases, when filling out data, it is necessary to analyze data from external data relative to a particular object using some algorithms. In some DBMSs, for this it is possible to describe calls to external libraries as function calls. A more common solution is post data processing. In this case, after receiving the primary data, an additional pass is made with the filling of additional calculated data. XData has a mechanism for the logic modules of a data object . We came across them when considering the trigger logic of data objects. But to calculate the additional data, another type of logic DataActionType.InitObject is used, it is performed during the object transformation from relational data. Suppose that we have some reporting system. When requesting report parameters, we get their descriptions and default values from the database, but the value of the date / time parameter must be calculated. Since the database does not store ready-made values, but only data for their calculation (for example, the last Sunday 00:00). 1) First of all, we need to add property that are not involved in the mapping to the description of our data object : public partial class ParamDefaultDescription { ... public DateTime? DateVal { get; set; } } 2) When requesting report parameters, we fill in the data object variable with the moment the input arrives at the report generation. We will need these data for calculation. var date = DateTime.Now; var v = new[] {nameof(userLogin).SetVar(userLogin), nameof(date).SetVar(date)}; using (var dataScope = _dataEngine.NewDataScope(Startup.ReportDb)) { return await dataScope.GetRepository<ParamDescription>(v) .Do(x => x.Instance.GetChild(z => z.ParamDefault, variables: v), x => x.Instance.GetChild(z => z.ParamRule, variables: v)) .Where(x => templateName == x.TemplateName && x.IsPublic == true) .ToArrayAsync(); } 3) We describe the logic module of the data object. public class ParamDefaultDescriptionLogic : XDataLogic<ParamDefaultDescription> { [Action(DataActionType.InitObject)] public InitObject<ParamDefaultDescription> InitObject => ((ref ParamDefaultDescription def) => { if (def.Type.HasFlag(ParamDefaultType.Date)) { var d = def; var id = d.Id; using (var list = GetRepository<ParamDefault>(d.GetLayer(), context: d.GetContext())) { var obj = list.SingleOrDefault(x => x.Id == id); if (obj?.ParamDefaultDateType != null) { var date = (DateTime)def.GetRepository().Variables[\"date\"]; def.DateVal = ReportBuilder.GetDate(date, obj.ParamDefaultDateType.Value, obj.ParamDefaultDateAddType, obj.ParamDefaultDateAdd); } } } }); } The data module must be an XDataLogic descendant with the typing of our data object. Inside should be a property of type InitObject typed by our type. And this property should be marked with an Action attribute with the DataActionType.InitObject parameter. Inside the object initialization event handler, there should be logic to fill in the value of our property if necessary."
  },
  "quick_start/asp_net_core/web_api_controller.html": {
    "href": "quick_start/asp_net_core/web_api_controller.html",
    "title": "WebAPI Controller | XData website",
    "keywords": "WebAPI Controller 1) To write a WebAPI controller that serves the model class we wrote earlier, it is recommended to make some base controller class that has the implementation of all the basic actions on the object. This will allow you to reuse this basic logic of it for most typical controllers... using System; using System.Threading.Tasks; using Microsoft.AspNetCore.Mvc; using Microsoft.AspNetCore.Mvc.ModelBinding; using XData; using XData.Async; namespace <..Youre namespace..> { /// <summary> /// Extensions /// </summary> public static class Extensions { /// <summary> /// Fill model state /// </summary> /// <param name=\"exception\"></param> /// <param name=\"modelState\"></param> public static void FillModelState(this Exception exception, ModelStateDictionary modelState) { modelState.AddModelError(\"\", exception.Message); modelState.AddModelError(\"at\", exception.StackTrace); var inner = exception.InnerException; while (inner != null) { modelState.AddModelError(\"innerException\", inner.Message); modelState.AddModelError(\"at\", inner.Message); inner = inner.InnerException; } } } [Route(\"api/[controller]/[action]\")] [ApiController] public class DataObjectController<T> : ControllerBase where T : class, IDataObject, new() { private protected IDataEngine _dataEngine; public DataObjectController(IDataEngine dataEngine) { _dataEngine = dataEngine; } [HttpGet] public virtual async Task<ActionResult<T[]>> All(CancellationToken cancellationToken) { try { using (var dataScope = _dataEngine.NewDataScope(cancellationToken)) { return await dataScope.GetRepository<T>().ToArrayAsync(); } } catch (Exception e) { e.FillModelState(ModelState); throw; } } [HttpDelete] public virtual async Task<ActionResult<bool>> Delete([FromBody] T obj, CancellationToken cancellationToken) { try { using (var dataScope = _dataEngine.NewDataScope(cancellationToken)) { var found = dataScope.GetRepository<T>().Find(obj); if (found == null) return NotFound(); return await found.SetDeleted(true).SubmitAsync(); } } catch (Exception e) { e.FillModelState(ModelState); throw; } } [HttpPut] public virtual async Task<ActionResult<T>> Save([FromBody] T obj, CancellationToken cancellationToken) { try { using (var dataScope = _dataEngine.NewDataScope(cancellationToken)) { return await dataScope.GetRepository<T>() .Apply(obj).SubmitAndReturnAsync(); } } catch (Exception e) { e.FillModelState(ModelState); throw; } } } } 2) The FillModelState helper extension method is used to fill out error information... 3) The base class of the controller receives from the container the implementation of the interface IDataEngine as a constructor parameter and stores it in a private variable. This object is already initialized with the settings specified during the initialization of the XData described earlier in the article about registering a XData. 4) The All method is used to get ALL registered in the database objects served by the controller type. We get the data_scope object using NewDataScope in the default context and call the GetRepository<T> method from it, which returns the IQueriable<T> interface typed by our object type. At the end, we call the asynchronous method wrapper ToArrayAsync to asynchronously return the collection received from the repository. 5) To delete an object, used the Delete method. In addition to the methods discussed above, the Find method is also used which looks for an object in the repository by the values of key fields. It should be noted that there can be several key fields when using several fields as a composite key of a data object. In this case, the key fields of the data object may not coincide with the key fields of the table since the data object may contain several data sources such as tables and subqueries. After the record is successfully found, we mark it as deleted using the SetDeleted method and apply the changes using the asynchronous SubmitAsync method. The SubmitAsync method returns a boolean sign of success of the operation. 6) In order to apply object changes made on the web client side (both creating a new object and changing an existing one), the Save controller method is used. In addition to the methods already familiar to us, the Apply method is used here, which analyzes the key fields of the data object and if they (at least one of the key fields) have empty values or by their combination the object is not found in the database, then the object must be created otherwise a new update will be applied to found by key information object. The SubmitAndReturnAsync method applies changes to the database and returns, if the operation succeeds, the changed (or created) object in asynchronous mode. 7) Based on the base class that we created, we will create a DocStateController controller (in Controllers\\API folder) to work specifically with the DocState class described earlier... using XData; using System.Threading.Tasks; using Microsoft.AspNetCore.Mvc; using <..Youre namespace..>.Models; namespace <..Youre namespace..>.Controllers.API { public class DocStateController : DataObjectController<DocState> { public DocStateController(IDataEngine dataEngine) : base(dataEngine) { } [HttpGet] public async Task<ActionResult<DocState>> Get(long id, CancellationToken cancellationToken) { try { using (var dataScope = _dataEngine.NewDataScope(cancellationToken)) { return await dataScope.GetRepository<DocState>() .SingleOrDefaultAsync(x => x.DocStateId == id); } } catch (Exception e) { e.FillModelState(ModelState); throw; } } } } 8) Here we define the Get method for obtaining data on the primary key, and the new method for us here is the SingleOrDefaultAsync method, which in asynchronous mode returns the object found by the primary key or null value. See documentation about asynchronous extensions , basic methods of manipulating data and serialization into JSON format to get more detailed information..."
  },
  "quick_start/asp_net_core/trigger.html": {
    "href": "quick_start/asp_net_core/trigger.html",
    "title": "Trigger logic | XData website",
    "keywords": "Trigger logic When a task arises of maintaining information that is not directly related to the business logic of the application, for example, an audit task, it is convenient to take out the code leading the tracking of such information and store it separately from the main application code. Moreover, it usually does not require user input. Nevertheless, it is often necessary to conduct an audit. The task given here is somewhat degenerate, but nevertheless it is simple and explains the essence of the approach, which is important for training. In addition, in the course of a closer acquaintance with this mechanism, you will be able to discover not obvious aspects of its use and will be able to evaluate its significance in a new way. 1) Let's start as always with the database... <!--MD5=[5ea577eca533bfca935d04f775d3f167] class t_doc--> t_doc <!--MD5=[4efa0cfa5e1d38a4afda4e219b98680a] class t_doc_state--> t_doc_state <!--MD5=[0d4a222ed2d2d268b8328f05b8f9e363] class t_doc_history--> t_doc_history doc_history_id doc_id doc_state_id changed <!--MD5=[1bc25729a460827afacde8227586a6ce] reverse link t_doc_history to t_doc--> doc_id <!--MD5=[fa5c516205306036950004734ceabedd] link t_doc_state to t_doc_history--> doc_state_id <!--MD5=[3a2c0bfdc661d142f5d70924e5b5c22a] @startuml hide circle skinparam ClassHeaderBackgroundColor lightgray skinparam ClassBorderColor black skinparam ClassBorderThickness 1 skinparam ClassBackgroundColor transparrent skinparam ArrowFontSize 8 skinparam ArrowColor black entity t_doc { } entity t_doc_state { } entity t_doc_history { <&key> doc_history_id - - <&arrow-circle-right> doc_id <&arrow-circle-right> doc_state_id - - <&lock> changed } t_doc -left-{ t_doc_history : doc_id t_doc_state -right-{ t_doc_history : doc_state_id @enduml PlantUML version 1.2020.12(Sat Jun 06 10:54:15 UTC 2020) (GPL source distribution) Java Runtime: Java(TM) SE Runtime Environment JVM: Java HotSpot(TM) 64-Bit Server VM Default Encoding: UTF-8 Language: en Country: US --> 2) We describe the new mapping of DocHistory the and a class of logic. It is recommended to describe the logic and related class mappings in a separate assembly. This will allow loading module as plugin... public partial class DocHistory { public long DocId => this.GetProperty(x => x.DocId); public long DocStateId => this.GetProperty(x => x.DocStateId); public DateTime Changed { get; set; } } public partial class DocHistory : IDataObject { private static Expression<CustomMapping<DocHistory>> _ = () => XDataMapping.CustomMapping<DocHistory>() .DataTable(\"T_DOC_HISTORY\", \"H\") .ReadOnlyProperty(x => x.DocId, x => x.Field<long>(\"H\", string.Empty)) .ReadOnlyProperty(x => x.DocStateId, x => x.Field<long>(\"H\", string.Empty)) .Column(\"DocHistoryId\", x => x.Field<long>(\"H\", string.Empty, z => z.Key())) .Map(x => new DocHistory { Changed = x.Field<DateTime>(\"H\", string.Empty) }).SetBaseTable(\"H\"); } public class InvoiceLogic : XDataLogic<Invoice> { [Action(DataActionType.AfterInsert), Action(DataActionType.AfterUpdate)] public Trigger<Invoice> UpdateHistory => ((ref Invoice invoice, ref DataTriggerFlag flag) => { if (!invoice.CheckState(DataObjectState.New) && !invoice.IsChanged(x => x.DocState)) return true; var rep = invoice.GetRepository(); using (var hist = GetRepository<DocHistory>(rep.Layer, context: rep.Context)) { return hist.Do(x => x.Instance.Reset() .SetFilterValue<DocHistory>(x => x.DocId, invoice.DocId) .SetFilterValue<DocHistory>(x => x.DocStateId, invoice.GetProperty<long>(\"DocStateId\"))) .New(x => x.Changed = DateTime.Now) .Submit(); } }); [Action(DataActionType.BeforeDelete)] public Trigger<Invoice> ClearHistory => ((ref Invoice invoice, ref DataTriggerFlag flag) => { var i = invoice; using (var hist = GetRepository<DocHistory>( i.GetLayer(), context: i.GetContext())) { return hist.Reset().Clear(x => x.DocId == i.DocId)); } }); [Action(DataActionType.BeforeClear)] public RepositoryTrigger<Invoice> ClearHistoryBatch => ((IRepository<Invoice> invoiceRepository, ref DataTriggerFlag flag) => { using (var hist = GetRepository<DocHistory>(invoiceRepository.Layer, context: invoiceRepository.Context)) { return hist.Reset().Clear(x => invoiceRepository.Any(z => x.DocId == z.DocId)); } }); } 3) The type of logic module must be inherited from the XDataLogic<T> class typed by the type of the parent data object ( Invoice ). 4) Inside the logic module, the properties of the delegate type are described which will be called during the processing of entities of the base type ( Invoice ). The moment of the logic call is set using the Action attribute to which DataActionType , the type of handler, is passed as a parameter. In this case, the same handler can be assigned to several actions (this is shown by the example of the UpdateHistory handler). The types of delegates are different for Trigger<T> record-level handlers, which are triggered when changes are applied to the same object and the repository level - RepositoryTrigger<T> , which are triggered by mass actions on repository objects. 5) It should be noted that a different GetRepository method is used here. It takes as parameters the identifier of the layer and the database context in which the base object (and its repository) are located. This allows us to get into the context of making changes to the base object. 6) In addition, the Reset method is used here, which clears the filters assigned to the repository instance and thereby frees us from the influence of its previous use. 7) Our new method will be Clear . It is used to delete all repository objects or objects that satisfy a certain condition specified when this method is called. In addition, you can configure the logic module to call a special handler before or after deleting objects using this method (as demonstrated by the ClearHistoryBatch delegate). Important It is important to understand the difference between database level triggers and these XData level triggers. A database trigger is called during changes made to the records of the table, whereas XData logic module processes the changes in the level of the data object. It must be remembered that a data object can include several database tables on the one hand (the same Invoice object can serve as an example here) and, on the other hand, a part of information regarding other objects can be stored in one table (for example, the T_DOC table will contain data not only related to the Invoice ). And from this point of view, the value of such a mechanism inside the XData can hardly be overestimated! 8) We register our logic module in the IoC container. In this case, we will provide the registration code directly during the initialization of the container, but you can use more complex usage scenarios if necessary. public void ConfigureServices(IServiceCollection services) { ... services.AddSingleton<IDataLogic<Invoice>, InvoiceLogic>(); ... } public void Configure(IApplicationBuilder app, IHostingEnvironment env) { ... app.UseXData(); ... } 9) In order to use the registration of logic modules in the IoC container, you need to call the UseXData method from the service provider. Note Here we are considering the use of XData in ASP .Net Core. Registration of logic modules with the IoC container when .Net 4.0 version used the additional NuGet package XData net 4.0 Inversion of Control container package is required. Tip Note that we use the IDataLogic<T> interface typed by our data object type Invoice as the registration interface in the IoC container"
  },
  "quick_start/asp_net_core/register.html": {
    "href": "quick_start/asp_net_core/register.html",
    "title": "Registration XData | XData website",
    "keywords": "Registration XData 1) Create a ASP.Net Core project 2) Set up the NuGet configuration and place the configuration file in the solution (or project) folder 3) Install the XData NuGet packages : main package and the adapter package (or many of) according to the database you selected 4) Configure the configuration file of your solution in the xml notation (or json or yaml or any you like and .Net Core supported). And add XData initialization in your startup.cs file... services.AddXData(x => x.UseConfiguration( System.Web.Configuration.WebConfigurationManager.OpenWebConfiguration(\"~\"))) Optionally you can define configuration during runtime like that... // You can use something like that class to define constants public static class Constants { // Database context name (any unique name to identify context) public const string TestDb = \"TestDb\"; // Database dialect name (any unique name to identify dialect) public const string DialectName = \"MyDbDialect\"; // Database adapter name (any unique name to identify adapter) public const string AdapterName = \"MyDbAdapter\"; // Connection string configuration path public const string TestDbConnectionString = \"connectionStrings:TestDb\"; } public void ConfigureServices(IServiceCollection services) { ... // Read connection string var testDb = Configuration.GetValue<string>(Constants.TestDbConnectionString, null); // Register XData in container services.AddXData(x => x.AddDialect(Constants.DialectName, XDataAdapter.PostgreSql.Dialect) .AddAdapter(Constants.AdapterName, XDataAdapter.PostgreSql.Adapter) .AddContext(Constants.TestDb, Constants.DialectName, Constants.AdapterName, testDb, true)); ... } Tip You can add multiply dialects, adapters and contexts you need Tip You can share dialects and/or adapters between multiple contexts Warning Only one context can be marked as default. But if no default context defined an initialization error will occur See documentation topic for more details"
  },
  "quick_start/asp_net_core/mapping_two.html": {
    "href": "quick_start/asp_net_core/mapping_two.html",
    "title": "More complex mapping | XData website",
    "keywords": "More complex mapping 1) Now consider a slightly more complex mapping using the directory object as an example. Add a table with a recursive link to ourselves ... <!--MD5=[957235e470c5a75c0bcb7e32f4b6bfa6] class t_catalog--> t_catalog catalog_id code name parent_id <!--MD5=[9e57ba7a659eb57cc2ff8d3e32c5b298] link t_catalog to t_catalog--> parent_id <!--MD5=[09e21257042b0fbf55fdd9699152ae5d] @startuml hide circle skinparam ClassHeaderBackgroundColor lightgray skinparam ClassBorderColor black skinparam ClassBorderThickness 1 skinparam ClassBackgroundColor transparrent skinparam ArrowFontSize 8 skinparam ArrowColor black entity t_catalog { <&key> catalog_id - - <&code> code name <&arrow-circle-right> //parent_id// } t_catalog - -{ t_catalog : parent_id @enduml PlantUML version 1.2020.12(Sat Jun 06 10:54:15 UTC 2020) (GPL source distribution) Java Runtime: Java(TM) SE Runtime Environment JVM: Java HotSpot(TM) 64-Bit Server VM Default Encoding: UTF-8 Language: en Country: US --> 2) Add Model class Catalog.cs in a Models folder... using XData; using XData.Mapping; namespace <..Your namespace..>.Models { public partial class Catalog { public long CatalogId => this.GetProperty(x => x.CatalogId); public string Code { get; set; } public string Name { get; set; } public Link<string, Catalog> Parent { get; set; } } } 3) Here, the type of the property Parent will be new to us. It is used in XData to describe an external reference to a dictionary or other entity. And here is a slightly more specific case - a tree reference to oneself. The description type of such a link is Link<TVal,TSource> and it is typed by the type of value that will be in the Value property of Link and the type of entity to which we refer (in this case, our type - Catalog ). In our case Value of Link is the unique Code of the parent entity. See documentation topic for more details 4) Add class Catalog.xdata.cs in a Models folder and define mapping... using System.Linq.Expressions; using XData; using XData.Mapping.Dynamic; namespace <..Your namespace..>.Models { public partial class Catalog : IDataObject { // ReSharper disable once UnusedMember.Local private static Expression<CustomMapping<Catalog>> _ = () => XDataMapping.CustomMapping<Catalog>() .DataTable(\"T_CATALOG\", \"C\") .DataTable(\"T_CATALOG\", \"P\", x => x.Link(\"C\", \"parent_id\", \"catalog_id\") .SetOperation(FilterOperation.OuterJoin)) .Column(\"ParentId\", x => x.Field<long?>(\"C\", string.Empty)) .ReadOnlyProperty(x => x.CatalogId, x => x.Field<long>(\"C\", string.Empty, z => z.Key(), z => z.Default(DefaultType.AutoIncrement))) .Map(x => new Catalog { Code = x.Field<string>(\"C\", string.Empty), Name = x.Field<string>(\"C\", string.Empty), Parent = x.Link<string, Catalog>(\"P\", \"code\", z => z.OuterFlag(), z => z.LinkProperty((Catalog y) => y.Code), z => z.LinkProperty<Catalog>(y => y.CatalogId, y => y.GetProperty<long?>(\"ParentId\"))) }).SetBaseTable(\"C\"); } } 5) The first mention of the DataTable method is similar to what we have already seen, but the second is more interesting, we describe the same table under a different alias \"P\" and also describe its relationship with the first table. This is indicated by the alias \"C\" as the first parameter of the Link method, the second parameter denotes the field name of the linked table \"C\" and the third field name of the current table (with the \"P\" alias). If the names of the related fields are the same, another overload of this method is used which allows you to specify the field name once. See documentation topic for more details 6) By default, the connection has the operation \"equal\", but in this case we need to link these tables by the outer join join and to indicate this we \"refine\" the link using the SetOperation method and specify the operation FilterOperation.OuterJoin . See documentation topic for more details 7) For now, skip the Column method and return to it later... 8) The next new element for us will be a description of the mapping of the \"Parent\" link field. It is described by the Link<TVal,TSource> method typed as the type of the property in the main description of the object. The first parameter is the data source alias (\"P\") of the field that will be assigned in link Value , the second parameter designates the field that will be assigned in Value . The third parameter contains the lambda-modifiers assigned to the link field ... 9) The first modifier OuterFlag shows that this field is an indicator of whether or not to insert an entry into the table connected by the outer join (when inserting). If value is null inserting to this table (and their child tables in updatable tables hierarchy) will be skipped. When updating to an empty value, it signals the need to delete the record from the table optionally connected and their child tables in updatable tables hierarchy. See documentation topic for more details 10) The rest of the modifiers describe which fields will be copied when assigning the link from the source object. There are few overloads of the LinkProperty method: with one lambda parameter that takes a link type parameter (in our case, the first occurrence). It determines which property of the link object will be copied to Value with no parameters (in our case this does not occur). It determines property of the link object will be copied to Value named the same as link property with one lambda parameter that takes a parameter of the type of the object being edited (in our case this does not occur). It means copying to the specified property from the property of the link object with the same name with two parameters (second occurrence). The first parameter is the copy source, the second is the target... 11) The last parameter needs to be considered especially. It is specified using the GetProperty method with the string parameter \"ParentId\". Note that this coincides with the first parameter of the Column method we skipped. Using this method, a hidden field is described that is necessary only for mapping and not displayed on the properties of the described object. And therefore, the CatalogId property of the source will be copied to a hidden property named \"ParentId\". See documentation topic for more details 12) Web API controller for this object will look like... using XData; using System.Linq; using System.Threading.Tasks; using Microsoft.AspNetCore.Mvc; using <..Youre namespace..>.Models; namespace <..Youre namespace..>.Controllers.API { public class CatalogController : DataObjectController<Catalog> { public CatalogController(IDataEngine dataEngine) : base(dataEngine) { } [HttpGet] public async Task<ActionResult<Catalog>> Get(long id, CancellationToken cancellationToken) { try { using (var dataScope = _dataEngine.NewDataScope(cancellationToken)) { return await dataScope.GetRepository<Catalog>() .SingleOrDefaultAsync(x => x.CatalogId == id); } } catch (Exception e) { e.FillModelState(ModelState); throw; } } [HttpGet] public async Task<ActionResult<Catalog[]>> GetChilds(long id, CancellationToken cancellationToken) { try { using (var dataScope = _dataEngine.NewDataScope(cancellationToken)) { if(id == 0) //return root catalogs return await dataScope.GetRepository<Catalog>() .Where(x => x.GetProperty<object>(\"ParentId\") == null) .ToArrayAsync(); return await dataScope.GetRepository<Catalog>() .Where(x => x.GetProperty<long>(\"ParentId\") == id) .ToArrayAsync(); } } catch (Exception e) { e.FillModelState(ModelState); throw; } } } } Tip An attentive reader will certainly notice that this implementation does not have protection against directory tree loops. This can be done using XData, but this will unnecessarily complicate the example of this lesson."
  },
  "quick_start/asp_net_core/mapping_three.html": {
    "href": "quick_start/asp_net_core/mapping_three.html",
    "title": "Advanced mapping | XData website",
    "keywords": "Advanced mapping 1) Let's write something really complicated! Let's start as usual with the preparation of the database. We already have the tables t_catalog and t_doc_state , we will create the rest and link them as shown in the diagram. The fields deserve special mention: t_doc.generation - guid t_doc_delivery.delivery_type - a short integer (we will store the enam value there) t_doc_scan.scan - binary t_doc_source.source - xml Dictionary t_doc_type must contain at least one entry with code = \"INVOICE\" <!--MD5=[4efa0cfa5e1d38a4afda4e219b98680a] class t_doc_state--> t_doc_state <!--MD5=[bccea5d0c54fc84e4bad16ab69fd73e7] class t_doc_type--> t_doc_type doc_type_id code name <!--MD5=[5ea577eca533bfca935d04f775d3f167] class t_doc--> t_doc doc_id doc_date numb doc_state_id doc_type_id generation changed <!--MD5=[eab5c40043b4b5329be06de2f0271aac] class t_catalog_doc--> t_catalog_doc catalog_id doc_id <!--MD5=[957235e470c5a75c0bcb7e32f4b6bfa6] class t_catalog--> t_catalog <!--MD5=[fd8c5e68644f1f4fc0b14eca97226ae4] class t_doc_delivery--> t_doc_delivery doc_id delivery_type delivery_date <!--MD5=[710d3dc0240fd500b1d510e138be1447] class t_doc_scan--> t_doc_scan doc_id scan <!--MD5=[5937349b424f6b33ad58af94594dfd63] class t_doc_source--> t_doc_source doc_id source <!--MD5=[8feb3003cd59a4822a76af3887dc1c0a] link t_doc_state to t_doc--> doc_state_id <!--MD5=[691dc1cbb8fa0f09f9906b607bf3ccef] reverse link t_doc to t_doc_type--> doc_type_id <!--MD5=[cc073f3f803e6be11274258daf9be266] reverse link t_catalog to t_catalog_doc--> catalog_id <!--MD5=[64363e4c077e3ece99a0e625ba56e6a8] link t_catalog_doc to t_doc--> doc_id <!--MD5=[94de7abaa940d64e718a7c3244926e87] reverse link t_doc_delivery to t_doc--> doc_id <!--MD5=[7c459e52799c0d4d655e72449bb91e72] reverse link t_doc_scan to t_doc--> doc_id <!--MD5=[4aa29f824d631e9db9c0b4ff518403cc] reverse link t_doc_source to t_doc--> doc_id <!--MD5=[e5289b989f20ef9db91ec766c5f49285] @startuml hide circle skinparam ClassHeaderBackgroundColor lightgray skinparam ClassBorderColor black skinparam ClassBorderThickness 1 skinparam ClassBackgroundColor transparrent skinparam ArrowFontSize 8 skinparam ArrowColor black entity t_doc_state { } entity t_doc_type { <&key> doc_type_id - - <&code> code name } entity t_doc { <&key> doc_id - - doc_date numb <&arrow-circle-right> doc_state_id <&arrow-circle-right> doc_type_id - - <&tag> generation <&clock> changed } t_doc_state -right-{ t_doc : doc_state_id t_doc_type -left-{ t_doc : doc_type_id entity t_catalog_doc { <&key> <&arrow-circle-right> catalog_id <&key> <&arrow-circle-right> doc_id } t_catalog_doc -up-{ t_catalog : catalog_id t_catalog_doc - -{ t_doc : doc_id entity t_doc_delivery { <&key> <&arrow-circle-right> doc_id - - delivery_type delivery_date } t_doc_delivery }o- - t_doc : doc_id entity t_doc_scan { <&key> <&arrow-circle-right> doc_id - - <&map> scan } t_doc_scan }o- - t_doc : doc_id entity t_doc_source { <&key> <&arrow-circle-right> doc_id - - <&document> source } t_doc_source }o- - t_doc : doc_id @enduml PlantUML version 1.2020.12(Sat Jun 06 10:54:15 UTC 2020) (GPL source distribution) Java Runtime: Java(TM) SE Runtime Environment JVM: Java HotSpot(TM) 64-Bit Server VM Default Encoding: UTF-8 Language: en Country: US --> 2) Add Model class Invoice.cs in a Models folder... public enum DeliveryTypeEnum { [Display(Description = \"PickUp\")] PickUp, [Display(Description = \"Courier\")] Courier, [Display(Description = \"Mail\")] Mail } public partial class Invoice { public long DocId => this.GetProperty(x => x.DocId); public string DocStateCode => this.GetProperty(x => x.DocStateCode); public Link<string, DocState> DocState { get; set; } public long DocCatalogId { get; set; } public string Numb { get; set; } public DateTime? DocDate { get; set; } public Guid Generation => this.GetProperty(x => x.Generation); public DateTime Changed => this.GetProperty(x => x.Changed); public Lob Scan { get; set; } public Xml Source { get; set; } public DeliveryTypeEnum DeliveryType { get; set; } public DateTime DeliveryDate { get; set; } } 3) Add class Invoice.xdata.cs in a Models folder and define mapping... public partial class Invoice: IDataObject { private static Expression<CustomMapping<Invoice>> _ = ( () => XDataMapping.CustomMapping<Invoice>() .DataTable(\"T_DOC\", \"D\", x => x.DictFilter(\"T_DOC_TYPE\", \"doc_type_id\", \"code\", \"INVOICE\")) .DataTable(\"T_DOC_STATE\", \"S\", x => x.Link(\"D\", \"doc_state_id\")) .DataTable(\"T_DOC_CATALOG\", \"DC\", \"D\", x => x.Link(\"D\", \"doc_id\")) .DataTable(\"T_DOC_SCAN\", \"SC\", \"D\", x => x.Link(\"D\", \"doc_id\") .SetOperation(FilterOperation.OuterJoin)) .DataTable(\"T_DOC_SOURCE\", \"SR\", \"D\", x => x.Link(\"D\", \"doc_id\") .SetOperation(FilterOperation.OuterJoin)) .DataTable(\"T_DOC_DELIVERY\", \"DD\", \"D\", x => x.Link(\"D\", \"doc_id\")) .ReadOnlyProperty(x => x.DocId, x => x.Field<long>(\"D\", string.Empty, z => z.Key(), z => z.Default(DefaultType.AutoIncrement))) .Column(\"DocStateId\", x => x.Field<long>(\"S\", string.Empty)) .ReadOnlyProperty(x => x.DocStateCode, x => x.Field<string>(\"S\", \"code\")) .ReadOnlyProperty(x => x.Generation, x => x.Field<Guid>(\"D\", string.Empty, z => z.ConcurrencyToken(), z => z.Default(DefaultType.NewGuid))) .ReadOnlyProperty(x => x.Changed, x => x.Field<DateTime>(\"D\", string.Empty, z => z.Default(DefaultType.CurrentDateTime, DefaultFeature.UseOnUpdate))) .Map(x => new Invoice { DocCatalogId => x.Field<long>(\"DC\", \"catalog_id\"), DocState = x.Link<string, DocState>(\"S\", \"name\", z => z.LinkProperty<DocState>(y => y.Name), z => z.LinkProperty<DocState>((Invoice y) => y.DocStateId), z => z.LinkProperty<DocState>(y => y.Code, y => y.DocStateCode)), Numb = x.Field<string>(\"D\", string.Empty), DocDate = x.Field<DateTime?>(\"D\", string.Empty, z => z.Default(DefaultType.CurrentDate)), Scan = x.Lob(\"SC\", z => z.OuterFlag()), Source = x.Xml(\"SR\", z => z.OuterFlag()), DeliveryType = x.Field<DeliveryTypeEnum>(\"DD\", string.Empty), DeliveryDate = x.Field<DateTime>(\"DD\", string.Empty, z => z.Default(DefaultType.CurrentDate)) }).SetBaseTable(\"D\") ); } 4) The first unfamiliar thing for us is DictFilter . This method allows you to filter the data object by reference to the dictionary in which there is a unique string field Code with which we can not rely on the dictionary identifiers at the level of mapping and business logic. In fact, it degenerates into a filter on a subquery (in our case it will be D.doc_type_id = (select doc_type_id from T_DOC_TYPE where code = 'INVOICE') ). See documentation topic for more details 5) A not very noticeable, but extremely important detail is that for some tables a new overload of the DataTable method is used with the parent parameter, which defines the alias of the parent table in updatable tables hierarchy . The introduction of this concept allows applying the change not to one table, but to any number of tables in which information about an instance of a data object is stored. Important Do not forget to specify the parent table in the updatable table tree for those tables that should be updated when the data object changes. At the same time, tables containing reference information are not included in the updatable table tree and do not participate in the update process. For such tables, an overload of the DataTable method is used, which we used earlier. 6) The next interesting thing is the ConcurrencyToken modifier, which is responsible for optimistic lock support. This modifier works in tandem with the familiar Default modifier, which is initialized with the DefaultType.NewGuid value, which means generating a new unique key (GUID). See documentation topic for more details Tip Note that the competition token is described in mapping and does not require any other code! It can even be mapped into a read-only field (as in this case). 7) The next interesting detail is the automatic completion of the Changed property by change date. Using the Default modifier with two parameters, the first DefaultType.CurrentDateTime sets the mechanism for obtaining the default field value by storing the date and time of the change in the local time zone, and the second DefaultFeature.UseOnUpdate allows you to save the change time not only during insertion but also during update. See documentation topic for more details 8) The DocDate and DeliveryDate properties are modified with the default value DefaultType.CurrentDate which means that by default, the current date will be written to these properties. 9) The Scan property has a specific type of Lob and its mapping is described using the Lob method. Similarly, the Source property has a specific Xml type and its mapping is described using the Xml method. The work with these types is different, but it is important that by default the value of such fields is loaded only if the value of a large object is immediately addressed. There are also features when serializing them in JSON (we will consider this below). There are also features when serializing them in JSON (we will consider this below). This behavior allows you to significantly accelerate the work with objects that contain information in large fields. See documentation topic about binary properties and Xml properties for more details 10) Web API controller for this object will look like... using XData; using System.Linq; using System.Threading.Tasks; using Microsoft.AspNetCore.Mvc; using <..Youre namespace..>.Models; namespace <..Youre namespace..>.Controllers.API { public class InvoiceController : DataObjectController<Invoice> { public InvoiceController(IDataEngine dataEngine) : base(dataEngine) { } [HttpGet] public async Task<ActionResult<Invoice>> Get(long id, CancellationToken cancellationToken) { try { using (var dataScope = _dataEngine.NewDataScope(cancellationToken)) { return await dataScope.GetRepository<Invoice>() .SingleOrDefaultAsync(x => x.DocId == id); } } catch (Exception e) { e.FillModelState(ModelState); throw; } } [HttpGet] public async Task<ActionResult<Invoice[]>> GetByCatalog(long id, CancellationToken cancellationToken) { try { using (var dataScope = _dataEngine.NewDataScope(cancellationToken)) { return await dataScope.GetRepository<Invoice>() .ToArrayAsync(x => x.CatalogId == id); } } catch (Exception e) { e.FillModelState(ModelState); throw; } } [HttpGet] public async Task<ActionResult<Invoice>> Export(long id, CancellationToken cancellationToken) { try { using (var dataScope = _dataEngine.NewDataScope(cancellationToken)) { return await dataScope.GetRepository<Invoice>() .SingleOrDefaultAsync(x => x.DocId == id, x => x.LoadLob()); } } catch (Exception e) { e.FillModelState(ModelState); throw; } } [HttpGet] public async Task<ActionResult<byte[]>> GetScan(long id, CancellationToken cancellationToken) { try { using (var dataScope = _dataEngine.NewDataScope(cancellationToken)) { return await dataScope.GetRepository<Invoice>() .Where(x => x.DocId == id) .Scan.Value; } } catch (Exception e) { e.FillModelState(ModelState); throw; } } [HttpPut] public async Task<ActionResult<Invoice[]>> FindBySource([FromBody]string xpath, string value, CancellationToken cancellationToken) { try { using (var dataScope = _dataEngine.NewDataScope(cancellationToken)) { return await dataScope.GetRepository<Invoice>() .Where(x => x.Source.Extract(xpath) == value) .ToArrayAsync(); } } catch (Exception e) { e.FillModelState(ModelState); throw; } } } } 11) The Export method shows how you can get an object with large fields filled. This is available due to the use of the LoadLob modifier. Most asynchronous XData methods have overloads to describe serialization parameters. For a complete description, refer to the corresponding documentation article . 12) Getting the value of a binary object is shown in the GetScan method. To get the value, use the Value property of the Lob object. 13) The Xml type is interesting, among other things, because its contents can be used to construct XPath queries and use them to filter data. To do this, use the Extract method of type Xml as shown in the FindBySource method."
  },
  "quick_start/asp_net_core/hierarchical.html": {
    "href": "quick_start/asp_net_core/hierarchical.html",
    "title": "Hierarchical object | XData website",
    "keywords": "Hierarchical object 1) Now let's build a hierarchically constructed object. To do this, well complete the database again ... <!--MD5=[5ea577eca533bfca935d04f775d3f167] class t_doc--> t_doc <!--MD5=[8e96e01ed3abbee593418fa4b48090e7] class t_good--> t_good good_id code name price <!--MD5=[4ed4cd12cd2eeb59e644791b1ec40217] class t_doc_spec--> t_doc_spec doc_spec_id doc_id good_id quantity <!--MD5=[cef6fc7600387b202b7e697154b0ecaf] link t_doc to t_doc_spec--> doc_id <!--MD5=[eeb11361b0a0b0ef64915b36dd69fe72] link t_good to t_doc_spec--> good_id <!--MD5=[ae30e78afd9ee325f9a0c2f7fcde567c] @startuml hide circle skinparam ClassHeaderBackgroundColor lightgray skinparam ClassBorderColor black skinparam ClassBorderThickness 1 skinparam ClassBackgroundColor transparrent skinparam ArrowFontSize 8 skinparam ArrowColor black entity t_doc { } entity t_good { <&key> good_id - - <&code> code name <&dollar> price } entity t_doc_spec { <&key> doc_spec_id - - <&arrow-circle-right> doc_id <&arrow-circle-right> good_id quantity } t_doc -down-{ t_doc_spec : doc_id t_good -right-{ t_doc_spec : good_id @enduml PlantUML version 1.2020.12(Sat Jun 06 10:54:15 UTC 2020) (GPL source distribution) Java Runtime: Java(TM) SE Runtime Environment JVM: Java HotSpot(TM) 64-Bit Server VM Default Encoding: UTF-8 Language: en Country: US --> 2) Goods dictionary and specification of a document itself contain mostly familiar to us elements... public partial class Good { public long GoodId => this.GetProperty(x => x.GoodId); public string Code { get; set; } public string Name { get; set; } public decimal Price { get; set; } } public partial class Good : IDataObject { private static Expression<CustomMapping<Good>> _ = () => XDataMapping.CustomMapping<Good>() .DataTable(\"T_GOOD\", \"G\") .ReadOnlyProperty(x => x.GoodId, x => x.Field<long>(\"G\", string.Empty, z => z.Key(), z => z.Default(DefaultType.AutoIncrement))) .Map(x => new Good { Code = x.Field<string>(\"G\", string.Empty), Name = x.Field<string>(\"G\", string.Empty), Price = x.Field<decimal>(\"G\", string.Empty) }).SetBaseTable(\"G\"); } public partial class DocSpec { public long DocSpecId => this.GetProperty(x => x.DocSpecId); public long DocId => this.GetProperty(x => x.DocId); public string GoodCode => this.GetProperty(x => x.GoodCode); public Link<string, Good> Good { get; set; } public decimal Price => this.GetProperty(x => x.Price); public decimal Quantity { get; set; } public decimal Amount => this.GetProperty(x => x.Amount); public bool Deleted { get; set; } } public partial class DocSpec : IDataObject { private static Expression<CustomMapping<DocSpec>> _ = () => XDataMapping.CustomMapping<DocSpec>() .DataTable(\"T_DOC_SPEC\", \"S\") .DataTable(\"T_GOOD\", \"G\", x => x.Link(\"S\", \"good_id\")) .ReadOnlyProperty(x => x.DocSpecId, x => x.Field<long>(\"S\", string.Empty, z => z.Key(), z => z.Default(DefaultType.AutoIncrement))) .ReadOnlyProperty(x => x.DocId, x => x.Field<long>(\"S\", string.Empty)) .ReadOnlyProperty(x => x.GoodCode, x => x.Field<string>(\"G\", \"code\")) .ReadOnlyProperty(x => x.Price, x => x.Field<decimal>(\"G\", string.Empty)) .ReadOnlyProperty(x => x.Amount, x => x.Expr<decimal>(\"amount\", z => z.Field<decimal>(\"G\", \"price\") * z.Field<decimal>(\"S\", \"quantity\"), DbType.Decimal, z => z.Size(17, 2))) .Column(\"GoodId\", x => x.Field<long>(\"G\", string.Empty)) .Map(x => new DocSpec { Quantity = x.Field<decimal>(\"S\", string.Empty), Good = x.Link<string, Good>(\"S\", \"name\", z => z.LinkProperty<Good>(y => y.Name), z => z.LinkProperty<Good>((Invoice y) => y.GoodId), z => z.LinkProperty<Good>(y => y.Code, y => y.GoodCode)) }).SetBaseTable(\"S\"); } 3) What is new to us here is only the Expr method, which allows us to use SQL expressions in mapping. In this case, we calculated the position amount by multiplying the quantity by the goods price. The first parameter is the name of the expression field, the second describes the expression itself, the third is the type of expression (DbType.Decimal), Size is used as a modifier, which allows us to specify the size and accuracy of the expression. See documentation topic for more details 4) And also note that in the DocSpec object there is a boolean flag Deleted not reflected on the database. But we'll talk about it a little later... 5) Create a GoodController controller (in Controllers\\API folder)... using XData; using System.Threading.Tasks; using Microsoft.AspNetCore.Mvc; using <..Youre namespace..>.Models; namespace <..Youre namespace..>.Controllers.API { public class GoodController : DataObjectController<Good> { public DocStateController(IDataEngine dataEngine) : base(dataEngine) { } [HttpGet] public async Task<ActionResult<Good>> Get(long id, CancellationToken cancellationToken) { try { using (var dataScope = _dataEngine.NewDataScope(cancellationToken)) { return await dataScope.GetRepository<Good>() .SingleOrDefaultAsync(x => x.GoodId == id); } } catch (Exception e) { e.FillModelState(ModelState); throw; } } } } 6) And here, instead of the sequence of actions we already know, we modify the object from the previous part (Advanced mapping) of the lesson in order to learn how to work with hierarchical objects. First, we will show the changes in the code and then in detail we will analyze all the new techniques for us that will be used here... public partial class Invoice { public long DocId => this.GetProperty(x => x.DocId); public string DocStateCode => this.GetProperty(x => x.DocStateCode); public Link<string, DocState> DocState { get; set; } public long DocCatalogId { get; set; } public string Numb { get; set; } public DateTime? DocDate { get; set; } public Guid Generation => this.GetProperty(x => x.Generation); public DateTime Changed => this.GetProperty(x => x.Changed); public Lob Scan { get; set; } public Xml Source { get; set; } public DeliveryTypeEnum DeliveryType { get; set; } public DateTime DeliveryDate { get; set; } // Add an array for the entries of the child repository public DocSpec[] Specification { get; set; } // And the calculated amount for the document as a whole public decimal DocAmount => this.GetProperty(x => x.DocAmount); } public partial class Invoice: IDataObject { private static Expression<CustomMapping<Invoice>> _ = ( () => XDataMapping.CustomMapping<Invoice>() .DataTable(\"T_DOC\", \"D\", x => x.DictFilter(\"T_DOC_TYPE\", \"doc_type_id\", \"code\", \"INVOICE\")) .DataTable(\"T_DOC_STATE\", \"S\", x => x.Link(\"D\", \"doc_state_id\")) .DataTable(\"T_DOC_CATALOG\", \"DC\", \"D\", x => x.Link(\"D\", \"doc_id\")) .DataTable(\"T_DOC_SCAN\", \"SC\", \"D\", x => x.Link(\"D\", \"doc_id\") .SetOperation(FilterOperation.OuterJoin)) .DataTable(\"T_DOC_SOURCE\", \"SR\", \"D\", x => x.Link(\"D\", \"doc_id\") .SetOperation(FilterOperation.OuterJoin)) .DataTable(\"T_DOC_DELIVERY\", \"DD\", \"D\", x => x.Link(\"D\", \"doc_id\")) .ReadOnlyProperty(x => x.DocId, x => x.Field<long>(\"D\", string.Empty, z => z.Key(), z => z.Default(DefaultType.AutoIncrement))) .Column(\"DocStateId\", x => x.Field<long>(\"S\", string.Empty)) .ReadOnlyProperty(x => x.DocStateCode, x => x.Field<string>(\"S\", \"code\")) .ReadOnlyProperty(x => x.Generation, x => x.Field<Guid>(\"D\", string.Empty, z => z.ConcurrencyToken(), z => z.Default(DefaultType.NewGuid))) .ReadOnlyProperty(x => x.Changed, x => x.Field<DateTime>(\"D\", string.Empty, z => z.Default(DefaultType.CurrentDateTime, DefaultFeature.UseOnUpdate))) // Describe the subquery for calculating the amount of the document .Subquery(\"A\", typeof(DocSpecAmount), \"Amount\", DataGrouping.Sum, x => x.SubqueryLink(x => x.DocId)) //And mapping properties for the amount of the document .ReadOnlyProperty(x => x.DocAmount, x => x.Expr<decimal?>(null, DataExpressionType.SubQuery, \"A\", DbType.Decimal, z => z.Size(17, 5))) .Map(x => new Invoice { DocCatalogId => x.Field<long>(\"DC\", \"catalog_id\"), DocState = x.Link<string, DocState>(\"S\", \"name\", z => z.LinkProperty<DocState>(y => y.Name), z => z.LinkProperty<DocState>((Invoice y) => y.DocStateId), z => z.LinkProperty<DocState>(y => y.Code, y => y.DocStateCode)), Numb = x.Field<string>(\"D\", string.Empty), DocDate = x.Field<DateTime?>(\"D\", string.Empty, z => z.Default(DefaultType.CurrentDate)), Scan = x.Lob(\"SC\", z => z.OuterFlag()), Source = x.Xml(\"SR\", z => z.OuterFlag()), DeliveryType = x.Field<DeliveryTypeEnum>(\"DD\", string.Empty), DeliveryDate = x.Field<DateTime>(\"DD\", string.Empty, z => z.Default(DefaultType.CurrentDate)) }, // Define a rule for link to a DocSpec child repository x => x.ExternalLink<DocSpec>(x => x.DocId) ).SetBaseTable(\"D\") ); } 7) We describe the subquery as a separate mapping. In this case, we dont need the object itself, but a separate mapping calculating the amount for any type of documents will come in handy... public class DocSpecAmount: ISqlObject { private static Expression<CustomMapping<DocSpecAmount>> _ = ( () => XDataMapping.CustomMapping<DocSpecAmount>() .DataTable(\"T_DOC_SPEC\", \"S\") .DataTable(\"T_GOOD\", \"G\", x => x.Link(\"S\", \"good_id\")) .Column(\"DocId\", x => x.Field<long>(\"S\", string.Empty, z => z.Hidden())) .Column(\"Amount\", x => x.Expr<decimal>(\"amount\", z => z.Field<decimal>(\"G\", \"price\") * z.Field<decimal>(\"S\", \"quantity\"), DbType.Decimal, z => z.Hidden(), z => z.Size(17, 2))) .Map().SetBaseTable(\"S\")); } 8) Now we will deal with the new that is used in the presented pieces of code... 9) First, we added an array Specification for the objects of the DocSpec type described earlier to the main declaration of the Invoice object. But we note that he does not participate directly in mapping, and nevertheless, there will be child records in it. But first things first... 10) A subquery is described using the Subquery method with parameters - the alias of the subquery, the type of mapping description of this subquery, the property that will be selected from it, the group operation that will be applied to this property (note that we are talking here not only about the usual properties of the object, but also about hidden properties, as in this example). The last parameter describes SubqueryLink - the filter which the subquery link with an external query. The property by which the subquery will be linked will be DocId , and since in the subquery the communication property is named the same, additional information is not required. See documentation topic for more details 11) The description of the SQL expression when using a subquery is somewhat different and uses a different overload of the Expr method. The first parameter, as before, is the name of the field - expression, but here it is possible to specify null to use the field name according to the naming rules depending on the name of the property (here it will be doc_amount ). The second parameter determines the type of SQL expression and DataExpressionType.SubQuery is used here. The third parameter in this case (since the SQL type of the expression is DataExpressionType.SubQuery ) should be equal to the subquery alias \"A\". See documentation topic for more details 12) To describe the link rule with the child repository DocSpec , the ExternalLink modifier of the Map method is used. The DocId property is specified as its first parameter, and since the associated property has the same name, this is enough. See documentation topic for more details 13) The description of the mapping of the subquery implements the ISqlObject interface and since we will not use it as an independent data object, we have enough. Quite a few extensions are assigned to the IDataObject interface and the use of a more general interface is architecturally justified here. 14) The Column method in our example for both properties is marked with the Hidden modifier. This modifier hides this field from the SQL construct Select and for group operations (and we define this subquery exactly for this only), it is often justified. Since we described the name of the \"Amount\" property and the group operation DataGrouping.Sum in the description of the use of the subquery, this information will be enough to build the correct SQL construct without further limiting the possible reused description in the future. 15) And now we change InvoiceController WebAPI controller... [HttpGet] public async Task<ActionResult<Invoice>> Get(long id, CancellationToken cancellationToken) { try { using (var dataScope = _dataEngine.NewDataScope(cancellationToken)) { return await dataScope.GetRepository<Invoice>() // Initialize the child repository .Do(x => x.Instance.GetChild<DocSpec>(z => z.Specification)) .SingleOrDefaultAsync(x => x.DocId == id); } } catch (Exception e) { e.FillModelState(ModelState); throw; } } [HttpDelete] public override async Task<ActionResult<bool>> Delete([FromBody] Invoice obj, CancellationToken cancellationToken) { try { using (var dataScope = _dataEngine.NewDataScope(cancellationToken)) { var found = dataScope.GetRepository<Invoice>() // Initialize the child repository .Do(x => x.Instance.GetChild<DocSpec>()) .Find(obj); if (found == null) return NotFound(); return await found.SetDeleted(true).SubmitAsync(); } } catch (Exception e) { e.FillModelState(ModelState); throw; } } [HttpPut] public override async Task<ActionResult<Invoice>> Save([FromBody] Invoice obj, CancellationToken cancellationToken) { try { using (var dataScope = _dataEngine.NewDataScope(cancellationToken)) { return await dataScope.GetRepository<Invoice>() // Initialize the child repository .Do(x => x.Instance.GetChild<DocSpec>(z => z.Specification), // Specify DeleteFlag x => obj.WithJsonSettings( z => z.DeleteFlag( y => y.Specification, y => y.Deleted))) .Apply(obj).SubmitAndReturnAsync(); } } catch (Exception e) { e.FillModelState(ModelState); throw; } } 16) A call was added to the Get method. Do is a helper that allows you to add processing to some object, and after the actions of this processing, we need to continue actions on this object, regardless of what methods that are used in the processing steps are returned. For example, here we use Do processing to initialize communication with a child repository. To do this, the repository that is accessible through the processing Instance property calls the GetChild method typed by DocSpec and specifies the Specification property where the child entities will be placed. See documentation topic for more details Important It is important to note that we do not always use binding with the child repository, but only when we really need to and specify the property where the child entities will be unloaded even less often. Such an approach allows us to significantly increase productivity due to the fact that we access the child repository only when it is really necessary and fill the array of child entities even less often. 17) In the Delete method, we initialize the connection with the child repository so that cascading deletion occurs, but (as noted above), we do not specify a property for storing child entities, since this is not required here. 18) In the Save method, we not only initialize the connection with the child repository for applying changes to the child objects, but also indicate that these child objects have an additional Deleted property not mapped to the database (now we can understand what it for) with which we we can tell the XData system that we need to delete this child entity. To do this, use the WithJsonSettings method, which is applied to the disconnected object received from the web. Here, the DeleteFlag method with parameters is used as a modifier  the property to which the child repository is configured and the property of the child object that is used as the delete flag. See documentation topic for more details Tip It is important to note that this mechanism can be used for hierarchical construction of objects with several child repositories (and even with several differently filtered repositories of the same type), as well as for organizing hierarchically organized objects of unlimited nesting. It is only necessary to take into account the overhead affecting performance."
  },
  "tutorial/mapping/static/property/link.html": {
    "href": "tutorial/mapping/static/property/link.html",
    "title": "Links | XData website",
    "keywords": "Links To statically define link property pairs used LinkPropertyAttribute with parameters: DictSource - optional, source object property name, Property - optional, property name. When one or both of parameters is omitted, followed rules are used: When omit both properties - used property name of link property as target and equal named property from source object When DictSource is omitted - used Property as target property name and equal named property from source object When Property is omitted - used property name of link property as target and property with name equals DictSource from source object [Property(\"S\", \"name\"), LinkProperty(\"Name\") /* DocState.Name -> this.DocState */, LinkProperty(Property = \"DocStateId\") /* column DocState.DocStateId -> column this.DocStateId */, LinkProperty(\"Code\", \"DocStateCode\") /* DocState.Code -> this.DocStateCode */] public Link<string, DocState> DocState { get; set; }"
  },
  "tutorial/mapping/static/property/grouping.html": {
    "href": "tutorial/mapping/static/property/grouping.html",
    "title": "Property grouping parameters | XData website",
    "keywords": "Property grouping parameters Property grouping parameters used when data object mapped to grouped query to specify property role in GROUP BY expression. PropertyGroupingAttribute has properties: Grouping - optional, property aggregation type , default is None , GroupOrder - optional, property grouping order when Grouping = DataGrouping . None . [PropertyGrouping(DataGrouping.Sum)]"
  },
  "tutorial/mapping/static/property/default.html": {
    "href": "tutorial/mapping/static/property/default.html",
    "title": "Property default value | XData website",
    "keywords": "Property default value To set default value of property with static mapping, use PropertyDefaultAttribute with parameters: DefaultSource - default value type , DefaultValue optional, depends on DefaultSource , DefaultFeature - optional, default is DefaultFeature.UseOnInsert , default value assignment will be applied with some extended features . [PropertyDefault(DefaultType.UserName, AlwaysUseDefault = true)]"
  },
  "tutorial/mapping/static/tree.html": {
    "href": "tutorial/mapping/static/tree.html",
    "title": "Tree | XData website",
    "keywords": "Tree To statically map tree organized data structure used special data source attributes With to describe tree root query and WithRecursive to describe tree childs. Both of them use subquery mappings (see example below) to set subquery structure for tree query construction. Important Data source flags of tree organized data sources must contain DataStructureFlag.ReadOnly and DataStructureFlag.Tree! With attribute has properties: Alias - alias of tree data source, SubqueryType - type of root subquery mapping, Type - data source combination within tree query, Properties - tree properties order. WithRecursive attribute has properties: Alias - alias of recursive data source, SubqueryType - type of root subquery mapping, InitialAlias - alias of tree data source. [DataObject(\"CAT\", Flags = DataStructureFlag.ReadOnly | DataStructureFlag.Tree), With(\"CAT\", typeof(CatalogueTreeRoot), WithRecursiveType.RecursiveUnion, \"CatalogueId\", \"Name\", \"Code\", \"ParentId\"), WithRecursive(\"S\", typeof(CatalogueTreeFolders), \"CAT\"), SubqueryLink(\"S\", \"ParentId\", \"CatalogueId\")] public class CatalogueTree : IDataObject { public static readonly RuntimeFilter FilterByRoot = new RuntimeFilter(null, \"FilterByRoot\"); public static readonly RuntimeFilter FilterByCathalogue = new RuntimeFilter(null, \"FilterByCathalogue\"); [Property(\"T\", Flags = DataPropertyFlag.Id)] public long CatalogueId { get { return this.GetProperty(x => x.CatalogueId); } } [Property(\"T\")] public string Code { get { return this.GetProperty(x => x.Code); } } [Property(\"T\")] public string Name { get { return this.GetProperty(x => x.Name); } } [Property(\"T\")] public long? ParentId { get { return this.GetProperty(x => x.ParentId); } } } [DataObject(\"R\"), DataTable(\"T_CATALOGUE\", \"R\"), Column(\"CatalogueId\", typeof(long), \"R\"), Column(\"Code\", typeof(string), \"R\"), Column(\"Name\", typeof(string), \"R\"), Column(\"ParentId\", typeof(long?), \"R\"), FilterCombination(\"root\", Combination = Combination.Or), ConstantFilter(\"FilterByCathalogue\", \"R\", \"catalogue_id\", null, Combination = \"root\", Nullable = FilterNullable.NullsNotAllowed), ConstantFilter(\"FilterByRoot\", \"R\", \"parent_id\", null, Combination = \"root\", Nullable = FilterNullable.NullsCompared)] public class CatalogueTreeRoot : ISqlObject {} [DataObject(\"S\"), DataTable(\"T_CATALOGUE\", \"S\"), Column(\"CatalogueId\", typeof(long), \"S\"), Column(\"Code\", typeof(string), \"S\"), Column(\"Name\", typeof(string), \"S\"), Column(\"ParentId\", typeof(long?), \"S\")] public class CatalogueTreeFolders : ISqlObject {}"
  },
  "tutorial/mapping/static/subquery.html": {
    "href": "tutorial/mapping/static/subquery.html",
    "title": "Subqueries | XData website",
    "keywords": "Subqueries XData allows use subqueries as part of mapping. This feature can be used for get property values from subquery, for subquery filters , and inner view definitions. Subquery recursive deep is not limited. Class used subquery in mapping definition must to marked with attribute SubqueryAttribute or InnerViewAttribute (when it used as inner view definition). Both of them has a parameter Alias - subquery alias in resulting query. InnerViewAttribute additionally has parameter InnerViewType - type mapped to subquery. SubqueryAttribute additionally has parameters: SubqueryType - type mapped to subquery, PropertyName - subquery returned property and Grouping - aggregation type of resulting property. [Subquery(\"A\" /* subquery alias */, typeof(DocSpecAmounts) /* subquery mapped type */, \"Amount\" /* subquery result property name */, Grouping = DataGrouping.Sum /* result property aggregation type */)] ... [InnerView(\"H\" /* inner view alias */, typeof(DocLastChange) /* inner view mapped type */)]"
  },
  "tutorial/mapping/static/static.html": {
    "href": "tutorial/mapping/static/static.html",
    "title": "Static mapping | XData website",
    "keywords": "XData tutorial Mapping common rules Static mapping Tip Before read this topic be sure to already readied Glossary and Common mapping rules contains base information to better understanding this. Static mapping is defined using attributes of mapped class and it properties. Static mapping sample <!--MD5=[9fbc3a7cfb9f92e84de8970988e48bb2] class t_catalogue--> t_catalogue catalogue_id code name parent_id <!--MD5=[ea6ea2e31c0cbff1b909b1f0bd59093e] class t_customer--> t_customer customer_id code name <!--MD5=[a6ce46e431db16f1c4014df928aac3e8] class t_doc_cust_type--> t_doc_cust_type doc_cust_type_id code name <!--MD5=[bccea5d0c54fc84e4bad16ab69fd73e7] class t_doc_type--> t_doc_type doc_type_id code name <!--MD5=[5ea577eca533bfca935d04f775d3f167] class t_doc--> t_doc doc_id doc_type_id doc_date generation changed author <!--MD5=[d4ba8adfb5df751cf422e2fad2a28e94] class t_catalogue_doc--> t_catalogue_doc catalogue_id doc_id <!--MD5=[8cca3b0685271c670c4226b30b01cbcf] class t_doc_cust--> t_doc_cust doc_cust_id doc_id customer_id doc_cust_type_id <!--MD5=[fd8c5e68644f1f4fc0b14eca97226ae4] class t_doc_delivery--> t_doc_delivery doc_id delivery_type delivery_date <!--MD5=[dd40a5851c55ff9d7da9b59b2cdb5061] class t_doc_number--> t_doc_number doc_id numb <!--MD5=[710d3dc0240fd500b1d510e138be1447] class t_doc_scan--> t_doc_scan doc_id scan <!--MD5=[5937349b424f6b33ad58af94594dfd63] class t_doc_source--> t_doc_source doc_id source <!--MD5=[4efa0cfa5e1d38a4afda4e219b98680a] class t_doc_state--> t_doc_state doc_state_id code name <!--MD5=[5c02744e5b0455229387a946a811ce2e] class t_doc_doc_state--> t_doc_doc_state doc_id doc_state_id <!--MD5=[0d4a222ed2d2d268b8328f05b8f9e363] class t_doc_history--> t_doc_history doc_history_id doc_id doc_state_id history_date <!--MD5=[d4b45c8a441f4cb1774906928f147529] link t_catalogue to t_catalogue--> parent_id <!--MD5=[b3294211ce75436a8f4d3c51fb151377] link t_doc_type to t_doc--> doc_type_id <!--MD5=[840062eaffe844779ca4f4f301a47d9a] reverse link t_catalogue to t_catalogue_doc--> catalogue_id <!--MD5=[b3a8eac680fbb6e047950cbceafbeb2c] link t_catalogue_doc to t_doc--> doc_id <!--MD5=[7eefc4f6dff794e64e78dcbbfb9c491a] link t_doc to t_doc_cust--> doc_id <!--MD5=[0005336a9822bd19ef61e4ce8910c4c5] reverse link t_doc_cust to t_customer--> customer_id <!--MD5=[131b4a0e76521106752daee341bf156a] reverse link t_doc_cust to t_doc_cust_type--> doc_cust_type_id <!--MD5=[94de7abaa940d64e718a7c3244926e87] reverse link t_doc_delivery to t_doc--> doc_id <!--MD5=[2d23622d96560790c79c16e9140044a4] reverse link t_doc_number to t_doc--> doc_id <!--MD5=[7c459e52799c0d4d655e72449bb91e72] reverse link t_doc_scan to t_doc--> doc_id <!--MD5=[4aa29f824d631e9db9c0b4ff518403cc] reverse link t_doc_source to t_doc--> doc_id <!--MD5=[fdc70aa94f88d88b378c08a646310f88] reverse link t_doc_doc_state to t_doc--> doc_id <!--MD5=[63d405c0f3a8aa08b15fc74dd2b85047] link t_doc_state to t_doc_doc_state--> doc_state_id <!--MD5=[9c004340c543d5fd28395a65d65b76dd] link t_doc to t_doc_history--> doc_id <!--MD5=[ac06e947c28172a1581fe83d17c1f569] reverse link t_doc_history to t_doc_state--> doc_state_id <!--MD5=[a24f9b6c28c3f11eb813d302e9c42a66] @startuml hide circle skinparam ClassHeaderBackgroundColor lightgray skinparam ClassBorderColor black skinparam ClassBorderThickness 1 skinparam ClassBackgroundColor transparrent skinparam ArrowFontSize 8 skinparam ArrowColor black entity t_catalogue { <&key> catalogue_id - - <&code> code name <&arrow-circle-right> //parent_id// } t_catalogue - -{ t_catalogue : parent_id entity t_customer { <&key> customer_id - - <&code> code name } entity t_doc_cust_type { <&key> doc_cust_type_id - - <&code> code name } entity t_doc_type { <&key> doc_type_id - - <&code> code name } entity t_doc { <&key> doc_id - - <&arrow-circle-right> doc_type_id doc_date - - <&tag> generation <&clock> changed <&person> author } t_doc_type -right-{ t_doc : doc_type_id entity t_catalogue_doc { <&key> <&arrow-circle-right> catalogue_id <&key> <&arrow-circle-right> doc_id } t_catalogue_doc -up-{ t_catalogue : catalogue_id t_catalogue_doc - -{ t_doc : doc_id entity t_doc_cust { <&key> doc_cust_id - - <&arrow-circle-right> doc_id <&arrow-circle-right> customer_id <&arrow-circle-right> doc_cust_type_id } t_doc_cust }-up- t_doc : doc_id t_doc_cust }- - t_customer : customer_id t_doc_cust }- - t_doc_cust_type : doc_cust_type_id entity t_doc_delivery { <&key> <&arrow-circle-right> doc_id - - delivery_type delivery_date } t_doc_delivery }o- - t_doc : doc_id entity t_doc_number { <&key> <&arrow-circle-right> doc_id - - numb } t_doc_number }o- - t_doc : doc_id entity t_doc_scan { <&key> <&arrow-circle-right> doc_id - - <&map> scan } t_doc_scan }o- - t_doc : doc_id entity t_doc_source { <&key> <&arrow-circle-right> doc_id - - <&document> source } t_doc_source }o- - t_doc : doc_id entity t_doc_state { <&key> doc_state_id - - <&code> code name } entity t_doc_doc_state { <&key> <&arrow-circle-right> doc_id - - <&arrow-circle-right> doc_state_id } t_doc_doc_state }o-right- t_doc : doc_id t_doc_doc_state }-left- t_doc_state : doc_state_id entity t_doc_history { <&key> doc_history_id - - <&arrow-circle-right> doc_id <&arrow-circle-right> doc_state_id <&clock> history_date } t_doc_history }-up- t_doc : doc_id t_doc_history }- - t_doc_state : doc_state_id @enduml PlantUML version 1.2020.12(Sat Jun 06 10:54:15 UTC 2020) (GPL source distribution) Java Runtime: Java(TM) SE Runtime Environment JVM: Java HotSpot(TM) 64-Bit Server VM Default Encoding: UTF-8 Language: en Country: US --> <!--MD5=[5ea577eca533bfca935d04f775d3f167] class t_doc--> t_doc doc_id doc_type_id doc_date generation changed author <!--MD5=[e871482fb55f9150fc3be5a0e93d8569] class t_doc_spec_type--> t_doc_spec_type doc_spec_type_id code name <!--MD5=[4ed4cd12cd2eeb59e644791b1ec40217] class t_doc_spec--> t_doc_spec doc_spec_id doc_id doc_spec_type_id <!--MD5=[025ac326a6ab31b45989aa42f37da176] class t_doc_spec_amount--> t_doc_spec_amount doc_spec_id amount <!--MD5=[cef6fc7600387b202b7e697154b0ecaf] link t_doc to t_doc_spec--> doc_id <!--MD5=[175fa9f72450b3173fe29432cd7fb745] reverse link t_doc_spec to t_doc_spec_type--> doc_spec_type_id <!--MD5=[542647722f52d6ccd9b263e63b85e2d8] link t_doc_spec to t_doc_spec_amount--> doc_spec_id <!--MD5=[5cb7b5aa399201d5b29efcb8adfe8a65] @startuml hide circle skinparam ClassHeaderBackgroundColor lightgray skinparam ClassBorderColor black skinparam ClassBorderThickness 1 skinparam ClassBackgroundColor transparrent skinparam ArrowFontSize 8 skinparam ArrowColor black entity t_doc { <&key> doc_id - - <&arrow-circle-right> doc_type_id doc_date - - <&tag> generation <&clock> changed <&person> author } entity t_doc_spec_type { <&key> doc_spec_type_id - - <&code> code name } entity t_doc_spec { <&key> doc_spec_id - - <&arrow-circle-right> doc_id <&arrow-circle-right> doc_spec_type_id } t_doc_spec }-left- t_doc : doc_id t_doc_spec }- - t_doc_spec_type : doc_spec_type_id entity t_doc_spec_amount { <&key> <&arrow-circle-right> doc_spec_id - - <&dollar> amount } t_doc_spec_amount }o-left- t_doc_spec : doc_spec_id @enduml PlantUML version 1.2020.12(Sat Jun 06 10:54:15 UTC 2020) (GPL source distribution) Java Runtime: Java(TM) SE Runtime Environment JVM: Java HotSpot(TM) 64-Bit Server VM Default Encoding: UTF-8 Language: en Country: US --> Here is example of data object static mapping. Of course, real mapping is much simpler then this, but as example of XData capabilities it's really representative... SQL representation of following sample: with recursive T (catalogue_id, code, name, parent_id) as ((SELECT R.catalogue_id AS R_catalogue_id, R.code AS R_code, R.name AS R_name, R.parent_id AS R_parent_id FROM T_CATALOGUE R WHERE ((@FilterByRoot is not null and R.catalogue_id = @FilterByRoot) OR (@FilterByRoot is null and R.parent_id is null))) UNION (SELECT S.catalogue_id AS S_catalogue_id, S.code AS S_code, S.name AS S_name, S.parent_id AS S_parent_id FROM T_CATALOGUE S, T T WHERE S.parent_id = (T.catalogue_id))) SELECT CF.CUSTOMER_ID AS CF_CUSTOMER_ID, CF.DOC_CUST_ID AS CF_DOC_CUST_ID, CF.DOC_CUST_TYPE_ID AS CF_DOC_CUST_TYPE_ID, CF.DOC_ID AS CF_DOC_ID, CT.CUSTOMER_ID AS CT_CUSTOMER_ID, CT.DOC_CUST_ID AS CT_DOC_CUST_ID, CT.DOC_CUST_TYPE_ID AS CT_DOC_CUST_TYPE_ID, CT.DOC_ID AS CT_DOC_ID, CAST((SELECT Sum(A.amount) AS A_amount FROM T_DOC_SPEC S JOIN T_DOC_SPEC_AMOUNT A ON A.DOC_SPEC_ID = S.DOC_SPEC_ID WHERE S.doc_id = S.doc_id) AS NUMERIC(17, 5)) AS doc_amount /* DocAmount */, D.doc_date AS D_doc_date /* DocDate */, D.doc_id AS D_doc_id /* DocId */, D.DOC_TYPE_ID AS D_DOC_TYPE_ID, D.generation AS D_generation /* Generation */, D.changed AS D_changed /* Changed */, D.author AS D_author /* Author */, DD.delivery_date AS DD_delivery_date /* DeliveryDate */, DD.delivery_type AS DD_delivery_type /* DeliveryType */, DD.DOC_ID AS DD_DOC_ID, DS.DOC_DOC_STATE_ID AS DS_DOC_DOC_STATE_ID, DS.DOC_ID AS DS_DOC_ID, DS.DOC_STATE_ID AS DS_DOC_STATE_ID, F.CODE AS F_CODE, F.CUSTOMER_ID AS F_CUSTOMER_ID, F.name AS F_name /* CustomerFrom */, H.H_doc_id AS H_H_doc_id, H.H_history_date AS H_H_history_date /* DocLastChange */, N.DOC_ID AS N_DOC_ID, N.numb AS N_numb /* DocNumb */, S.code AS S_code /* DocStateCode */, S.DOC_STATE_ID AS S_DOC_STATE_ID, S.name AS S_name /* DocState */, SC.DOC_ID AS SC_DOC_ID, SC.scan AS SC_scan /* Scan */, SR.DOC_ID AS SR_DOC_ID, SR.source AS SR_source /* Source */, ST.S_doc_id AS ST_S_doc_id, T.CODE AS T_CODE, T.CUSTOMER_ID AS T_CUSTOMER_ID, T.name AS T_name /* CustomerTo */ FROM T_DOC D JOIN T_DOC_DOC_STATE DS ON DS.doc_id = D.doc_id JOIN T_DOC_STATE S ON S.DOC_STATE_ID = DS.DOC_STATE_ID JOIN T_DOC_NUMBER N ON N.doc_id = D.doc_id JOIN T_DOC_CUST CF ON CF.doc_id = D.doc_id JOIN T_DOC_CATALOGUE DC ON DC.doc_id = D.doc_id JOIN T_CATALOGUE U ON DC.catalogue_id = U.catalogue_id JOIN T_CUSTOMER F ON F.CUSTOMER_ID = CF.CUSTOMER_ID JOIN T_DOC_CUST CT ON CT.doc_id = D.doc_id JOIN T_CUSTOMER T ON T.CUSTOMER_ID = CF.CUSTOMER_ID LEFT OUTER JOIN T_DOC_SCAN SC ON SC.doc_id = D.doc_id LEFT OUTER JOIN T_DOC_SOURCE SR ON SR.doc_id = D.doc_id LEFT OUTER JOIN T_DOC_DELIVERY DD ON DD.doc_id = D.doc_id LEFT OUTER JOIN (SELECT H.doc_id AS H_doc_id, H.history_date AS H_history_date FROM T_DOC_HISTORY H) H ON D.doc_id = H.H_doc_id JOIN (SELECT S.doc_id AS S_doc_id FROM T_DOC_SPEC_TYPE ST JOIN T_DOC_SPEC S ON S.DOC_SPEC_TYPE_ID = ST.DOC_SPEC_TYPE_ID WHERE ST.code = @FilterBySpecTypeCode) ST ON D.doc_id = ST.S_doc_id WHERE D.DOC_TYPE_ID = (select doc_type_id from T_DOC_TYPE where code='INVOICE') AND CF.DOC_CUST_TYPE_ID = (select doc_cust_type_id from T_DOC_CUST_TYPE where code='FROM') AND CF.DOC_CUST_TYPE_ID = (select doc_cust_type_id from T_DOC_CUST_TYPE where code='TO') AND D.doc_id = @FilterByDocId AND DC.catalogue_id in (SELECT T.catalogue_id AS T_catalogue_id FROM T T) Mapping sample: [DataObject(\"D\", LogicAssemblyName = \"XDataObjectTest\"), DataTable(\"T_DOC\", \"D\"), DictionaryFilter(\"T_DOC_TYPE\", \"doc_type_id\", \"code\", \"INVOICE\", \"D\"), DataTable(\"T_DOC_DOC_STATE\", \"DS\", Parent = \"D\"), Link(\"D\", \"doc_id\", \"DS\"), DataTable(\"T_DOC_STATE\", \"S\"), Link(\"DS\", \"doc_state_id\", \"S\"), DataTable(\"T_DOC_NUMBER\", \"N\", Parent = \"D\"), Link(\"D\", \"doc_id\", \"N\"), DataTable(\"T_DOC_CUST\", \"CF\", Parent = \"D\"), Link(\"D\", \"doc_id\", \"CF\"), DataTable(\"T_CUSTOMER\", \"F\"), Link(\"CF\", \"customer_id\", \"F\"), DictionaryFilter(\"T_DOC_CUST_TYPE\", \"doc_cust_type_id\", \"code\", \"FROM\", \"CF\"), DataTable(\"T_DOC_CUST\", \"CT\", Parent = \"D\"), Link(\"D\", \"doc_id\", \"CT\"), DataTable(\"T_CUSTOMER\", \"T\"), Link(\"CT\", \"customer_id\", \"T\"), DictionaryFilter(\"T_DOC_CUST_TYPE\", \"doc_cust_type_id\", \"code\", \"TO\", \"CT\"), DataTable(\"T_DOC_SCAN\", \"SC\", Parent = \"D\"), Link(\"D\", \"doc_id\", \"SC\", Operation = FilterOperation.OuterJoin), DataTable(\"T_DOC_SOURCE\", \"SR\", Parent = \"D\"), Link(\"D\", \"doc_id\", \"SR\", Operation = FilterOperation.OuterJoin), DataTable(\"T_DOC_DELIVERY\", \"DD\", Parent = \"D\"), Link(\"D\", \"doc_id\", \"DD\", Operation = FilterOperation.OuterJoin), DataTable(\"T_DOC_CATALOGUE\", \"DC\", Parent = \"D\"), Link(\"D\", \"doc_id\", \"DC\"), DataTable(\"T_CATALOGUE\", \"U\"), Link(\"U\", \"catalogue_id\", \"DC\"), Subquery(\"A\", typeof(DocSpecAmounts), \"Amount\", Grouping = DataGrouping.Sum), SubqueryLink(\"A\", \"DocId\"), InnerView(\"H\", typeof(DocLastChange)), SubqueryLink(\"H\", \"DocId\", Operation = FilterOperation.OuterJoin), ExternalLink(typeof(InvoiceSpec), \"DocId\"), InnerView(\"ST\", typeof(DocBySpecType)), SubqueryLink(\"ST\", \"DocId\"), Subquery(\"UT\", typeof(CatalogueTree), \"CatalogueId\"), SubqueryFilter(\"UT\", \"DC\", \"catalogue_id\", Operation = FilterOperation.In), Column(\"DocId\", typeof(long?), \"D\", Flags = DataPropertyFlag.Id), Column(\"DocStateId\", typeof(long), \"S\"), Column(\"FromCustomerId\", typeof(long), \"F\"), Column(\"ToCustomerId\", typeof(long), \"T\"), Column(\"CatalogueId\", typeof(long), \"U\"), ColumnDefault(\"DocId\", DefaultType.AutoIncrement)] public class Invoice: IDataObject { [Property(\"S\", \"code\")] public string DocStateCode { get { return this.GetProperty(x => x.DocStateCode); } } [Property(\"S\", \"name\"), LinkProperty(\"Name\"), LinkProperty(Property = \"DocStateId\"), LinkProperty(\"Code\", \"DocStateCode\")] public Link<string, DocState> DocState { get; set; } [Property(\"U\", \"name\"), LinkProperty(Property = \"CatalogueId\"), LinkProperty(\"Name\")] public Link<string, Catalogue> DocCatalog { get; set; } [Property(\"N\", \"numb\")] public string DocNumb { get; set; } [Property(\"D\"), PropertyDefault(DefaultType.CurrentDate)] public DateTime? DocDate { get; set; } [Property(\"D\", Flags = DataPropertyFlag.ConcurrencyToken), PropertyDefault(DefaultType.AutoIncrement)] public long Generation { get { return this.GetProperty(x => x.Generation); } } [Property(\"D\"), PropertyDefault(DefaultType.CurrentDateTime, DefaultFeature = DefaultFeature.UseOnUpdate)] public DateTime Changed { get { return this.GetProperty(x => x.Changed); } } [Property(\"D\"), PropertyDefault(DefaultType.UserName, DefaultFeature = DefaultFeature.UseOnUpdate)] public string Author { get { return this.GetProperty(x => x.Author); } } [Property, PropertyExpression(\"A\", DataExpressionType.SubQuery, DbType.Decimal, ExprSize = 17, ExprScale = 5)] public decimal? DocAmount { get { return this.GetProperty(x => x.DocAmount); } } [Reference(\"H\", \"HistoryDate\")] public DateTime? DocLastChange { get { return this.GetProperty(x => x.DocLastChange); } } [Property(\"SC\", Flags = DataPropertyFlag.OuterFlag)] public Lob Scan { get; set; } [Property(\"SR\", Flags = DataPropertyFlag.OuterFlag)] public Xml Source { get; set; } [Property(\"F\", \"name\"), LinkProperty(\"CustomerId\", \"FromCustomerId\"), LinkProperty(\"Name\")] public Link<string, Customer> CustomerFrom { get; set; } [Property(\"T\", \"name\"), LinkProperty(\"CustomerId\", \"ToCustomerId\"), LinkProperty(\"Name\")] public Link<string, Customer> CustomerTo { get; set; } [Property(\"DD\")] public DeliveryTypeEnum DeliveryType { get; set; } [Property(\"DD\"), PropertyDefault(DefaultType.CurrentDate)] public DateTime? DeliveryDate { get; set; } public IRepository<InvoiceSpec> Spec { get { return this.GetRepository().GetChild<InvoiceSpec>(); } } } Mapping parameters All statically mapped classes must be marked with DataObjectAttribute . Parameters of DataObjectAttribute : BaseTable - alias of base table (optional, default is virtual table with empty alias), Context - database context (optional, context will be specified at runtime), and Flags - data source flags (optional, default is None ). Example: [DataObject(\"D\" /* base table alias */, Context: \"Main\", Flags: DataObjectFlags.ReadOnly)] The DataObjectAttribute attribute can also be used to inherit the mapping description of the data object. To do this, an alternative constructor is used that allows you to limit BaseMappingType - the base object in the inheritance hierarchy of the mapping description. The BaseMappingType class must implement the ISqlObject interface but does not have to be associated with the current class. The depth of the inheritance hierarchy of the mapping description is not limited. [DataObject(typeof(ParentDescription))] Warning When inheriting mapping descriptions, a mixture of the static and dynamic description methods within the a single mapping inheritance hierarchy is not allowed! Tables All tables in repository query must to be specified using DataTableAttribute . Parameters of DataTableAttribute : Name - name of table and Alias - table alias in query. Tables in updatable tables hierarchy , but not base table must to specify Parent parameter of this attribute - alias of parent table in updatable tables hierarchy. [DataTable(\"P\" /* table alias */, \"patient\" /* table name */, \"D\" /* parent table alias */)] Same way we can define mapping to view, but all fields of view must to be explicitly defined as read-only properties or columns . Subqueries XData allows use subqueries as part of mapping. This feature can be used for get property values from subquery, for subquery filters , and inner view definitions. Subquery recursive deep is not limited. Class used subquery in mapping definition must to marked with attribute SubqueryAttribute or InnerViewAttribute (when it used as inner view definition). Both of them has a parameter Alias - subquery alias in resulting query. InnerViewAttribute additionally has parameter InnerViewType - type mapped to subquery. SubqueryAttribute additionally has parameters: SubqueryType - type mapped to subquery, PropertyName - subquery returned property and Grouping - aggregation type of resulting property. [Subquery(\"A\" /* subquery alias */, typeof(DocSpecAmounts) /* subquery mapped type */, \"Amount\" /* subquery result property name */, Grouping = DataGrouping.Sum /* result property aggregation type */)] ... [InnerView(\"H\" /* inner view alias */, typeof(DocLastChange) /* inner view mapped type */)] Filters Filters can be defined as: Constant filters SQL expression filters Dictionary filters Range filters Subquery filters Inner links Each of filter type is defined by own special attribute of data object class. Each of attributes has parameters: Source - data source alias of filtered field, FieldName - filtered field name, Operation - filter operation (optional, default is FilterOperation . Equal ), Combination - filter group name (optional, default is root filter group). Above this every filter attribute has their own specific parameters described below. Filter operation is defined by enum FilterOperation : Equal - equal NotEqual - not equal LessThan - less then GreaterThan - greater then LessThanOrEqual - less or equal GreaterThanOrEqual - greater or equal In - field value in range or subquery NotIn - field value is not in range or subquery Exists - subquery returns one or more rows NotExists - subquery returns no rows Like - field value correlated with find expression NotLike - field value not correlated with find expression OuterJoin - left outer join link between query sources (tables or inner views) Contains - field value correlated with full-text search NotContains - field value not correlated with full-text search Filter group Filter group can be defined by FilterCombinationAttribute with parameters: Name - filter group unique name, Combination - logical operation between filters and subgroups inside group (optional, default is FilterCombination . And ), Parent - parent filter group name (optional, can be omitted for filter groups with parent - root filter group). Logic operation inside filter group is defined by enum Combination : And - and Or - or [FilterCombination(\"OrGroup\" /* group filter name */, Combination: Combination.OR /* logical operation */)] Constant filters Constant filters can restrict query by constant value. This filter is defined by ConstantFilterAttribute , with specific (over described above ) parameters: Name - filter name (will be transformed to query parameter name), ConstantType - constant type (see below) and ConstantValue - constant value depends on ConstantType . Constant types is defined by enum FilterConstantType : Const - value of ConstantValue . Variable - value of variable with name equals ConstantValue . CurrentDate - current date. CurrentDateTime - current date/time. CurrentDateTimeUTC - current date/time (UTC). [ConstantFilter(\"FilterByZero\" /* filter name */, \"P\" /* table alias */, \"discount\" /* DB field name */, 0m /* decimal constant value */, Operation: FilterOperation.Equal /* filter operation */, ConstantType: FilterConstantType.Const /* constant type */)] SQL expression filters To define filter over SQL expression used ExpressionFilterAttribute with specific (over described above ) parameter: ExpressionText - depends on value can be: subquery alias, [ExpressionFilter(\"P\" /* table alias */, \"discount\" /* field name */, \"D\" /* ExpressionText: subquery alias */, Operation: FilterOperation.In /* filter operation */)] private static field name contains dynamic definition of SQL expression, [ExpressionFilter(\"P\" /* table alias */, \"discount\" /* field name */, \"AllowedDiscount\" /* ExpressionText: SQL expression description field name */, Operation: FilterOperation.NotEqual /* filter operation */)] ... //Private static field of mapped class marked with SqlExpression attribute [SqlExpression] private static Calculate<int> AllowedDiscount = x => x.Case<Product, int>( z => z.Field<bool>(\"is_vip\"), z => 0, 1.SetExpression(z => 10)); plain SQL expression text. [ExpressionFilter(\"P\" /* table alias */, \"discount\" /* field name */, \"case P.is_vip when 1 then 10 else 0 end\" /* ExpressionText: plain SQL expression */, Operation: FilterOperation.NotEqual /* filter operation */)] Important If possible do not use plain SQL expressions. It possibly use specific SQL dialect features not supported by other DBMS or providers. Range filters To define filter checks field value over array of values used RangeFilterAttribute with specific (over described above ) parameter: Range - array of values to filter on. [RangeFilter(\"P\" /* table alias */, \"discount\" /* field name */, new[] {0,5,10} /* range of values */, Operation: FilterOperation.In /* filter operation */)] Dictionary filters Dictionaries surrogate keys may varied over one instance to another, and names can be changed by users. Sometimes business logic need to operate with the concrete value of dictionary. Because of this it's recommended to add into dictionary DB structure a special unique text field - mnemonic code. XData supports using mnemonic code when define filters on dictionary value - dictionary filters. They defined by DictionaryFilterAttribute with specific (over described above ) parameters: DictionaryTable - dictionary table name, DictionaryId - dictionary id field name, DictionaryCode - dictionary mnemonic code field name, DictionaryValue - mnemonic code value to filter query on, ValueIsVariable - flag DictionaryValue contains not a value but name of variable with value. Tip In case filter field name is equals dictionary id field name, parameter FieldName can be omitted. Important This filter can be used when dictionary has simple (one field only) identity field and mnemonic code field. But it's a very common case. [DictionaryFilter(\"t_doc_state\" /* dictionary table name */, \"doc_state_id\" /* dictionary id field name */, \"code\" /* dictionary mnemonic code field name */, \"CREATED\" /* mnemonic code value */, \"D\" /* filtered table alias */)] Inner links To define links between data sources inside query used LinkAttribute with specific parameters: LinkedSourceAlias - linked table alias, LinkedFieldName - linked table field name (optional, can be omitted when equals with FieldName ). Tip Inner links can be used to define optional filters . To specify role in optional filter chain need to set parameter PrimaryFilter to true . [Link(\"D\" /* table alias */, \"doc_id\" /* field name */, \"DD\" /* linked table alias */)] Subquery filters To define filters checks field value is correspond subquery results used SubqueryFilterAttribute with specific (over defined above ) parameter: Subquery - subquery alias (see Subqueries ). Inner view can not be used with subquery filters. [SubqueryFilter(\"D\" /* table alias */, \"doc_state_id\" /* field name */, \"A\" /* subquery alias */, Operation: FilterOperation.In /* filter operation */)] When flag PrimaryFilter is set to true optional part of query is defined by followed rules: when one of linked data sources is skipped then other one will skipped too. When base table of subquery is skipped then subquery is skipped completely. Subquery links Links with subqueries is used to link not table fields but properties of base class and subquery mapped class including hidden properties . To link with subquery or inner view used SubqueryLinkAttribute with parameters: Subquery - subquery alias, SubqueryProperty - linked property from subquery, PropertyName - optional, linked property from base class (when omit, base class property name is equal SubqueryProperty ), also optional properties: Operation , Combination and PrimaryFilter is supported. They was described above in topics Filters and Inner links . [SubqueryLink(\"H\" /* subquery alias */, \"DocId\" /* subquery property to link */)] When flag PrimaryFilter is set to true optional part of query is defined by followed rules: when subquery is skipped, then data source linked to subquery by this filter will be skipped too, and skip data sources analysis will continue inside base class (see Inner links ). Properties Static mapping is performed as each property with specific attributes mark. Main attribute to statically map property is PropertyAttribute with parameters: Source - data source alias (may be omitted for virtual table ), FieldName - DB field name mapped to property (may be omitted when field and property correspond naming rule, for example DB field named as some_field_name and mapped to SomeFieldName property), Flags - optional, mask of property flags , NativeSqlType - optional, SQL type name in DB. Parameter NativeSqlType is used when type default mapping is conflicted with real SQL type name. [Property(\"S\" /* table alias */, \"code\" /* field name */)] SQL expression property Read only property can be mapped to SQL expression. Static mapping of SQL expression is defined by PropertyExpressionAttribute with parameters: ExprText - depends of ExprType value (see below) it can be: subquery alias / SQL expression / private static field name define SQL expression in LINQ style, ExprType - optional, SQL expression type , default is DataExpressionType . PlainSql , DbType - ADO ,Net provider data type (optional, default is DbType . String ), ExprSize - optional, expression field size (if applicable), ExprScale - optional, expression field precision (if applicable). Possible to use SQL expressions of three types: subquery, [PropertyExpression(\"A\", DataExpressionType.SubQuery, DbType.Decimal, ExprSize = 17, ExprScale = 5)] LINQ expression, [PropertyExpression(\"AllowedDiscount\", DataExpressionType.LinqExpression, DbType.Decimal, ExprSize = 17, ExprScale = 5)] ... //Private static field of mapped class marked with SqlExpression attribute [SqlExpression] private static Calculate<int> AllowedDiscount = x => x.Case<Product, int>( z => z.Field<bool>(\"is_vip\"), z => 0, 1.SetExpression(z => 10)); plain text SQL expression. [PropertyExpression(\"case P.is_vip when 1 then 10 else 0 end\", DataExpressionType.PlainSql, DbType.Decimal, ExprSize = 17, ExprScale = 5)] Tip Attribute PropertyExpressionAttribute is not replaced PropertyAttribute but extend it. Important If possible do not use plain SQL expressions. It possibly use specific SQL dialect features not supported by other DBMS or providers. Tip It's recommended to use virtual table as SQL expression source omitting data source alias in PropertyAttribute . Property default value To set default value of property with static mapping, use PropertyDefaultAttribute with parameters: DefaultSource - default value type , DefaultValue optional, depends on DefaultSource , DefaultFeature - optional, default is DefaultFeature.UseOnInsert , default value assignment will be applied with some extended features . [PropertyDefault(DefaultType.UserName, AlwaysUseDefault = true)] Property grouping parameters Property grouping parameters used when data object mapped to grouped query to specify property role in GROUP BY expression. PropertyGroupingAttribute has properties: Grouping - optional, property aggregation type , default is None , GroupOrder - optional, property grouping order when Grouping = DataGrouping . None . [PropertyGrouping(DataGrouping.Sum)] Hidden properties Hidden properties statically defined using couple of specific attributes: ColumnAttribute , ColumnExpressionAttribute and ColumnDefaultAttribute as analog with similar attributes of properties . ColumnAttribute has parameters: PropertyName - name of hidden property, PropertyType - type of hidden property, Source - data source alias, FieldName - optional, DB field name (can be omitted when correspond default mapping rule (example: some_field_name is mapped to SomeFieldName )), Flags - optional, bit mask of property flags , Grouping - optional, defined aggregation type , default is None , GroupOrder - optional, group order when Grouping = DataGrouping . None , Hidden - optional, mapped field omitted in SELECT expression of result query (when grouping limitations demand this), default is false , NativeSqlType - optional, native SQL type name. NativeSqlType is used when default data type mapping is conflicted with result set data type. ColumnExpressionAttribute has parameters: PropertyName - name of hidden property (same as defined by ColumnAttribute ), ExprText - depends on ExprType (see below): subquery alias / SQL expression text / field name with LINQ style expression definition, ExprType - optional, SQL expression type default is DataExpressionType . PlainSql , DbType - data type on ADO .Net provider level (optional, default is DbType . String ), ExprSize - optional, expression field size (if applicable), ExprScale - optional, expression field precision (if applicable). ColumnDefaultAttribute has parameters: PropertyName - hidden property name (same as defined by ColumnAttribute ), DefaultSource - default value type , DefaultValue optional, depends on DefaultSource , DefaultFeature - optional, default is DefaultFeature.UseOnInsert , default value assignment will be applied with some extended features . [Column(\"DocId\", typeof(long?), \"D\", Flags = DataPropertyFlag.Id), ColumnDefault(\"DocId\", DefaultType.AutoIncrement)] Inner view reference To map property to field from inner view a ReferenceAttribute is used with parameters: Source - inner view alias, PropertyName - optional, DB field name (may be omitted when property name is equals with inner view mapped class property), Flags - optional, mask of property flags , NativeSqlType - optional, SQL type name in DB. Parameter NativeSqlType is used when type default mapping is conflicted with real SQL type name. [Reference(\"H\" /* inner view alias */, \"HistoryDate\" /* property name inside inner view */)] Links To statically define link property pairs used LinkPropertyAttribute with parameters: DictSource - optional, source object property name, Property - optional, property name. When one or both of parameters is omitted, followed rules are used: When omit both properties - used property name of link property as target and equal named property from source object When DictSource is omitted - used Property as target property name and equal named property from source object When Property is omitted - used property name of link property as target and property with name equals DictSource from source object [Property(\"S\", \"name\"), LinkProperty(\"Name\") /* DocState.Name -> this.DocState */, LinkProperty(Property = \"DocStateId\") /* column DocState.DocStateId -> column this.DocStateId */, LinkProperty(\"Code\", \"DocStateCode\") /* DocState.Code -> this.DocStateCode */] public Link<string, DocState> DocState { get; set; } Tree To statically map tree organized data structure used special data source attributes With to describe tree root query and WithRecursive to describe tree childs. Both of them use subquery mappings (see example below) to set subquery structure for tree query construction. Important Data source flags of tree organized data sources must contain DataStructureFlag.ReadOnly and DataStructureFlag.Tree! With attribute has properties: Alias - alias of tree data source, SubqueryType - type of root subquery mapping, Type - data source combination within tree query, Properties - tree properties order. WithRecursive attribute has properties: Alias - alias of recursive data source, SubqueryType - type of root subquery mapping, InitialAlias - alias of tree data source. [DataObject(\"CAT\", Flags = DataStructureFlag.ReadOnly | DataStructureFlag.Tree), With(\"CAT\", typeof(CatalogueTreeRoot), WithRecursiveType.RecursiveUnion, \"CatalogueId\", \"Name\", \"Code\", \"ParentId\"), WithRecursive(\"S\", typeof(CatalogueTreeFolders), \"CAT\"), SubqueryLink(\"S\", \"ParentId\", \"CatalogueId\")] public class CatalogueTree : IDataObject { public static readonly RuntimeFilter FilterByRoot = new RuntimeFilter(null, \"FilterByRoot\"); public static readonly RuntimeFilter FilterByCathalogue = new RuntimeFilter(null, \"FilterByCathalogue\"); [Property(\"T\", Flags = DataPropertyFlag.Id)] public long CatalogueId { get { return this.GetProperty(x => x.CatalogueId); } } [Property(\"T\")] public string Code { get { return this.GetProperty(x => x.Code); } } [Property(\"T\")] public string Name { get { return this.GetProperty(x => x.Name); } } [Property(\"T\")] public long? ParentId { get { return this.GetProperty(x => x.ParentId); } } } [DataObject(\"R\"), DataTable(\"T_CATALOGUE\", \"R\"), Column(\"CatalogueId\", typeof(long), \"R\"), Column(\"Code\", typeof(string), \"R\"), Column(\"Name\", typeof(string), \"R\"), Column(\"ParentId\", typeof(long?), \"R\"), FilterCombination(\"root\", Combination = Combination.Or), ConstantFilter(\"FilterByCathalogue\", \"R\", \"catalogue_id\", null, Combination = \"root\", Nullable = FilterNullable.NullsNotAllowed), ConstantFilter(\"FilterByRoot\", \"R\", \"parent_id\", null, Combination = \"root\", Nullable = FilterNullable.NullsCompared)] public class CatalogueTreeRoot : ISqlObject {} [DataObject(\"S\"), DataTable(\"T_CATALOGUE\", \"S\"), Column(\"CatalogueId\", typeof(long), \"S\"), Column(\"Code\", typeof(string), \"S\"), Column(\"Name\", typeof(string), \"S\"), Column(\"ParentId\", typeof(long?), \"S\")] public class CatalogueTreeFolders : ISqlObject {} External link External link can be statically defined using ExternalLinkAttribute with parameters: ChildType - detail repository mapped type, ChildProperty - link property in detail repository, Property - optional, link property in master repository, default used same name as ChildProperty , FilterName - optional, detail repository filter name, default used \"FilterBy\" + ChildProperty , MasterRefresh - optional, refresh master repository current row data on submit detail changes flag (useful when master has calculated properties over detail repository data), default is false , DirectLink - optional, see tree master-detail specifics for details, default is false Operation - optional, link filter operation (see Filters ), default FilterOperation . Equal , Nullable - optional, filter null processing behavior , default is FilterNullable . Nullable , Combination - optional, filter group name in detail repository. External links can be used in optional filters description (see Optional filters and optional subqueries ). To specify external link is optional filter part You can set primary filter flag PrimaryFilter . [ExternalLink(typeof(InvoiceSpec), \"DocId\")] Variables The use of variables is described here . Here we describe a way of setting variable values for reused mapping Subquery (and InnerView ) mapping. To do this, use the SubqueryVariableAttribute attribute. Parameter Alias - subquery alias in resulting query. Name - the name of the variable. Value - the value of the variable. [SubqueryVariable(\"A\" /* subquery alias */, \"TestVar\" /* variable name */, 1 /* variable value */)] SQL procedures & functions Common information about mapping to SQL procedures and functions has described in common mapping rules description and here we just represent static mapping rules for various procedure types. Warning SQLite not supported SQL procedures & functions Warning PostgreSql functions has restrictions: returning refcursor or set of refcursor requires transaction! parameters use lower case names ONLY! result set names (refcursor names) use lower case names ONLY! SQL procedure as query To define procedure as data source of mapping used ProcedureAttribute with parameters: Alias - procedure alias, Name - procedure or function name, ProcedureType - ProcedureType : ProcedureType . Procedure or ProcedureType . Function . SQL procedure parameter To define SQL procedure parameter used ParameterAttribute with parameters: Alias - procedure alias, Order - order number of parameter, Binding - name used inside application code (it's handy to use parameter with another name, not the name defined inside DB), Type - data type used inside application code, DbType - data type on ADO .Net provider level, Direction - optional, parameter direction, default is ParameterDirection . Input , Size - optional, parameter size(if applicable), Scale - optional, parameter precision (if applicable), Name - optional, parameter name, default is equal with Binding , DefaultType - default value type , DefaultValue optional, depends on DefaultType , NativeSqlType - optional, SQL type name ( NativeSqlType is used when type default mapping is conflicted with real SQL type), UdtTypeName - optional, user defined type (UDT), UdtElementTypeName - optional, user defined type (UDT) of UdtTypeName element (in case where UdtTypeName - array or table), IsArray - optional, parameter is array of UdtElementTypeName (when UdtElementTypeName is omitted, array of DbType ), default is false . SQL procedure result set To describe result set of SQL procedure used ResultSetAttribute with parameters: Alias - procedure alias, Name - result set name used inside application code, when result set is not mapped to procedure parameter set it to \"\" (empty string), Order - optional, order number of result set (required to procedures returns multiple result sets), ResultType - optional, mapped type of result set, default is attributed class itself, IsDefault - optional, result set is default - mapped to attributed class (used when procedure returns multiple result sets), default is false . SQL procedure result set as query sample MS SQL Server CREATE PROCEDURE [dbo].[TestProcedure] ( @param1 int, @param2 varchar(20) ) AS SELECT @param1 as Id, @param2 as Name Oracle procedure TestProcedure(p_Id int, p_Name varchar2, p_Out out SYS_REFCURSOR) as begin open p_Out for select p_Id as Id, p_Name as Name from dual; end TestProcedure; PostgreSQL CREATE OR REPLACE FUNCTION public.TestProcedure (p_id integer, p_name varchar, refcursor) RETURNS refcursor AS $$ begin open $3 for select p_id as Id, p_name as Name; return $3; end $$ LANGUAGE plpgsql; MySQL create procedure TestProcedure(p_Id int, p_Name varchar(50)) begin select p_Id as Id, p_Name as Name; end Mapping [DataObject(\"T\"), Procedure(\"T\", \"dbo.TestProcedure\", ProcedureType.Procedure), Parameter(\"T\", 1, \"param1\", typeof(int), DbType.Int32), Parameter(\"T\", 2, \"param2\", typeof(string), DbType.String), ResultSet(\"T\")] public class TestProcedure : IDataObject { [Property(\"T\", \"Id\", Flags = DataPropertyFlag.Id)] public int Id { get { return this.GetProperty(x => x.Id); } } [Property(\"T\", \"Name\")] public string Name { get { return this.GetProperty(x => x.Name); } } } SQL procedure with multiple result sets sample MS SQL Server CREATE PROCEDURE [dbo].[TestProcedure2] ( @param1 int, @param2 varchar(20), @param3 int, @param4 varchar(20) ) AS BEGIN SELECT @param1 as Id, @param2 as Name SELECT @param3 as Id, @param4 as Name END Oracle procedure TestProcedure2(p_Id int, p_Name varchar2, p_Out out SYS_REFCURSOR, p_Out2 out SYS_REFCURSOR) as begin open p_Out for select p_Id as Id, p_Name as Name from dual; open p_Out2 for select p_Id as Id, p_Name as Name from dual; end TestProcedure2; Tip Use refcursor parameters names as ResultSet names! PostgreSQL CREATE OR REPLACE FUNCTION public.TestProcedure2 (p_id integer, p_name varchar, refcursor, refcursor) RETURNS SETOF refcursor AS $$ begin open $3 for select p_id as Id, p_name as Name; return NEXT $3; open $4 for select p_id as Id, p_name as Name; return NEXT $4; end $$ LANGUAGE plpgsql; Warning Functions witch returns setof refcursor is not supported by NpgSql .Net Standard 2.0 Edition :( XData net4.0 version can call that type functions with the same mapping rules as described here... Tip If refcursor parameters have a names it must be used as ResultSet names! MySQL create procedure TestProcedure2(p_Id int, p_Name varchar(50)) begin select p_Id as Id, p_Name as Name; select p_Id as Id, p_Name as Name; end Mapping [DataObject(\"T\"), Procedure(\"T\", \"dbo.TestProcedure2\", ProcedureType.Procedure), Parameter(\"T\", 1, \"param1\", typeof(int), DbType.Int32), Parameter(\"T\", 2, \"param2\", typeof(string), DbType.String), Parameter(\"T\", 3, \"param3\", typeof(int), DbType.Int32), Parameter(\"T\", 4, \"param4\", typeof(string), DbType.String), ResultSet(\"T\", IsDefault = true), ResultSet(\"T\", \"SecondResult\", ResultType = typeof(TestResult), Order = 2)] public class TestProcedure2 : IDataObject { [Property(\"T\", \"Id\", Flags = DataPropertyFlag.Id)] public int Id { get { return this.GetProperty(x => x.Id); } } [Property(\"T\", \"Name\")] public string Name { get { return this.GetProperty(x => x.Name); } } public IEnumerable<TestResult> SecondResult { get { return this.GetResultSet(x => x.SecondResult); } } } SQL procedure with out parameter sample MS SQL Server CREATE PROCEDURE [dbo].[TestProcedure3] ( @param1 int, @param2 varchar(20), @param3 varchar(20) OUTPUT ) AS SET @param3 = convert(varchar(20), @param1) + ' - ' + @param2 RETURN Oracle procedure TestProcedure3(p_Id int, p_Name varchar2, p_Out out varchar2) as begin select p_Id || ' - ' || p_Name into p_Out from dual; end TestProcedure3; PostgreSQL CREATE or REPLACE function TestProcedure3(p_id integer, p_name varchar, out p_out varchar) as $$ begin p_Out := p_id || ' - ' || p_name; end $$ LANGUAGE plpgsql; MySQL create procedure TestProcedure3(p_Id int, p_Name varchar(50), out p_Out varchar(100)) begin set p_Out = CONCAT(p_Id, ' - ', p_Name); end Mapping [DataObject(\"T\"), Procedure(\"T\", \"dbo.TestProcedure3\", ProcedureType.Procedure), Parameter(\"T\", 1, \"param1\", typeof(int), DbType.Int32), Parameter(\"T\", 2, \"param2\", typeof(string), DbType.String), Parameter(\"T\", 3, \"OutParameter\", typeof(string), DbType.String, Size = 20, Direction = ParameterDirection.Output, Name = \"param3\")] public class TestProcedure3 : IDataObject { public string OutParameter { get { return this.GetParameter(x => x.OutParameter); } } } SQL procedure with out parameter and result set sample MS SQL Server CREATE PROCEDURE [dbo].[TestProcedure4] ( @param1 int, @param2 varchar(20) ) AS SELECT @param1 as Id, @param2 as Name RETURN(@param1) Oracle procedure TestProcedure4(p_Tab in classifier_tab, p_Out out SYS_REFCURSOR) as begin open p_Out for select Id, Name from table(p_Tab); end TestProcedure4; Tip Use refcursor parameters names as ResultSet names! PostgreSQL CREATE OR REPLACE FUNCTION public.TestProcedure4 (p_tab public.classifier_rec [], refcursor) RETURNS refcursor AS $$ begin open $2 for select Id, Name from unnest(p_tab); return $2; end $$ LANGUAGE plpgsql; Tip If refcursor parameters have a names it must be used as ResultSet names! MySQL Not supported Mapping [DataObject(\"T\"), Procedure(\"T\", \"dbo.TestProcedure4\", ProcedureType.Procedure), Parameter(\"T\", 1, \"param1\", typeof(int), DbType.Int32), Parameter(\"T\", 2, \"param2\", typeof(string), DbType.String), Parameter(\"T\", 3, \"OutParameter\", typeof(string), DbType.String, Size = 20, Direction = ParameterDirection.Output, Name = \"param3\"), ResultSet(\"T\")] public class TestProcedure4 : IDataObject { [Property(\"T\", \"Id\", Flags = DataPropertyFlag.Id)] public int Id { get { return this.GetProperty(x => x.Id); } } [Property(\"T\", \"Name\")] public string Name { get { return this.GetProperty(x => x.Name); } } public string OutParameter { get { return this.GetParameter(x => x.OutParameter); } } } SQL procedure with return value sample MS SQL Server CREATE PROCEDURE [dbo].[TestProcedure5] ( @param1 int, @param2 varchar(20) ) AS RETURN(@param1) Oracle Not supported PostgreSQL Not supported MySQL Not supported Mapping [DataObject(\"T\"), Procedure(\"T\", \"dbo.TestProcedure5\", ProcedureType.Procedure), Parameter(\"T\", 1, \"param1\", typeof(int), DbType.Int32), Parameter(\"T\", 2, \"param2\", typeof(string), DbType.String), Parameter(\"T\", 3, \"ReturnValue\", typeof(string), DbType.String, Size = 20, Direction = ParameterDirection.ReturnValue, Name = \"result\")] public class TestProcedure5 : IDataObject { public string ReturnValue { get { return this.GetParameter(x => x.ReturnValue); } } } SQL procedure with return value and result set sample MS SQL Server MS SQL Server CREATE PROCEDURE [dbo].[TestProcedure6] ( @param1 int, @param2 varchar(20) ) AS SELECT @param1 as Id, @param2 as Name RETURN(@param1) Oracle Not supported PostgreSQL Not supported MySQL Not supported Mapping [DataObject(\"T\"), Procedure(\"T\", \"dbo.TestProcedure6\", ProcedureType.Procedure), Parameter(\"T\", 1, \"param1\", typeof(int), DbType.Int32), Parameter(\"T\", 2, \"param2\", typeof(string), DbType.String), Parameter(\"T\", 3, \"ResultParameter\", typeof(int), DbType.Int32, Direction = ParameterDirection.ReturnValue), ResultSet(\"T\")] public class TestProcedure6 : IDataObject { [Property(\"T\", \"Id\", Flags = DataPropertyFlag.Id)] public int Id { get { return this.GetProperty(x => x.Id); } } [Property(\"T\", \"Name\")] public string Name { get { return this.GetProperty(x => x.Name); } } public int ResultParameter { get { return this.GetParameter(x => x.ResultParameter); } } } SQL procedure with simple array parameter sample MS SQL Server Not supported Oracle Not supported PostgreSQL CREATE or REPLACE function TestFunction6(p_arr INTEGER[]) returns integer as $$ begin return sum(s) from unnest(p_arr) s; end $$ LANGUAGE plpgsql; MySQL Not supported Mapping [DataObject(\"T\"), Procedure(\"T\", \"TestFunction\", ProcedureType.Function), Parameter(\"T\", 1, \"param1\", typeof(int[]), DbType.Int32, IsArray = true), Parameter(\"T\", 2, \"Result\", typeof(int), DbType.Int32, Direction = ParameterDirection.ReturnValue)] public class TestFunction : IDataObject { public int Result { get { return this.GetParameter(x => x.Result); } } } SQL procedure with UDT parameter sample MS SQL Server Not supported Tip MS SQL Server does not support passing single UDT object as a parameter value, but support array of UDT Oracle Not supported Warning Oracle ODP.Net provider does not support UDT PostgreSQL CREATE TYPE public.classifier_rec AS ( Id integer, Name varchar(20) ); CREATE or REPLACE function TestFunction5(p_obj classifier_rec) returns varchar as $$ begin return p_obj.Id || ' - ' || p_obj.Name; end $$ LANGUAGE plpgsql; MySQL Not supported Mapping /* Type mapped to UDT required to be Xml serializable */ [Serializable] public class Classifier { [XmlAttribute] public int Id { get; set; } [XmlAttribute] public string Name { get; set; } } ... [DataObject(\"T\"), Procedure(\"T\", \"TestFunction5\", ProcedureType.Function), Parameter(\"T\", 1, \"p_obj\", typeof(Classifier), DbType.Object, UdtTypeName = \"classifier_rec\" /* Full qualified name of UDT */ ), Parameter(\"T\", 2, \"Result\", typeof(string), DbType.String, Size = 20, Direction = ParameterDirection.ReturnValue)] public class TestFunction5 : IDataObject { public string Result => this.GetParameter(x => x.Result); } SQL procedure with UDT array parameter sample MS SQL Server CREATE TYPE [dbo].[Classifier] AS TABLE( [Id] [int] NULL, [Name] [varchar](20) NULL ) CREATE PROCEDURE [dbo].[TestProcedure7] (@param1 Classifier READONLY) AS SELECT * from @param1 Oracle Not supported Warning Oracle ODP.Net provider does not support UDT PostgreSQL CREATE TYPE public.classifier_rec AS ( Id integer, Name varchar(20) ); CREATE or REPLACE function TestProcedure7(p_tab classifier_rec[]) returns setof classifier_rec as $$ select a.Id, a.Name from unnest(p_tab) a; $$ LANGUAGE sql; MySQL Not supported Mapping /* Type mapped to UDT required to be Xml serializable */ [Serializable] public class Classifier { [XmlAttribute] public int Id { get; set; } [XmlAttribute] public string Name { get; set; } } ... [DataObject(\"T\"), Procedure(\"T\", \"dbo.TestProcedure7\", ProcedureType.Procedure), Parameter(\"T\", 1, \"param1\", typeof(Classifier[]) /* Parameter type must be an array of mapped type */, DbType.Object, UdtTypeName = \"dbo.Classifier\" /* Full qualified name of UDT */ ), ResultSet(\"T\")] public class TestProcedure7 : IDataObject { [Property(\"T\", \"Id\", Flags = DataPropertyFlag.Id)] public int Id => this.GetProperty(x => x.Id); [Property(\"T\", \"Name\")] public string Name => this.GetProperty(x => x.Name); } SQL table valued function as query sample MS SQL Server CREATE FUNCTION [dbo].[TestFunction] ( @param1 int, @param2 varchar(20) ) RETURNS TABLE AS RETURN ( SELECT @param1 as Id, @param2 as Name ) Oracle CREATE OR REPLACE type classifier_rec is object (Id int, Name varchar2(20)); CREATE OR REPLACE type classifier_tab is table of classifier_rec; function TestFunction(p_Id int, p_Name varchar2) return classifier_tab pipelined is begin for curr in (select p_Id as Id, p_Name as Name from dual) loop pipe row (classifier_rec(curr.Id, curr.Name)); end loop; end TestFunction; PostgreSQL CREATE or REPLACE function TestFunction(p_id integer, p_name varchar) returns TABLE ( Id bigint, Name varchar ) as $$ select p_id as Id, p_name as Name; $$ LANGUAGE SQL; ... or with the same mapping syntax... CREATE TYPE public.classifier_rec AS ( Id integer, Name varchar(20) ); CREATE or REPLACE function TestFunction(p_Id integer, p_Name varchar) returns setof classifier_rec as $$ select p_Id as Id, p_Name as Name; $$ LANGUAGE SQL; MySQL Not supported Mapping [DataObject(\"T\"), Procedure(\"T\", \"dbo.TestFunction\", ProcedureType.Function), Parameter(\"T\", 1, \"param1\", typeof(int), DbType.Int32), Parameter(\"T\", 2, \"param2\", typeof(string), DbType.String), ResultSet(\"T\")] public class TestFunction : IDataObject { [Property(\"T\", \"Id\", Flags = DataPropertyFlag.Id)] public int Id { get { return this.GetProperty(x => x.Id); } } [Property(\"T\", \"Name\")] public string Name { get { return this.GetProperty(x => x.Name); } } } Mapping table function with joined table [DataObject(\"D\"), Procedure(\"T\", \"dbo.TestFunction\", ProcedureType.Function), Parameter(\"T\", 1, \"param1\", typeof(int), DbType.Int32), Parameter(\"T\", 2, \"param2\", typeof(string), DbType.String), ResultSet(\"T\"), DataTable(\"T_DOC_TYPE\", \"D\"), Link(\"D\", \"doc_type_id\", \"T\", \"Id\")] public class TestFunctionJoin : IDataObject { [Property(\"T\", \"Id\", Flags = DataPropertyFlag.Id)] public int Id { get; set; } [Property(\"T\", \"Name\")] public string Name { get; set; } [Property(\"D\", \"Code\")] public string Code { get; set; } } SQL scalar function as property data source sample MS SQL Server CREATE FUNCTION [dbo].[TestFunction2] ( @param1 int, @param2 varchar(20) ) RETURNS varchar(20) AS BEGIN DECLARE @res varchar(20) SET @res = convert(varchar(20), @param1) + ' - ' + @param2 RETURN @res END Oracle function TestFunction2(p_Id int, p_Name varchar2) return varchar2 is begin return p_Id || ' - ' || p_Name; end TestFunction2; PostgreSQL CREATE or REPLACE function TestFunction2(p_id integer, p_name varchar) returns varchar as $$ DECLARE ret varchar; begin select p_id || ' - ' || p_name into ret; return ret; end $$ LANGUAGE plpgsql; MySQL create function TestFunction2(p_Id int, p_Name varchar(20)) returns varchar(100) begin declare res varchar(100); select CONCAT(p_Id, ' - ', p_Name) into res; return(res); end Mapping [DataObject(\"T\"), DataTable(\"T_DOC_TYPE\", \"T\"), Column(\"DocTypeId\", typeof(long), Flags = DataPropertyFlag.Id)] public class TestFunction4 : IDataObject { [Property(\"T\")] public string Code { get; set; } [Property(\"T\")] public string Name { get; set; } [Property, // Property expression attribute \"name\" is the name of private static field // with type Calculate<string> and attributed by SqlExpressionAttribute PropertyExpression(\"test\", DataExpressionType.LinqExpression, ExprSize = 20)] public string Test { get { return this.GetProperty(x => x.Test); } } // Private static field with type Calculate<string> and attributed by // SqlExpressionAttribute [SqlExpression] private static Calculate<string> test z => z.SqlFn<string>(\"dbo.TestFunction2\", y => y.Field<long>(\"T\", \"doc_type_id\"), y => y.Field<string>(\"T\", \"name\")) }"
  },
  "tutorial/mapping/static/sample.html": {
    "href": "tutorial/mapping/static/sample.html",
    "title": "Static mapping sample | XData website",
    "keywords": "Static mapping sample <!--MD5=[9fbc3a7cfb9f92e84de8970988e48bb2] class t_catalogue--> t_catalogue catalogue_id code name parent_id <!--MD5=[ea6ea2e31c0cbff1b909b1f0bd59093e] class t_customer--> t_customer customer_id code name <!--MD5=[a6ce46e431db16f1c4014df928aac3e8] class t_doc_cust_type--> t_doc_cust_type doc_cust_type_id code name <!--MD5=[bccea5d0c54fc84e4bad16ab69fd73e7] class t_doc_type--> t_doc_type doc_type_id code name <!--MD5=[5ea577eca533bfca935d04f775d3f167] class t_doc--> t_doc doc_id doc_type_id doc_date generation changed author <!--MD5=[d4ba8adfb5df751cf422e2fad2a28e94] class t_catalogue_doc--> t_catalogue_doc catalogue_id doc_id <!--MD5=[8cca3b0685271c670c4226b30b01cbcf] class t_doc_cust--> t_doc_cust doc_cust_id doc_id customer_id doc_cust_type_id <!--MD5=[fd8c5e68644f1f4fc0b14eca97226ae4] class t_doc_delivery--> t_doc_delivery doc_id delivery_type delivery_date <!--MD5=[dd40a5851c55ff9d7da9b59b2cdb5061] class t_doc_number--> t_doc_number doc_id numb <!--MD5=[710d3dc0240fd500b1d510e138be1447] class t_doc_scan--> t_doc_scan doc_id scan <!--MD5=[5937349b424f6b33ad58af94594dfd63] class t_doc_source--> t_doc_source doc_id source <!--MD5=[4efa0cfa5e1d38a4afda4e219b98680a] class t_doc_state--> t_doc_state doc_state_id code name <!--MD5=[5c02744e5b0455229387a946a811ce2e] class t_doc_doc_state--> t_doc_doc_state doc_id doc_state_id <!--MD5=[0d4a222ed2d2d268b8328f05b8f9e363] class t_doc_history--> t_doc_history doc_history_id doc_id doc_state_id history_date <!--MD5=[d4b45c8a441f4cb1774906928f147529] link t_catalogue to t_catalogue--> parent_id <!--MD5=[b3294211ce75436a8f4d3c51fb151377] link t_doc_type to t_doc--> doc_type_id <!--MD5=[840062eaffe844779ca4f4f301a47d9a] reverse link t_catalogue to t_catalogue_doc--> catalogue_id <!--MD5=[b3a8eac680fbb6e047950cbceafbeb2c] link t_catalogue_doc to t_doc--> doc_id <!--MD5=[7eefc4f6dff794e64e78dcbbfb9c491a] link t_doc to t_doc_cust--> doc_id <!--MD5=[0005336a9822bd19ef61e4ce8910c4c5] reverse link t_doc_cust to t_customer--> customer_id <!--MD5=[131b4a0e76521106752daee341bf156a] reverse link t_doc_cust to t_doc_cust_type--> doc_cust_type_id <!--MD5=[94de7abaa940d64e718a7c3244926e87] reverse link t_doc_delivery to t_doc--> doc_id <!--MD5=[2d23622d96560790c79c16e9140044a4] reverse link t_doc_number to t_doc--> doc_id <!--MD5=[7c459e52799c0d4d655e72449bb91e72] reverse link t_doc_scan to t_doc--> doc_id <!--MD5=[4aa29f824d631e9db9c0b4ff518403cc] reverse link t_doc_source to t_doc--> doc_id <!--MD5=[fdc70aa94f88d88b378c08a646310f88] reverse link t_doc_doc_state to t_doc--> doc_id <!--MD5=[63d405c0f3a8aa08b15fc74dd2b85047] link t_doc_state to t_doc_doc_state--> doc_state_id <!--MD5=[9c004340c543d5fd28395a65d65b76dd] link t_doc to t_doc_history--> doc_id <!--MD5=[ac06e947c28172a1581fe83d17c1f569] reverse link t_doc_history to t_doc_state--> doc_state_id <!--MD5=[a24f9b6c28c3f11eb813d302e9c42a66] @startuml hide circle skinparam ClassHeaderBackgroundColor lightgray skinparam ClassBorderColor black skinparam ClassBorderThickness 1 skinparam ClassBackgroundColor transparrent skinparam ArrowFontSize 8 skinparam ArrowColor black entity t_catalogue { <&key> catalogue_id - - <&code> code name <&arrow-circle-right> //parent_id// } t_catalogue - -{ t_catalogue : parent_id entity t_customer { <&key> customer_id - - <&code> code name } entity t_doc_cust_type { <&key> doc_cust_type_id - - <&code> code name } entity t_doc_type { <&key> doc_type_id - - <&code> code name } entity t_doc { <&key> doc_id - - <&arrow-circle-right> doc_type_id doc_date - - <&tag> generation <&clock> changed <&person> author } t_doc_type -right-{ t_doc : doc_type_id entity t_catalogue_doc { <&key> <&arrow-circle-right> catalogue_id <&key> <&arrow-circle-right> doc_id } t_catalogue_doc -up-{ t_catalogue : catalogue_id t_catalogue_doc - -{ t_doc : doc_id entity t_doc_cust { <&key> doc_cust_id - - <&arrow-circle-right> doc_id <&arrow-circle-right> customer_id <&arrow-circle-right> doc_cust_type_id } t_doc_cust }-up- t_doc : doc_id t_doc_cust }- - t_customer : customer_id t_doc_cust }- - t_doc_cust_type : doc_cust_type_id entity t_doc_delivery { <&key> <&arrow-circle-right> doc_id - - delivery_type delivery_date } t_doc_delivery }o- - t_doc : doc_id entity t_doc_number { <&key> <&arrow-circle-right> doc_id - - numb } t_doc_number }o- - t_doc : doc_id entity t_doc_scan { <&key> <&arrow-circle-right> doc_id - - <&map> scan } t_doc_scan }o- - t_doc : doc_id entity t_doc_source { <&key> <&arrow-circle-right> doc_id - - <&document> source } t_doc_source }o- - t_doc : doc_id entity t_doc_state { <&key> doc_state_id - - <&code> code name } entity t_doc_doc_state { <&key> <&arrow-circle-right> doc_id - - <&arrow-circle-right> doc_state_id } t_doc_doc_state }o-right- t_doc : doc_id t_doc_doc_state }-left- t_doc_state : doc_state_id entity t_doc_history { <&key> doc_history_id - - <&arrow-circle-right> doc_id <&arrow-circle-right> doc_state_id <&clock> history_date } t_doc_history }-up- t_doc : doc_id t_doc_history }- - t_doc_state : doc_state_id @enduml PlantUML version 1.2020.12(Sat Jun 06 10:54:15 UTC 2020) (GPL source distribution) Java Runtime: Java(TM) SE Runtime Environment JVM: Java HotSpot(TM) 64-Bit Server VM Default Encoding: UTF-8 Language: en Country: US --> <!--MD5=[5ea577eca533bfca935d04f775d3f167] class t_doc--> t_doc doc_id doc_type_id doc_date generation changed author <!--MD5=[e871482fb55f9150fc3be5a0e93d8569] class t_doc_spec_type--> t_doc_spec_type doc_spec_type_id code name <!--MD5=[4ed4cd12cd2eeb59e644791b1ec40217] class t_doc_spec--> t_doc_spec doc_spec_id doc_id doc_spec_type_id <!--MD5=[025ac326a6ab31b45989aa42f37da176] class t_doc_spec_amount--> t_doc_spec_amount doc_spec_id amount <!--MD5=[cef6fc7600387b202b7e697154b0ecaf] link t_doc to t_doc_spec--> doc_id <!--MD5=[175fa9f72450b3173fe29432cd7fb745] reverse link t_doc_spec to t_doc_spec_type--> doc_spec_type_id <!--MD5=[542647722f52d6ccd9b263e63b85e2d8] link t_doc_spec to t_doc_spec_amount--> doc_spec_id <!--MD5=[5cb7b5aa399201d5b29efcb8adfe8a65] @startuml hide circle skinparam ClassHeaderBackgroundColor lightgray skinparam ClassBorderColor black skinparam ClassBorderThickness 1 skinparam ClassBackgroundColor transparrent skinparam ArrowFontSize 8 skinparam ArrowColor black entity t_doc { <&key> doc_id - - <&arrow-circle-right> doc_type_id doc_date - - <&tag> generation <&clock> changed <&person> author } entity t_doc_spec_type { <&key> doc_spec_type_id - - <&code> code name } entity t_doc_spec { <&key> doc_spec_id - - <&arrow-circle-right> doc_id <&arrow-circle-right> doc_spec_type_id } t_doc_spec }-left- t_doc : doc_id t_doc_spec }- - t_doc_spec_type : doc_spec_type_id entity t_doc_spec_amount { <&key> <&arrow-circle-right> doc_spec_id - - <&dollar> amount } t_doc_spec_amount }o-left- t_doc_spec : doc_spec_id @enduml PlantUML version 1.2020.12(Sat Jun 06 10:54:15 UTC 2020) (GPL source distribution) Java Runtime: Java(TM) SE Runtime Environment JVM: Java HotSpot(TM) 64-Bit Server VM Default Encoding: UTF-8 Language: en Country: US --> Here is example of data object static mapping. Of course, real mapping is much simpler then this, but as example of XData capabilities it's really representative... SQL representation of following sample: with recursive T (catalogue_id, code, name, parent_id) as ((SELECT R.catalogue_id AS R_catalogue_id, R.code AS R_code, R.name AS R_name, R.parent_id AS R_parent_id FROM T_CATALOGUE R WHERE ((@FilterByRoot is not null and R.catalogue_id = @FilterByRoot) OR (@FilterByRoot is null and R.parent_id is null))) UNION (SELECT S.catalogue_id AS S_catalogue_id, S.code AS S_code, S.name AS S_name, S.parent_id AS S_parent_id FROM T_CATALOGUE S, T T WHERE S.parent_id = (T.catalogue_id))) SELECT CF.CUSTOMER_ID AS CF_CUSTOMER_ID, CF.DOC_CUST_ID AS CF_DOC_CUST_ID, CF.DOC_CUST_TYPE_ID AS CF_DOC_CUST_TYPE_ID, CF.DOC_ID AS CF_DOC_ID, CT.CUSTOMER_ID AS CT_CUSTOMER_ID, CT.DOC_CUST_ID AS CT_DOC_CUST_ID, CT.DOC_CUST_TYPE_ID AS CT_DOC_CUST_TYPE_ID, CT.DOC_ID AS CT_DOC_ID, CAST((SELECT Sum(A.amount) AS A_amount FROM T_DOC_SPEC S JOIN T_DOC_SPEC_AMOUNT A ON A.DOC_SPEC_ID = S.DOC_SPEC_ID WHERE S.doc_id = S.doc_id) AS NUMERIC(17, 5)) AS doc_amount /* DocAmount */, D.doc_date AS D_doc_date /* DocDate */, D.doc_id AS D_doc_id /* DocId */, D.DOC_TYPE_ID AS D_DOC_TYPE_ID, D.generation AS D_generation /* Generation */, D.changed AS D_changed /* Changed */, D.author AS D_author /* Author */, DD.delivery_date AS DD_delivery_date /* DeliveryDate */, DD.delivery_type AS DD_delivery_type /* DeliveryType */, DD.DOC_ID AS DD_DOC_ID, DS.DOC_DOC_STATE_ID AS DS_DOC_DOC_STATE_ID, DS.DOC_ID AS DS_DOC_ID, DS.DOC_STATE_ID AS DS_DOC_STATE_ID, F.CODE AS F_CODE, F.CUSTOMER_ID AS F_CUSTOMER_ID, F.name AS F_name /* CustomerFrom */, H.H_doc_id AS H_H_doc_id, H.H_history_date AS H_H_history_date /* DocLastChange */, N.DOC_ID AS N_DOC_ID, N.numb AS N_numb /* DocNumb */, S.code AS S_code /* DocStateCode */, S.DOC_STATE_ID AS S_DOC_STATE_ID, S.name AS S_name /* DocState */, SC.DOC_ID AS SC_DOC_ID, SC.scan AS SC_scan /* Scan */, SR.DOC_ID AS SR_DOC_ID, SR.source AS SR_source /* Source */, ST.S_doc_id AS ST_S_doc_id, T.CODE AS T_CODE, T.CUSTOMER_ID AS T_CUSTOMER_ID, T.name AS T_name /* CustomerTo */ FROM T_DOC D JOIN T_DOC_DOC_STATE DS ON DS.doc_id = D.doc_id JOIN T_DOC_STATE S ON S.DOC_STATE_ID = DS.DOC_STATE_ID JOIN T_DOC_NUMBER N ON N.doc_id = D.doc_id JOIN T_DOC_CUST CF ON CF.doc_id = D.doc_id JOIN T_DOC_CATALOGUE DC ON DC.doc_id = D.doc_id JOIN T_CATALOGUE U ON DC.catalogue_id = U.catalogue_id JOIN T_CUSTOMER F ON F.CUSTOMER_ID = CF.CUSTOMER_ID JOIN T_DOC_CUST CT ON CT.doc_id = D.doc_id JOIN T_CUSTOMER T ON T.CUSTOMER_ID = CF.CUSTOMER_ID LEFT OUTER JOIN T_DOC_SCAN SC ON SC.doc_id = D.doc_id LEFT OUTER JOIN T_DOC_SOURCE SR ON SR.doc_id = D.doc_id LEFT OUTER JOIN T_DOC_DELIVERY DD ON DD.doc_id = D.doc_id LEFT OUTER JOIN (SELECT H.doc_id AS H_doc_id, H.history_date AS H_history_date FROM T_DOC_HISTORY H) H ON D.doc_id = H.H_doc_id JOIN (SELECT S.doc_id AS S_doc_id FROM T_DOC_SPEC_TYPE ST JOIN T_DOC_SPEC S ON S.DOC_SPEC_TYPE_ID = ST.DOC_SPEC_TYPE_ID WHERE ST.code = @FilterBySpecTypeCode) ST ON D.doc_id = ST.S_doc_id WHERE D.DOC_TYPE_ID = (select doc_type_id from T_DOC_TYPE where code='INVOICE') AND CF.DOC_CUST_TYPE_ID = (select doc_cust_type_id from T_DOC_CUST_TYPE where code='FROM') AND CF.DOC_CUST_TYPE_ID = (select doc_cust_type_id from T_DOC_CUST_TYPE where code='TO') AND D.doc_id = @FilterByDocId AND DC.catalogue_id in (SELECT T.catalogue_id AS T_catalogue_id FROM T T) Mapping sample: [DataObject(\"D\", LogicAssemblyName = \"XDataObjectTest\"), DataTable(\"T_DOC\", \"D\"), DictionaryFilter(\"T_DOC_TYPE\", \"doc_type_id\", \"code\", \"INVOICE\", \"D\"), DataTable(\"T_DOC_DOC_STATE\", \"DS\", Parent = \"D\"), Link(\"D\", \"doc_id\", \"DS\"), DataTable(\"T_DOC_STATE\", \"S\"), Link(\"DS\", \"doc_state_id\", \"S\"), DataTable(\"T_DOC_NUMBER\", \"N\", Parent = \"D\"), Link(\"D\", \"doc_id\", \"N\"), DataTable(\"T_DOC_CUST\", \"CF\", Parent = \"D\"), Link(\"D\", \"doc_id\", \"CF\"), DataTable(\"T_CUSTOMER\", \"F\"), Link(\"CF\", \"customer_id\", \"F\"), DictionaryFilter(\"T_DOC_CUST_TYPE\", \"doc_cust_type_id\", \"code\", \"FROM\", \"CF\"), DataTable(\"T_DOC_CUST\", \"CT\", Parent = \"D\"), Link(\"D\", \"doc_id\", \"CT\"), DataTable(\"T_CUSTOMER\", \"T\"), Link(\"CT\", \"customer_id\", \"T\"), DictionaryFilter(\"T_DOC_CUST_TYPE\", \"doc_cust_type_id\", \"code\", \"TO\", \"CT\"), DataTable(\"T_DOC_SCAN\", \"SC\", Parent = \"D\"), Link(\"D\", \"doc_id\", \"SC\", Operation = FilterOperation.OuterJoin), DataTable(\"T_DOC_SOURCE\", \"SR\", Parent = \"D\"), Link(\"D\", \"doc_id\", \"SR\", Operation = FilterOperation.OuterJoin), DataTable(\"T_DOC_DELIVERY\", \"DD\", Parent = \"D\"), Link(\"D\", \"doc_id\", \"DD\", Operation = FilterOperation.OuterJoin), DataTable(\"T_DOC_CATALOGUE\", \"DC\", Parent = \"D\"), Link(\"D\", \"doc_id\", \"DC\"), DataTable(\"T_CATALOGUE\", \"U\"), Link(\"U\", \"catalogue_id\", \"DC\"), Subquery(\"A\", typeof(DocSpecAmounts), \"Amount\", Grouping = DataGrouping.Sum), SubqueryLink(\"A\", \"DocId\"), InnerView(\"H\", typeof(DocLastChange)), SubqueryLink(\"H\", \"DocId\", Operation = FilterOperation.OuterJoin), ExternalLink(typeof(InvoiceSpec), \"DocId\"), InnerView(\"ST\", typeof(DocBySpecType)), SubqueryLink(\"ST\", \"DocId\"), Subquery(\"UT\", typeof(CatalogueTree), \"CatalogueId\"), SubqueryFilter(\"UT\", \"DC\", \"catalogue_id\", Operation = FilterOperation.In), Column(\"DocId\", typeof(long?), \"D\", Flags = DataPropertyFlag.Id), Column(\"DocStateId\", typeof(long), \"S\"), Column(\"FromCustomerId\", typeof(long), \"F\"), Column(\"ToCustomerId\", typeof(long), \"T\"), Column(\"CatalogueId\", typeof(long), \"U\"), ColumnDefault(\"DocId\", DefaultType.AutoIncrement)] public class Invoice: IDataObject { [Property(\"S\", \"code\")] public string DocStateCode { get { return this.GetProperty(x => x.DocStateCode); } } [Property(\"S\", \"name\"), LinkProperty(\"Name\"), LinkProperty(Property = \"DocStateId\"), LinkProperty(\"Code\", \"DocStateCode\")] public Link<string, DocState> DocState { get; set; } [Property(\"U\", \"name\"), LinkProperty(Property = \"CatalogueId\"), LinkProperty(\"Name\")] public Link<string, Catalogue> DocCatalog { get; set; } [Property(\"N\", \"numb\")] public string DocNumb { get; set; } [Property(\"D\"), PropertyDefault(DefaultType.CurrentDate)] public DateTime? DocDate { get; set; } [Property(\"D\", Flags = DataPropertyFlag.ConcurrencyToken), PropertyDefault(DefaultType.AutoIncrement)] public long Generation { get { return this.GetProperty(x => x.Generation); } } [Property(\"D\"), PropertyDefault(DefaultType.CurrentDateTime, DefaultFeature = DefaultFeature.UseOnUpdate)] public DateTime Changed { get { return this.GetProperty(x => x.Changed); } } [Property(\"D\"), PropertyDefault(DefaultType.UserName, DefaultFeature = DefaultFeature.UseOnUpdate)] public string Author { get { return this.GetProperty(x => x.Author); } } [Property, PropertyExpression(\"A\", DataExpressionType.SubQuery, DbType.Decimal, ExprSize = 17, ExprScale = 5)] public decimal? DocAmount { get { return this.GetProperty(x => x.DocAmount); } } [Reference(\"H\", \"HistoryDate\")] public DateTime? DocLastChange { get { return this.GetProperty(x => x.DocLastChange); } } [Property(\"SC\", Flags = DataPropertyFlag.OuterFlag)] public Lob Scan { get; set; } [Property(\"SR\", Flags = DataPropertyFlag.OuterFlag)] public Xml Source { get; set; } [Property(\"F\", \"name\"), LinkProperty(\"CustomerId\", \"FromCustomerId\"), LinkProperty(\"Name\")] public Link<string, Customer> CustomerFrom { get; set; } [Property(\"T\", \"name\"), LinkProperty(\"CustomerId\", \"ToCustomerId\"), LinkProperty(\"Name\")] public Link<string, Customer> CustomerTo { get; set; } [Property(\"DD\")] public DeliveryTypeEnum DeliveryType { get; set; } [Property(\"DD\"), PropertyDefault(DefaultType.CurrentDate)] public DateTime? DeliveryDate { get; set; } public IRepository<InvoiceSpec> Spec { get { return this.GetRepository().GetChild<InvoiceSpec>(); } } }"
  },
  "tutorial/mapping/static/parameters.html": {
    "href": "tutorial/mapping/static/parameters.html",
    "title": "Mapping parameters | XData website",
    "keywords": "Mapping parameters All statically mapped classes must be marked with DataObjectAttribute . Parameters of DataObjectAttribute : BaseTable - alias of base table (optional, default is virtual table with empty alias), Context - database context (optional, context will be specified at runtime), and Flags - data source flags (optional, default is None ). Example: [DataObject(\"D\" /* base table alias */, Context: \"Main\", Flags: DataObjectFlags.ReadOnly)] The DataObjectAttribute attribute can also be used to inherit the mapping description of the data object. To do this, an alternative constructor is used that allows you to limit BaseMappingType - the base object in the inheritance hierarchy of the mapping description. The BaseMappingType class must implement the ISqlObject interface but does not have to be associated with the current class. The depth of the inheritance hierarchy of the mapping description is not limited. [DataObject(typeof(ParentDescription))] Warning When inheriting mapping descriptions, a mixture of the static and dynamic description methods within the a single mapping inheritance hierarchy is not allowed!"
  },
  "tutorial/mapping/static/external_link.html": {
    "href": "tutorial/mapping/static/external_link.html",
    "title": "External link | XData website",
    "keywords": "External link External link can be statically defined using ExternalLinkAttribute with parameters: ChildType - detail repository mapped type, ChildProperty - link property in detail repository, Property - optional, link property in master repository, default used same name as ChildProperty , FilterName - optional, detail repository filter name, default used \"FilterBy\" + ChildProperty , MasterRefresh - optional, refresh master repository current row data on submit detail changes flag (useful when master has calculated properties over detail repository data), default is false , DirectLink - optional, see tree master-detail specifics for details, default is false Operation - optional, link filter operation (see Filters ), default FilterOperation . Equal , Nullable - optional, filter null processing behavior , default is FilterNullable . Nullable , Combination - optional, filter group name in detail repository. External links can be used in optional filters description (see Optional filters and optional subqueries ). To specify external link is optional filter part You can set primary filter flag PrimaryFilter . [ExternalLink(typeof(InvoiceSpec), \"DocId\")]"
  },
  "tutorial/mapping/static/datatable.html": {
    "href": "tutorial/mapping/static/datatable.html",
    "title": "Tables | XData website",
    "keywords": "Tables All tables in repository query must to be specified using DataTableAttribute . Parameters of DataTableAttribute : Name - name of table and Alias - table alias in query. Tables in updatable tables hierarchy , but not base table must to specify Parent parameter of this attribute - alias of parent table in updatable tables hierarchy. [DataTable(\"P\" /* table alias */, \"patient\" /* table name */, \"D\" /* parent table alias */)] Same way we can define mapping to view, but all fields of view must to be explicitly defined as read-only properties or columns ."
  },
  "tutorial/mapping/dynamic/property/grouping.html": {
    "href": "tutorial/mapping/dynamic/property/grouping.html",
    "title": "Property grouping parameters | XData website",
    "keywords": "Property grouping parameters Property grouping parameters used when data object mapped to grouped query to specify property role in GROUP BY expression. Use one of IPropertyMappingAdapter interface Group method overload: Group(int groupOrder) - when property mapped to field query grouped by with N-th order Group(DataGrouping grouping) - when property mapped to aggregation function over field ... HistoryDate = x.Field<DateTime?>(\"H\", string.Empty, z => z.Group(DataGrouping.Max)) ..."
  },
  "tutorial/mapping/dynamic/property/default.html": {
    "href": "tutorial/mapping/dynamic/property/default.html",
    "title": "Property default value | XData website",
    "keywords": "Property default value To set default value of property with dynamic mapping, use one of IRepositoryPropertyMappingAdapter<T, TValue> interface Default method overload: Default(DefaultType source) - use with DefaultType.AutoIncrement , DefaultType.CurrentDate , DefaultType.CurrentDateTime , DefaultType.CurrentDateTimeUtc , DefaultType.NewGuid , DefaultType.UserName where default value assigned data row on insert only Default(DefaultType source, DefaultFeature features) - use with DefaultType.AutoIncrement , DefaultType.CurrentDate , DefaultType.CurrentDateTime , DefaultType.CurrentDateTimeUtc , DefaultType.NewGuid , DefaultType.UserName where default value assigned data row on insert or update Default(DefaultType source, TValue value) - use with DefaultType.Const or DefaultType.Variable where default value assigned data row on insert only Default(DefaultType source, TValue value, DefaultFeature features) - use with DefaultType.Const or DefaultType.Variable where default value assigned data row on insert or update ... .ReadOnlyProperty(x => x.Changed, x => x.Field<DateTime>(\"D\", string.Empty, z => z.Default(DefaultType.CurrentDateTime, DefaultFeature.UseOnUpdate))) ..."
  },
  "tutorial/mapping/dynamic/property/column.html": {
    "href": "tutorial/mapping/dynamic/property/column.html",
    "title": "Hidden properties | XData website",
    "keywords": "Hidden properties Hidden properties dynamically defined using Column method call of IRepositoryStructure<T> interface. Hidden property can be mapped to: data source field - Field<TVal> SQL expression (see detailed description above ) - Expr<TVal> inner view property (see detailed description below ) - Ref<TVal> ... .Column(\"DocId\", x => x.Field<long?>(\"D\", string.Empty, z => z.Key(), z => z.Default(DefaultType.AutoIncrement))) ..."
  },
  "tutorial/mapping/dynamic/procedure/source.html": {
    "href": "tutorial/mapping/dynamic/procedure/source.html",
    "title": "SQL procedure as query | XData website",
    "keywords": "SQL procedure as query To define procedure as data source of mapping used Procedure method call of IRepositoryStructure<T> interface."
  },
  "tutorial/mapping/dynamic/procedure/sample_udt_array.html": {
    "href": "tutorial/mapping/dynamic/procedure/sample_udt_array.html",
    "title": "SQL procedure with UDT array parameter sample | XData website",
    "keywords": "SQL procedure with UDT array parameter sample MS SQL Server CREATE TYPE [dbo].[Classifier] AS TABLE( [Id] [int] NULL, [Name] [varchar](20) NULL ) CREATE PROCEDURE [dbo].[TestProcedure7] (@param1 Classifier READONLY) AS SELECT * from @param1 Oracle Not supported Warning Oracle ODP.Net provider does not support UDT PostgreSQL CREATE TYPE public.classifier_rec AS ( Id integer, Name varchar(20) ); CREATE or REPLACE function TestProcedure7(p_tab classifier_rec[]) returns setof classifier_rec as $$ select a.Id, a.Name from unnest(p_tab) a; $$ LANGUAGE sql; MySQL Not supported Dynamic query /* Type mapped to UDT required to be Xml serializable */ [Serializable] public class Classifier { [XmlAttribute] public int Id { get; set; } [XmlAttribute] public string Name { get; set; } } ... var param = new[] { new Classifier { Id = 1, Name = \"Test\" }, new Classifier { Id = 2, Name = \"Some\" } }; var f4 = XDataMapping.GetStructure(\"T\") .Procedure(\"T\", \"dbo.TestProcedure7\", ProcedureType.Procedure) .Parameter<Classifier[]>(\"T\", 1, \"param1\", DbType.Object, z => z.UdtDataType(null, \"dbo.Classifier\")) .Return(\"T\") .Call(DataScope, string.Empty, \"param1\".SetVar(param)); foreach (var classifier in res) Console.WriteLine(\"{0} - \\\"{1}\\\"\", classifier.Id, classifier.Name); Mapping /* Type mapped to UDT required to be Xml serializable */ [Serializable] public class Classifier { [XmlAttribute] public int Id { get; set; } [XmlAttribute] public string Name { get; set; } } ... .Procedure(\"T\", \"dbo.TestProcedure7\", ProcedureType.Procedure) .Parameter<Classifier[]>(\"T\", 1, \"param1\", DbType.Object, z => z.UdtDataType(null, \"dbo.Classifier\")) .Return(\"T\") .Map(x => new TestProcedure { Id = x.Field<int>(\"T\", string.Empty, z => z.Key()), Name = x.Field<string>(\"T\", string.Empty) }) .SetBaseTable(\"T\")"
  },
  "tutorial/mapping/dynamic/procedure/sample_udt.html": {
    "href": "tutorial/mapping/dynamic/procedure/sample_udt.html",
    "title": "SQL procedure with UDT parameter sample | XData website",
    "keywords": "SQL procedure with UDT parameter sample MS SQL Server Not supported Tip MS SQL Server does not support passing single UDT object as a parameter value, but support array of UDT Oracle Not supported Warning Oracle ODP.Net provider does not support UDT PostgreSQL CREATE TYPE public.classifier_rec AS ( Id integer, Name varchar(20) ); CREATE or REPLACE function TestFunction5(p_obj classifier_rec) returns varchar as $$ begin return p_obj.Id || ' - ' || p_obj.Name; end $$ LANGUAGE plpgsql; MySQL Not supported Dynamic query /* Type mapped to UDT required to be Xml serializable */ [Serializable] public class Classifier { [XmlAttribute] public int Id { get; set; } [XmlAttribute] public string Name { get; set; } } ... var f5 = XDataMapping.GetStructure(\"T\") .Procedure(\"T\", \"TestFunction5\", ProcedureType.Function) .Parameter<Classifier>(\"T\", 1, \"p_obj\", DbType.Object, z => z.UdtDataType(\"classifier_rec\")) .Parameter<string>(\"T\", 3, \"result\", DbType.String, z => z.Size(20), z => z.Direction(ParameterDirection.ReturnValue)) .Call(DataScope, \"p_obj\".SetVar( new Classifier { Id = 1, Name = \"Test\" })); Console.WriteLine(f5.GetParameter<string>(\"result\")); Mapping /* Type mapped to UDT required to be Xml serializable */ [Serializable] public class Classifier { [XmlAttribute] public int Id { get; set; } [XmlAttribute] public string Name { get; set; } } ... .Procedure(\"T\", \"TestFunction5\", ProcedureType.Function) .Parameter<Classifier>(\"T\", 1, \"p_obj\", DbType.Object, z => z.UdtDataType(\"classifier_rec\")) .Parameter<string>(\"T\", 3, \"result\", DbType.String, z => z.Size(20), z => z.Direction(ParameterDirection.ReturnValue)) .Map() .SetBaseTable(\"T\") ... public class TestFunction5 : IDataObject { public string Result => this.GetParameter(x => x.Result); }"
  },
  "tutorial/mapping/tree.html": {
    "href": "tutorial/mapping/tree.html",
    "title": "Tree | XData website",
    "keywords": "Tree XData can use CTE (common table expression) as part of repository data source definition. Supported as plain (WITH), as recursive (WITH RECURSIVE) expressions. CTE is defined in mapping differently for static and dynamic mapping paradigm, but it can be used with similar way: defined one or more tables with unique aliases and name equals CTE name. Recursive CTE can be used as independent data source too. In this case CTE name must to be declared as base table of repository."
  },
  "tutorial/mapping/reference.html": {
    "href": "tutorial/mapping/reference.html",
    "title": "Child repositories references | XData website",
    "keywords": "Child repositories references Detail related repositories XData require to perform as: public IRepository<InvoiceSpec> Spec { get { return this.GetRepository().GetChild<InvoiceSpec>(); } } No additional mapping description are needed. Only external reference is required. Tip To use hierarchical objects and XData Unit of Work realization ( WorkSet ), child repositories references are required."
  },
  "tutorial/mapping/readonly.html": {
    "href": "tutorial/mapping/readonly.html",
    "title": "Read only properties | XData website",
    "keywords": "Read only properties Read only properties XData require to perform as in example below: public string DocStateCode { get { return this.GetProperty(x => x.DocStateCode); } } Data access is provided through extension method GetProperty , but property is read only."
  },
  "tutorial/mapping/procedures.html": {
    "href": "tutorial/mapping/procedures.html",
    "title": "SQL functions & procedures | XData website",
    "keywords": "SQL functions & procedures Stored procedures and functions can be used as data source of mapping (if used DBMS and ADO .Net provider is support this). Important At this moment we has various limitations of using SQL procedures as on DBMS SQL dialect level, as on ADO .Net provider realization level. Please, choose DBMS and ADO .Net provider with keep in mind limitations they have. XData support many procedure mapping styles and call conventions, but can not garant all of them is supported by DBMS and ADO .Net provider You choose. XData has support followed SQL procedure mapping styles and call conventions and it combinations: Using procedure result set as data source Using procedure with multiple result sets Using out parameters Using return value of stored procedure Using simple type array as parameter Using cursor as parameter Using UTD (user defined type) as parameter Using table valued function as data source Using scalar function as single property source Warning Class mapped to UDT must support native XML serialization! All this mapping features described as for static as for dynamic mapping paradigm."
  },
  "tutorial/versions.html": {
    "href": "tutorial/versions.html",
    "title": "Versions of XData | XData website",
    "keywords": "Versions of XData XData delivered as two specific versions: .Net 4.0 package to use with full featured Windows .Net framework version 4.0 or later, and cross platformed .Net Standard 2.0 package. The versions has similar API but some different implementations of certain features: 1) Different initialization of XData: Net 4.0: using (var dataEngine = XDataManager.InitXData(x => x.UseConfiguration(ConfigurationManager .OpenExeConfiguration(ConfigurationUserLevel.None)))) { using (var dataScope = dataEngine.NewDataScope()) { foreach(var data in dataScope.GetRepository<SomeObject>()) Console.WriteLine(string.Format(\"{0}, {1}\", data.SomeId, data.Name)); } } NetStandard 2.0: //Set configuration file var builder = new ConfigurationBuilder(); builder.AddXmlFile(\"MyConsoleApp.config\"); var configFile = builder.Build(); //Set services using(var serviceProvider = new ServiceCollection() .AddLogging() // Localization only for ASP.NET Core .AddSingleton(typeof(IStringLocalizerFactory), x => null) .AddSingleton(typeof(IConfigurationRoot), x => configFile) .AddXData() .BuildServiceProvider()) { //Configure logging serviceProvider.GetRequiredService<ILoggerFactory>() .AddConsole(LogLevel.Warning).AddDebug(); var dataEngine = serviceProvider.GetRequiredService<IDataEngine>(); using (var dataScope = dataEngine.NewDataScope()) { foreach(var data in dataScope.GetRepository<SomeObject>()) Console.WriteLine($\"{data.SomeId}, {data.Name}\"); } } 2) Logging in .Net 4.0 version is realized with log plugins implements ILogWriter interface. Logging in .Net Standard 2.0 version is realized using Microsoft.Extensions.Logging service. 3) Configuration of .Net 4.0 version is limited by using app.config/web.config files. Configuration in .Net Standard 2.0 version is realized using Microsoft.Extensions.Configuration service. Configuration structure for both versions described here . 4) Localization of .Net 4.0 version use satellite localization assemblies. Localization in .Net Standard 2.0 version is realized using Microsoft.Extensions.Localization service. Localization procedures for both versions described here . 5) Some database adapters not implemented for .Net Standard 2.0 version because no applicable implementation of .Net data providers for .Net Standard 2.0 found now. We are hope they will be implemented in short time future, and XData can be use that databases too. 6) Three tier architecture is not implemented for .Net Standard 2.0 version for now. Some limitations of current .Net Core realization makes not possible to implement this feature on same technologies now. And no specific requests to implement it quick as possible. 7) Three tier client plugin required full .Net 4.0 framework only (base functionality is available on .Net 4.0 Client version). Life time limited cache (for IDataScope and WorkSet ) is required full .Net 4.0 framework. Same caching functionality is implemented in .Net Standard 2.0 version."
  },
  "tutorial/using.html": {
    "href": "tutorial/using.html",
    "title": "Basic operations with data | XData website",
    "keywords": "Basic operations with data Data engine, data scope and repository To start using XData You need get IDataEngine interface reference (see examples below). It will be used to create new data scopes using NewDataScope method. XData use data scope isolation when same typed repositories used by multiple logic at the same time. Data scope is represented by IDataScope interface. Data scope identified by Layer (GUID). Important IDataScope is IDisposable . When disposing IDataScope all repositories, opened at this scope are disposed and XData free all memory used by this data scope. To get data object instances of type T it's required to get typed repository interface IRepository<T> using method GetRepository<T> of IDataScope . Tip IRepository is also IDisposable . When disposing IRepository it's data cache cleared. You can dispose repositories manually, but if not, disposing data scope will free that repository resources. Recommended to dispose large data repositories manually to reduce memory utilized by application. While repository is not disposed inside data scope it can be requested many times without recreating and database access and GetRepository<T> method of same IDataScope returns the same instance of repository. Net 4.0: using (var dataEngine = XDataManager.InitXData(x => x.UseConfiguration(ConfigurationManager .OpenExeConfiguration(ConfigurationUserLevel.None)))) { using (var dataScope = dataEngine.NewDataScope()) { foreach(var data in dataScope.GetRepository<SomeObject>()) Console.WriteLine(string.Format(\"{0}, {1}\", data.SomeId, data.Name)); } } NetStandard 2.0: //Set configuration file var builder = new ConfigurationBuilder(); builder.AddXmlFile(\"MyConsoleApp.config\"); var configFile = builder.Build(); //Set services using(var serviceProvider = new ServiceCollection() .AddLogging() // Localization only for ASP.NET Core .AddSingleton(typeof(IStringLocalizerFactory), x => null) .AddSingleton(typeof(IConfigurationRoot), x => configFile) .AddXData() .BuildServiceProvider()) { //Configure logging (logger messages minimal allowed levels can be set using config file) serviceProvider.GetRequiredService<ILoggerFactory>() .AddConsole(LogLevel.Warning).AddDebug(LogLevel.Debug); var dataEngine = serviceProvider.GetRequiredService<IDataEngine>(); using (var dataScope = dataEngine.NewDataScope()) { foreach(var data in dataScope.GetRepository<SomeObject>()) Console.WriteLine($\"{data.SomeId}, {data.Name}\"); } } Data object properties access Read/write properties using has no specifics: var invoice = dataScope.GetRepository<Invoice>().First(); invoice.DocNumb = \"12345\"; Except Link , Lob and Xml discussed below . Changing data It's possible to change data object properties with assignment operator (except Link , Lob and Xml discussed below ): var newInvoice = dataScope.GetRepository<Invoice>().New(); newInvoice.DocNumb = String.Format(\"Inv-{0}\", number.ToString(CultureInfo.InvariantCulture).PadLeft(6, '0')); newInvoice.Submit(); To edit data of new object You can also use New method overload with initialization logic wrapper: return dataScope.GetRepository<Invoice>().New( //property DocNumb is a sting assigned as usual z => z.DocNumb = String.Format(\"Inv-{0}\", number.ToString(CultureInfo.InvariantCulture).PadLeft(6, '0')), //property DocCatalog - link to data object typed Catalog //assignment using += operator is the same as DocCatalog.Source = ... z => z.DocCatalog += dataScope.GetDictionaryValue<Catalog>(x => x.Code == catalogCode), //property DeliveryType is enum DeliveryTypeEnum z => z.DeliveryType = DeliveryTypeEnum.PickUp, //property DeliveryDate is DateTime z => z.DeliveryDate = DateTime.Today.AddDays(1), //property Source is Xml, assignment using += operator is the same as //Source.Document = ... z => z.Source += new XDocument( new XElement(\"invoice\", new XAttribute(\"number\", number), new XAttribute(\"state\", z.DocStateCode))), //property Source - is a large binary object (Lob) and assignment using += operator //is the same as Scan.Value = ... z => z.Scan += Encoding.UTF8.GetBytes(z.Source.Document.ToString ).Submit(out _); Or Modify method extension to change object data: var invoice = dataScope.GetRepository<Invoice>() .SingleOrDefault(x => x.DocNumb.Like($\"%0{number}\") && x.DocStateCode == oldStateCode); if (invoice == null) return true; return invoice.Modify( z => z.DocState += dataScope.GetDictionaryValue<DocState>(x => x.Code == newStateCode), z => z.Source.Modify(doc => doc.Element(\"invoice\").Attribute(\"state\").Value = newStateCode)) .Submit(out _); Delete XData has ability to mark data object as deleted. Before submit changes this flag can be undone. Marking and rejecting the mark can be done with extension method of interface IDataObject.SetDeleted invoice.SetDeleted(true); // mark data object for delete ... invoice.SetDeleted(false); // undone delete mark ... //... and little more complex example: // set the delete flag and submit changes with submit success flag returning return invoice.SetDeleted(true).Submit(out _); Tip To delete a number of objects at once, it's a handy to use ICollection<T>.SetDeleted extension method. Submit changes To submit changes can be used extension method of interface IDataObject Submit newInvoice.Submit(out var invoice); var docTypeCode = invoice.DocTypeCode; To submit changes applied to multiple data objects of the same type can be used IRepository<T>.Submit method accepted ( IEnumerable<T> ) as one of parameters. When object is not changed this method will skip it while updating database. Mapping declaration To use the repository, required to describe the object-relational mapping rule for the type of repository objects. XData has two styles of mapping definition static - based on attribute assignment and dynamic - LINQ style mapping description. SQL representation of samples below: SELECT A.amount AS A_amount /* Amount */, A.DOC_SPEC_ID AS A_DOC_SPEC_ID, DS.doc_id AS DS_doc_id /* DocId */, DS.doc_spec_id AS DS_doc_spec_id /* DocSpecId */, DS.DOC_SPEC_TYPE_ID AS DS_DOC_SPEC_TYPE_ID, ST.code AS ST_code /* Code */, ST.DOC_SPEC_TYPE_ID AS ST_DOC_SPEC_TYPE_ID, ST.name AS ST_name /* Name */ FROM T_DOC_SPEC DS JOIN T_DOC_SPEC_AMOUNT A ON A.DOC_SPEC_ID = DS.DOC_SPEC_ID JOIN T_DOC_SPEC_TYPE ST ON ST.DOC_SPEC_TYPE_ID = DS.DOC_SPEC_TYPE_ID Static mapping description sample: [DataObject(\"DS\"), DataTable(\"T_DOC_SPEC\", \"DS\"), DataTable(\"T_DOC_SPEC_AMOUNT\", \"A\", Parent = \"DS\"), DataTable(\"T_DOC_SPEC_TYPE\", \"ST\"), Link(\"A\", \"doc_spec_id\", \"DS\"), Link(\"ST\", \"doc_spec_type_id\", \"DS\"), Column(\"DocSpecId\", typeof(long), \"DS\", Flags = DataPropertyFlag.Id), ColumnDefault(\"DocSpecId\", DefaultType.AutoIncrement), Column(\"DocSpecTypeId\", typeof(long), \"ST\"), Column(\"DocId\", typeof(long), \"DS\")] public class InvoiceSpec: IDataObject { [Property(\"ST\"), LinkProperty, LinkProperty(Property = \"DocSpecTypeId\"), LinkProperty(Property = \"Code\")] public Link<string, DocSpecType> Name { get; set; } [Property(\"ST\")] public string Code { get { return this.GetProperty(x => x.Code); } } [Property(\"A\")] public decimal Amount { get; set; } } Dynamic mapping description sample: public partial class InvoiceSpec: IDataObject { private static Expression<CustomMapping<InvoiceSpec>> _mapping = ( () => XDataMapping.CustomMapping<InvoiceSpec>() .DataTable(\"T_DOC_SPEC\", \"DS\") .DataTable(\"T_DOC_SPEC_AMOUNT\", \"A\", \"DS\", x => x.Link(\"DS\", \"doc_spec_id\")) .DataTable(\"T_DOC_SPEC_TYPE\", \"ST\", x => x.Link(\"DS\", \"doc_spec_type_id\")) .Column(\"DocSpecId\", x => x.Field<long>(\"DS\", string.Empty, z => z.Key(), z => z.Default(DefaultType.AutoIncrement))) .Column(\"DocSpecTypeId\", x => x.Field<long>(\"ST\", string.Empty)) .Column(\"DocId\", x => x.Field<long>(\"DS\", string.Empty)) .Map(x => new InvoiceSpec { Name = x.Link<string, DocSpecType>(\"ST\", \"name\", z => z.LinkProperty<DocSpecType>(y => y.Name), z => z.LinkProperty<DocSpecType>((InvoiceSpec y) => y.Code)), Amount = x.Field<decimal>(\"A\", string.Empty) }).SetBaseTable(\"DS\")); } public partial class InvoiceSpec { public Link<string, DocSpecType> Name { get; set; } public string Code { get { return this.GetProperty(x => x.Code); } } public decimal Amount { get; set; } } Detailed description of static and dynamic methods of mapping described in relevant sections."
  },
  "tutorial/unit_of_work.html": {
    "href": "tutorial/unit_of_work.html",
    "title": "Processing of related objects (Unit of Work) | XData website",
    "keywords": "Processing of related objects (Unit of Work) XData has supported processing data object mapped to number of tricky related tables. Transactional support is required to apply changes over various but related data objects. For example we have a business object having one ore more related objects collections. Every one of thous can have related collections of other objects and so on. And some business logic works with this related conglomerate as single complicated entity required submitted into DB using one transaction. XData is support using transaction , but some non terminal data objects can be inserted inside the same transaction and writing code that can support this case is a non trivial thing. Common but elegant way to make it simple and clear is a realizing \"Unit of Work\" pattern. Most of ORM has own realization of this pattern, but XData using this mechanic on right level of business logic - to operate with related conglomerate of business objects. Using of Unit of Work pattern with XData is pure declarative: no custom business logic classes is needed to use it. Lets describe this by example: Initialization of new UoW container for new root object is described using static Add method of the Work class: var rep = dataScope.GetRepository<Model.Patient>(Instance); var instance = rep.New(); /* Using static class Work we init UoW container with new root object and describe collections of related objects. Because of new root object we use Work.Empty method to initialize that collections without fetching any data. */ using (var work = Work.Add(instance, Work.Empty<Model.Patient, Model.PatientDiagnosis>() .Empty<Model.Patient, Model.PatientOper>())) { if (new PatientWindow { DataContext = instance, Owner = window } .ShowDialog() == true) work.Submit(); // submitting UoW container changes } Initialization of UoW container for existing object (update): /* Using static class Work we init UoW container over existed root object and describe collections of related objects. Because of root object is exists collections will be filled from DB using Work.Fill method. */ using (var work = Work.Add(patient, Work.Fill<Model.Patient, Model.PatientDiagnosis>() .Fill<Model.Patient, Model.PatientOper>())) { if (new PatientWindow { DataContext = patient, Owner = window } .ShowDialog() != true) return; work.Submit(); // submitting UoW container changes } Initialization of single related object inside of UoW container (one-to-one relationship) is described by Add method, that analog to Empty and Fill methods we use before. UoW container can be initialized with a not only single root object, but using collection of root objects with overloaded Add method that accept an collection ( ICollection ) of root objects. To select a single object form UoW container use Get method. This method can accept predicate as parameter to specify unique condition of object selection. After acquiring a single object we can change it (or delete it as explained in followed example): _patient = work.Get(); _patient.SetDeleted(True); To select multiple objects from UoW container can be made using Select method: var newOperations = work.Child<Model.PatientOper>() .Select(x => x.Date > startDate); To acquire detail UoW container we can use Child method. This method can accept predicate to select root object when root container has initialized by collection of objects. New related object can be added to detail UoW container using New method we discussed above: work.Child<Model.PatientOper>() .New(x => x.SomeField = 42, x => x.OtherField = \"some\"); Important Unit of Work realization is not internal part of XData. It can be attached to Your project when this functionality is really needed using separate NuGet package XData WorkSet (UnitOfWork) package . In addition, the UoW container supports exporting hierarchically constructed objects using the static Export method. At the same time, it is possible to export any selected part of the contents of the UoW container, starting either from the root node or from any container node. To export a node, it must contain a property of type Guid for storing the object key in the UoW container and another property of type Guid for storing the data layer of the UoW container. These properties should not be included in the mapping. The GetKey (or it's overload version) and SelectKeys methods are used to get the value of the keys of UoW container objects. To export an object with child objects, it is necessary to define a property to which it will be used to store an array of child objects (or a child instance for one-to-one relation). Such properties should also not be included in the mapping. In addition, the bool property can be defined in the child objects to pass the delete flag. Such properties should also not be included in the mapping. To determine the structure of the exported part of the UoW container, a LINQ-style descriptor is used, the use of which is clear from the example below. Using the descriptor, it is possible not only to determine which child objects should be exported together with the root element, but also what service properties of objects at each level, what information will be filled. var expInvoice = Work.Export(work.DbLayer, key.Value, () => Work.Root<Invoice>(z => z.Layer, /* Guid Data scope layer property */ z => z.Key) /* Guid Work set key property */ .With(z => z.InvoiceSpec, /* InvoiceSpec[] child entities array property */ z => z.Key, /* child entity: Guid Work set key property */ z => z.Deleted)); /* child entity: bool delete flag property */ After exporting, this object (and its child objects transferred with it) can be modified somewhere outside the system (for example, on a JS-based Web client) and then applied using the Apply method. In addition to the object itself, the Apply method accepts a descriptor built on the principle similar to that described above. Work.Apply(inv, () => Work.Root<Invoice>(z => z.Layer, z => z.Key) .With(z => z.InvoiceSpec, z => z.Key, z => z.Deleted)); Warning In order to apply changes to the UoW container, the data layer (data scope) on which it is built must not be destroyed like the UoW container itself. XData has internal caching mechanisms that allow them to store and retrieve their instances by layer ID using the GetDataScope and GetWorkSet methods. Important Data layers are cached independently of UoW containers and you need to destroy the data layer after removing the UoW container separately!"
  },
  "tutorial/three_tier.html": {
    "href": "tutorial/three_tier.html",
    "title": "Using three tier architecture | XData website",
    "keywords": "Using three tier architecture Important This is feature of .Net 4.0 version only. One of unique features of XData is using same application logic modules as in two-tier-architecture (client-db), as in three-tier-architecture (client-application server-db). And You can switch three-tier application in two-tier mode to simplify debugging changing configuration file only!!! Tip In three-tier mode no database client software needed on client workstation. And no database credential stored in configuration file. To extract part of data aware application logic on application server level You will need: extract mapped classes in separated assembly (or assemblies) called \"data modules\" extract server data logic in separated assembly (or assemblies) called \"server modules\" in server modules create logic classes for some data objects extend abstract class XDataLogic<T> , where T - data object class type that uses server logic including trigger logic and call server logic from client code. public abstract class InvoiceLogic : XDataLogic<Invoice> { [Action(DataActionType.AfterInsert), Action(DataActionType.AfterUpdate)] public readonly static Trigger<Invoice> UpdateHistory = ((ref Invoice invoice, ref DataTriggerFlag flag) => { if (!invoice.CheckState(DataObjectState.New) && !invoice.IsChanged(x => x.DocState)) return true; var rep = invoice.GetRepository(); var hist = GetRepository<DocHistory>(rep.Layer, context: rep.Context) .Reset() .SetFilterValue(DocHistory.FilterByDocId, invoice.GetProperty<long>(\"DocId\")) .SetFilterValue(DocHistory.FilterByDocStateId, invoice.DocState.Key); var newHist = hist.New(); newHist.HistoryDate = DateTime.UtcNow; return hist.Submit(ref newHist); }); [Action(DataActionType.BeforeDelete)] public readonly static Trigger<Invoice> ClearHistory = ((ref Invoice invoice, ref DataTriggerFlag flag) => { var i = invoice; return GetRepository<DocHistory>(i.GetLayer(), context: i.GetContext()) .Reset() .Clear(x => x.GetProperty<long>(\"DocId\") == i.GetProperty<long>(\"DocId\")); }); [Action(DataActionType.BeforeClear)] public readonly static RepositoryTrigger<Invoice> ClearHistoryBatch = ((IRepository<Invoice> invoiceRepository, ref DataTriggerFlag flag) => GetRepository<DocHistory>(invoiceRepository.Layer, context: invoiceRepository.Context) .Reset() .Clear(x => invoiceRepository .Any(z => x.GetProperty<long>(\"DocId\") == z.GetProperty<long>(\"DocId\")))); public static readonly CustomLogic<Invoice> TestCustomLogic = (objects => { Log.Write(MessageType.Information, () => String.Format(\"TestCustomLogic called with {0} objects\", objects.Length)); foreach (var invoice in objects) { var i = invoice; invoice.PostData(\"testPost\", () => Encoding.UTF8.GetBytes(i.DocNumb)); var p = Encoding.UTF8.GetBytes(i.DocNumb); var r = i.Callback(\"testCall\", ref p); Log.Write(MessageType.Information, () => String.Format(\"Call for \\\"{0}\\\" returned \\\"{1}\\\" with data \\\"{2}\\\"\", i.DocNumb, r, p == null ? null : Encoding.UTF8.GetString(p))); } return true; }); } set server module assembly name in data object mapping in data modules [DataObject(\"D\", LogicAssemblyName = \"InvoiceServerLogic\")] //for static mapping //or ... .SetLogicAssembly(\"InvoiceServerLogic\") //for dynamic mapping register custom logic handlers inside mapped types in data modules public static CustomLogic<Invoice> TestCustomLogic; write custom logic calls from client modules var random = new Random(); return dataScope.GetRepository<Invoice>().ToArray().Execute( () => Invoice.TestCustomLogic, \"testPost\".SetValue((Action<byte[]>)(data => Console.WriteLine(\"Post message received (data=\\\"{0}\\\")\", data == null ? null : Encoding.UTF8.GetString(data)))).AsEnum().ToDictionary(), \"testCall\".SetValue((Func<byte[], byte[]>)(data => { Console.WriteLine(\"Call received \\\"{0}\\\")\", data == null ? null : Encoding.UTF8.GetString(data)); return random.NextDouble() >= 0.5 ? null : Encoding.UTF8.GetBytes( string.Format(\"reply for \\\"{0}\\\"\", data == null ? null : Encoding.UTF8.GetString(data))); })).AsEnum().ToDictionary()); Tip Custom logic handlers can use synchronous and asynchronous callbacks to client code and perform analysis of synchronous callbacks result. This functionality allows to realize very complex and interactive distributed business processes."
  },
  "tutorial/sql_block.html": {
    "href": "tutorial/sql_block.html",
    "title": "SQL block | XData website",
    "keywords": "SQL block XData has the ability to describe and execute an anonymous SQL block in LINQ style. To call an SQL block that does not return a result set, you can call it using the ExecuteSqlBlock extension method, and GetSqlBlockData<T> can be used to get a collection of objects of type T. An expression of type Expression<SqlBlockDefinition> is used to describe the SQL block and an expression of type Expression<SqlBlockDefinition<T>> is used as the value of the block parameter of the methods described above to return a result of type T. These types are delegates of the functions parameterized by ISqlBlockAdapter and ISqlBlockAdapter<T> , respectively. An array called parameters is used to describe the parameter values of an unnamed SQL block. Lets explain in more detail with specific examples: to DELETE SQL block... delete T from T_TEST T where T.test2_id = 1 dataScope.ExecuteSqlBlock(x => x.Delete(t => t.GetStructure(\"T\", y => y.DataTable(\"T_TEST\", \"T\", a => a.ConstFilter(\"FilterByTest2Id\", \"test2_id\", 1))))); to INSERT VALUES SQL block... insert into T_TEST(test2_id, date) values(@id, @date) dataScope.ExecuteSqlBlock(x => x.Insert(\"T_TEST\", z => new { TestId = z.Value(y => y.Default<long>(DefaultType.AutoIncrement)), Test2Id = z.Value(\"test2_id\", y => y.Data<long>(\"id\")), DateField = z.Value(y => y.Data<DateTime>(\"date_param\")) }), x => x.Param<long>(\"id\", DbType.Int32).Set(1), x => x.Param<DateTime>(\"date_param\", DbType.DateTime).Set(DateTime.Now)); Tip Note that the key auto-increment field is described separately here. For some DBMSs (such as Oracle for example), this is important. But for the rest, this does not interfere with the SQL block. to INSERT MULTIPLE VALUES SQL block... insert into T_TEST(test2_id, date) values(1, '2017-01-01'), (1, '2017-01-02'), (2, '2017-01-03') using (var table = new DataTable()) { table.Columns.AddRange(new[]{ new DataColumn(\"id\", typeof(long)), new DataColumn(\"date_param\", typeof(DateTime)) }); table.Rows.Add(1, DateTime.Parse(\"2017-01-01\")); table.Rows.Add(1, DateTime.Parse(\"2017-01-02\")); table.Rows.Add(2, DateTime.Parse(\"2017-01-03\")); table.AcceptChanges(); dataScope.ExecuteSqlBlock( x => x.Insert(\"T_TEST\", table, z => new { TestId = z.Value(y => y.Default<long>(DefaultType.AutoIncrement)), Test2Id = z.Value(\"test2_id\", y => y.Data<long>(\"id\")), DateField = z.Value(y => y.Data<DateTime>(\"date_param\")) })); } to INSERT INTO SELECT SQL block... insert into T_TEST(test2_id, date_field) select 2 as id, dateadd(day, -4, X.date_field) as date_val from T_TEST X where test2_id = 1 dataScope.ExecuteSqlBlock( x => x.Insert(\"T_TEST\", t => t.GetStructure(\"X\", y => y.DataTable(\"T_TEST\", \"X\", z => z.ConstFilter(\"FilterByTest2Id\", \"test2_id\", 1))) .Select(z => new { //!!! Auto increment primary key description is required //!!! here only for Oracle and leads to an error for //!!! others! TestId = z.Default<long>(DefaultType.AutoIncrement), Test2Id = z.Expr(\"id\", s => 2, DbType.Int64), DateField = z.Expr(\"date_val\", s => s.Field<DateTime>(\"X\", \"date_field\").AddDays(-4), DbType.DateTime) }))); Warning Oracle has required explicit description of auto increment primary key in that sort SQL block and other RDBMS threat that as error. Due to some features of the implementation at the moment, it was not possible to reduce this to a single syntax. Perhaps this will change further. to UPDATE SQL block... update T_TEST T set date_field = @date where T.test2_id in (select T2.test2_id from T_TEST2 T2 where T2.some_field = 2) dataScope.ExecuteSqlBlock( x => x.Update(t => t.GetStructure(\"T\", y => y.DataTable(\"T_TEST\", \"T\", z => z.SubqueryFilter(\"test2_id\", \"X\") .SetOperation(FilterOperation.In)) .Subquery(\"X\", XDataMapping.GetStructure(\"T2\", null, DataStructureFlag.ReadOnly) .DataTable(\"T_TEST2\", \"T2\", z => z.ConstFilter(\"SomeFilter\", \"some_field\", FilterConstantType.Const, 2)) .Select(z => new { Test2Id = z.Field<long>(\"T2\", \"test2_id\") }), \"Test2Id\", DataGrouping.None)), z => new { DateField = z.Value(y => y.Data<DateTime>(\"date_param\")) }), x => x.Param<DateTime>(\"date_param\", DbType.DateTime).Set(DateTime.Now.AddDays(-8))); to UPDATE FROM SUBQUERY SQL block... update T_TEST T set date_field = (select min(Z.date_field) from T_TEST Z where Z.test2_id = 2) where T.test2_id in (select T2.test2_id from T_TEST2 T2 where T2.some_field = 2) dataScope.ExecuteSqlBlock( x => x.Update(t => t.GetStructure(\"T\", y => y.DataTable(\"T_TEST\", \"T\", z => z.SubqueryFilter(\"test2_id\", \"X\") .SetOperation(FilterOperation.In)) .Subquery(\"X\", XDataMapping.GetStructure(\"T2\", null, DataStructureFlag.ReadOnly) .DataTable(\"T_TEST2\", \"T2\", z => z.ConstFilter(\"SomeFilter\", \"some_field\", FilterConstantType.Const, 2)) .Select(z => new { Test2Id = z.Field<long>(\"T2\", \"test2_id\") }), \"Test2Id\", DataGrouping.None)), z => new { DateField = z.Value(y => y.Subquery(xa => xa.GetStructure(\"Z\", ya => ya.DataTable(\"T_TEST\", \"Z\", za => za.ConstFilter(\"FkFilter\", \"test2_id\", FilterConstantType.Const, minT2 + 1)) .Column(\"TestId\", f => f.Field<long>(\"Z\", \"test_id\", k => k.Key(), k => k.Hidden()))), za => za.Field<DateTime>(\"Z\", \"date_field\", ya => ya.Group(DataGrouping.Min)), DataStructureFlag.Grouping)) })); Note It is necessary to consider the fact that in MySQL there is a restriction that you cannot access the same table or subqueries based on it during update. to UPDATE JOINED TABLE SQL block... update T set date = @date from T_TEST T join T_TEST2 T2 on T.test2_id = T2.test2_id where T2.some_field = 1 dataScope.ExecuteSqlBlock( x => x.Update(t => t.GetStructure(\"T\", y => y.DataTable(\"T_TEST\", \"T\") .DataTable(\"T_TEST2\", \"T2\", z => z.Link(\"T\", \"test2_id\"), z => z.ConstFilter(\"SomeFilter\", \"some_field\", FilterConstantType.Const, 1))), z => new { DateField = z.Value(y => y.Data<DateTime>(\"date_param\")) }), x => x.Param<DateTime>(\"date_param\", DbType.DateTime).Set(DateTime.Now.AddDays(-8))); Note It is necessary to consider the fact that in MySQL there is a restriction that you cannot access the same table or subqueries based on it during update. Warning Not supported in SQLite to UPDATE SET FIELD VALUE FROM JOINED TABLE SQL block... update T set some_field = T2.some_field from T_TEST2 T join T_TEST2 T2 on T.test2_id = T2.test2_id where T2.some_field = 1 dataScope.ExecuteSqlBlock( x => x.Update(t => t.GetStructure(\"T\", y => y.DataTable(\"T_TEST2\", \"T\") .DataTable(\"T_TEST2\", \"T2\", z => z.Link(\"T\", \"test2_id\"), z => z.ConstFilter(\"SomeFilter\", \"some_field\", FilterConstantType.Const, 1))), z => new { SomeField = z.Value(y => y.Field<int>(\"T2\", \"some_field\")) })); Note It is necessary to consider the fact that in MySQL there is a restriction that you cannot access the same table or subqueries based on it during update. Warning Not supported in SQLite to MERGE TABLE WITH VALUES... merge T_TEST2 T using (select @test2_id, @some) S (test2_id, some_field) on (T.test2_id = S.test2_id) when matched then update set some_field = S.some_field when not matched then insert(some_field) values(@some) dataScope.ExecuteSqlBlock( x => x.Merge(\"T_TEST2\", \"T\", \"S\", z => new { Test2Id = z.Field(\"test2_id\", y => y.Data<long>(\"Test2Id\"), y => y.Insert(DefaultType.AutoIncrement), y => y.Link()), SomeField = z.Field(y => y.Data<int>(\"Some\"), y => y.Update(), y => y.Insert()) }), x => x.Param<int>(\"Test2Id\", DbType.Int64).Set(3), x => x.Param<int>(\"Some\", DbType.Int32).Set(3)); Warning Not supported in SQLite to MERGE TABLE WITH ANOTHER TABLE... merge T_TEST2 T using (select doc_state_id DS_doc_state_id, 1 some_field from T_DOC_STATE DS where DS.doc_state_id=1) S (doc_state_id, some_field) on (T.test2_id = S.doc_state_id) when matched then update set some_field = @some when not matched then insert(some_field) values(@some) dataScope.ExecuteSqlBlock( x => x.Merge(\"T_TEST2\", \"T\", z => z.GetStructure(\"DS\", y => y.DataTable(\"T_DOC_STATE\", \"DS\", f => f.ConstFilter(\"FilterById\", \"doc_state_id\", FilterConstantType.Const, 1))) .Select(s => new { DocStateId = s.Field<long>(\"DS\", \"doc_state_id\"), //!!! PostgreSql and MySql don't support merge statement //!!! only insert with conflict handling so second field //!!! leads to error but required for MS SQL Server and //!!! Oracle! SomeField = s.Expr<int>(\"some_field\", DataExpressionType.PlainSql, \"1\", DbType.Int32) }), \"S\", z => new { Test2Id = z.Field(\"test2_id\", y => y.Field<long>(\"S\", \"doc_state_id\"), y => y.Insert(DefaultType.AutoIncrement), y => y.Link()), SomeField = z.Field(y => y.Data<int>(\"Some\"), y => y.Update(), y => y.Insert()) }), x => x.Param<int>(\"Some\", DbType.Int32).Set(4)); Warning PostgreSql and MySql don't support merge statement only insert with conflict handling so second field leads to error but required for MS SQL Server and Oracle! Warning Not supported in SQLite to IF BLOCK... if @id >= 1 begin insert into T_TEST(test2_id, date_field) values(@id, @date_param) end dataScope.ExecuteSqlBlock( x => x.If(z => z.Data<long>(\"id\"), z => z.Const(1, DbType.Int64), FilterOperation.GreaterThanOrEqual, s => s.Insert(\"T_TEST\", z => new { TestId = z.Value(y => y.Default<long>(DefaultType.AutoIncrement)), Test2Id = z.Value(\"test2_id\", y => y.Data<long>(\"id\")), DateField = z.Value(y => y.Data<DateTime>(\"date_param\")) })), x => x.Param<long>(\"id\", DbType.Int64).Set(1), x => x.Param<DateTime>(\"date_param\", DbType.DateTime).Set(DateTime.Now)); Warning Unnamed procedure SQL blocks are not supported in SQLite and MySQL to IF EXISTS... if not exists(select 1 from T_TEST where test2_id = @id) begin insert into T_TEST(test2_id, date_field) values(@id, @date_param) end dataScope.ExecuteSqlBlock( x => x.If(t => t.GetStructure(\"T\", y => y.DataTable(\"T_TEST\", \"T\", z => z.ConstFilter(\"FilterByTest2\", \"test2_id\", FilterConstantType.Variable, \"id\"))), FilterOperation.NotExists, s => s.Insert(\"T_TEST\", z => new { TestId = z.Value(y => y.Default<long>(DefaultType.AutoIncrement)), Test2Id = z.Value(\"test2_id\", y => y.Data<long>(\"id\")), DateField = z.Value(y => y.Data<DateTime>(\"date_param\")) })), x => x.Param<long>(\"id\", DbType.Int64).Set(1), x => x.Param<DateTime>(\"date_param\", DbType.DateTime).Set(DateTime.Now)); Warning Unnamed procedure SQL blocks are not supported in SQLite and MySQL some other sample declare @test table(test_id int, test2_id int, date_field datetime), @pid int, @pfk int, @pdate datetime; begin select test_id, test2_id, date_field into @test from T_TEST; declare test_cursor cursor for select test_id, test2_id, date_field from @test where test2_id = 2; open test_cursor; fetch next from test_cursor into @pid, @pfk, @pdate; while @@fetch_status = 0 begin fetch next from test_cursor into @pid, @pfk, @pdate; end close test_cursor; deallocate test_cursor; select test_id, test2_id, date_field from @test; end var sqlBlockData = dataScope.GetSqlBlockData<TestObj>( b => b.Block<TestObj>( x => x.Declare( z => z.Var<DataTable>(\"test\", y => y.Field(\"test_id\", DbType.Int64), y => y.Field(\"test2_id\", DbType.Int64), y => y.Field(\"date_field\", DbType.DateTime)), z => z.Var<long>(\"pid\", DbType.Int64), z => z.Var<long>(\"pfk\", DbType.Int64), z => z.Var<DateTime>(\"pdate\", DbType.DateTime)), x => x.SetVar(t => t.GetStructure(\"T\", y => y.DataTable(\"T_TEST\", \"T\")) .Select(z => new { TestId = z.Field<long>(\"T\", string.Empty), Test2Id = z.Field<long>(\"T\", \"test2_id\"), DateField = z.Field<DateTime>(\"T\", string.Empty) }), z => z.Var<DataTable>(\"test\")), x => x.ForEach(t => t.GetStructure(\"T\", y => y.DataTable(t.Var(\"test\"), \"T\", z => z.ConstFilter(\"FilterByTest2\", \"test2_id\", FilterConstantType.Const, 2))) .Select(z => new { TestId = z.Field<long>(\"T\", string.Empty), Test2Id = z.Field<long>(\"T\", \"test2_id\"), DateField = z.Field<DateTime>(\"T\", string.Empty) }), \"test_cursor\", z => null, z => z.Map(\"pid\", y => y.TestId), z => z.Map(\"pfk\", y => y.Test2Id), z => z.Map(\"pdate\", y => y.DateField)), x => x.Return(t => t.GetStructure(\"T\", y => y.DataTable(t.Var(\"test\"), \"T\")) .Select(z => new TestObj { TestId = z.Field<long>(\"T\", string.Empty), Test2Id = z.Field<long>(\"T\", \"test2_id\"), DateField = z.Field<DateTime>(\"T\", string.Empty) })) )); foreach (TestObj testObj in sqlBlockData) { Console.WriteLine(testObj.DateField); } Warning Oracle support predefined table variables types only so table variable type declaration in unnamed block is not supported in Oracle and block need to be redesigned Warning Oracle support return table from predefined pipelined functions only so unnamed SQL blocks thats returns collection of objects conflicts with Oracle concept and not supported at RDMS level. This block in Oracle can be realized using pipelined functions and XData procedure call ability Warning Unnamed procedure SQL blocks are not supported in SQLite and MySQL"
  },
  "tutorial/security.html": {
    "href": "tutorial/security.html",
    "title": "Security issues | XData website",
    "keywords": "Security issues XData is able the application to take a full control over data access rights and rights to execute any data aware business logic. Inside the XData has designed a complete data security solution for control access to some properties of data objects , access to data objects corresponds some rules, access to standard (CRUD), or custom data aware business logic. For using this ability is required to implement interface ISecuritySession and use it as parameter of GetRepository method of data scope interface to get security sensible repository . XData is not specify the way to authentication and authorization. Your application can use any existing technologies or products on the market. Here the synthetic but simple and demonstrative example of ISecuritySession implementation: public class MySecuritySession : SecuritySession { private const string Manager = \"Manager\"; private const string Guest = \"Guest\"; private const string Chief = \"Chief\"; private const string Clerk = \"Clerk\"; public static MySecuritySession CreateSecuritySession (string userName, string password) { if (userName == \"Admin\" && password == \"123\") return new MySecuritySession(userName, new string[0], true); if (userName == \"Manager\" && password == \"111\") return new MySecuritySession(userName, new[] { Manager, Clerk }); if (userName == \"Guest\" && password == \"222\") return new MySecuritySession(userName, new[] { Guest }); if (userName == \"Chief\" && password == \"333\") return new MySecuritySession(userName, new[] { Chief, Manager, Clerk }); if (userName == \"Clerk\" && password == \"444\") return new MySecuritySession(userName, new[] { Clerk }); RiseUnauthorizedAccessException(); return null; } /// <exception cref=\"XDataSecurityException\"></exception> [DebuggerStepThrough] [DebuggerNonUserCode] private static void RiseUnauthorizedAccessException() { throw new XDataSecurityException(\"XDataObjectTest system\"); } public MySecuritySession (string userName, string[] roles, bool isSupervisor = false) : base(userName, roles, isSupervisor) { } protected override void InitializeSession() { //Hide some columns from Guests RegisterRestrictedProperties(\"\", typeof(Invoice), new[] { Guest.SetValue(new[] { Property<Invoice>(x => x.DocAmount), Property<Invoice>(x => x.DocLastChange), Property<Invoice>(x => x.Scan), Property<Invoice>(x => x.Source), Property<Invoice>(x => x.CustomerTo), Property<Invoice>(x => x.DeliveryType) }) }); RegisterGrantedActions(\"\", typeof(Invoice), new[] { //Grant all actions to Chief Chief.SetValue(new [] { Actions.All }), //Grant all CRUD but TestCustomLogic is denied for Manager Manager.SetValue(new [] { Actions.CRUD }), //Grant update only for Clerk Clerk.SetValue(new [] { Actions.Update }), //Grant execute TestCustomLogic only for Guest Guest.SetValue(new[] { Action(() => Invoice.TestCustomLogic) }) }); //Hide non ACTIVE invoices from Guests RegisterSecurityFilters(\"\", typeof(Invoice), new[] { Guest.SetValue<string, Expression>( (Expression<Func<Invoice, bool>>)(x => x.DocStateCode == \"ACTIVE\")) }); } } To simplify the ISecuritySession interface implementation use the NuGet package XData Security package . This package provide an abstract class SecuritySession implemented base functionality and useful helpers. This functionality is shipped separately because of security session using is optional. Important Required to override the constructor SecuritySession(string userName, string[] roles, bool isSupervisor = false) used in three-tier architecture on server side, and override method InitializeSession . Method InitializeSession is used to cache access rues profile. Tip Caching of all users security rules (as exposed in sample above) is not effective. This for simplify demonstration only. Security session is current user security describer. Recommended to cache rules for current user only using initialized before calling of InitializeSession properties: UserName , Roles and IsSupervisor . In sample above take a look on using caching methods: RegisterRestrictedProperties , RegisterGrantedActions and RegisterSecurityFilters , and a helper methods: Property and Action . When describing access rules to actions (standard and custom) use constants defined in Actions static class: All - all actions over data object, including standard (CRUD) and custom named actions CRUD - all standard actions: Create , Update , Delete Create - create new data object action Update - update data object properties Delete - delete data object"
  },
  "tutorial/runtime_filter.html": {
    "href": "tutorial/runtime_filter.html",
    "title": "Runtime filters | XData website",
    "keywords": "Runtime filters Runtime filters used for filtering data by field (or SQL expression) where filter value will be accessible during runtime only. Similar results can be reached using LINQ, but may be field to filter on is not selected. Or the result we need is not a read-only dynamic dataset (see LINQ support and Dynamic queries ), but feature rich repository , only filtered. Runtime filters in XData are defined as static fields of data object typed as RuntimeFilter . Name of runtime filter is mast to be unique over data object mapping structure (with subqueries). When value of runtime filter is set and filter with same name is not found in mapping, it will be dynamically added to mapping structure. To set value of runtime filter, use SetFilterValue method of repository . To clear one runtime filter value, set null value. To reset all runtime filters, use Reset method of repository. Tip When runtime filter value is set to null check filter null processing behavior assigned to this filter! var rep = invoice.GetRepository(); var hist = dataScope.GetRepository<DocHistory>(rep.Layer, context: rep.Context) .Reset() .SetFilterValue(DocHistory.FilterByDocId, invoice.GetProperty<long>(\"DocId\")) .SetFilterValue(DocHistory.FilterByDocStateId, invoice.DocState.Key); var newHist = hist.New(); newHist.HistoryDate = DateTime.UtcNow; return hist.Submit(ref newHist); Runtime filters can be described on place: //Using column name .SetFilterValue(\"DocId\", doc_id) //Using property expression .SetFilterValue(x => DocNumber, docNumber) //Using FilterName helper .SetFilterValue(new FilterName(\"FilterByDocId\"), doc_id)"
  },
  "tutorial/adapter.html": {
    "href": "tutorial/adapter.html",
    "title": "Making new XData adapter | XData website",
    "keywords": "Making new XData adapter Note Oops... not ready yet... but we've working on it"
  },
  "tips/yaml_config.html": {
    "href": "tips/yaml_config.html",
    "title": "YAML configuration file | XData website",
    "keywords": "YAML configuration file (for .Net Standard 2.0 only!) Since .Net Core and .Net Standard 2.0 supported various configuration file formats it's possible to configure XData with, as a sample, YAML file. connectionStrings: add: - name: \"DICT\" connectionString: \"Server=server;Database=test;User Id=postgres;Password=123456;Search Path=dictionaries\" - name: \"CONTACTS\" connectionString: \"Server=server;Database=test;User Id=postgres;Password=123456;Search Path=contacts\" xdata: adapter: - name: \"DICT_POSTGRESQL\" assembly: \"XData.PostgreSql.NpgSql.Adapter\" schema: dictionaries: - name: \"CONTACTS_POSTGRESQL\" assembly: \"XData.PostgreSql.NpgSql.Adapter\" schema: contacts: dialect: - name: \"POSTGRESQL\" assembly: \"XData.PostgreSql.Dialect\" context: - name: \"DICT\" adapter: \"DICT_POSTGRESQL\" dialect: \"POSTGRESQL\" - name: \"CONTACTS\" adapter: \"CONTACTS_POSTGRESQL\" dialect: \"POSTGRESQL\" default: \"CONTACTS\" debug: true Tip Note, the PostgreSQL connection strings can specify schema name in a Search Path key! That is required to work with tables from different then public schema without specify schema name in table name definitions. Tip Names of adapters, that use various connection strings must to be unique! Names of contexts must correspond connection strings names. Tip Be aware with PostgreSQL specific adapter configuration section schema required to specify home schema name for an adapter. Adapter and dialect specific configuration sections has described here ."
  },
  "tips/view.html": {
    "href": "tips/view.html",
    "title": "Mapping view | XData website",
    "keywords": "Mapping view To map data objects to SQL views used same techniques and commands as data table, but then mapping non read-only repository to table some fields of updatable table can be mapped automatically by XData engine using meta-data information from source database. When mapping is described over view, all fields must to be described explicitly. Same rule is worked when source of data is text represented SQL expression or virtual record-set defined as union of records (see ToDataSet as example, similar result can be reached using string SQL expression as table name). All fields must to be described explicitly. Important Repository mapping is required to marked as ReadOnly when view is a base table!"
  },
  "tips/useful.html": {
    "href": "tips/useful.html",
    "title": "Useful little things... | XData website",
    "keywords": "Useful little things... During the development of XData, some helpers were developed that may be useful to You too... Single value IEnumerable When it is necessary to call the method that requires IEnumerable<T> and You have a single value, the AsEnum method will be useful. Extensions for collections To clear List with a preliminary call of some logic to free resources associated with a sheet element, the Clear method will help. The GetOrAdd method for List will also be useful. When you need to compare two Dictionary instances, the HasSameValuesAs method can help. For ConcurrentDictionary , the RemoveAll method may come in handy. Outer join For those who are familiar with SQL, it is often convenient to use the concept of OuterJoin in the union of sets, and how it is implemented in LINQ is not comfortable to use. XData has a built-in mechanism for combining sets using methods: FullOuterJoin LeftOuterJoin RightOuterJoin Tip It is necessary to take into account that these procedures use the Linq2object interface IEnumerable and for the effective use of combining data in the database, you must use mapping or dynamic queries . Processing To pre-process an object before using it (for example, to initialize the properties of a repository before using it as a LINQ data source), it is useful to use the Do extension: var obj = dataScope.GetRepository<Invoice>() .Do(x => x.Instance.GetChild(z => z.InvoiceSpec)) .First(); To access source object use property Instance of action argument and properties of dynamic property State of action argument to store some values between actions."
  },
  "tips/update_source.html": {
    "href": "tips/update_source.html",
    "title": "Property update source | XData website",
    "keywords": "Property update source Data object properties (or hidden properties ) values can depend on other properties values or calculated with some expression. XData allow to describe this expression or dependency as part of mapping, to skip that property initialization when inserting or updating data object. Property value update source is used when data object is inserted or updated. When property default value and update source are defined, default value is used on insert and update source on update. Property value update source expression when using static mapping is defined by PropertyUpdateWithAttribute (or ColumnUpdateWithAttribute ) with same rules as PlainSQL or LinqExpression SQL expression properties : // for PlainSQL [PropertyUpdateWith(\"case P.is_vip when 1 then 10 else 0 end\")] // or for LinqExpression [PropertyUpdateWith(\"AllowedDiscount\", DataExpressionType.LinqExpression)] ... [SqlExpression] private static Calculate<int> AllowedDiscount = x => x.Case<Product, int>( z => z.Field<bool>(\"is_vip\"), z => 0, 1.SetExpression(z => 10)); When using dynamic mapping it is defined by Field's mapping attribute UpdateWith overloads: UpdateWith(DataExpressionType type, string exprText) UpdateWith(Expression<Func<IQueryStructureAdapter, TValue>> expr) DeliveryDate = x.Field<DateTime?>(\"DD\", string.Empty, z => z.UpdateWith(y => DateTime.Today.AddDays(1))) Property value update source dependency when using static mapping is defined by PropertyUpdateWithAttribute (or ColumnUpdateWithAttribute ) with same rules as Subquery SQL expression properties : [Subquery(\"A\" /* subquery alias */, typeof(DocSpecAmounts) /* subquery mapped type */, \"Amount\" /* subquery result property name */, Grouping = DataGrouping.Sum /* result property aggregation type */)] ... [PropertyUpdateWith(\"A\", DataExpressionType.SubQuery)] When using dynamic mapping it is defined by Field's mapping attribute UpdateWith overloads: UpdateWith(string alias, Type dobjType, string property, DataGrouping grouping = DataGrouping.None, params Expression<Func<ISubqueryLinkAdapter, IStructureFlag>>[] attributes) UpdateWith(string alias, IQueryDescription<TDObj> sub, string property, DataGrouping grouping = DataGrouping.None, params Expression<Func<ISubqueryLinkAdapter, IStructureFlag>>[] attributes) UpdateWith(string alias, IQueryDescription<TDObj> sub, Expression<Func<TDObj, TValue>> property, DataGrouping grouping = DataGrouping.None, params Expression<Func<ISubqueryLinkAdapter, IStructureFlag>>[] attributes) DeliveryType = x.Field<DeliveryTypeEnum>(\"DD\", string.Empty, z => z.UpdateWith(\"DT\", XDataMapping.GetStructure() .Select(y => new { DeliveryType = y.Expr(\"delivery_type\", a => DeliveryTypeEnum.Courier, DbType.Int32)}), y => y.DeliveryType, DataGrouping.None)),"
  },
  "tips/udt.html": {
    "href": "tips/udt.html",
    "title": "Using UDT | XData website",
    "keywords": "Using UDT SQL User Defined Type (UDT) - Complex data type definition. Some databases support it, some does not. XData supported UDT when it supported by database engine and ADO .Net provider too. And range of operations over UDT is depends on abilities of database engine and provider. UDT can be mapped as SQL procedure (or function) In or Out parameter statically or dynamically ."
  },
  "tips/trigger_logic.html": {
    "href": "tips/trigger_logic.html",
    "title": "Trigger business logic | XData website",
    "keywords": "Trigger business logic Important It is important to understand the difference between database level triggers and these XData level triggers. A database trigger is called during changes made to the records of the table, whereas XData logic module processes the changes in the level of the data object. It must be remembered that a data object can include several database tables on the one hand and, on the other hand, a part of information regarding other objects can be stored in one table. And from this point of view, the value of such a mechanism inside the XData can hardly be overestimated! Custom logic called over data object explicitly. But XData can call trigger logic over business valuable data object (not a single table!) on middle-ware level (no matter extracted this logic to dedicated application server or not). This logic will be called automatically when corresponded changes are applied: InitRepository - middle-ware trigger executed when Repository has been initialized (trigger delegate type - InitRepository<T> ) InvalidateRepository - middle-ware trigger executed when Repository data need to be reseted (trigger delegate type - InvalidateRepository<T> ) InvalidateObject - middle-ware trigger executed when Repository object need to be reloaded (trigger delegate type - InvalidateObject<T> ) InitObject - middle-ware trigger executed when Repository object has been initialized (trigger delegate type - InitObject<T> ) BeforeInsert - middle-ware trigger executed before object inserted into Repository (trigger delegate type - Trigger<T> ) BeforeUpdate - middle-ware trigger executed before Repository object has been updated (trigger delegate type - Trigger<T> ) BeforeDelete - middle-ware trigger executed before object has been deleted from Repository (trigger delegate type - Trigger<T> ) AfterInsert - middle-ware trigger executed after object inserted into Repository (trigger delegate type - Trigger<T> ). Skip flag is not applicable! AfterUpdate - middle-ware trigger executed after Repository object has been updated (trigger delegate type - Trigger<T> ). Skip flag is not applicable! AfterDelete - middle-ware trigger executed after object has been deleted from Repository (trigger delegate type - Trigger<T> ). Skip flag is not applicable! BeforeClear - middle-ware trigger executed before Repository has been cleared (trigger delegate type - RepositoryTrigger<T> ) AfterClear - middle-ware trigger executed after Repository has been cleared (trigger delegate type - RepositoryTrigger<T> ). Skip flag is not applicable! Trigger delegate type - it's a method signature for middle-ware trigger handler. public class InvoiceLogic : XDataLogic<Invoice> { [Action(DataActionType.AfterInsert), Action(DataActionType.AfterUpdate)] public Trigger<Invoice> UpdateHistory => ((ref Invoice invoice, ref DataTriggerFlag flag) => { if (!invoice.CheckState(DataObjectState.New) && !invoice.IsChanged(x => x.DocState)) return true; var rep = invoice.GetRepository(); using (var hist = GetRepository<DocHistory>(rep.Layer, context: rep.Context)) { hist.Reset() .SetFilterValue(DocHistory.FilterByDocId, invoice.GetProperty<long>(\"DocId\")) .SetFilterValue(DocHistory.FilterByDocStateId, invoice.DocState.Key); var newHist = hist.New(); newHist.HistoryDate = DateTime.UtcNow; return hist.Submit(ref newHist); } }); [Action(DataActionType.BeforeDelete)] public Trigger<Invoice> ClearHistory => ((ref Invoice invoice, ref DataTriggerFlag flag) => { var i = invoice; using (var hist = GetRepository<DocHistory>(i.GetLayer(), context: i.GetContext())) { return hist.Reset() .Clear(x => x.GetProperty<long>(\"DocId\") == i.GetProperty<long>(\"DocId\")); } }); [Action(DataActionType.BeforeClear)] public RepositoryTrigger<Invoice> ClearHistoryBatch => ((IRepository<Invoice> invoiceRepository, ref DataTriggerFlag flag) => { using (var hist = GetRepository<DocHistory>(invoiceRepository.Layer, context: invoiceRepository.Context)) { return hist.Reset().Clear(x => invoiceRepository .Any(z => x.GetProperty<long>(\"DocId\") == z.GetProperty<long>(\"DocId\"))); } }); } Trigger and RepositoryTrigger delegates has a reference parameter of type DataTriggerFlag to specify behavior of data processing after trigger executed. There are three possible behaviors defined: None - Submit using default algorithm, representation layer is already refreshed Skip - Data submitting have completed in trigger logic or not applicable. No standard updates will called. It's a kind of \"instead of\" trigger logic flag. Refresh - Default value. Representation layer manual data refreshing is needed. Trigger logic defined as attributed by Action attribute read only property of XDataLogic<T> class descendant. One property can be attributed as a handler for multiple triggers. Property type must to be Trigger<T> except repository based triggers ( BeforeClear , AfterCLear , InitRepository or InvalidateRepository ) - RepositoryTrigger<T> ."
  },
  "tips/tree_childs.html": {
    "href": "tips/tree_childs.html",
    "title": "Tree organized repository child specifics | XData website",
    "keywords": "Tree organized repository child specifics When master repository has hierarchy structure, than detail objects can be filtered by two methods to choose detail repository data: filter data linked with selected tree node only ( direct links ), and linked to subtree from selected node and below by hierarchy. XData has functional to choose one of this methods in runtime. To provide this ability mapping of master objects must describe external links marked as direct links . Than master repository flag ShowSubtree can be used as a switch between this two methods. Let's explain that on example... Mapping master tree organized data object... private static Expression<CustomMapping<Catalog>> _unused = ( () => XDataMapping.CustomMapping<Catalog>() .DataTable(\"R\", \"T_CATALOG\") .Map(x => new Catalog{ CatalogId = x.Field<long>(\"R\", string.Empty, z => z.Key()), Code = x.Field<string>(\"R\", string.Empty), Name = x.Field<string>(\"R\", string.Empty), ParentId = x.Field<long?>(\"R\", string.Empty) }, // Direct link x => x.ExternalLink<Document>(x => x.CatalogId, x => x.DirectLink()), // Subquery link x => x.ExternalLink<Document>(x => x.CatalogId, z => z.Filter(y => new FilterName(\"FilterByRoot\")))) .SetBaseTable(\"R\").SetFlags(DataStructureFlag.Tree) ); Master data object SQL... SELECT R.catalog_id AS R_catalog_id, R.code AS R_code, R.name AS R_name, R.parent_id AS R_parent_id FROM T_CATALOG R Mapping detail data object... private static Expression<CustomMapping<Document>> _unused = ( () => XDataMapping.CustomMapping<Document>() .DataTable(\"D\", \"T_DOC\") .DataTable(\"DC\", \"T_DOC_CATALOG\", x => x.Link(\"D\", \"doc_id\"), x => x.SubqueryFilter(\"catalog_id\", \"UT\") .SetOperation(FilterOperation.In)) .Subquery<CatalogTree>(\"UT\", x => x.CatalogId, DataGrouping.None) .Map(x => new Document{ DocId = x.Field<long>(\"D\", string.Empty, z => z.Key()), DocDate = x.Field<DateTime>(\"D\", string.Empty), CatalogId = x.Field<long>(\"DC\", string.Empty) }) .SetBaseTable(\"D\") ); ... private static Expression<CustomMapping<CatalogTree>> _unused = ( () => XDataMapping.CustomMapping<CatalogTree>() .With(\"CAT\", XDataMapping.GetStructure(\"R\") .DataTable(\"T_CATALOG\", \"R\", x => x.ConstFilter(\"FilterByRoot\", \"parent_id\", FilterConstantType.Const, null, FilterNullable.NullsCompared)) .Select(x => new { CatalogId = x.Field<long>(\"R\", string.Empty, z => z.Key()), ParentId = x.Field<long?>(\"R\", string.Empty), }), x => x.Properties(z => z.CatalogId, z => z.ParentId), x => x.WithRecursive(\"S\", XDataMapping.GetStructure(\"S\") .DataTable(\"T_CATALOG\", \"S\") .Select(y => new { CatalogId = y.Field<long>(\"S\", string.Empty, z => z.Key()), ParentId = y.Field<long?>(\"S\", string.Empty) }), z => z.SubqueryLink(y => y.ParentId, y => y.CatalogId))) .ReadOnlyProperty(x => x.CatalogId, x => x.Field<long>(\"CAT\", string.Empty, z => z.Key())) .ReadOnlyProperty(x => x.ParentId, x => x.Field<long?>(\"CAT\", string.Empty)) .Map().SetFlags(DataStructureFlag.ReadOnly) ); Link and using data objects with ShowSubtree off... dataScope.GetReposytory<Catalog>() .Do(x => x.Instance.GetChild<Document>()) .ToArray(); Detail data object SQL... with recursive T (catalog_id, code, name, parent_id) as ((SELECT R.catalog_id AS R_catalog_id, R.parent_id AS R_parent_id FROM T_CATALOG R WHERE R.catalog_id = @FilterByRoot) UNION ALL (SELECT S.catalog_id AS S_catalog_id, S.parent_id AS S_parent_id FROM T_CATALOG S, T T WHERE S.parent_id = (T.catalog_id))) SELECT D.doc_date AS D_doc_date /* DocDate */, D.doc_id AS D_doc_id /* DocId */, DC.catalog_id AS DC_catalog_id /* CatalogId */ FROM T_DOC D JOIN T_DOC_CATALOGUE DC ON DC.doc_id = D.doc_id WHERE DC.catalog_id in (SELECT T.catalog_id AS T_catalog_id FROM T T) and DC.catalog_id = @FilterByCatalogId Direct link is filled and detail data object data is restricted by single catalogue_id from master data object. Link and using data objects with ShowSubtree on... dataScope.GetReposytory<Catalog>() .Do(x => x.Instance.GetChild<Document>(), x => x.Instance.ShowSubtree = true) .ToArray(); Detail data object SQL... with recursive T (catalog_id, code, name, parent_id) as ((SELECT R.catalog_id AS R_catalog_id, R.parent_id AS R_parent_id FROM T_CATALOG R WHERE R.catalog_id = @FilterByRoot) UNION ALL (SELECT S.catalog_id AS S_catalog_id, S.parent_id AS S_parent_id FROM T_CATALOG S, T T WHERE S.parent_id = (T.catalog_id))) SELECT D.doc_date AS D_doc_date /* DocDate */, D.doc_id AS D_doc_id /* DocId */, DC.catalog_id AS DC_catalog_id /* CatalogId */ FROM T_DOC D JOIN T_DOC_CATALOGUE DC ON DC.doc_id = D.doc_id WHERE DC.catalog_id in (SELECT T.catalog_id AS T_catalog_id FROM T T) Direct link not filled and data not restricted by single catalogue_id from master data object. Resulted detail data will match master data object current record subtree."
  },
  "tips/transactions.html": {
    "href": "tips/transactions.html",
    "title": "Transactions | XData website",
    "keywords": "Transactions XData use automatic transactions handling by default. But allows to manage transactions manually using IDataScope interface method BeginTransaction returned transaction state interface ITransaction . Transaction state is a IDisposable object. Transaction is committed when method Commit is called. When transaction state is disposed without call Commit method, transaction is rolled back. Transaction can be started as read-only or read/write. This depends on parameter read of BeginTransaction method. XData can simulate wrap transactions one over another. First non read only transaction is related to real database transaction, and all wrapped transactions is related to transaction labels. When wrapped transaction is rolled back real transaction is rolled back to label only. Only rolling back the \"main\" transaction calls ROLLBACK statement over database."
  },
  "tips/tips.html": {
    "href": "tips/tips.html",
    "title": "Tips & Tricks | XData website",
    "keywords": "Tips & Tricks There are some special themes related with using XData in uncommon scenarios, or more detetailed information about not trivial internal XData mechanics. YAML configuration file (for .Net Standard 2.0 only!) Since .Net Core and .Net Standard 2.0 supported various configuration file formats it's possible to configure XData with, as a sample, YAML file. connectionStrings: add: - name: \"DICT\" connectionString: \"Server=server;Database=test;User Id=postgres;Password=123456;Search Path=dictionaries\" - name: \"CONTACTS\" connectionString: \"Server=server;Database=test;User Id=postgres;Password=123456;Search Path=contacts\" xdata: adapter: - name: \"DICT_POSTGRESQL\" assembly: \"XData.PostgreSql.NpgSql.Adapter\" schema: dictionaries: - name: \"CONTACTS_POSTGRESQL\" assembly: \"XData.PostgreSql.NpgSql.Adapter\" schema: contacts: dialect: - name: \"POSTGRESQL\" assembly: \"XData.PostgreSql.Dialect\" context: - name: \"DICT\" adapter: \"DICT_POSTGRESQL\" dialect: \"POSTGRESQL\" - name: \"CONTACTS\" adapter: \"CONTACTS_POSTGRESQL\" dialect: \"POSTGRESQL\" default: \"CONTACTS\" debug: true Tip Note, the PostgreSQL connection strings can specify schema name in a Search Path key! That is required to work with tables from different then public schema without specify schema name in table name definitions. Tip Names of adapters, that use various connection strings must to be unique! Names of contexts must correspond connection strings names. Tip Be aware with PostgreSQL specific adapter configuration section schema required to specify home schema name for an adapter. Adapter and dialect specific configuration sections has described here . Adapter and dialect specific configuration Some of adapters and dialects has their own specific configuration settings to setup unique features and behaviors. That specific settings can be defined in configuration file or dynamically with AddAdapter or AddDialect methods options parameter. Tip Function signatures is slightly different for .Net 4.0 version. XData.PostgreSql.NpgSql.Adapter: ... when XML configuration file is used: <adapter name=\"POSTGRESQL_NPG\" assembly=\"XData.PostgreSql.NpgSql.Adapter\"> <schema name=\"public\"/> </adapter> ... when YAML configuration file is used: adapter: - name: \"DICT_POSTGRESQL\" assembly: \"XData.PostgreSql.NpgSql.Adapter\" schema: dictionaries: ... when configuration is provided in runtime: // replace someschemaname to real schema name var source = new MemoryConfigurationSource { InitialData = new[] { new KeyValuePair<string, string>(\"schema:someschemaname\", null) }}; var conf = new ConfigurationBuilder().Add(source).Build(); ... .AddAdapter(\"postgresql\", XDataAdapter.PostgreSql.Adapter, conf) XData.MsSqlServer.Dialect: ... when XML configuration file is used (for modern versions of MSSQL): <dialect name=\"MSSQL\" assembly=\"XData.MsSqlServer.Dialect\"/> or if you have to use MSSQL 2005/2008 <dialect name=\"MSSQL\" assembly=\"XData.MsSqlServer.Dialect\"> <useOldOrderBy value=\"true\"/> </dialect> ... when YAML configuration file is used (for MSSQL 2005/2008): dialect: - name: \"DICT_MSSQL\" assembly: \"XData.MsSqlServer.Dialect\" useOldOrderBy: value: true ... when configuration is provided in runtime (for MSSQL 2005/2008): var source = new MemoryConfigurationSource { InitialData = new[] { new KeyValuePair<string, string>(\"useOldOrderBy:value\", \"true\") }}; var conf = new ConfigurationBuilder().Add(source).Build(); ... .AddDialect(\"mssql\", XDataAdapter.MsSqlServer.Dialect, conf) Using DI container XData can be effectively used with any DI containers You prefer. When using the .Net Standard 2.0 version of XData, the .Net Core Dependency Abstraction technology is applied internally and can be implemented with any DI container. The IDataEngine interface is injected as dependency by calling AddXData method during ConfigureServices method of Startup module. Any trigger logic modules can be registered as singleton services in DI container as well. public void ConfigureServices(IServiceCollection services) { services.AddXData(x => x.AddDialect(Constants.DialectName, XDataAdapter.PostgreSql.Dialect) .AddAdapter(Constants.AdapterName, XDataAdapter.PostgreSql.Adapter) .AddContext(Constants.TestDb, Constants.DialectName, Constants.AdapterName, testDb, true)); ... services.AddSingleton<IDataLogic<Invoice>, InvoiceLogic>(); ... } Note The registration of logic modules must be performed using the IDataLogic<T> interface Tip The number of logic modules for each data object is not limited, but it must be kipped in mind that the order in which various handlers are called is not guaranteed If any logic module are injected through DI container UseXData method required to call during Configure method of Startup module. public void Configure(IApplicationBuilder app, IHostingEnvironment env) { ... app.UseXData(); ... } When using .Net 4.0 XData version IDataEngine interface can be obtained from container similarly. In this case, you must use an additional NuGet package XData net 4.0 Inversion of Control container package . IDataEngine must to be registered as singleton with XDataManager.InitXData method call. If any logic module are injected through DI container UseXDataDependencies extension method similar to previously reviewed before version for .Net Standard 2.0 but assigned to IDependencyResolver interface is required to call. Here is an example using Autofac but you can use any DI container implementation analogically... var builder = new ContainerBuilder(); builder.Register<IDataLogic<Invoice>>(x => new InvoiceLogic()); builder.Register(x => XDataManager.InitXData(z => z.UseConfiguration(ConfigurationManager .OpenExeConfiguration(ConfigurationUserLevel.None)))); var container = builder.Build(); using (var resolver = new AutofacApiDependencyResolver(container).UseXDataDependencies()) { using (var dataEngine = (IDataEngine)resolver.GetService(typeof(IDataEngine))) { ... Any IoC container with IDependencyResolver interface implementation is supported. If the selected container DI implementation does not support this interface, it is simple and can easily be implemented independently. Large object loading Large objects specific properties Lob and Xml specially used to lazy access to potentially big sized data stored in database. When data object accessed using XData, large objects data not queried, but replaced with null values to create full structure of object. To get or set value of Lob or Xml Lob.Value and Xml.Document properties are used. Size of Lob can be checked using GetSize method. To simplify value assigning overrided operation += can be used as described in example below: obj.Source += new XDocument(new XElement(\"invoice\", new XAttribute(\"number\", number), new XAttribute(\"state\", z.DocStateCode))); obj.Scan += Encoding.UTF8.GetBytes(z.Source.Document.ToString()); To modify value of large objects in LINQ styled sequence of command helper methods Modify(Xml, Action<XDocument>) and Modify(Lob, Action<Byte[]>) can be used like in example below: invoice.Modify( z => z.DocState += dataScope.GetDictionaryValue<DocState>(x => x.Code == newStateCode), z => z.Source.Modify(doc => doc.Element(\"invoice\").Attribute(\"state\").Value = newStateCode)) .Submit(); Warning When object is serialized large objects properties are serialized with null values by default! When actual value of large object is required it must to be requested separately. To fill object large properties before serialization can be used one of LoadLob or LoadLobAsync helper method overloads. JSON serialization When used Json.NET XData data objects are serialized and deserialized automatically. There are some serialization specifics of data objects: By default Read only properties and Hidden properties are serialized and deserialized as well as writable properties, but have a some restrictions when copied to object to apply into database (see Apply method description below). Large objects ) are serialized to null value by default. They are designed for lazy data loading. To serialize data with actual values one of LoadLob helper method overloads can be used. By default Links are serialized as limited representation of link source object. Only properties listed as LinkProperties are included in serialized object. Additionally an \"linkPropertyName.Value\" JSON property is serialized with the value of Link.Value property. Default serialization rules can be overrided with ICollection<T> and T WithJsonSettings extension methods. JsonSettings<T> has followed methods to specify serializing options: Hide - alow to specify properties to skip on serialization LoadLob - alow to specify large object properties to load data before serialize ( LoadLob method alternative) LinkMode - alow to specify serialization rules for multiple (or all) link properties: Default - default rules will be applied (see above) Value - only value will be serialized Source - only source will be serialized DeleteFlag - allow to delete child entities in database using unmapped boolean property value in JSON serialized child object (see below). Used to deserialized (detached) objects only! return dataScope.GetRepository<Some>().ToArray() .WithJsonSettings(s => s.Hide(JsonHideFlags.Columns) //hide all columns .Hide(x => x.SomeReadOnlyProperty) //hide SomeReadOnlyProperty .LoadLob() //load all large data properties .LinkMode(LinkMode.Default, x => SomeLinkProperty, x => AnotherLinkProperty) //set default rules to 2 properties .LinkMode(LinkMode.Value)); //set other link properties serialize Value property only Warning Deserialized objects are detached from repository and had limited ways of using! Deserialized object can be used as a filter to find data object in database (for example to delete) with Find method: var found = dataScope.GetRepository<Some>().Find(detachedObj); if(found == null) throw new DbConcurrencyException(); return found.SetDeleted(true).Submit(); Deserialized object can be used as a source to copy some data to new object with Copy method: return dataScope.GetRepository<Some>().New().Copy(detachedObj).Submit(); Deserialized object can be used as to apply changes to database with Apply method: dataScope.GetRepository<Some>().Apply(detachedObj).Submit(); Apply is a combination of Find and Copy methods with followed algorithm: 1) if detached object has all keys assigned, corresponded object will be searched in database using keys and correlation token (if described in mapping) values (*) 2) if no data found XDataConcurrencyException will be trowed (**) 3) when some key properties are not assigned new entity has been created 4) detached object's data will be copied to found (or new) object (***) (*) Using of correlation token value with Find method can be escaped with optional ignoreConcurrency parameter. Same result can be reached with ApplyFlag.IgnoreConcurrency flag has been passed in Apply method call. (**) ApplyFlag.AddWhenNotFound flag can be passed in Apply method call to add new entity when not found in database. (***) Copy and Apply has parameter properties to specify witch property values will be copied. ApplyFlag.ExceptProperties flag can be used to SKIP listed properties on copy. ApplyFlag.CopyReadOnlyProperties flag can be used to allow copy Read only properties and Hidden properties disabled by default. You can define child repositories and associate them using the property parameter of the GetChild method with an unmatched property with the type of the child repository (for one-to-one relationships) or with a typed array of the child repository (for one-to-many relationships) . These properties will be populated during data collection, and the values will be automatically serialized to JSON and deserialized from JSON to a detached object. These values can be used to cascade changes to the database. Inserting and updating child objects is supported without further action. But for deleting entities, it is required that the developer define a delete flag - it the unmapped property used as a flag to mark the child entity as removed. To specify which property will be used as the delete flag for the property associated with the child repository, the WithJsonSettings method is used with the DeleteFlag combination applied to the detached object. // set delete flag to child repository entities to unmapped boolean property dataScope.GetRepository<Some>() .Do(x => x.Instance.GetChild<Child>(z => z.Childs), x => detachedObj.WithJsonSettings( z => z.DeleteFlag(y => y.Childs, y => y.Deleted))) .Apply(detachedObj).Submit(); See Master-detail relations to get more information about linking objects with Master-detail relations. Asynchronous wrapped operations Warning Only .Net Core Standard 2.0 version supported asynchronous wrapped operations To access data with XData inside async methods it's handy to use asynchronous wrappers declared inside XData.Async extension methods as illustrated in followed example: using XData.Async; ... IDataEngine _dataEngine; ... internal async Task<DocType[]> TestArrayAsync(CancellationToken cancellationToken) { using (var dataScope = dataEngine.NewDataScope(\"TEST_POSTGRE_NPG\", cancellationToken)) { return await dataScope.GetRepository<DocType>().ToArrayAsync(); } } Using asynchronously disposable objects requires an additional package XData net standard 2.0 Asynchronous Disposable support package and supporting of .Net Standard 2.1 specification To get asynchronous disposable version of... IDataScope use NewDataScopeAsync or GetDataScopeAsync extension methods of IDataEngine . ITransaction use BeginTransactionAsync extension methods of IDataScope . using XData.Async; using XData.AsyncDisposable; ... IDataEngine _dataEngine; ... internal async Task<DocType[]> TestArrayAsync(CancellationToken cancellationToken) { await using var dataScope = _dataEngine.NewDataScopeAsync(\"TEST_POSTGRE_NPG\", cancellationToken); return await dataScope.GetRepository<DocType>().ToArrayAsync(); } Mapping view To map data objects to SQL views used same techniques and commands as data table, but then mapping non read-only repository to table some fields of updatable table can be mapped automatically by XData engine using meta-data information from source database. When mapping is described over view, all fields must to be described explicitly. Same rule is worked when source of data is text represented SQL expression or virtual record-set defined as union of records (see ToDataSet as example, similar result can be reached using string SQL expression as table name). All fields must to be described explicitly. Important Repository mapping is required to marked as ReadOnly when view is a base table! Get connection settings in runtime Connection settings can be obtained from initialized context using code below: var ctx = dataScope.GetContext(s); Console.WriteLine(\"*** Testing context: {0} (DB type: {1})\", ctx.Name, ctx.DatabaseAdapter.ConnectType); Console.WriteLine(\"*** Server: {0}, Schema: {1}\", ctx.ConnectionInfo.Server, ctx.ConnectionInfo.Schema); Optional filters Optional filters is the mechanic to simplify query structure when some filters are not set. For example, we can map data structure to some class and to allow filter objects over some property of dictionary linked to main data structure. When filter applied this link to dictionary table is used, but when not we ineffectively rise query complexity. To avoid unplanned query complexity XData has optional filter feature. Some filters marked as primary - when this filter has value, query has full form. When filter value has cleared or set to null, data source of filtered field (table or view) will be skipped when SQL query composed. When data source has been skipped then links between already skipped and other data sources are analyzed. And when found link marked as primary linked data source will also skipped. When base table of subquery has been skipped - all subquery will be skipped and subquery links analysis for primary links will be provided over outer query. Until no primary filters found. This allows to compose complex query relations over multiple tables and subqueries that reflect on real query only when it really necessary. Let's explain that on example... public partial class TestOptional: IDataObject { private static Expression<CustomMapping<TestOptional>> _mapping = ( () => XDataMapping.CustomMapping<TestOptional>() .DataTable(\"T_TEST\", \"T\", x => x.SubqueryFilter(string.Empty, \"A\") .SetOperation(FilterOperation.Exists) .Subquery(\"A\", XDataMapping.GetStructure(\"H\") .DataTable(\"T_TEST_OPT\", \"H\") .DataTable(\"T_OPT\", \"P\", // Link between H and P table marked as Primary filter x => x.Link(\"H\", \"opt_id\").AsPrimary(), // ConstFilter \"OptCode\" marked as Primary filter x => x.ConstFilter(\"OptCode\", \"code\", null).AsPrimary()) .Select(x => new { TestId = x.Field<long>(\"H\", string.Empty) }), \"TestId\", DataGrouping.None, x => x.SubqueryLink(\"DocId\")) .Column(\"TestId\", x => x.Field<long>(\"T\", string.Empty)) .Map(x => new TestOptional { Name = x.Field<decimal>(\"T\", string.Empty) }).SetBaseTable(\"T\")); } When repository accessed like that... dataScope.GetReposytory<TestOptional>().ToArray(); XData generate a simple SQL... select T.test_id as T_test_id, T.name as T_name from T_TEST T Because... ConstFilter \"OptCode\" has null value and marked as primary => T_OPT table skipped T_OPT table skipped and Link to T_TEST_OPT marked as primary => T_TEST_OPT table skipped T_TEST_OPT table skipped and marked as base table => subquery is skipped and SubqueryFilter skipped as well, but because it not marked as primary => table T_TEST is not skipped And when filter is filled... dataScope.GetReposytory<TestOptional>() .SetFilterValue(new FilterName(\"OptCode\"), \"TEST\").ToArray(); Now XData generate SQL with optional parts... select T.test_id as T_test_id, T.name as T_name from T_TEST T where exists(select 1 from T_TEST_OPT H join T_OPT P on H.opt_id = P.opt_id where P.code = \"TEST\") Conditional filters XData realization of LINQ \"Where\" method has provide ability to use runtime condition evaluation during predicate compilation into SQL statements to analyze runtime data and conditionally omit non valued data (0, empty or null) filters. // string author, int rating, decimal? lowerPrice and decimal? higherPrice is an optional filter values return dataScope.GetRepository<Book>() .Where(x => (string.IsNullOrEmpty(author) || x.Author == author) && (rating <= 0 || x.Rating >= rating) && (lowerPrice.HasValue || x.Price >= lowerPrice) && (higherPrice.HasValue || x.Price <= higherPrice)) .ToArray(); When runtime condition is true and LINQ expression is OrElse whole expression is omitted while predicate compilation into SQL statements. Outer joined table filtration specifics XDataMapping.CustomMapping<UserList>() .DataTable(\"t_user\", \"U\") // *t_user_claim* has inner joined to *t_user* by *user_id* field .DataTable(\"t_user_claim\", \"UC\", z => z.Link(\"U\", \"user_id\"), // constant filter use default equal operation (see SQL result below) z => z.ConstFilter(\"ClaimNickName\", \"claim_type\", \"nickname\")) // *t_user_app* has outer joined to *t_user* by *user_id* field .DataTable(\"t_user_app\", \"A\", x => x.Link(\"U\", \"user_id\").SetOperation(FilterOperation.OuterJoin), // IMOPRTANT! all filters for outer joined table must use *OuterJoin* operation to apply correct filtration x => x.ConstFilter(\"FilterByAsubs\", \"app_type\", (int) AppType.Asubs).SetOperation(FilterOperation.OuterJoin), x => x.ConstFilter(\"FilterByAsubsEnabled\", \"enabled\", 1).SetOperation(FilterOperation.OuterJoin)) select ... from t_user U join t_user_claim UC on UC.user_id = U.user_id outer join t_user_app A on A.user_id = U.user_id and A.app_type = 1 and A.enabled = 1 Constant filters are moved to outer join condition not in where statement conditions and query will return correct results. Similar rules is applied to static mapping and dynamic query. Tree organized repository child specifics When master repository has hierarchy structure, than detail objects can be filtered by two methods to choose detail repository data: filter data linked with selected tree node only ( direct links ), and linked to subtree from selected node and below by hierarchy. XData has functional to choose one of this methods in runtime. To provide this ability mapping of master objects must describe external links marked as direct links . Than master repository flag ShowSubtree can be used as a switch between this two methods. Let's explain that on example... Mapping master tree organized data object... private static Expression<CustomMapping<Catalog>> _unused = ( () => XDataMapping.CustomMapping<Catalog>() .DataTable(\"R\", \"T_CATALOG\") .Map(x => new Catalog{ CatalogId = x.Field<long>(\"R\", string.Empty, z => z.Key()), Code = x.Field<string>(\"R\", string.Empty), Name = x.Field<string>(\"R\", string.Empty), ParentId = x.Field<long?>(\"R\", string.Empty) }, // Direct link x => x.ExternalLink<Document>(x => x.CatalogId, x => x.DirectLink()), // Subquery link x => x.ExternalLink<Document>(x => x.CatalogId, z => z.Filter(y => new FilterName(\"FilterByRoot\")))) .SetBaseTable(\"R\").SetFlags(DataStructureFlag.Tree) ); Master data object SQL... SELECT R.catalog_id AS R_catalog_id, R.code AS R_code, R.name AS R_name, R.parent_id AS R_parent_id FROM T_CATALOG R Mapping detail data object... private static Expression<CustomMapping<Document>> _unused = ( () => XDataMapping.CustomMapping<Document>() .DataTable(\"D\", \"T_DOC\") .DataTable(\"DC\", \"T_DOC_CATALOG\", x => x.Link(\"D\", \"doc_id\"), x => x.SubqueryFilter(\"catalog_id\", \"UT\") .SetOperation(FilterOperation.In)) .Subquery<CatalogTree>(\"UT\", x => x.CatalogId, DataGrouping.None) .Map(x => new Document{ DocId = x.Field<long>(\"D\", string.Empty, z => z.Key()), DocDate = x.Field<DateTime>(\"D\", string.Empty), CatalogId = x.Field<long>(\"DC\", string.Empty) }) .SetBaseTable(\"D\") ); ... private static Expression<CustomMapping<CatalogTree>> _unused = ( () => XDataMapping.CustomMapping<CatalogTree>() .With(\"CAT\", XDataMapping.GetStructure(\"R\") .DataTable(\"T_CATALOG\", \"R\", x => x.ConstFilter(\"FilterByRoot\", \"parent_id\", FilterConstantType.Const, null, FilterNullable.NullsCompared)) .Select(x => new { CatalogId = x.Field<long>(\"R\", string.Empty, z => z.Key()), ParentId = x.Field<long?>(\"R\", string.Empty), }), x => x.Properties(z => z.CatalogId, z => z.ParentId), x => x.WithRecursive(\"S\", XDataMapping.GetStructure(\"S\") .DataTable(\"T_CATALOG\", \"S\") .Select(y => new { CatalogId = y.Field<long>(\"S\", string.Empty, z => z.Key()), ParentId = y.Field<long?>(\"S\", string.Empty) }), z => z.SubqueryLink(y => y.ParentId, y => y.CatalogId))) .ReadOnlyProperty(x => x.CatalogId, x => x.Field<long>(\"CAT\", string.Empty, z => z.Key())) .ReadOnlyProperty(x => x.ParentId, x => x.Field<long?>(\"CAT\", string.Empty)) .Map().SetFlags(DataStructureFlag.ReadOnly) ); Link and using data objects with ShowSubtree off... dataScope.GetReposytory<Catalog>() .Do(x => x.Instance.GetChild<Document>()) .ToArray(); Detail data object SQL... with recursive T (catalog_id, code, name, parent_id) as ((SELECT R.catalog_id AS R_catalog_id, R.parent_id AS R_parent_id FROM T_CATALOG R WHERE R.catalog_id = @FilterByRoot) UNION ALL (SELECT S.catalog_id AS S_catalog_id, S.parent_id AS S_parent_id FROM T_CATALOG S, T T WHERE S.parent_id = (T.catalog_id))) SELECT D.doc_date AS D_doc_date /* DocDate */, D.doc_id AS D_doc_id /* DocId */, DC.catalog_id AS DC_catalog_id /* CatalogId */ FROM T_DOC D JOIN T_DOC_CATALOGUE DC ON DC.doc_id = D.doc_id WHERE DC.catalog_id in (SELECT T.catalog_id AS T_catalog_id FROM T T) and DC.catalog_id = @FilterByCatalogId Direct link is filled and detail data object data is restricted by single catalogue_id from master data object. Link and using data objects with ShowSubtree on... dataScope.GetReposytory<Catalog>() .Do(x => x.Instance.GetChild<Document>(), x => x.Instance.ShowSubtree = true) .ToArray(); Detail data object SQL... with recursive T (catalog_id, code, name, parent_id) as ((SELECT R.catalog_id AS R_catalog_id, R.parent_id AS R_parent_id FROM T_CATALOG R WHERE R.catalog_id = @FilterByRoot) UNION ALL (SELECT S.catalog_id AS S_catalog_id, S.parent_id AS S_parent_id FROM T_CATALOG S, T T WHERE S.parent_id = (T.catalog_id))) SELECT D.doc_date AS D_doc_date /* DocDate */, D.doc_id AS D_doc_id /* DocId */, DC.catalog_id AS DC_catalog_id /* CatalogId */ FROM T_DOC D JOIN T_DOC_CATALOGUE DC ON DC.doc_id = D.doc_id WHERE DC.catalog_id in (SELECT T.catalog_id AS T_catalog_id FROM T T) Direct link not filled and data not restricted by single catalogue_id from master data object. Resulted detail data will match master data object current record subtree. Reuse mapping in dynamic query Already declared mappings can be reused in dynamic query construction with generic GetStructure method overload. See the example below to understand how it works: using (var dataScope = DataEngine.NewDataScope()) { var user = dataScope.GetRepository<User>().SingleOrDefault(x => x.UserId.ToString() == userId); if (user == null) throw new Exception(\"User not found!\"); // prepare enum values expression array to *Case* expression based on AppType enum var enumValues = typeof(AppType).GetEnumKeyValuePairs() .Select(i => i.Key.SetExpression(x => i.Value)) .ToArray(); // reuse *UserRole* mapping adding filter by *user_id* column and redefine select output var roleClaims = XDataMapping.GetStructure<UserRole>().AddFilters(\"UR\", x => x.ConstFilter(\"FilterByUserId\", \"user_id\", userId.ToString())) .Column(\"UserId\", x => x.Field<Guid>(\"UR\", string.Empty)) .Select(x => new UserClaim { // set negative id to preserve key uniqueness after appling *Union* operation using expression field Id = x.Expr(\"id\", z => -1 * z.Field<long>(\"R\", \"role_id\"), DbType.Int64), Type = x.Expr(\"role\", z => \"role\", DbType.String), // construct role name based by *app_type* enum field and role name using SQL *Case* expression Value = x.Expr(\"val\", z => z.Case(y => y.Field<long>(\"R\", \"app_type\"), y => \"\", enumValues) + \".\" + x.Field<string>(\"R\", \"role\"), DbType.String) }).AsQuery(dataScope); user.Applications = apps.SetFilterValue(x => UserId, userId).ToArray(); user.Roles = dataScope.GetRepository<UserRole>().SetFilterValue(x => UserId, userId).ToArray(); // Combine simple claims and synthetic role claims user.Claims = dataScope.GetRepository<UserClaim>() .SetFilterValue(x => UserId, userId) .Union(roleClaims).ToArray(); return user; } Dynamic query external data sources XData dynamic query can use external data sources to operate with runtime tabular or xml data together with data stored inside database. Warning This feature is not supported by all of databases! XML data sources can be used with Ms SQL Server and PostgreSQL only. Local temporary tables is not supported by Oracle database. As You can see, Oracle not supported both of features. Use PL/SQL functions, packages or predefined global temporary tables instead. XML data source // prepare XML document var doc = new XDocument(new XElement(\"root\", new XElement(\"test\", new XAttribute(\"doc_state_id\", 1), new XAttribute(\"test\", \"one\")), new XElement(\"test\", new XAttribute(\"doc_state_id\", 2), new XAttribute(\"test\", \"two\")) )).ToString(); var query = XDataMapping.GetStructure(\"S\") .DataTable(\"T_DOC_STATE\", \"S\") // use XmlSource definition providing XPath expression for data source .XmlSource(\"Test\", \"T\", \"root/test\", x => x.Link(\"S\", \"doc_state_id\")) .Select(x => new { // use XmlField definition with XPath expression as a field source DocStateId = x.XmlField<int>(\"T\", string.Empty, \"@doc_state_id\", DbType.Int32, z => z.Key()), Code = x.Field<string>(\"S\", string.Empty), // note, string and number (decimal) xml fields need size defined, like an expression fields Test = x.XmlField<string>(\"T\", string.Empty, \"@test\", DbType.String, z => z.Size(20)) // set XML string to variable with the same name as XmlSource }).AsQuery(dataScope, \"Test\".SetVar(doc)); Temporary table // prepare tabular data var table = new DataTable(); table.Columns.AddRange(new [] { new DataColumn(\"doc_state_id\", typeof(long)), new DataColumn(\"test\", typeof(string)) }); table.Rows.Add(1, \"one\"); table.Rows.Add(2, \"two\"); table.AcceptChanges(); var query = XDataMapping.GetStructure(\"S\") .DataTable(\"T_DOC_STATE\", \"S\") // use temporary table definition .TempTable(\"Test\", \"T\", x => x.Link(\"S\", \"doc_state_id\")) .Select(x => new { // use Field method overload with dbType parameter to define temporary table field DocStateId = x.Field<long>(\"T\", string.Empty, DbType.Int64, z => z.Key()), Code = x.Field<string>(\"S\", string.Empty), // note, string and number (decimal) xml fields need size defined, like an expression fields Test = x.Field<string>(\"T\", string.Empty, DbType.String, z => z.Size(20)) // set DataTable to variable with the same name as TempTable }).AsQuery(dataScope, \"Test\".SetVar(table)); Using dictionaries Dictionaries can be used to reduce data re-query count when rarely changed data of dictionary will linked multiple times through Link<T,TSource> data type properties over small amount of time (one business process). Dictionaries is cached as single mapped objects (not a data cahe as described in Caching repository data topic). Property update source Data object properties (or hidden properties ) values can depend on other properties values or calculated with some expression. XData allow to describe this expression or dependency as part of mapping, to skip that property initialization when inserting or updating data object. Property value update source is used when data object is inserted or updated. When property default value and update source are defined, default value is used on insert and update source on update. Property value update source expression when using static mapping is defined by PropertyUpdateWithAttribute (or ColumnUpdateWithAttribute ) with same rules as PlainSQL or LinqExpression SQL expression properties : // for PlainSQL [PropertyUpdateWith(\"case P.is_vip when 1 then 10 else 0 end\")] // or for LinqExpression [PropertyUpdateWith(\"AllowedDiscount\", DataExpressionType.LinqExpression)] ... [SqlExpression] private static Calculate<int> AllowedDiscount = x => x.Case<Product, int>( z => z.Field<bool>(\"is_vip\"), z => 0, 1.SetExpression(z => 10)); When using dynamic mapping it is defined by Field's mapping attribute UpdateWith overloads: UpdateWith(DataExpressionType type, string exprText) UpdateWith(Expression<Func<IQueryStructureAdapter, TValue>> expr) DeliveryDate = x.Field<DateTime?>(\"DD\", string.Empty, z => z.UpdateWith(y => DateTime.Today.AddDays(1))) Property value update source dependency when using static mapping is defined by PropertyUpdateWithAttribute (or ColumnUpdateWithAttribute ) with same rules as Subquery SQL expression properties : [Subquery(\"A\" /* subquery alias */, typeof(DocSpecAmounts) /* subquery mapped type */, \"Amount\" /* subquery result property name */, Grouping = DataGrouping.Sum /* result property aggregation type */)] ... [PropertyUpdateWith(\"A\", DataExpressionType.SubQuery)] When using dynamic mapping it is defined by Field's mapping attribute UpdateWith overloads: UpdateWith(string alias, Type dobjType, string property, DataGrouping grouping = DataGrouping.None, params Expression<Func<ISubqueryLinkAdapter, IStructureFlag>>[] attributes) UpdateWith(string alias, IQueryDescription<TDObj> sub, string property, DataGrouping grouping = DataGrouping.None, params Expression<Func<ISubqueryLinkAdapter, IStructureFlag>>[] attributes) UpdateWith(string alias, IQueryDescription<TDObj> sub, Expression<Func<TDObj, TValue>> property, DataGrouping grouping = DataGrouping.None, params Expression<Func<ISubqueryLinkAdapter, IStructureFlag>>[] attributes) DeliveryType = x.Field<DeliveryTypeEnum>(\"DD\", string.Empty, z => z.UpdateWith(\"DT\", XDataMapping.GetStructure() .Select(y => new { DeliveryType = y.Expr(\"delivery_type\", a => DeliveryTypeEnum.Courier, DbType.Int32)}), y => y.DeliveryType, DataGrouping.None)), Default value features Data object properties (or hidden properties ) can be assigned by default values described by mapping. Using DefaultFeature enumeration it's possible to extend basic functionality of default value assignment with... UseOnUpdate - use default value not only on insert, but on update also. SkipWhenAssigned - skip insert into table when PK value assigned explicitly. UpdateWhenAssigned - change insert operation over table to update when PK value assigned explicitly. Last two of features is usable when data object 's primary table is linked with another table in data object mapping as one-to-one, and insert into base table can be skipped (or replaced with update statement) when it's primary key is assigned explicitly in application code. This features helps logically combine mappings to hide technological entities, which don't reflect business object model of application. Default features can be combined. For example: DefaultFeature.UseOnUpdate | DefaultFeature.SkipWhenAssigned Cast to type To cast type of Field or Expression while mapping declaration can be reached using CastTo method. ... OrgSubType = x.Expr(\"org_subtype\", z => z.CastTo<OrgSubType>().Field<string>(\"S\", \"param_value\"), DbType.String) ... Caching repository data Some data is changed often, some is rarely, but some data will never changed until application has upgraded. To reduce re-query of this static data, XData has mechanism to cache requested data (not a mapped objects) in XData. Repository property FixedQuery can be assigned to true when caching is required. All LINQ queries will be translated to this cache without re-query data from database. When this property resets to false, the cache will erased and repository returns to common algorithms of database requests. Similar feature is used to access rarely changed dictionary data over multiple related operative data changes. Copy data Data can be copied from one repository to another using IRepository<T>.Add<TFrom> method as illustrated in followed example: // Query source data (statically, or dynamically) into sourceQuery variable var rep = dataScope.GetRepository<Target>(); using(var tr = dataScope.BeginTransaction()) { rep.Add<Source>(sourceQuery, x => new Target{ TargetSome = x.Some, TargetAnother = x.Another }); tr.Commit(); } Trigger business logic Important It is important to understand the difference between database level triggers and these XData level triggers. A database trigger is called during changes made to the records of the table, whereas XData logic module processes the changes in the level of the data object. It must be remembered that a data object can include several database tables on the one hand and, on the other hand, a part of information regarding other objects can be stored in one table. And from this point of view, the value of such a mechanism inside the XData can hardly be overestimated! Custom logic called over data object explicitly. But XData can call trigger logic over business valuable data object (not a single table!) on middle-ware level (no matter extracted this logic to dedicated application server or not). This logic will be called automatically when corresponded changes are applied: InitRepository - middle-ware trigger executed when Repository has been initialized (trigger delegate type - InitRepository<T> ) InvalidateRepository - middle-ware trigger executed when Repository data need to be reseted (trigger delegate type - InvalidateRepository<T> ) InvalidateObject - middle-ware trigger executed when Repository object need to be reloaded (trigger delegate type - InvalidateObject<T> ) InitObject - middle-ware trigger executed when Repository object has been initialized (trigger delegate type - InitObject<T> ) BeforeInsert - middle-ware trigger executed before object inserted into Repository (trigger delegate type - Trigger<T> ) BeforeUpdate - middle-ware trigger executed before Repository object has been updated (trigger delegate type - Trigger<T> ) BeforeDelete - middle-ware trigger executed before object has been deleted from Repository (trigger delegate type - Trigger<T> ) AfterInsert - middle-ware trigger executed after object inserted into Repository (trigger delegate type - Trigger<T> ). Skip flag is not applicable! AfterUpdate - middle-ware trigger executed after Repository object has been updated (trigger delegate type - Trigger<T> ). Skip flag is not applicable! AfterDelete - middle-ware trigger executed after object has been deleted from Repository (trigger delegate type - Trigger<T> ). Skip flag is not applicable! BeforeClear - middle-ware trigger executed before Repository has been cleared (trigger delegate type - RepositoryTrigger<T> ) AfterClear - middle-ware trigger executed after Repository has been cleared (trigger delegate type - RepositoryTrigger<T> ). Skip flag is not applicable! Trigger delegate type - it's a method signature for middle-ware trigger handler. public class InvoiceLogic : XDataLogic<Invoice> { [Action(DataActionType.AfterInsert), Action(DataActionType.AfterUpdate)] public Trigger<Invoice> UpdateHistory => ((ref Invoice invoice, ref DataTriggerFlag flag) => { if (!invoice.CheckState(DataObjectState.New) && !invoice.IsChanged(x => x.DocState)) return true; var rep = invoice.GetRepository(); using (var hist = GetRepository<DocHistory>(rep.Layer, context: rep.Context)) { hist.Reset() .SetFilterValue(DocHistory.FilterByDocId, invoice.GetProperty<long>(\"DocId\")) .SetFilterValue(DocHistory.FilterByDocStateId, invoice.DocState.Key); var newHist = hist.New(); newHist.HistoryDate = DateTime.UtcNow; return hist.Submit(ref newHist); } }); [Action(DataActionType.BeforeDelete)] public Trigger<Invoice> ClearHistory => ((ref Invoice invoice, ref DataTriggerFlag flag) => { var i = invoice; using (var hist = GetRepository<DocHistory>(i.GetLayer(), context: i.GetContext())) { return hist.Reset() .Clear(x => x.GetProperty<long>(\"DocId\") == i.GetProperty<long>(\"DocId\")); } }); [Action(DataActionType.BeforeClear)] public RepositoryTrigger<Invoice> ClearHistoryBatch => ((IRepository<Invoice> invoiceRepository, ref DataTriggerFlag flag) => { using (var hist = GetRepository<DocHistory>(invoiceRepository.Layer, context: invoiceRepository.Context)) { return hist.Reset().Clear(x => invoiceRepository .Any(z => x.GetProperty<long>(\"DocId\") == z.GetProperty<long>(\"DocId\"))); } }); } Trigger and RepositoryTrigger delegates has a reference parameter of type DataTriggerFlag to specify behavior of data processing after trigger executed. There are three possible behaviors defined: None - Submit using default algorithm, representation layer is already refreshed Skip - Data submitting have completed in trigger logic or not applicable. No standard updates will called. It's a kind of \"instead of\" trigger logic flag. Refresh - Default value. Representation layer manual data refreshing is needed. Trigger logic defined as attributed by Action attribute read only property of XDataLogic<T> class descendant. One property can be attributed as a handler for multiple triggers. Property type must to be Trigger<T> except repository based triggers ( BeforeClear , AfterCLear , InitRepository or InvalidateRepository ) - RepositoryTrigger<T> . Execute custom business logic XData has many features targeting this technology as not only ORM, but a full featured Data Access Layer. This is one of this features. Custom logic defined as public property of XDataLogic<T> class descendant with type of CustomLogic<T> . public class InvoiceLogic : XDataLogic<Invoice> { public CustomLogic<Invoice> TestCustomLogic => (objects => { Log.Write(MessageType.Information, () => $\"TestCustomLogic called with {objects.Length} objects\"); foreach (var invoice in objects) { var i = invoice; invoice.PostData(\"testPost\", () => Encoding.UTF8.GetBytes(i.DocNumb)); var p = Encoding.UTF8.GetBytes(i.DocNumb); var r = i.Callback(\"testCall\", ref p); Log.Write(MessageType.Information, () => @$\"Call for \\\"{i.DocNumb}\\\" returned \\\"{r}\\\" with data \\\"{(p == null ? null : Encoding.UTF8.GetString(p))}\\\"\"); } return true; }); } ... //Call example logic var random = new Random(); return dataScope.GetRepository<Invoice>().ToArray().Execute(() => \"TestCustomLogic\", \"testPost\".SetValue((Action<byte[]>)(data => Console.WriteLine(\"Post message received (data=\\\"{0}\\\")\", data == null ? null : Encoding.UTF8.GetString(data)))) .AsEnum().ToDictionary(), \"testCall\".SetValue((Func<byte[], byte[]>)(data => { Console.WriteLine(\"Call received \\\"{0}\\\")\", data == null ? null : Encoding.UTF8.GetString(data)); return random.NextDouble() >= 0.5 ? null : Encoding.UTF8.GetBytes( $\"reply for \\\"{(data == null ? null : Encoding.UTF8.GetString(data))}\\\"\"); })).AsEnum().ToDictionary()); Programmer can develop data centric logic over some of mapped objects with ability to execute this logic in the middle ware layer of three-tier architecture on a dedicated server (or cluster). And this code can be simple and representable debugged in two-tier environment. Architecture can be switched by configuration! No code modification, no side effects... This feature is linked with Trigger logic and reached by Callbacks . When code is organized using data mapping modules, data logic modules and client (or Web site) it can help programmer to keep module relations clean and get ready to changes, with no matter of middle-ware layer existence. And this rules are not dictated, You can use it or not. You can write this logic anywhere You architect to do. Nothing will be breaks, except of ability to use XData three-tier architecture. But if You really don't need it, what is wrong? Using business logic callbacks XData allows to use business logic callbacks to interact back-end modules with front-end using synchronous Callback and asynchronous PostData models. Synchronous calls can return result value. Callbacks can be used with three-tier-architecture as well as with client-server model. Callbacks has provided business logic clear, complete view and allows debug same code in two-tier environment as code will be executed in three-tier. public class InvoiceLogic : XDataLogic<Invoice> { public CustomLogic<Invoice> TestCustomLogic => (objects => { Log.Write(MessageType.Information, () => $\"TestCustomLogic called with {objects.Length} objects\"); foreach (var invoice in objects) { var i = invoice; invoice.PostData(\"testPost\", () => Encoding.UTF8.GetBytes(i.DocNumb)); var p = Encoding.UTF8.GetBytes(i.DocNumb); var r = i.Callback(\"testCall\", ref p); Log.Write(MessageType.Information, () => @$\"Call for \\\"{i.DocNumb}\\\" returned \\\"{r}\\\" with data \\\"{(p == null ? null : Encoding.UTF8.GetString(p))}\\\"\"); } return true; }); } Business logic calculated fields XData allowed to calculate fields not only using SQL expressions . You can subscribe OnInvalidateObject event and calculate some fields on client side. More detailed events discussed below . Using events Custom logic call and trigger logic is executed on the middle-ware layer, deployed on the application server or not. But some reaction on data change events may be required on client side. XData has followed events to subscribe changes of data: InitRepository<T> OnInit - event acquired when repository has been initialized InitObject<T> OnInitObject - event acquired when object has been initialized by database or default values InvalidateRepository<T> OnInvalidate - repository data has been re-queried from database InvalidateObject<T> OnInvalidateObject - object has been changed and re-queried from database CurrentObjectChanging<T> OnCurrentObjectChanging - current object is changing CurrentObjectChanged<T> OnCurrentObjectChanged - current object has been changed Virtual data and attached handlers You can use XData as database mock engine. XData has feature to replace database interactions with attached handlers call. Virtual objects is attached to repository using Attach method of IRepository<T> interface. To detach virtual objects used Detach method. Multiple virtual entities can be attached to repository as new objects using AttachNewObjects method. Tip This method ( AttachNewObjects ) can be used to add multiple detached objects to real repository. Every virtual entity can override handlers attached to repository with their own realization using parameters of AttachNewObjects method or SetAttachedHandlers method call. To set repository level handlers use special overload of SetAttachedHandlers . To clear attached objects You can use ClearAttachedObjects method. To help wrap handlers to abstract AttachedHandler<T> class and unwrap it back to specialized handlers XData has a wrapper class RepositoryAttachedHandler . Attached handlers can have followed types (see AttachedHandlerType ): OnClear - ( ClearAttachedHandler ) handler called instead of Clear OnExecute - ( ExecuteAttachedHandler<T> ) handler called instead of Execute OnGetLob - ( GetLobAttachedHandler ) handler called instead of requesting LOB data OnGetLobSize - ( GetLobSizeAttachedHandler ) handler called instead of requesting LOB size OnGetXml - ( GetXmlAttachedHandler ) handler called instead of requesting XML data OnLock - ( LockAttachedHandler<T> ) handler called instead of Lock OnRefresh - ( RefreshAttachedHandler<T> ) handler called instead of refreshing data OnSetLob - ( SetLobAttachedHandler ) handler called instead of saving LOB data OnSetXml - ( SetXmlAttachedHandler ) handler called instead of saving XML data OnSubmit - ( SubmitAttachedHandler<T> ) handler called instead of Submit multiple objects OnSubmitObject - ( SubmitObjectAttachedHandler<T> ) handler called instead of submitting single object OnSubmitQuery - ( SubmitQueryAttachedHandler<T> ) handler called instead of submitting query generation Transactions XData use automatic transactions handling by default. But allows to manage transactions manually using IDataScope interface method BeginTransaction returned transaction state interface ITransaction . Transaction state is a IDisposable object. Transaction is committed when method Commit is called. When transaction state is disposed without call Commit method, transaction is rolled back. Transaction can be started as read-only or read/write. This depends on parameter read of BeginTransaction method. XData can simulate wrap transactions one over another. First non read only transaction is related to real database transaction, and all wrapped transactions is related to transaction labels. When wrapped transaction is rolled back real transaction is rolled back to label only. Only rolling back the \"main\" transaction calls ROLLBACK statement over database. SQL hints Warning Before using SQL hints, be sure to use all other query optimization features. This is a \"double-edged weapon.\" You need to understand very well why you are using what hints and how it will affect performance, and also make all the necessary tests confirming the effectiveness of the changes you made! XData supports using SQL hints to improve SQL query productivity. All databases supports this feature using various mechanics and can change various parameters of SQL execution... Types of hints supported by XData for RDBMS... MS SQL Server Query hints Table hints Oracle Query hints MySql Query hints PostgreSQL PostgreSQL does not support hints for queries, but procedures that returns set of record required declare columns definition on call (see example below). Of course, this is not a SQL hint actually, but... create or replace function GetRows(text) returns set of record as $ declare r record; begin for r in EXECUTE ''select * from '' || $1 loop return next r; end loop; return; end $ language 'plpgsql'; select * from GetRows('Department') as dept(deptid int, deptname text); SQLite SQLite does not support hints. Using hints in static mapping Query hints: // hint for empty string alias is applied to query // possible to apply different hints on // select, insert, update, delete statements or their combination [DataObject(\"T\"), Hint(\"\", \"SQL_NO_CACHE\", HintType.Select), Hint(\"\", \"HIGH_PRIORITY\", HintType.Select | HintType.Insert), ... Table hints (MS SQL Server only): [DataObject(\"T\"), DataTable(\"Test\", \"T\"), Hint(\"T\", \"nolock\"), ... Procedure hints (PostgreSQL only): [DataObject(\"T\"), Procedure(\"T\", \"TestFunction9\", ProcedureType.Function), Hint(\"T\", \"Id integer, Name varchar(20)\"), Parameter(\"T\", 1, \"p_id1\", typeof(int), DbType.Int32), Parameter(\"T\", 1, \"p_name1\", typeof(string), DbType.String), Parameter(\"T\", 1, \"p_id2\", typeof(int), DbType.Int32), Parameter(\"T\", 1, \"p_name2\", typeof(string), DbType.String), ResultSet(\"T\")] public class PostgreSqlTestFunction9 : IDataObject { [Property(\"T\", \"Id\", Flags = DataPropertyFlag.Id)] public int Id { get; set; } [Property(\"T\", \"Name\")] public string Name { get; set; } } Using hints in dynamic mapping and dynamic queries Query hints: // hint for empty string alias is applied to query // possible to apply different hints on // select, insert, update, delete statements or their combination XDataMapping.GetStructure(\"T\") .Hint(\"\", \"SQL_NO_CACHE\", HintType.Select) .Hint(\"\", \"HIGH_PRIORITY\", HintType.Select | HintType.Insert)... Table hints (MS SQL Server only): XDataMapping.GetStructure(\"T\") .DataTable(\"Test\", \"T\") .Hint(\"T\", \"nolock\")... Procedure hints (PostgreSQL only): XDataMapping.GetStructure() .Procedure(\"T\", \"TestFunction8\", ProcedureType.Function) .Hint(\"T\", \"Id integer, Name varchar(20)\") .Parameter<Classifier[]>(\"T\", 1, \"p_tab\", DbType.Object, z => z.UdtDataType(null, \"classifier_rec\"), z => z.Array()) .Select(x => new Classifier { Id = x.Field<int>(\"T\", \"Id\", z => z.Key()), Name = x.Field<string>(\"T\", \"Name\") }) .AsQuery(DataScope, \"p_tab\".SetVar(param)); Call custom SQL code XData can help the programmer to obtain data and process it with many ways. But also we hold in mind XData is just a common tool with limited quantity of features, and some very specific (but handy and powerful) SQL dialect constructions may be out of XData possibilities. To call dialect specific SQL statements used IDataScope interface with methods: FillTable , ExecuteScalar and ExecuteNonQuery . const string getCoordComResourceStateChangesForCaseCommand = @\" select x.ResourceCode, x.ReportedDateTime, x.UserName, x.MissionStatusCode, x.ResourceStatusCode from (select h.ResourceCode, h.ReportedDateTime, h.MissionStatusCode, h.ResourceStatusCode, isnull((select top(1) log.Creator from cse_CaseFolderLog_tab log with (nolock) where log.CallCenterId = h.CallCenterId and log.CaseFolderId = h.CaseFolderId and log.CaseId = h.CaseId and log.Created >= h.ReportedDateTime and datediff(s, h.ReportedDateTime, log.Created) <= 10 and (charindex(case h.MissionStatusCode when '---' then 'ready' else h.MissionStatusCode end, log.LogText COLLATE Latin1_General_CS_AS) > 0 or charindex(case h.MissionStatusCode when '---' then 'disconnected' else h.MissionStatusCode end, log.LogText COLLATE Latin1_General_CS_AS) > 0) and charindex(h.ResourceCode, log.LogText COLLATE Latin1_General_CS_AS) > 0 and charindex('|' + log.Creator + '|', @IntegrationUsers) = 0 order by log.Created ) , (select top(1) log.Creator from cse_CaseFolderLogFinished_tab log with (nolock) where log.CallCenterId = h.CallCenterId and log.CaseFolderId = h.CaseFolderId and log.CaseId = h.CaseId and log.Created >= h.ReportedDateTime and datediff(s,h.ReportedDateTime, log.Created) <= 10 and (charindex(case h.MissionStatusCode when '---' then 'ready' else h.MissionStatusCode end, log.LogText COLLATE Latin1_General_CS_AS) > 0 or charindex(case h.MissionStatusCode when '---' then 'disconnected' else h.MissionStatusCode end, log.LogText COLLATE Latin1_General_CS_AS) > 0) and charindex(h.ResourceCode, log.LogText COLLATE Latin1_General_CS_AS) > 0 and charindex('|' + log.Creator + '|', @IntegrationUsers) = 0 order by log.Created )) as UserName from res_ResourceHistory_tab h where h.CallCenterId = @CallCenterId and h.CaseFolderId = @CaseFolderId and h.CaseId = @CaseId and not exists(select 1 from sph_ResourceHistory_tab sh where sh.CallCenterId = h.CallCenterId and sh.CaseFolderId = h.CaseFolderId and sh.CaseId = h.CaseId and sh.ResourceCode = h.ResourceCode and (sh.MissionStatusCode = h.MissionStatusCode or (sh.MissionStatusCode = '---' and sh.ResourceStatusCode = @ClosedStatusCode)) and sh.ReportedDateTime = h.ReportedDateTime)) x where x.UserName is not null\"; using (var dataScope = DataEngine.Value.NewDataScope(CoordComDb)) { return dataScope.FillTable( new Query(getCoordComResourceStateChangesForCaseCommand, CommandType.Text, new QueryParam(\"@CaseFolderId\", caseIdentity.CaseFolderId, DbType.Int32), new QueryParam(\"@CallCenterId\", caseIdentity.CallCenterId, DbType.Int32), new QueryParam(\"@CaseId\", caseIdentity.CaseId, DbType.Int32), new QueryParam(\"@IntegrationUsers\", $\"|{string.Join(\"|\", integrationUsers)}|\"), new QueryParam(\"@ClosedStatusCode\", closedStatusCode) ), CommandBehavior.SingleResult).Rows.OfType<DataRow>() .Select(x => new Tuple<string, DateTime, string, string>( x.Field<string>(0), x.Field<DateTime>(1), x.Field<string>(2), x.Field<string>(3) == \"---\" ? x.Field<string>(4) : x.Field<string>(3))).ToList(); } Tip Use this mechanism with maximum care! This eliminates cross dialect approach of XData development, but we are in a real world with real programmers tasks... and we are never seen real tasks are correspond the rules of ideal program system architecture ;) Anyway this bad feature is a back-door we must provide while XData is not support all features of all specific SQL dialects. Is this really possible?. We think that not, but we will try to provide most of necessary features inside XData as soon as possible. We are need Your help to choose the order of features implementation and ideas to do it best! Important DDL instructions is not implemented by design. We believe DDL in big complicated real business application is not a thing we can delegate to \"dumb-metal-doll\". This is why XData has no mechanics to \"CodeFirst\"... If You're task can use CodeFirst approach - use EF. This way is historically reserved by EF, and no reason to fight for it. Calling custom SQL code is a legal way to apply DDL in XData context. Programmer or database administrator write this SQL script. This code is produced by human, real (not artificial) intellect of professional... XData only has ability to run it over database. Useful little things... During the development of XData, some helpers were developed that may be useful to You too... Single value IEnumerable When it is necessary to call the method that requires IEnumerable<T> and You have a single value, the AsEnum method will be useful. Extensions for collections To clear List with a preliminary call of some logic to free resources associated with a sheet element, the Clear method will help. The GetOrAdd method for List will also be useful. When you need to compare two Dictionary instances, the HasSameValuesAs method can help. For ConcurrentDictionary , the RemoveAll method may come in handy. Outer join For those who are familiar with SQL, it is often convenient to use the concept of OuterJoin in the union of sets, and how it is implemented in LINQ is not comfortable to use. XData has a built-in mechanism for combining sets using methods: FullOuterJoin LeftOuterJoin RightOuterJoin Tip It is necessary to take into account that these procedures use the Linq2object interface IEnumerable and for the effective use of combining data in the database, you must use mapping or dynamic queries . Processing To pre-process an object before using it (for example, to initialize the properties of a repository before using it as a LINQ data source), it is useful to use the Do extension: var obj = dataScope.GetRepository<Invoice>() .Do(x => x.Instance.GetChild(z => z.InvoiceSpec)) .First(); To access source object use property Instance of action argument and properties of dynamic property State of action argument to store some values between actions."
  },
  "tips/outer_join.html": {
    "href": "tips/outer_join.html",
    "title": "Outer joined table filtration specifics | XData website",
    "keywords": "Outer joined table filtration specifics XDataMapping.CustomMapping<UserList>() .DataTable(\"t_user\", \"U\") // *t_user_claim* has inner joined to *t_user* by *user_id* field .DataTable(\"t_user_claim\", \"UC\", z => z.Link(\"U\", \"user_id\"), // constant filter use default equal operation (see SQL result below) z => z.ConstFilter(\"ClaimNickName\", \"claim_type\", \"nickname\")) // *t_user_app* has outer joined to *t_user* by *user_id* field .DataTable(\"t_user_app\", \"A\", x => x.Link(\"U\", \"user_id\").SetOperation(FilterOperation.OuterJoin), // IMOPRTANT! all filters for outer joined table must use *OuterJoin* operation to apply correct filtration x => x.ConstFilter(\"FilterByAsubs\", \"app_type\", (int) AppType.Asubs).SetOperation(FilterOperation.OuterJoin), x => x.ConstFilter(\"FilterByAsubsEnabled\", \"enabled\", 1).SetOperation(FilterOperation.OuterJoin)) select ... from t_user U join t_user_claim UC on UC.user_id = U.user_id outer join t_user_app A on A.user_id = U.user_id and A.app_type = 1 and A.enabled = 1 Constant filters are moved to outer join condition not in where statement conditions and query will return correct results. Similar rules is applied to static mapping and dynamic query."
  },
  "tips/events.html": {
    "href": "tips/events.html",
    "title": "Using events | XData website",
    "keywords": "Using events Custom logic call and trigger logic is executed on the middle-ware layer, deployed on the application server or not. But some reaction on data change events may be required on client side. XData has followed events to subscribe changes of data: InitRepository<T> OnInit - event acquired when repository has been initialized InitObject<T> OnInitObject - event acquired when object has been initialized by database or default values InvalidateRepository<T> OnInvalidate - repository data has been re-queried from database InvalidateObject<T> OnInvalidateObject - object has been changed and re-queried from database CurrentObjectChanging<T> OnCurrentObjectChanging - current object is changing CurrentObjectChanged<T> OnCurrentObjectChanged - current object has been changed"
  },
  "tips/distinct.html": {
    "href": "tips/distinct.html",
    "title": "Use some LINQ analogs in mapping | XData website",
    "keywords": "Use some LINQ analogs in mapping Warning Usually the use of LINQ analogues of operations in mapping is redundant and does not allow the most complete reuse of mapping results. But in the case when it is necessary to apply operations not to the final query but to its part (subquery or inner view), there are no options... Distinct when Static mapping used as... ... [DataObject(\"S\", Distinct = true)] and when Dynamic mapping used as... ... .Distinct() ... Skip when Static mapping used as... ... [DataObject(\"S\", Skip = 10)] and when Dynamic mapping used as... ... .Skip(10) ... Take when Static mapping used as... ... [DataObject(\"S\", Limit = 1)] and when Dynamic mapping used as... ... .Limit(1) ... OrderBy... Sorting options can be specified when mapping fields... when Static mapping used as... ... [Column(\"DocStateId\", typeof(long?), \"S\", Flags = DataPropertyFlag.Id, OrderBy = 1, /* set order by position for mapped field */ OrderByDesc = true)] /* (optional) set descent sort order */ ... [Property(OrderBy = 1, /* set order by position for mapped field */ OrderByDesc = true)] /* (optional) set descent sort order */ ... [Reference(OrderBy = 1, /* set order by position for mapped field */ OrderByDesc = true)] /* (optional) set descent sort order */ and when Dynamic mapping used as... ... x.Field<string>(\"S\", String.Empty, z => z.OrderBy(1)) ...or for descent sort order x.Field<string>(\"S\", String.Empty, z => z.OrderBy(1, true))"
  },
  "tutorial/mapping/static/procedure/sample_retval_cursor.html": {
    "href": "tutorial/mapping/static/procedure/sample_retval_cursor.html",
    "title": "SQL procedure with return value and result set sample | XData website",
    "keywords": "SQL procedure with return value and result set sample MS SQL Server MS SQL Server CREATE PROCEDURE [dbo].[TestProcedure6] ( @param1 int, @param2 varchar(20) ) AS SELECT @param1 as Id, @param2 as Name RETURN(@param1) Oracle Not supported PostgreSQL Not supported MySQL Not supported Mapping [DataObject(\"T\"), Procedure(\"T\", \"dbo.TestProcedure6\", ProcedureType.Procedure), Parameter(\"T\", 1, \"param1\", typeof(int), DbType.Int32), Parameter(\"T\", 2, \"param2\", typeof(string), DbType.String), Parameter(\"T\", 3, \"ResultParameter\", typeof(int), DbType.Int32, Direction = ParameterDirection.ReturnValue), ResultSet(\"T\")] public class TestProcedure6 : IDataObject { [Property(\"T\", \"Id\", Flags = DataPropertyFlag.Id)] public int Id { get { return this.GetProperty(x => x.Id); } } [Property(\"T\", \"Name\")] public string Name { get { return this.GetProperty(x => x.Name); } } public int ResultParameter { get { return this.GetParameter(x => x.ResultParameter); } } }"
  },
  "tutorial/mapping/static/procedure/sample_retval.html": {
    "href": "tutorial/mapping/static/procedure/sample_retval.html",
    "title": "SQL procedure with return value sample | XData website",
    "keywords": "SQL procedure with return value sample MS SQL Server CREATE PROCEDURE [dbo].[TestProcedure5] ( @param1 int, @param2 varchar(20) ) AS RETURN(@param1) Oracle Not supported PostgreSQL Not supported MySQL Not supported Mapping [DataObject(\"T\"), Procedure(\"T\", \"dbo.TestProcedure5\", ProcedureType.Procedure), Parameter(\"T\", 1, \"param1\", typeof(int), DbType.Int32), Parameter(\"T\", 2, \"param2\", typeof(string), DbType.String), Parameter(\"T\", 3, \"ReturnValue\", typeof(string), DbType.String, Size = 20, Direction = ParameterDirection.ReturnValue, Name = \"result\")] public class TestProcedure5 : IDataObject { public string ReturnValue { get { return this.GetParameter(x => x.ReturnValue); } } }"
  },
  "tutorial/mapping/static/procedure/sample_out_param.html": {
    "href": "tutorial/mapping/static/procedure/sample_out_param.html",
    "title": "SQL procedure with out parameter sample | XData website",
    "keywords": "SQL procedure with out parameter sample MS SQL Server CREATE PROCEDURE [dbo].[TestProcedure3] ( @param1 int, @param2 varchar(20), @param3 varchar(20) OUTPUT ) AS SET @param3 = convert(varchar(20), @param1) + ' - ' + @param2 RETURN Oracle procedure TestProcedure3(p_Id int, p_Name varchar2, p_Out out varchar2) as begin select p_Id || ' - ' || p_Name into p_Out from dual; end TestProcedure3; PostgreSQL CREATE or REPLACE function TestProcedure3(p_id integer, p_name varchar, out p_out varchar) as $$ begin p_Out := p_id || ' - ' || p_name; end $$ LANGUAGE plpgsql; MySQL create procedure TestProcedure3(p_Id int, p_Name varchar(50), out p_Out varchar(100)) begin set p_Out = CONCAT(p_Id, ' - ', p_Name); end Mapping [DataObject(\"T\"), Procedure(\"T\", \"dbo.TestProcedure3\", ProcedureType.Procedure), Parameter(\"T\", 1, \"param1\", typeof(int), DbType.Int32), Parameter(\"T\", 2, \"param2\", typeof(string), DbType.String), Parameter(\"T\", 3, \"OutParameter\", typeof(string), DbType.String, Size = 20, Direction = ParameterDirection.Output, Name = \"param3\")] public class TestProcedure3 : IDataObject { public string OutParameter { get { return this.GetParameter(x => x.OutParameter); } } }"
  },
  "tutorial/mapping/static/procedure/sample_out_cursor.html": {
    "href": "tutorial/mapping/static/procedure/sample_out_cursor.html",
    "title": "SQL procedure with out parameter and result set sample | XData website",
    "keywords": "SQL procedure with out parameter and result set sample MS SQL Server CREATE PROCEDURE [dbo].[TestProcedure4] ( @param1 int, @param2 varchar(20) ) AS SELECT @param1 as Id, @param2 as Name RETURN(@param1) Oracle procedure TestProcedure4(p_Tab in classifier_tab, p_Out out SYS_REFCURSOR) as begin open p_Out for select Id, Name from table(p_Tab); end TestProcedure4; Tip Use refcursor parameters names as ResultSet names! PostgreSQL CREATE OR REPLACE FUNCTION public.TestProcedure4 (p_tab public.classifier_rec [], refcursor) RETURNS refcursor AS $$ begin open $2 for select Id, Name from unnest(p_tab); return $2; end $$ LANGUAGE plpgsql; Tip If refcursor parameters have a names it must be used as ResultSet names! MySQL Not supported Mapping [DataObject(\"T\"), Procedure(\"T\", \"dbo.TestProcedure4\", ProcedureType.Procedure), Parameter(\"T\", 1, \"param1\", typeof(int), DbType.Int32), Parameter(\"T\", 2, \"param2\", typeof(string), DbType.String), Parameter(\"T\", 3, \"OutParameter\", typeof(string), DbType.String, Size = 20, Direction = ParameterDirection.Output, Name = \"param3\"), ResultSet(\"T\")] public class TestProcedure4 : IDataObject { [Property(\"T\", \"Id\", Flags = DataPropertyFlag.Id)] public int Id { get { return this.GetProperty(x => x.Id); } } [Property(\"T\", \"Name\")] public string Name { get { return this.GetProperty(x => x.Name); } } public string OutParameter { get { return this.GetParameter(x => x.OutParameter); } } }"
  },
  "tutorial/mapping/static/procedure/sample_multiple_cursor.html": {
    "href": "tutorial/mapping/static/procedure/sample_multiple_cursor.html",
    "title": "SQL procedure with multiple result sets sample | XData website",
    "keywords": "SQL procedure with multiple result sets sample MS SQL Server CREATE PROCEDURE [dbo].[TestProcedure2] ( @param1 int, @param2 varchar(20), @param3 int, @param4 varchar(20) ) AS BEGIN SELECT @param1 as Id, @param2 as Name SELECT @param3 as Id, @param4 as Name END Oracle procedure TestProcedure2(p_Id int, p_Name varchar2, p_Out out SYS_REFCURSOR, p_Out2 out SYS_REFCURSOR) as begin open p_Out for select p_Id as Id, p_Name as Name from dual; open p_Out2 for select p_Id as Id, p_Name as Name from dual; end TestProcedure2; Tip Use refcursor parameters names as ResultSet names! PostgreSQL CREATE OR REPLACE FUNCTION public.TestProcedure2 (p_id integer, p_name varchar, refcursor, refcursor) RETURNS SETOF refcursor AS $$ begin open $3 for select p_id as Id, p_name as Name; return NEXT $3; open $4 for select p_id as Id, p_name as Name; return NEXT $4; end $$ LANGUAGE plpgsql; Warning Functions witch returns setof refcursor is not supported by NpgSql .Net Standard 2.0 Edition :( XData net4.0 version can call that type functions with the same mapping rules as described here... Tip If refcursor parameters have a names it must be used as ResultSet names! MySQL create procedure TestProcedure2(p_Id int, p_Name varchar(50)) begin select p_Id as Id, p_Name as Name; select p_Id as Id, p_Name as Name; end Mapping [DataObject(\"T\"), Procedure(\"T\", \"dbo.TestProcedure2\", ProcedureType.Procedure), Parameter(\"T\", 1, \"param1\", typeof(int), DbType.Int32), Parameter(\"T\", 2, \"param2\", typeof(string), DbType.String), Parameter(\"T\", 3, \"param3\", typeof(int), DbType.Int32), Parameter(\"T\", 4, \"param4\", typeof(string), DbType.String), ResultSet(\"T\", IsDefault = true), ResultSet(\"T\", \"SecondResult\", ResultType = typeof(TestResult), Order = 2)] public class TestProcedure2 : IDataObject { [Property(\"T\", \"Id\", Flags = DataPropertyFlag.Id)] public int Id { get { return this.GetProperty(x => x.Id); } } [Property(\"T\", \"Name\")] public string Name { get { return this.GetProperty(x => x.Name); } } public IEnumerable<TestResult> SecondResult { get { return this.GetResultSet(x => x.SecondResult); } } }"
  },
  "tutorial/mapping/static/procedure/parameter.html": {
    "href": "tutorial/mapping/static/procedure/parameter.html",
    "title": "SQL procedure parameter | XData website",
    "keywords": "SQL procedure parameter To define SQL procedure parameter used ParameterAttribute with parameters: Alias - procedure alias, Order - order number of parameter, Binding - name used inside application code (it's handy to use parameter with another name, not the name defined inside DB), Type - data type used inside application code, DbType - data type on ADO .Net provider level, Direction - optional, parameter direction, default is ParameterDirection . Input , Size - optional, parameter size(if applicable), Scale - optional, parameter precision (if applicable), Name - optional, parameter name, default is equal with Binding , DefaultType - default value type , DefaultValue optional, depends on DefaultType , NativeSqlType - optional, SQL type name ( NativeSqlType is used when type default mapping is conflicted with real SQL type), UdtTypeName - optional, user defined type (UDT), UdtElementTypeName - optional, user defined type (UDT) of UdtTypeName element (in case where UdtTypeName - array or table), IsArray - optional, parameter is array of UdtElementTypeName (when UdtElementTypeName is omitted, array of DbType ), default is false ."
  },
  "tutorial/mapping/static/filter/subquery_links.html": {
    "href": "tutorial/mapping/static/filter/subquery_links.html",
    "title": "Subquery links | XData website",
    "keywords": "Subquery links Links with subqueries is used to link not table fields but properties of base class and subquery mapped class including hidden properties . To link with subquery or inner view used SubqueryLinkAttribute with parameters: Subquery - subquery alias, SubqueryProperty - linked property from subquery, PropertyName - optional, linked property from base class (when omit, base class property name is equal SubqueryProperty ), also optional properties: Operation , Combination and PrimaryFilter is supported. They was described above in topics Filters and Inner links . [SubqueryLink(\"H\" /* subquery alias */, \"DocId\" /* subquery property to link */)] When flag PrimaryFilter is set to true optional part of query is defined by followed rules: when subquery is skipped, then data source linked to subquery by this filter will be skipped too, and skip data sources analysis will continue inside base class (see Inner links )."
  },
  "api/XData.Mapping.SubqueryVariableAttribute.html": {
    "href": "api/XData.Mapping.SubqueryVariableAttribute.html",
    "title": "Class SubqueryVariableAttribute | XData website",
    "keywords": "Class SubqueryVariableAttribute Data object subquery variable attribute Inheritance Object Attribute SubqueryVariableAttribute Inherited Members Attribute.Equals(Object) Attribute.GetCustomAttribute(Assembly, Type) Attribute.GetCustomAttribute(Assembly, Type, Boolean) Attribute.GetCustomAttribute(MemberInfo, Type) Attribute.GetCustomAttribute(MemberInfo, Type, Boolean) Attribute.GetCustomAttribute(Module, Type) Attribute.GetCustomAttribute(Module, Type, Boolean) Attribute.GetCustomAttribute(ParameterInfo, Type) Attribute.GetCustomAttribute(ParameterInfo, Type, Boolean) Attribute.GetCustomAttributes(Assembly) Attribute.GetCustomAttributes(Assembly, Boolean) Attribute.GetCustomAttributes(Assembly, Type) Attribute.GetCustomAttributes(Assembly, Type, Boolean) Attribute.GetCustomAttributes(MemberInfo) Attribute.GetCustomAttributes(MemberInfo, Boolean) Attribute.GetCustomAttributes(MemberInfo, Type) Attribute.GetCustomAttributes(MemberInfo, Type, Boolean) Attribute.GetCustomAttributes(Module) Attribute.GetCustomAttributes(Module, Boolean) Attribute.GetCustomAttributes(Module, Type) Attribute.GetCustomAttributes(Module, Type, Boolean) Attribute.GetCustomAttributes(ParameterInfo) Attribute.GetCustomAttributes(ParameterInfo, Boolean) Attribute.GetCustomAttributes(ParameterInfo, Type) Attribute.GetCustomAttributes(ParameterInfo, Type, Boolean) Attribute.GetHashCode() Attribute.IsDefaultAttribute() Attribute.IsDefined(Assembly, Type) Attribute.IsDefined(Assembly, Type, Boolean) Attribute.IsDefined(MemberInfo, Type) Attribute.IsDefined(MemberInfo, Type, Boolean) Attribute.IsDefined(Module, Type) Attribute.IsDefined(Module, Type, Boolean) Attribute.IsDefined(ParameterInfo, Type) Attribute.IsDefined(ParameterInfo, Type, Boolean) Attribute.Match(Object) Object.Equals(Object, Object) Object.GetType() Object.MemberwiseClone() Object.ReferenceEquals(Object, Object) Object.ToString() Namespace : XData.Mapping Assembly : XData.docfx.dll Syntax [AttributeUsage(AttributeTargets.Class, AllowMultiple = true)] public class SubqueryVariableAttribute : Attribute Examples SubqueryVariable(\"A\", \"TestVar\", 1) Constructors | Improve this Doc View Source SubqueryVariableAttribute(String, String, Object) Declaration public SubqueryVariableAttribute(string alias, string name, object value) Parameters Type Name Description String alias String name Object value Properties | Improve this Doc View Source Alias Subquery alias Declaration public string Alias { get; } Property Value Type Description String | Improve this Doc View Source Name Variable name Declaration public string Name { get; } Property Value Type Description String | Improve this Doc View Source TypeId When implemented in a derived class, gets a unique identifier for this Attribute . Declaration public override object TypeId { get; } Property Value Type Description Object An Object that is a unique identifier for the attribute. Overrides Attribute.TypeId | Improve this Doc View Source Value Variable value Declaration public object Value { get; } Property Value Type Description Object Extension Methods SerializationExtensions.ToXml<T>(T) CollectionsExtensions.SetValue<TKey, T>(TKey, T) CollectionsExtensions.AsEnum<T>(T) DataObjectQueryableExtensions.CompareVariable(Object, FilterOperation, String) Processing.Do<T>(T, Action<IProcess<T>>[]) TypeExtensions.TryConvert<T, TResult>(T, Func<T, TResult>) TypeExtensions.TryConvert<T, TResult>(T, Func<T, TResult>, TResult) TypeExtensions.ChangeType<T>(Object) TypeExtensions.ChangeType(Object, Type) TypeExtensions.InvokeMethod<TRet>(Object, Type[], Expression<Func<TRet>>, BindingFlags) TypeExtensions.InvokeMethod(Object, Type[], Expression<Action>, BindingFlags) TypeExtensions.InvokeMethod<TRet>(Object, Expression<Func<TRet>>, BindingFlags) TypeExtensions.InvokeMethod(Object, Expression<Action>, BindingFlags) SqlBlockExtensions.SetExpression<TTag, TResult>(TTag, Expression<Func<IBlockQueryAdapter, TResult>>) QueryDescriptionExtensions.SetExpression<TTag, TResult>(TTag, Expression<Func<IQueryStructureAdapter, TResult>>) See Also SubqueryAttribute"
  },
  "api/XData.Mapping.SubqueryLinkAttribute.html": {
    "href": "api/XData.Mapping.SubqueryLinkAttribute.html",
    "title": "Class SubqueryLinkAttribute | XData website",
    "keywords": "Class SubqueryLinkAttribute Data object link to subquery attribute Inheritance Object Attribute FilterBaseAttribute SubqueryLinkAttribute Inherited Members Attribute.Equals(Object) Attribute.GetCustomAttribute(Assembly, Type) Attribute.GetCustomAttribute(Assembly, Type, Boolean) Attribute.GetCustomAttribute(MemberInfo, Type) Attribute.GetCustomAttribute(MemberInfo, Type, Boolean) Attribute.GetCustomAttribute(Module, Type) Attribute.GetCustomAttribute(Module, Type, Boolean) Attribute.GetCustomAttribute(ParameterInfo, Type) Attribute.GetCustomAttribute(ParameterInfo, Type, Boolean) Attribute.GetCustomAttributes(Assembly) Attribute.GetCustomAttributes(Assembly, Boolean) Attribute.GetCustomAttributes(Assembly, Type) Attribute.GetCustomAttributes(Assembly, Type, Boolean) Attribute.GetCustomAttributes(MemberInfo) Attribute.GetCustomAttributes(MemberInfo, Boolean) Attribute.GetCustomAttributes(MemberInfo, Type) Attribute.GetCustomAttributes(MemberInfo, Type, Boolean) Attribute.GetCustomAttributes(Module) Attribute.GetCustomAttributes(Module, Boolean) Attribute.GetCustomAttributes(Module, Type) Attribute.GetCustomAttributes(Module, Type, Boolean) Attribute.GetCustomAttributes(ParameterInfo) Attribute.GetCustomAttributes(ParameterInfo, Boolean) Attribute.GetCustomAttributes(ParameterInfo, Type) Attribute.GetCustomAttributes(ParameterInfo, Type, Boolean) Attribute.GetHashCode() Attribute.IsDefaultAttribute() Attribute.IsDefined(Assembly, Type) Attribute.IsDefined(Assembly, Type, Boolean) Attribute.IsDefined(MemberInfo, Type) Attribute.IsDefined(MemberInfo, Type, Boolean) Attribute.IsDefined(Module, Type) Attribute.IsDefined(Module, Type, Boolean) Attribute.IsDefined(ParameterInfo, Type) Attribute.IsDefined(ParameterInfo, Type, Boolean) Attribute.Match(Object) Object.Equals(Object, Object) Object.GetType() Object.MemberwiseClone() Object.ReferenceEquals(Object, Object) Object.ToString() Namespace : XData.Mapping Assembly : XData.docfx.dll Syntax [AttributeUsage(AttributeTargets.Class, AllowMultiple = true)] public sealed class SubqueryLinkAttribute : FilterBaseAttribute Constructors | Improve this Doc View Source SubqueryLinkAttribute(String, String, String) Subquery link attribute Declaration public SubqueryLinkAttribute(string subquery, string subqueryProperty, string property = \"\") Parameters Type Name Description String subquery Child source alias String subqueryProperty Child property to link String property Parent property contains value to link Exceptions Type Condition XDataRuntimeException Child source alias cannot be null or empty string XDataRuntimeException Child property to link cannot be null or empty string Properties | Improve this Doc View Source Combination Filter combination (filter group) name Declaration public string Combination { get; set; } Property Value Type Description String See Also FilterCombinationAttribute | Improve this Doc View Source FilterType Filter type Declaration public override FilterType FilterType { get; } Property Value Type Description FilterType Overrides FilterBaseAttribute.FilterType See Also FilterType | Improve this Doc View Source Operation Filter operation Declaration public FilterOperation Operation { get; set; } Property Value Type Description FilterOperation See Also FilterOperation | Improve this Doc View Source PrimaryFilter Primary filter flag Declaration public bool PrimaryFilter { get; set; } Property Value Type Description Boolean See Also OptionalFilterAttribute | Improve this Doc View Source PropertyName Parent property Declaration public string PropertyName { get; } Property Value Type Description String Remarks If not assigned used SubqueryProperty name | Improve this Doc View Source Subquery Child source alias Declaration public string Subquery { get; } Property Value Type Description String See Also Alias | Improve this Doc View Source SubqueryProperty Child property to link Declaration public string SubqueryProperty { get; } Property Value Type Description String | Improve this Doc View Source TypeId When implemented in a derived class, gets a unique identifier for this Attribute . Declaration public override object TypeId { get; } Property Value Type Description Object An Object that is a unique identifier for the attribute. Overrides Attribute.TypeId Extension Methods SerializationExtensions.ToXml<T>(T) CollectionsExtensions.SetValue<TKey, T>(TKey, T) CollectionsExtensions.AsEnum<T>(T) DataObjectQueryableExtensions.CompareVariable(Object, FilterOperation, String) Processing.Do<T>(T, Action<IProcess<T>>[]) TypeExtensions.TryConvert<T, TResult>(T, Func<T, TResult>) TypeExtensions.TryConvert<T, TResult>(T, Func<T, TResult>, TResult) TypeExtensions.ChangeType<T>(Object) TypeExtensions.ChangeType(Object, Type) TypeExtensions.InvokeMethod<TRet>(Object, Type[], Expression<Func<TRet>>, BindingFlags) TypeExtensions.InvokeMethod(Object, Type[], Expression<Action>, BindingFlags) TypeExtensions.InvokeMethod<TRet>(Object, Expression<Func<TRet>>, BindingFlags) TypeExtensions.InvokeMethod(Object, Expression<Action>, BindingFlags) SqlBlockExtensions.SetExpression<TTag, TResult>(TTag, Expression<Func<IBlockQueryAdapter, TResult>>) QueryDescriptionExtensions.SetExpression<TTag, TResult>(TTag, Expression<Func<IQueryStructureAdapter, TResult>>) See Also SubqueryAttribute InnerViewAttribute"
  },
  "api/XData.Mapping.SubqueryFilterAttribute.html": {
    "href": "api/XData.Mapping.SubqueryFilterAttribute.html",
    "title": "Class SubqueryFilterAttribute | XData website",
    "keywords": "Class SubqueryFilterAttribute Data object subquery filter attribute Inheritance Object Attribute FilterBaseAttribute FilterAttribute OptionalFilterAttribute SubqueryFilterAttribute Inherited Members OptionalFilterAttribute.PrimaryFilter FilterAttribute.Source FilterAttribute.FieldName FilterAttribute.Operation FilterAttribute.Combination Attribute.Equals(Object) Attribute.GetCustomAttribute(Assembly, Type) Attribute.GetCustomAttribute(Assembly, Type, Boolean) Attribute.GetCustomAttribute(MemberInfo, Type) Attribute.GetCustomAttribute(MemberInfo, Type, Boolean) Attribute.GetCustomAttribute(Module, Type) Attribute.GetCustomAttribute(Module, Type, Boolean) Attribute.GetCustomAttribute(ParameterInfo, Type) Attribute.GetCustomAttribute(ParameterInfo, Type, Boolean) Attribute.GetCustomAttributes(Assembly) Attribute.GetCustomAttributes(Assembly, Boolean) Attribute.GetCustomAttributes(Assembly, Type) Attribute.GetCustomAttributes(Assembly, Type, Boolean) Attribute.GetCustomAttributes(MemberInfo) Attribute.GetCustomAttributes(MemberInfo, Boolean) Attribute.GetCustomAttributes(MemberInfo, Type) Attribute.GetCustomAttributes(MemberInfo, Type, Boolean) Attribute.GetCustomAttributes(Module) Attribute.GetCustomAttributes(Module, Boolean) Attribute.GetCustomAttributes(Module, Type) Attribute.GetCustomAttributes(Module, Type, Boolean) Attribute.GetCustomAttributes(ParameterInfo) Attribute.GetCustomAttributes(ParameterInfo, Boolean) Attribute.GetCustomAttributes(ParameterInfo, Type) Attribute.GetCustomAttributes(ParameterInfo, Type, Boolean) Attribute.GetHashCode() Attribute.IsDefaultAttribute() Attribute.IsDefined(Assembly, Type) Attribute.IsDefined(Assembly, Type, Boolean) Attribute.IsDefined(MemberInfo, Type) Attribute.IsDefined(MemberInfo, Type, Boolean) Attribute.IsDefined(Module, Type) Attribute.IsDefined(Module, Type, Boolean) Attribute.IsDefined(ParameterInfo, Type) Attribute.IsDefined(ParameterInfo, Type, Boolean) Attribute.Match(Object) Object.Equals(Object, Object) Object.GetType() Object.MemberwiseClone() Object.ReferenceEquals(Object, Object) Object.ToString() Namespace : XData.Mapping Assembly : XData.docfx.dll Syntax [AttributeUsage(AttributeTargets.Class, AllowMultiple = true)] public sealed class SubqueryFilterAttribute : OptionalFilterAttribute Remarks Filter data by subquery: some_field = (select ...) some_field != (select ...) some_field in (select ...) some_field not in (select ...) exists (select ...) not exists (select ...) Constructors | Improve this Doc View Source SubqueryFilterAttribute(String, String, String) Subquery filter attribute Declaration public SubqueryFilterAttribute(string subquery, string source, string fieldName) Parameters Type Name Description String subquery Subquery alias String source Primary source alias String fieldName Primary field name Exceptions Type Condition XDataRuntimeException Subquery alias cannot be null or empty string Properties | Improve this Doc View Source FilterType Filter type Declaration public override FilterType FilterType { get; } Property Value Type Description FilterType Subquery Overrides FilterBaseAttribute.FilterType | Improve this Doc View Source Subquery Subquery alias Declaration public string Subquery { get; } Property Value Type Description String See Also SubqueryAttribute | Improve this Doc View Source TypeId When implemented in a derived class, gets a unique identifier for this Attribute . Declaration public override object TypeId { get; } Property Value Type Description Object An Object that is a unique identifier for the attribute. Overrides Attribute.TypeId Extension Methods SerializationExtensions.ToXml<T>(T) CollectionsExtensions.SetValue<TKey, T>(TKey, T) CollectionsExtensions.AsEnum<T>(T) DataObjectQueryableExtensions.CompareVariable(Object, FilterOperation, String) Processing.Do<T>(T, Action<IProcess<T>>[]) TypeExtensions.TryConvert<T, TResult>(T, Func<T, TResult>) TypeExtensions.TryConvert<T, TResult>(T, Func<T, TResult>, TResult) TypeExtensions.ChangeType<T>(Object) TypeExtensions.ChangeType(Object, Type) TypeExtensions.InvokeMethod<TRet>(Object, Type[], Expression<Func<TRet>>, BindingFlags) TypeExtensions.InvokeMethod(Object, Type[], Expression<Action>, BindingFlags) TypeExtensions.InvokeMethod<TRet>(Object, Expression<Func<TRet>>, BindingFlags) TypeExtensions.InvokeMethod(Object, Expression<Action>, BindingFlags) SqlBlockExtensions.SetExpression<TTag, TResult>(TTag, Expression<Func<IBlockQueryAdapter, TResult>>) QueryDescriptionExtensions.SetExpression<TTag, TResult>(TTag, Expression<Func<IQueryStructureAdapter, TResult>>) See Also SubqueryAttribute"
  },
  "api/XData.Mapping.Dynamic.html": {
    "href": "api/XData.Mapping.Dynamic.html",
    "title": "Namespace XData.Mapping.Dynamic | XData website",
    "keywords": "Namespace XData.Mapping.Dynamic Classes ParameterDescription SQL procedure / function parameter description QueryDescriptionExtensions Query description extensions TaggedExpression<TTag, TResult> Tagged expression XDataMapping Interfaces IExpressionPropertyAdapter SQL expression property mapping adapter IExternalLinkAdapter<T, TChild> External link mapping adapter IExternalLinkDefinition Dynamic structure external link definition interface IExternalLinkDefinitionAdapter<T> External link definition adapter IExternalLinkFlag Dynamic structure external link flag interface IFilterAdapter Filter description adapter IFilterDescription Dynamic query filter description IInheritedStructure<T> Inherited repository structure descriptor IInnerFilterAdapter Inner filter description adapter ILinkPropertyMappingAdapter<T> Link property mapping adapter IParameterDescription Dynamic stored procedure parameter description IProcedureParameterAdapter Procedure parameter mapping adapter IProcedureParameterFlag Procedure parameter mapping flag IPropertyMappingAdapter Basic dynamic structure adapter IQueryDescription Dynamic query description basic interface IQueryDescription<T> Dynamic query description with result type specified interface IQueryStructure Dynamic query structure interface IQueryStructureAdapter Query structure mapping adapter interface IQueryWithAdapter<TRoot> Common-Table-Expression (WITH) mapping attributes IQueryWithFlag Common-Table-Expression (WITH) flag IRepositoryDescription<T> Dynamic repository structure description interface IRepositoryExpressionMappingAdapter Repository SQL expression property mapping adapter IRepositoryPropertyMappingAdapter<T, TValue> Repository property mapping adapter IRepositoryReadOnlyPropertyMappingAdapter Repository read only property mapping adapter IRepositoryStructure<T> Repository structure descriptor IRepositoryStructureAdapter Repository structure adapter IRepositoryStructureAdapter<T> Repository structure mapping adapter interface IResultSetDescription Dynamic stored procedure result set description IStructureFlag Dynamic structure flag interface ISubqueryLinkAdapter Subquery link filter description adapter ISubqueryLinkAdapter<TDObj> Subquery link filter description adapter ISubqueryLinkAdapter<T, TDObj> Subquery link filter description adapter ITaggedExpression Object tagged expression interface"
  },
  "api/XData.Mapping.Dynamic.XDataMapping.html": {
    "href": "api/XData.Mapping.Dynamic.XDataMapping.html",
    "title": "Class XDataMapping | XData website",
    "keywords": "Class XDataMapping Inheritance Object XDataMapping Inherited Members Object.Equals(Object) Object.Equals(Object, Object) Object.GetHashCode() Object.GetType() Object.MemberwiseClone() Object.ReferenceEquals(Object, Object) Object.ToString() Namespace : XData.Mapping.Dynamic Assembly : XData.docfx.dll Syntax public static class XDataMapping Methods | Improve this Doc View Source CustomMapping<T>() Returns dynamic repository structure Declaration public static IRepositoryStructure<T> CustomMapping<T>() where T : class, ISqlObject, new() Returns Type Description IRepositoryStructure <T> Dynamic query structure Type Parameters Name Description T Repository element mapped type Exceptions Type Condition XDataRuntimeException See Also DataStructureFlag Variable IQueryStructure | Improve this Doc View Source GetStructure() Returns dynamic query structure Declaration public static IQueryStructure GetStructure() Returns Type Description IQueryStructure Dynamic query structure See Also DataStructureFlag IQueryStructure | Improve this Doc View Source GetStructure(String) Returns dynamic query structure Declaration public static IQueryStructure GetStructure(string baseTableAlias) Parameters Type Name Description String baseTableAlias Base table alias Returns Type Description IQueryStructure Dynamic query structure See Also DataStructureFlag IQueryStructure | Improve this Doc View Source GetStructure(String, String, DataStructureFlag, Variable[]) Returns dynamic query structure Declaration public static IQueryStructure GetStructure(string baseTableAlias, string context, DataStructureFlag flags = DataStructureFlag.ReadOnly, params Variable[] variables) Parameters Type Name Description String baseTableAlias Base table alias String context Context name DataStructureFlag flags Data object flags Variable [] variables Variables Returns Type Description IQueryStructure Dynamic query structure See Also DataStructureFlag Variable IQueryStructure | Improve this Doc View Source GetStructure(String, DataStructureFlag) Returns dynamic query structure Declaration public static IQueryStructure GetStructure(string baseTableAlias, DataStructureFlag flags) Parameters Type Name Description String baseTableAlias Base table alias DataStructureFlag flags Data object flags Returns Type Description IQueryStructure Dynamic query structure See Also DataStructureFlag IQueryStructure | Improve this Doc View Source GetStructure<T>(String) Returns dynamic query structure based on static mapping Declaration public static IQueryStructure GetStructure<T>(string context = null) where T : class, IDataObject, new() Parameters Type Name Description String context Context name Returns Type Description IQueryStructure Dynamic query structure Type Parameters Name Description T See Also DataStructureFlag Variable IQueryStructure | Improve this Doc View Source UseMapping<T>() Returns dynamic repository inherited structure Declaration public static IInheritedStructure<T> UseMapping<T>() where T : class, ISqlObject, new() Returns Type Description IInheritedStructure <T> Dynamic query structure Type Parameters Name Description T Repository element mapped type Exceptions Type Condition XDataRuntimeException See Also DataStructureFlag Variable IQueryStructure | Improve this Doc View Source UseMapping<T>(Expression<Func<IExternalLinkDefinitionAdapter<T>, IExternalLinkDefinition>>[]) Returns dynamic repository inherited structure Declaration public static IRepositoryDescription<T> UseMapping<T>(params Expression<Func<IExternalLinkDefinitionAdapter<T>, IExternalLinkDefinition>>[] externalLinks) where T : class, ISqlObject, new() Parameters Type Name Description Expression < Func < IExternalLinkDefinitionAdapter <T>, IExternalLinkDefinition >>[] externalLinks Returns Type Description IRepositoryDescription <T> Dynamic query structure Type Parameters Name Description T Repository element mapped type Exceptions Type Condition XDataRuntimeException See Also DataStructureFlag Variable IQueryStructure | Improve this Doc View Source UseMapping<T, TParent>() Returns dynamic repository inherited structure Declaration public static IInheritedStructure<T> UseMapping<T, TParent>() where T : class, ISqlObject, new() where TParent : class, ISqlObject, new() Returns Type Description IInheritedStructure <T> Dynamic query structure Type Parameters Name Description T Repository element mapped type TParent Parent mapping structure type Exceptions Type Condition XDataRuntimeException See Also DataStructureFlag Variable IQueryStructure | Improve this Doc View Source UseMapping<T, TParent>(Expression<Func<IExternalLinkDefinitionAdapter<T>, IExternalLinkDefinition>>[]) Returns dynamic repository inherited structure Declaration public static IRepositoryDescription<T> UseMapping<T, TParent>(params Expression<Func<IExternalLinkDefinitionAdapter<T>, IExternalLinkDefinition>>[] externalLinks) where T : class, TParent, new() where TParent : class, ISqlObject, new() Parameters Type Name Description Expression < Func < IExternalLinkDefinitionAdapter <T>, IExternalLinkDefinition >>[] externalLinks Returns Type Description IRepositoryDescription <T> Dynamic query structure Type Parameters Name Description T Repository element mapped type TParent Parent mapping structure type Exceptions Type Condition XDataRuntimeException See Also DataStructureFlag Variable IQueryStructure"
  },
  "api/XData.Mapping.Dynamic.TaggedExpression-2.html": {
    "href": "api/XData.Mapping.Dynamic.TaggedExpression-2.html",
    "title": "Class TaggedExpression<TTag, TResult> | XData website",
    "keywords": "Class TaggedExpression<TTag, TResult> Tagged expression Inheritance Object TaggedExpression<TTag, TResult> Implements ITaggedExpression Inherited Members Object.Equals(Object) Object.Equals(Object, Object) Object.GetHashCode() Object.GetType() Object.MemberwiseClone() Object.ReferenceEquals(Object, Object) Object.ToString() Namespace : XData.Mapping.Dynamic Assembly : XData.docfx.dll Syntax public class TaggedExpression<TTag, TResult> : ITaggedExpression Type Parameters Name Description TTag Tag type TResult Expression Properties | Improve this Doc View Source Key Tag key Declaration public object Key { get; } Property Value Type Description Object | Improve this Doc View Source KeyType Tag key type Declaration public Type KeyType { get; } Property Value Type Description Type | Improve this Doc View Source Value Tagged expression Declaration public Expression Value { get; } Property Value Type Description Expression Operators | Improve this Doc View Source Implicit(KeyValuePair<TTag, Expression<Func<IBlockQueryAdapter, TResult>>> to TaggedExpression<TTag, TResult>) Tagged expression implicit conversion operator Declaration public static implicit operator TaggedExpression<TTag, TResult>(KeyValuePair<TTag, Expression<Func<IBlockQueryAdapter, TResult>>> pair) Parameters Type Name Description KeyValuePair <TTag, Expression < Func < IBlockQueryAdapter , TResult>>> pair Key value pair Returns Type Description TaggedExpression <TTag, TResult> Tagged expression | Improve this Doc View Source Implicit(KeyValuePair<TTag, Expression<Func<IQueryStructureAdapter, TResult>>> to TaggedExpression<TTag, TResult>) Tagged expression implicit conversion operator Declaration public static implicit operator TaggedExpression<TTag, TResult>(KeyValuePair<TTag, Expression<Func<IQueryStructureAdapter, TResult>>> pair) Parameters Type Name Description KeyValuePair <TTag, Expression < Func < IQueryStructureAdapter , TResult>>> pair Key value pair Returns Type Description TaggedExpression <TTag, TResult> Tagged expression Implements ITaggedExpression Extension Methods SerializationExtensions.ToXml<T>(T) CollectionsExtensions.SetValue<TKey, T>(TKey, T) CollectionsExtensions.AsEnum<T>(T) DataObjectQueryableExtensions.CompareVariable(Object, FilterOperation, String) Processing.Do<T>(T, Action<IProcess<T>>[]) TypeExtensions.TryConvert<T, TResult>(T, Func<T, TResult>) TypeExtensions.TryConvert<T, TResult>(T, Func<T, TResult>, TResult) TypeExtensions.ChangeType<T>(Object) TypeExtensions.ChangeType(Object, Type) TypeExtensions.InvokeMethod<TRet>(Object, Type[], Expression<Func<TRet>>, BindingFlags) TypeExtensions.InvokeMethod(Object, Type[], Expression<Action>, BindingFlags) TypeExtensions.InvokeMethod<TRet>(Object, Expression<Func<TRet>>, BindingFlags) TypeExtensions.InvokeMethod(Object, Expression<Action>, BindingFlags) SqlBlockExtensions.SetExpression<TTag, TResult>(TTag, Expression<Func<IBlockQueryAdapter, TResult>>) QueryDescriptionExtensions.SetExpression<TTag, TResult>(TTag, Expression<Func<IQueryStructureAdapter, TResult>>)"
  },
  "api/XData.Interfaces.AdapterConfig.html": {
    "href": "api/XData.Interfaces.AdapterConfig.html",
    "title": "Class AdapterConfig | XData website",
    "keywords": "Class AdapterConfig Adapter configuration section Inheritance Object AdapterConfig Inherited Members Object.Equals(Object) Object.Equals(Object, Object) Object.GetHashCode() Object.GetType() Object.MemberwiseClone() Object.ReferenceEquals(Object, Object) Object.ToString() Namespace : XData.Interfaces Assembly : XData.docfx.dll Syntax public sealed class AdapterConfig Remarks WARNING! All attributes are required! Examples <adapter name=\"MSSQL\" file=\"C:\\XData\\XMsSqlAdapter.dll\"/> Properties | Improve this Doc View Source AssemblyName Adapter assembly name Declaration public string AssemblyName { get; set; } Property Value Type Description String | Improve this Doc View Source Config Adapter configuration Declaration public IConfiguration Config { get; set; } Property Value Type Description IConfiguration | Improve this Doc View Source Name Adapter name Declaration public string Name { get; set; } Property Value Type Description String Remarks Mast be the same as AdapterName Extension Methods SerializationExtensions.ToXml<T>(T) CollectionsExtensions.SetValue<TKey, T>(TKey, T) CollectionsExtensions.AsEnum<T>(T) DataObjectQueryableExtensions.CompareVariable(Object, FilterOperation, String) Processing.Do<T>(T, Action<IProcess<T>>[]) TypeExtensions.TryConvert<T, TResult>(T, Func<T, TResult>) TypeExtensions.TryConvert<T, TResult>(T, Func<T, TResult>, TResult) TypeExtensions.ChangeType<T>(Object) TypeExtensions.ChangeType(Object, Type) TypeExtensions.InvokeMethod<TRet>(Object, Type[], Expression<Func<TRet>>, BindingFlags) TypeExtensions.InvokeMethod(Object, Type[], Expression<Action>, BindingFlags) TypeExtensions.InvokeMethod<TRet>(Object, Expression<Func<TRet>>, BindingFlags) TypeExtensions.InvokeMethod(Object, Expression<Action>, BindingFlags) SqlBlockExtensions.SetExpression<TTag, TResult>(TTag, Expression<Func<IBlockQueryAdapter, TResult>>) QueryDescriptionExtensions.SetExpression<TTag, TResult>(TTag, Expression<Func<IQueryStructureAdapter, TResult>>) See Also Name AssemblyName"
  },
  "api/XData.FilterNullable.html": {
    "href": "api/XData.FilterNullable.html",
    "title": "Enum FilterNullable | XData website",
    "keywords": "Enum FilterNullable Filter null value assignment mode Namespace : XData Assembly : XData.docfx.dll Syntax [DataContract] public enum FilterNullable Fields Name Description Nullable Null value omit the filter (filter condition will not equated) NullsAllowed Null value is compared separately NullsCompared Null values is compared only NullsNotAllowed Null value is set filter condition to false See Also Nullable Nullable Nullable NullsAllowed NullsNotAllowed Extension Methods SerializationExtensions.ToXml<FilterNullable>() CollectionsExtensions.SetValue<FilterNullable, T>(T) CollectionsExtensions.AsEnum<FilterNullable>() DataObjectQueryableExtensions.CompareVariable(FilterOperation, String) Processing.Do<FilterNullable>(Action<IProcess<FilterNullable>>[]) TypeExtensions.ChangeType<T>() TypeExtensions.ChangeType(Type) TypeExtensions.InvokeMethod<TRet>(Type[], Expression<Func<TRet>>, BindingFlags) TypeExtensions.InvokeMethod(Type[], Expression<Action>, BindingFlags) TypeExtensions.InvokeMethod<TRet>(Expression<Func<TRet>>, BindingFlags) TypeExtensions.InvokeMethod(Expression<Action>, BindingFlags) TypeExtensions.ConvertTo<T>() TypeExtensions.EqualValue(Enum) SqlBlockExtensions.SetExpression<FilterNullable, TResult>(Expression<Func<IBlockQueryAdapter, TResult>>) QueryDescriptionExtensions.SetExpression<FilterNullable, TResult>(Expression<Func<IQueryStructureAdapter, TResult>>)"
  },
  "api/XData.FilterConstantType.html": {
    "href": "api/XData.FilterConstantType.html",
    "title": "Enum FilterConstantType | XData website",
    "keywords": "Enum FilterConstantType ConstantFilter value mode Namespace : XData Assembly : XData.docfx.dll Syntax [DataContract] public enum FilterConstantType Fields Name Description Const Constant value CurrentDate Current date value CurrentDateTime Current date and time value CurrentDateTimeUtc Current date and time UTC value Variable Repository variable value by name See Also ConstantType Const Variable CurrentDate CurrentDateTime CurrentDateTimeUtc Extension Methods SerializationExtensions.ToXml<FilterConstantType>() CollectionsExtensions.SetValue<FilterConstantType, T>(T) CollectionsExtensions.AsEnum<FilterConstantType>() DataObjectQueryableExtensions.CompareVariable(FilterOperation, String) Processing.Do<FilterConstantType>(Action<IProcess<FilterConstantType>>[]) TypeExtensions.ChangeType<T>() TypeExtensions.ChangeType(Type) TypeExtensions.InvokeMethod<TRet>(Type[], Expression<Func<TRet>>, BindingFlags) TypeExtensions.InvokeMethod(Type[], Expression<Action>, BindingFlags) TypeExtensions.InvokeMethod<TRet>(Expression<Func<TRet>>, BindingFlags) TypeExtensions.InvokeMethod(Expression<Action>, BindingFlags) TypeExtensions.ConvertTo<T>() TypeExtensions.EqualValue(Enum) SqlBlockExtensions.SetExpression<FilterConstantType, TResult>(Expression<Func<IBlockQueryAdapter, TResult>>) QueryDescriptionExtensions.SetExpression<FilterConstantType, TResult>(Expression<Func<IQueryStructureAdapter, TResult>>)"
  },
  "api/XData.ExistsOperation.html": {
    "href": "api/XData.ExistsOperation.html",
    "title": "Enum ExistsOperation | XData website",
    "keywords": "Enum ExistsOperation Exists subquery operation Namespace : XData Assembly : XData.docfx.dll Syntax public enum ExistsOperation Fields Name Description Exists Exists None Operation other NotExists Not exists Extension Methods SerializationExtensions.ToXml<ExistsOperation>() CollectionsExtensions.SetValue<ExistsOperation, T>(T) CollectionsExtensions.AsEnum<ExistsOperation>() DataObjectQueryableExtensions.CompareVariable(FilterOperation, String) Processing.Do<ExistsOperation>(Action<IProcess<ExistsOperation>>[]) TypeExtensions.ChangeType<T>() TypeExtensions.ChangeType(Type) TypeExtensions.InvokeMethod<TRet>(Type[], Expression<Func<TRet>>, BindingFlags) TypeExtensions.InvokeMethod(Type[], Expression<Action>, BindingFlags) TypeExtensions.InvokeMethod<TRet>(Expression<Func<TRet>>, BindingFlags) TypeExtensions.InvokeMethod(Expression<Action>, BindingFlags) TypeExtensions.ConvertTo<T>() TypeExtensions.EqualValue(Enum) SqlBlockExtensions.SetExpression<ExistsOperation, TResult>(Expression<Func<IBlockQueryAdapter, TResult>>) QueryDescriptionExtensions.SetExpression<ExistsOperation, TResult>(Expression<Func<IQueryStructureAdapter, TResult>>)"
  },
  "api/XData.ExecuteAttachedHandler-1.html": {
    "href": "api/XData.ExecuteAttachedHandler-1.html",
    "title": "Delegate ExecuteAttachedHandler<T> | XData website",
    "keywords": "Delegate ExecuteAttachedHandler<T> Execute attached handler delegate Namespace : XData Assembly : XData.docfx.dll Syntax public delegate bool ExecuteAttachedHandler<in T>(string key, IEnumerable<T> objects) where T : class, IDataObject; Parameters Type Name Description String key Custom logic key IEnumerable <T> objects Object sequence Returns Type Description Boolean Type Parameters Name Description T Object type Extension Methods SerializationExtensions.ToXml<T>(T) CollectionsExtensions.SetValue<TKey, T>(TKey, T) CollectionsExtensions.AsEnum<T>(T) DataObjectQueryableExtensions.CompareVariable(Object, FilterOperation, String) Processing.Do<T>(T, Action<IProcess<T>>[]) TypeExtensions.TryConvert<T, TResult>(T, Func<T, TResult>) TypeExtensions.TryConvert<T, TResult>(T, Func<T, TResult>, TResult) TypeExtensions.ChangeType<T>(Object) TypeExtensions.ChangeType(Object, Type) TypeExtensions.InvokeMethod<TRet>(Object, Type[], Expression<Func<TRet>>, BindingFlags) TypeExtensions.InvokeMethod(Object, Type[], Expression<Action>, BindingFlags) TypeExtensions.InvokeMethod<TRet>(Object, Expression<Func<TRet>>, BindingFlags) TypeExtensions.InvokeMethod(Object, Expression<Action>, BindingFlags) SqlBlockExtensions.SetExpression<TTag, TResult>(TTag, Expression<Func<IBlockQueryAdapter, TResult>>) QueryDescriptionExtensions.SetExpression<TTag, TResult>(TTag, Expression<Func<IQueryStructureAdapter, TResult>>)"
  },
  "api/XData.DateDiffKind.html": {
    "href": "api/XData.DateDiffKind.html",
    "title": "Enum DateDiffKind | XData website",
    "keywords": "Enum DateDiffKind Date difference kind Namespace : XData Assembly : XData.docfx.dll Syntax public enum DateDiffKind Fields Name Description Days Date difference in month days DaysTotal Date difference in days Hours Date difference in hours Minutes Date difference in minutes Months Date difference in months Seconds Date difference in seconds Years Date difference in years Extension Methods SerializationExtensions.ToXml<DateDiffKind>() CollectionsExtensions.SetValue<DateDiffKind, T>(T) CollectionsExtensions.AsEnum<DateDiffKind>() DataObjectQueryableExtensions.CompareVariable(FilterOperation, String) Processing.Do<DateDiffKind>(Action<IProcess<DateDiffKind>>[]) TypeExtensions.ChangeType<T>() TypeExtensions.ChangeType(Type) TypeExtensions.InvokeMethod<TRet>(Type[], Expression<Func<TRet>>, BindingFlags) TypeExtensions.InvokeMethod(Type[], Expression<Action>, BindingFlags) TypeExtensions.InvokeMethod<TRet>(Expression<Func<TRet>>, BindingFlags) TypeExtensions.InvokeMethod(Expression<Action>, BindingFlags) TypeExtensions.ConvertTo<T>() TypeExtensions.EqualValue(Enum) SqlBlockExtensions.SetExpression<DateDiffKind, TResult>(Expression<Func<IBlockQueryAdapter, TResult>>) QueryDescriptionExtensions.SetExpression<DateDiffKind, TResult>(Expression<Func<IQueryStructureAdapter, TResult>>)"
  },
  "api/XData.DataVersion.html": {
    "href": "api/XData.DataVersion.html",
    "title": "Enum DataVersion | XData website",
    "keywords": "Enum DataVersion Version of data Namespace : XData Assembly : XData.docfx.dll Syntax public enum DataVersion Fields Name Description Actual Actual data version Original Original data version See Also GetProperties<T> (T, DataVersion , String []) GetProperties<T> (T, IEnumerable < String >, DataVersion ) GetProperty<T, TRet> (T, Expression < Func <T, TRet>>, DataVersion ) XData.DataObjectExtensions.GetProperty``1(``0,System.String,XData.DataVersion) Actual Original Extension Methods SerializationExtensions.ToXml<DataVersion>() CollectionsExtensions.SetValue<DataVersion, T>(T) CollectionsExtensions.AsEnum<DataVersion>() DataObjectQueryableExtensions.CompareVariable(FilterOperation, String) Processing.Do<DataVersion>(Action<IProcess<DataVersion>>[]) TypeExtensions.ChangeType<T>() TypeExtensions.ChangeType(Type) TypeExtensions.InvokeMethod<TRet>(Type[], Expression<Func<TRet>>, BindingFlags) TypeExtensions.InvokeMethod(Type[], Expression<Action>, BindingFlags) TypeExtensions.InvokeMethod<TRet>(Expression<Func<TRet>>, BindingFlags) TypeExtensions.InvokeMethod(Expression<Action>, BindingFlags) TypeExtensions.ConvertTo<T>() TypeExtensions.EqualValue(Enum) SqlBlockExtensions.SetExpression<DataVersion, TResult>(Expression<Func<IBlockQueryAdapter, TResult>>) QueryDescriptionExtensions.SetExpression<DataVersion, TResult>(Expression<Func<IQueryStructureAdapter, TResult>>)"
  },
  "api/XData.DataSource.Structure.ITableLike.html": {
    "href": "api/XData.DataSource.Structure.ITableLike.html",
    "title": "Interface ITableLike | XData website",
    "keywords": "Interface ITableLike Temporary table Inherited Members IDataSource.SourceType IDataSource.Alias IDataSource.IsBase IDataSource.GetFields() IDataSource.GetFields(Type) IDataSource.GetField(String, String, String) IDataSource.GetField(String, String, String, String) ICloneable.Clone() Namespace : XData.DataSource.Structure Assembly : XData.docfx.dll Syntax public interface ITableLike : IDataSource, ICloneable Properties | Improve this Doc View Source Fields Fields Declaration SortedSet<IField> Fields { get; } Property Value Type Description SortedSet < IField > | Improve this Doc View Source Name Table name Declaration string Name { get; } Property Value Type Description String Extension Methods SerializationExtensions.ToXml<T>(T) CollectionsExtensions.SetValue<TKey, T>(TKey, T) CollectionsExtensions.AsEnum<T>(T) DataObjectQueryableExtensions.CompareVariable(Object, FilterOperation, String) Processing.Do<T>(T, Action<IProcess<T>>[]) TypeExtensions.TryConvert<T, TResult>(T, Func<T, TResult>) TypeExtensions.TryConvert<T, TResult>(T, Func<T, TResult>, TResult) TypeExtensions.ChangeType<T>(Object) TypeExtensions.ChangeType(Object, Type) TypeExtensions.InvokeMethod<TRet>(Object, Type[], Expression<Func<TRet>>, BindingFlags) TypeExtensions.InvokeMethod(Object, Type[], Expression<Action>, BindingFlags) TypeExtensions.InvokeMethod<TRet>(Object, Expression<Func<TRet>>, BindingFlags) TypeExtensions.InvokeMethod(Object, Expression<Action>, BindingFlags) SqlBlockExtensions.SetExpression<TTag, TResult>(TTag, Expression<Func<IBlockQueryAdapter, TResult>>) QueryDescriptionExtensions.SetExpression<TTag, TResult>(TTag, Expression<Func<IQueryStructureAdapter, TResult>>)"
  },
  "api/XData.Mapping.HintType.html": {
    "href": "api/XData.Mapping.HintType.html",
    "title": "Enum HintType | XData website",
    "keywords": "Enum HintType Hint type Namespace : XData.Mapping Assembly : XData.docfx.dll Syntax [Flags] public enum HintType Fields Name Description All Delete Insert Select Update Extension Methods SerializationExtensions.ToXml<HintType>() CollectionsExtensions.SetValue<HintType, T>(T) CollectionsExtensions.AsEnum<HintType>() DataObjectQueryableExtensions.CompareVariable(FilterOperation, String) Processing.Do<HintType>(Action<IProcess<HintType>>[]) TypeExtensions.ChangeType<T>() TypeExtensions.ChangeType(Type) TypeExtensions.InvokeMethod<TRet>(Type[], Expression<Func<TRet>>, BindingFlags) TypeExtensions.InvokeMethod(Type[], Expression<Action>, BindingFlags) TypeExtensions.InvokeMethod<TRet>(Expression<Func<TRet>>, BindingFlags) TypeExtensions.InvokeMethod(Expression<Action>, BindingFlags) TypeExtensions.ConvertTo<T>() TypeExtensions.EqualValue(Enum) SqlBlockExtensions.SetExpression<HintType, TResult>(Expression<Func<IBlockQueryAdapter, TResult>>) QueryDescriptionExtensions.SetExpression<HintType, TResult>(Expression<Func<IQueryStructureAdapter, TResult>>)"
  },
  "api/XData.Mapping.Dynamic.IQueryStructureAdapter.html": {
    "href": "api/XData.Mapping.Dynamic.IQueryStructureAdapter.html",
    "title": "Interface IQueryStructureAdapter | XData website",
    "keywords": "Interface IQueryStructureAdapter Query structure mapping adapter interface Namespace : XData.Mapping.Dynamic Assembly : XData.docfx.dll Syntax public interface IQueryStructureAdapter Methods | Improve this Doc View Source CastTo<T>() Type cast modifier Declaration IQueryStructureAdapter CastTo<T>() Returns Type Description IQueryStructureAdapter Type Parameters Name Description T Type to cast | Improve this Doc View Source Expr<TValue>(String, Expression<Func<IQueryStructureAdapter, TValue>>, DbType, Expression<Func<IExpressionPropertyAdapter, IStructureFlag>>[]) SQL expression mapping Declaration TValue Expr<TValue>(string fieldName, Expression<Func<IQueryStructureAdapter, TValue>> expr, DbType dbType, params Expression<Func<IExpressionPropertyAdapter, IStructureFlag>>[] attributes) Parameters Type Name Description String fieldName Expression field name Expression < Func < IQueryStructureAdapter , TValue>> expr Expression DbType dbType Expression database type Expression < Func < IExpressionPropertyAdapter , IStructureFlag >>[] attributes Property mapping attributes Returns Type Description TValue Expression value Type Parameters Name Description TValue Expression result type Remarks WARNING! Can be used in dynamic query mapping only! See Also DataExpressionType DbType Select<TResult>(Expression<Func<IQueryStructureAdapter, TResult>>) | Improve this Doc View Source Expr<TValue>(String, DataExpressionType, String, DbType, Expression<Func<IExpressionPropertyAdapter, IStructureFlag>>[]) SQL expression mapping Declaration TValue Expr<TValue>(string fieldName, DataExpressionType type, string exprText, DbType dbType, params Expression<Func<IExpressionPropertyAdapter, IStructureFlag>>[] attributes) Parameters Type Name Description String fieldName Expression field name DataExpressionType type Expression source type String exprText Expression text DbType dbType Expression database type Expression < Func < IExpressionPropertyAdapter , IStructureFlag >>[] attributes Property mapping attributes Returns Type Description TValue Expression value Type Parameters Name Description TValue Expression result type Remarks WARNING! Can be used in dynamic query mapping only! See Also DataExpressionType DbType Select<TResult>(Expression<Func<IQueryStructureAdapter, TResult>>) | Improve this Doc View Source Field<TValue>(Expression<Func<IPropertyMappingAdapter, IStructureFlag>>[]) Field mapping Declaration TValue Field<TValue>(params Expression<Func<IPropertyMappingAdapter, IStructureFlag>>[] attributes) Parameters Type Name Description Expression < Func < IPropertyMappingAdapter , IStructureFlag >>[] attributes Property mapping attributes Returns Type Description TValue Field value Type Parameters Name Description TValue Field type Remarks WARNING! Can be used in dynamic query mapping only! See Also Select<TResult>(Expression<Func<IQueryStructureAdapter, TResult>>) | Improve this Doc View Source Field<TValue>(String, String, DbType, Expression<Func<IExpressionPropertyAdapter, IStructureFlag>>[]) Field mapping Declaration TValue Field<TValue>(string sourceAlias, string fieldName, DbType dbType, params Expression<Func<IExpressionPropertyAdapter, IStructureFlag>>[] attributes) Parameters Type Name Description String sourceAlias Source alias String fieldName Field name DbType dbType Field database type Expression < Func < IExpressionPropertyAdapter , IStructureFlag >>[] attributes Property mapping attributes Returns Type Description TValue Field value Type Parameters Name Description TValue Field type See Also Select<TResult>(Expression<Func<IQueryStructureAdapter, TResult>>) | Improve this Doc View Source Field<TValue>(String, String, Expression<Func<IPropertyMappingAdapter, IStructureFlag>>[]) Field mapping Declaration TValue Field<TValue>(string sourceAlias, string fieldName, params Expression<Func<IPropertyMappingAdapter, IStructureFlag>>[] attributes) Parameters Type Name Description String sourceAlias Source alias String fieldName Field name Expression < Func < IPropertyMappingAdapter , IStructureFlag >>[] attributes Property mapping attributes Returns Type Description TValue Field value Type Parameters Name Description TValue Field type Remarks WARNING! Can be used in dynamic query mapping only! See Also Select<TResult>(Expression<Func<IQueryStructureAdapter, TResult>>) | Improve this Doc View Source Ref<TValue>(String, String, Expression<Func<IPropertyMappingAdapter, IStructureFlag>>[]) Inner view property reference mapping Declaration TValue Ref<TValue>(string sourceAlias, string property, params Expression<Func<IPropertyMappingAdapter, IStructureFlag>>[] attributes) Parameters Type Name Description String sourceAlias Referenced property subquery alias String property Referenced property name Expression < Func < IPropertyMappingAdapter , IStructureFlag >>[] attributes Property mapping attributes Returns Type Description TValue Referenced property value Type Parameters Name Description TValue Referenced property type Remarks WARNING! Can be used in dynamic query mapping only! See Also Select<TResult>(Expression<Func<IQueryStructureAdapter, TResult>>) | Improve this Doc View Source Ref<TValue, TInnerView>(String, Expression<Func<TInnerView, Object>>, Expression<Func<IPropertyMappingAdapter, IStructureFlag>>[]) Inner view property reference mapping Declaration TValue Ref<TValue, TInnerView>(string sourceAlias, Expression<Func<TInnerView, object>> property, params Expression<Func<IPropertyMappingAdapter, IStructureFlag>>[] attributes) where TInnerView : class Parameters Type Name Description String sourceAlias Referenced property subquery alias Expression < Func <TInnerView, Object >> property Referenced property name Expression < Func < IPropertyMappingAdapter , IStructureFlag >>[] attributes Property mapping attributes Returns Type Description TValue Referenced property value Type Parameters Name Description TValue Referenced property type TInnerView Referenced inner view type Remarks WARNING! Can be used in dynamic query mapping only! See Also Select<TResult>(Expression<Func<IQueryStructureAdapter, TResult>>) | Improve this Doc View Source XmlField<TValue>(String, String, String, DbType, Expression<Func<IExpressionPropertyAdapter, IStructureFlag>>[]) XML field mapping Declaration TValue XmlField<TValue>(string sourceAlias, string fieldName, string xPath, DbType dbType, params Expression<Func<IExpressionPropertyAdapter, IStructureFlag>>[] attributes) Parameters Type Name Description String sourceAlias XML data source alias String fieldName XML field name String xPath XML field XPath expression DbType dbType XML field database type Expression < Func < IExpressionPropertyAdapter , IStructureFlag >>[] attributes Property mapping attributes Returns Type Description TValue Field value Type Parameters Name Description TValue XML Field type Remarks WARNING! Can be used in dynamic query mapping for XmlSource(String, String, String, Expression<Func<IInnerFilterAdapter, IFilterDescription>>[]) data sources only! See Also Select<TResult>(Expression<Func<IQueryStructureAdapter, TResult>>) Extension Methods SerializationExtensions.ToXml<T>(T) CollectionsExtensions.SetValue<TKey, T>(TKey, T) CollectionsExtensions.AsEnum<T>(T) DataObjectQueryableExtensions.CompareVariable(Object, FilterOperation, String) Processing.Do<T>(T, Action<IProcess<T>>[]) TypeExtensions.TryConvert<T, TResult>(T, Func<T, TResult>) TypeExtensions.TryConvert<T, TResult>(T, Func<T, TResult>, TResult) TypeExtensions.ChangeType<T>(Object) TypeExtensions.ChangeType(Object, Type) TypeExtensions.InvokeMethod<TRet>(Object, Type[], Expression<Func<TRet>>, BindingFlags) TypeExtensions.InvokeMethod(Object, Type[], Expression<Action>, BindingFlags) TypeExtensions.InvokeMethod<TRet>(Object, Expression<Func<TRet>>, BindingFlags) TypeExtensions.InvokeMethod(Object, Expression<Action>, BindingFlags) SqlBlockExtensions.SetExpression<TTag, TResult>(TTag, Expression<Func<IBlockQueryAdapter, TResult>>) QueryDescriptionExtensions.Exists(IQueryStructureAdapter, String) QueryDescriptionExtensions.Case<T, TResult>(IQueryStructureAdapter, Expression<Func<IQueryStructureAdapter, T>>, Expression<Func<IQueryStructureAdapter, TResult>>, TaggedExpression<T, TResult>[]) QueryDescriptionExtensions.DateDiff<T>(IQueryStructureAdapter, Expression<Func<IQueryStructureAdapter, DateTime>>, Expression<Func<IQueryStructureAdapter, DateTime>>, DateDiffKind) QueryDescriptionExtensions.HasFlag<T>(IQueryStructureAdapter, Expression<Func<IQueryStructureAdapter, T>>, Expression<Func<IQueryStructureAdapter, T>>, Expression<Func<IQueryStructureAdapter, T>>, Expression<Func<IQueryStructureAdapter, T>>) QueryDescriptionExtensions.SetExpression<TTag, TResult>(TTag, Expression<Func<IQueryStructureAdapter, TResult>>) QueryDescriptionExtensions.SqlFn<TResult>(IQueryStructureAdapter, String, Expression<Func<IQueryStructureAdapter, Object>>[]) QueryDescriptionExtensions.SqlParam<TResult>(IQueryStructureAdapter, String, DbType, Expression<Func<IProcedureParameterAdapter, IProcedureParameterFlag>>[]) QueryDescriptionExtensions.SqlExpr<TResult>(IQueryStructureAdapter, String, Expression<Func<IQueryStructureAdapter, Object>>[]) QueryDescriptionExtensions.GetVariable<TResult>(IQueryStructureAdapter, String) See Also Select<TResult>(Expression<Func<IQueryStructureAdapter, TResult>>)"
  },
  "api/XData.DataPropertyFlag.html": {
    "href": "api/XData.DataPropertyFlag.html",
    "title": "Enum DataPropertyFlag | XData website",
    "keywords": "Enum DataPropertyFlag Data object property flags Namespace : XData Assembly : XData.docfx.dll Syntax [Flags] [DataContract] public enum DataPropertyFlag Fields Name Description ConcurrencyToken Data object concurrency token field flag Id Data object unique key part None Common data property OuterFlag Outer joined information filled flag See Also Flags Flags None Id OuterFlag Extension Methods SerializationExtensions.ToXml<DataPropertyFlag>() CollectionsExtensions.SetValue<DataPropertyFlag, T>(T) CollectionsExtensions.AsEnum<DataPropertyFlag>() DataObjectQueryableExtensions.CompareVariable(FilterOperation, String) Processing.Do<DataPropertyFlag>(Action<IProcess<DataPropertyFlag>>[]) TypeExtensions.ChangeType<T>() TypeExtensions.ChangeType(Type) TypeExtensions.InvokeMethod<TRet>(Type[], Expression<Func<TRet>>, BindingFlags) TypeExtensions.InvokeMethod(Type[], Expression<Action>, BindingFlags) TypeExtensions.InvokeMethod<TRet>(Expression<Func<TRet>>, BindingFlags) TypeExtensions.InvokeMethod(Expression<Action>, BindingFlags) TypeExtensions.ConvertTo<T>() TypeExtensions.EqualValue(Enum) SqlBlockExtensions.SetExpression<DataPropertyFlag, TResult>(Expression<Func<IBlockQueryAdapter, TResult>>) QueryDescriptionExtensions.SetExpression<DataPropertyFlag, TResult>(Expression<Func<IQueryStructureAdapter, TResult>>)"
  },
  "api/XData.DataObjectExtensions.html": {
    "href": "api/XData.DataObjectExtensions.html",
    "title": "Class DataObjectExtensions | XData website",
    "keywords": "Class DataObjectExtensions IDataObject extension functions Inheritance Object DataObjectExtensions Inherited Members Object.Equals(Object) Object.Equals(Object, Object) Object.GetHashCode() Object.GetType() Object.MemberwiseClone() Object.ReferenceEquals(Object, Object) Object.ToString() Namespace : XData Assembly : XData.docfx.dll Syntax public static class DataObjectExtensions Fields | Improve this Doc View Source SubquerySources Data sources types interpretable as sub queries Declaration public static readonly DataSourceType[] SubquerySources Field Value Type Description DataSourceType [] Methods | Improve this Doc View Source Apply<T>(IRepository<T>, T, String[]) Find object and apply changes from detached object Declaration public static T Apply<T>(this IRepository<T> repository, T source, params string[] properties) where T : class, IDataObject, new() Parameters Type Name Description IRepository <T> repository Repository T source Source detached object String [] properties Properties to copy Returns Type Description T Changed target object Type Parameters Name Description T Object type | Improve this Doc View Source Apply<T>(IRepository<T>, T, ApplyFlag, String[]) Find object and apply changes from detached object Declaration public static T Apply<T>(this IRepository<T> repository, T source, ApplyFlag flags, params string[] properties) where T : class, IDataObject, new() Parameters Type Name Description IRepository <T> repository Repository T source Source detached object ApplyFlag flags Apply behaviour flags String [] properties Properties to copy Returns Type Description T Changed target object Type Parameters Name Description T Object type | Improve this Doc View Source AssignProperty<T, TValue>(T, String, TValue) Assign property value Declaration public static bool AssignProperty<T, TValue>(this T obj, string prop, TValue value) where T : class, IDataObject, new() Parameters Type Name Description T obj Data object instance String prop Property name TValue value Property value Returns Type Description Boolean Property value changed Type Parameters Name Description T Data object type TValue Data property type Exceptions Type Condition XDataRuntimeException Property name can not be null or empty | Improve this Doc View Source AsString<T>(IQueryable<T>) Repository select query text Declaration public static string AsString<T>(this IQueryable<T> queryable) where T : class, IDataObject Parameters Type Name Description IQueryable <T> queryable Queryable source of data object Returns Type Description String Repository Type Parameters Name Description T Data object type Remarks WARNING! High resource utilization! Use it for debug only! | Improve this Doc View Source Callback<T>(T, String, ref Byte[]) Callback to client Declaration public static bool Callback<T>(this T obj, string message, ref byte[] data) where T : class, IDataObject, new() Parameters Type Name Description T obj Object context String message Message name Byte [] data Data to post Returns Type Description Boolean Type Parameters Name Description T Data object type | Improve this Doc View Source CheckState<T>(T, DataObjectState) Checks object for state Declaration public static bool CheckState<T>(this T obj, DataObjectState state) where T : class, IDataObject Parameters Type Name Description T obj Data object instance DataObjectState state State Returns Type Description Boolean Object has desired state flag Type Parameters Name Description T Data object type Exceptions Type Condition XDataRuntimeException No state attached to object See Also GetState<T>(T) SetDeleted<T>(T, Boolean) | Improve this Doc View Source Copy<T>(T, T, String[]) Copy detached object info Declaration public static T Copy<T>(this T target, T source, params string[] properties) where T : class, IDataObject, new() Parameters Type Name Description T target Target object attached to repository T source Source detached object String [] properties Properties to copy Returns Type Description T Changed target object Type Parameters Name Description T Object type | Improve this Doc View Source Copy<T>(T, T, ApplyFlag, String[]) Copy detached object info Declaration public static T Copy<T>(this T target, T source, ApplyFlag flags, params string[] properties) where T : class, IDataObject, new() Parameters Type Name Description T target Target object attached to repository T source Source detached object ApplyFlag flags Apply behaviour flags String [] properties Properties to copy Returns Type Description T Changed target object Type Parameters Name Description T Object type | Improve this Doc View Source Execute<T>(T, Expression<Func<CustomLogic<T>>>, IDictionary<String, Action<Byte[]>>, IDictionary<String, Func<Byte[], Byte[]>>) Run custom logic over single object Declaration public static bool Execute<T>(this T obj, Expression<Func<CustomLogic<T>>> routine, IDictionary<string, Action<byte[]>> post = null, IDictionary<string, Func<byte[], byte[]>> callback = null) where T : class, IDataObject, new() Parameters Type Name Description T obj Data object instance Expression < Func < CustomLogic <T>>> routine Action field name expression Example: () => SomeCustomActionField IDictionary < String , Action < Byte []>> post Post data handler IDictionary < String , Func < Byte [], Byte []>> callback Callback handler Returns Type Description Boolean Success flag Type Parameters Name Description T Data object type Remarks Hint: When using XData application server custom logic will executed on server side Exceptions Type Condition XDataRuntimeException Action field expression is null XDataRuntimeException CustomActionAttribute not found for expression specified field See Also Execute<T>(ICollection<T>, Expression<Func<CustomLogic<T>>>, IDictionary<String, Action<Byte[]>>, IDictionary<String, Func<Byte[], Byte[]>>) | Improve this Doc View Source Execute<T>(T, String, IDictionary<String, Action<Byte[]>>, IDictionary<String, Func<Byte[], Byte[]>>) Run custom logic over single object Declaration public static bool Execute<T>(this T obj, string key, IDictionary<string, Action<byte[]>> post = null, IDictionary<string, Func<byte[], byte[]>> callback = null) where T : class, IDataObject, new() Parameters Type Name Description T obj Data object instance String key Action key IDictionary < String , Action < Byte []>> post Post data handler IDictionary < String , Func < Byte [], Byte []>> callback Callback handler Returns Type Description Boolean Success flag Type Parameters Name Description T Data object type Remarks Hint: When using XData application server custom logic will executed on server side Exceptions Type Condition XDataRuntimeException Object repository is detached See Also Execute<T>(T, Expression<Func<CustomLogic<T>>>, IDictionary<String, Action<Byte[]>>, IDictionary<String, Func<Byte[], Byte[]>>) | Improve this Doc View Source Execute<T>(ICollection<T>, Expression<Func<CustomLogic<T>>>, IDictionary<String, Action<Byte[]>>, IDictionary<String, Func<Byte[], Byte[]>>) Run custom logic over array of objects Declaration public static bool Execute<T>(this ICollection<T> objects, Expression<Func<CustomLogic<T>>> routine, IDictionary<string, Action<byte[]>> post = null, IDictionary<string, Func<byte[], byte[]>> callback = null) where T : class, IDataObject, new() Parameters Type Name Description ICollection <T> objects Collection of objects Expression < Func < CustomLogic <T>>> routine Action field name expression Example: () => SomeCustomActionField IDictionary < String , Action < Byte []>> post Post data handler IDictionary < String , Func < Byte [], Byte []>> callback Callback handler Returns Type Description Boolean Success flag Type Parameters Name Description T Data object type Remarks Hint: When using XData application server custom logic will executed on server side Exceptions Type Condition XDataRuntimeException Action field name expression is null XDataRuntimeException CustomActionAttribute not found for expression specified field See Also Execute<T>(T, Expression<Func<CustomLogic<T>>>, IDictionary<String, Action<Byte[]>>, IDictionary<String, Func<Byte[], Byte[]>>) | Improve this Doc View Source Execute<T>(ICollection<T>, String, IDictionary<String, Action<Byte[]>>, IDictionary<String, Func<Byte[], Byte[]>>) Run custom logic over array of objects Declaration public static bool Execute<T>(this ICollection<T> objects, string key, IDictionary<string, Action<byte[]>> post = null, IDictionary<string, Func<byte[], byte[]>> callback = null) where T : class, IDataObject, new() Parameters Type Name Description ICollection <T> objects Collection of objects String key Action key IDictionary < String , Action < Byte []>> post Post data handler IDictionary < String , Func < Byte [], Byte []>> callback Callback handler Returns Type Description Boolean Success flag Type Parameters Name Description T Data object type Remarks Hint: When using XData application server custom logic will executed on server side Exceptions Type Condition XDataRuntimeException Object repository is detached See Also Execute<T>(ICollection<T>, Expression<Func<CustomLogic<T>>>, IDictionary<String, Action<Byte[]>>, IDictionary<String, Func<Byte[], Byte[]>>) | Improve this Doc View Source Find<T>(IRepository<T>, T, Boolean) Find detached object in repository Declaration public static T Find<T>(this IRepository<T> repository, T source, bool ignoreConcurrency = false) where T : class, IDataObject, new() Parameters Type Name Description IRepository <T> repository Repository T source Detached object Boolean ignoreConcurrency Find ignore concurrency token value (optional) default = false Returns Type Description T Found object Type Parameters Name Description T Object type | Improve this Doc View Source FindMemberExpression(Expression) Property name expression parse helper Declaration public static MemberExpression FindMemberExpression(Expression e) Parameters Type Name Description Expression e Property name expression: x => x.SomePropertyName Returns Type Description MemberExpression Property name Exceptions Type Condition XDataRuntimeException Property name expression can not be null XDataRuntimeException Expression has a wrong expression type | Improve this Doc View Source GetContext(IDataObject) Returns context name for object Declaration public static string GetContext(this IDataObject obj) Parameters Type Name Description IDataObject obj Data object Returns Type Description String Context name Exceptions Type Condition XDataRuntimeException | Improve this Doc View Source GetLayer(IDataObject) Returns repository layer for object Declaration public static Guid GetLayer(this IDataObject obj) Parameters Type Name Description IDataObject obj Data object Returns Type Description Guid Repository layer Exceptions Type Condition XDataRuntimeException | Improve this Doc View Source GetParameter<T>(IDataQuery, String) Returns SQL procedure/function out parameter value Declaration public static T GetParameter<T>(this IDataQuery query, string param) Parameters Type Name Description IDataQuery query Data query String param Parameter name Returns Type Description T Parameter value Type Parameters Name Description T Exceptions Type Condition XDataRuntimeException Parameter name can not be null or empty See Also GetParameter<T, TRet>(IDataQuery<T>, Expression<Func<T, TRet>>) | Improve this Doc View Source GetParameter<T, TRet>(T, Expression<Func<T, TRet>>) Returns SQL procedure/function out parameter value Declaration public static TRet GetParameter<T, TRet>(this T obj, Expression<Func<T, TRet>> param) where T : class, IDataObject, new() Parameters Type Name Description T obj Data object instance Expression < Func <T, TRet>> param Parameter name expression using same name property (case insensitive) Example: x => x.SomePropertyName Returns Type Description TRet Parameter value Type Parameters Name Description T Data object type TRet Parameter type Exceptions Type Condition XDataRuntimeException Parameter name expression can not be null | Improve this Doc View Source GetParameter<T, TRet>(T, String) Returns SQL procedure/function out parameter value Declaration public static TRet GetParameter<T, TRet>(this T obj, string param) where T : class, IDataObject, new() Parameters Type Name Description T obj Data object instance String param Parameter name Returns Type Description TRet Parameter value Type Parameters Name Description T Data object type TRet Parameter type Exceptions Type Condition XDataRuntimeException Parameter name can not be null or empty See Also GetParameter<T, TRet>(T, Expression<Func<T, TRet>>) | Improve this Doc View Source GetParameter<T, TRet>(IDataQuery<T>, Expression<Func<T, TRet>>) Returns SQL procedure/function out parameter value Declaration public static TRet GetParameter<T, TRet>(this IDataQuery<T> query, Expression<Func<T, TRet>> param) where T : class, new() Parameters Type Name Description IDataQuery <T> query Data query Expression < Func <T, TRet>> param Parameter name expression using same name property (case insensitive) Example: x => x.SomePropertyName Returns Type Description TRet Parameter value Type Parameters Name Description T Data object type TRet Parameter type Exceptions Type Condition XDataRuntimeException Parameter name expression can not be null | Improve this Doc View Source GetProperties<T>(T, IEnumerable<String>, DataVersion) Returns properties values Declaration public static IEnumerable<KeyValuePair<string, object>> GetProperties<T>(this T obj, IEnumerable<string> props, DataVersion version = DataVersion.Actual) where T : class, IDataObject Parameters Type Name Description T obj Data object instance IEnumerable < String > props Properties sequence DataVersion version Data version Returns Type Description IEnumerable < KeyValuePair < String , Object >> Sequence of name value pairs Type Parameters Name Description T Data object type Remarks Hint: To get a single property value use GetProperty<T, TRet>(T, Expression<Func<T, TRet>>, DataVersion) function. Exceptions Type Condition XDataRuntimeException Properties sequence is null | Improve this Doc View Source GetProperties<T>(T, String[]) Returns properties values Hint: To get a single property value use GetProperty function. Declaration public static IEnumerable<KeyValuePair<string, object>> GetProperties<T>(this T obj, params string[] props) where T : class, IDataObject Parameters Type Name Description T obj Data object instance String [] props Properties array Returns Type Description IEnumerable < KeyValuePair < String , Object >> Sequence of name value pairs Type Parameters Name Description T Data object type Remarks Hint: To get a single property value use GetProperty<T, TRet>(T, Expression<Func<T, TRet>>, DataVersion) function. | Improve this Doc View Source GetProperties<T>(T, DataVersion, String[]) Returns properties values Declaration public static IEnumerable<KeyValuePair<string, object>> GetProperties<T>(this T obj, DataVersion version = DataVersion.Actual, params string[] props) where T : class, IDataObject Parameters Type Name Description T obj Data object instance DataVersion version Data version String [] props Properties array Returns Type Description IEnumerable < KeyValuePair < String , Object >> Sequence of name value pairs Type Parameters Name Description T Data object type Remarks Hint: To get a single property value use GetProperty<T, TRet>(T, Expression<Func<T, TRet>>, DataVersion) function. | Improve this Doc View Source GetProperty<TRet>(IDataObject, String) Returns single property value Declaration public static TRet GetProperty<TRet>(this IDataObject obj, string prop) Parameters Type Name Description IDataObject obj Data object instance String prop Property name Returns Type Description TRet Property value Type Parameters Name Description TRet Property type Exceptions Type Condition XDataRuntimeException Property name can not be null or empty See Also GetProperty<T, TRet>(T, Expression<Func<T, TRet>>, DataVersion) | Improve this Doc View Source GetProperty<T, TRet>(T, Expression<Func<T, TRet>>) Returns property value Declaration public static TRet GetProperty<T, TRet>(this T obj, Expression<Func<T, TRet>> prop) where T : class, IDataObject, new() Parameters Type Name Description T obj Data object instance Expression < Func <T, TRet>> prop Property name expression: x => x.SomePropertyName Returns Type Description TRet Property value Type Parameters Name Description T Data object type TRet Property type Exceptions Type Condition XDataRuntimeException Property name expression can not be null | Improve this Doc View Source GetProperty<T, TRet>(T, Expression<Func<T, TRet>>, DataVersion) Returns property value Declaration public static TRet GetProperty<T, TRet>(this T obj, Expression<Func<T, TRet>> prop, DataVersion version) where T : class, IDataObject, new() Parameters Type Name Description T obj Data object instance Expression < Func <T, TRet>> prop Property name expression: x => x.SomePropertyName DataVersion version Data version Returns Type Description TRet Property value Type Parameters Name Description T Data object type TRet Property type Exceptions Type Condition XDataRuntimeException Property name expression can not be null | Improve this Doc View Source GetRepository<T>(T) Returns object repository Declaration public static IRepository<T> GetRepository<T>(this T obj) where T : class, IDataObject, new() Parameters Type Name Description T obj Data object instance Returns Type Description IRepository <T> Object repository Type Parameters Name Description T Data object type Exceptions Type Condition XDataRuntimeException Object repository is detached | Improve this Doc View Source GetRepositoryAlias(IDataObject) Returns object's repository alias Declaration public static string GetRepositoryAlias(this IDataObject obj) Parameters Type Name Description IDataObject obj Data object Returns Type Description String Repository alias Exceptions Type Condition XDataRuntimeException | Improve this Doc View Source GetResultSet<TRes>(IDataQuery, Expression<Func<IEnumerable<TRes>>>) Returns SQL procedure/function result set Declaration public static IEnumerable<TRes> GetResultSet<TRes>(this IDataQuery query, Expression<Func<IEnumerable<TRes>>> resultSetName) where TRes : class Parameters Type Name Description IDataQuery query Data query Expression < Func < IEnumerable <TRes>>> resultSetName Result set name expression using same name property (case insensitive) Example: x => x.SomePropertyName Returns Type Description IEnumerable <TRes> Result set object sequence Type Parameters Name Description TRes Result set object type Exceptions Type Condition XDataRuntimeException Result set name expression can not be null See Also GetResultSet<TRes>(IDataQuery, String) | Improve this Doc View Source GetResultSet<TRes>(IDataQuery, String) Returns SQL procedure/function result set Declaration public static IEnumerable<TRes> GetResultSet<TRes>(this IDataQuery query, string resultSetName) where TRes : class Parameters Type Name Description IDataQuery query Data query String resultSetName Result set name name Returns Type Description IEnumerable <TRes> Parameter value Type Parameters Name Description TRes Result set object type Exceptions Type Condition XDataRuntimeException Result set name can not be null or empty See Also GetResultSet<TRes>(IDataQuery, Expression<Func<IEnumerable<TRes>>>) | Improve this Doc View Source GetResultSet<T, TRes>(T, Expression<Func<T, IEnumerable<TRes>>>) Returns SQL procedure/function result set Declaration public static IEnumerable<TRes> GetResultSet<T, TRes>(this T obj, Expression<Func<T, IEnumerable<TRes>>> resultSetName) where T : class, IDataObject, new() where TRes : class Parameters Type Name Description T obj Data object instance Expression < Func <T, IEnumerable <TRes>>> resultSetName Result set name expression using same name property (case insensitive) Example: x => x.SomePropertyName Returns Type Description IEnumerable <TRes> Result set object sequence Type Parameters Name Description T Data object type TRes Result set object type Exceptions Type Condition XDataRuntimeException Result set name expression can not be null | Improve this Doc View Source GetResultSet<T, TRes>(IRepository<T>, Expression<Func<T, IEnumerable<TRes>>>) Returns SQL procedure/function result set Declaration public static IEnumerable<TRes> GetResultSet<T, TRes>(this IRepository<T> repository, Expression<Func<T, IEnumerable<TRes>>> resultSetName) where T : class, IDataObject, new() where TRes : class Parameters Type Name Description IRepository <T> repository Data object repository Expression < Func <T, IEnumerable <TRes>>> resultSetName Result set name expression using same name property (case insensitive) Example: x => x.SomePropertyName Returns Type Description IEnumerable <TRes> Result set object sequence Type Parameters Name Description T Object type TRes Result set object type Exceptions Type Condition XDataRuntimeException Result set name expression can not be null See Also GetResultSet<TRes>(IDataQuery, String) | Improve this Doc View Source GetState<T>(T) Returns state of object Declaration public static DataObjectState GetState<T>(this T obj) where T : class, IDataObject Parameters Type Name Description T obj Data object instance Returns Type Description DataObjectState Object state flags combination(see DataObjectState) Type Parameters Name Description T Data object type Exceptions Type Condition XDataRuntimeException No state attached to object See Also CheckState<T>(T, DataObjectState) SetDeleted<T>(T, Boolean) | Improve this Doc View Source IsAttached(IDataObject, Type) Check data object is attached Declaration public static bool IsAttached(this IDataObject obj, Type type) Parameters Type Name Description IDataObject obj Data object instance Type type Data object type Returns Type Description Boolean Object is attached Exceptions Type Condition XDataRuntimeException Object is detached | Improve this Doc View Source IsChanged<T>(T, Expression<Func<T, Object>>[]) Test property value is assigned Declaration public static bool IsChanged<T>(this T obj, params Expression<Func<T, object>>[] prop) where T : class, IDataObject Parameters Type Name Description T obj Data object instance Expression < Func <T, Object >>[] prop Property name expression Example: x => x.SomePropertyName Returns Type Description Boolean Property is changed Type Parameters Name Description T Data object type Exceptions Type Condition XDataRuntimeException Property name expression can not be null | Improve this Doc View Source IsChanged<T>(T, String) Test property value is assigned Declaration public static bool IsChanged<T>(this T obj, string prop) where T : class, IDataObject Parameters Type Name Description T obj Data object instance String prop Property name Returns Type Description Boolean Property is changed Type Parameters Name Description T Data object type Exceptions Type Condition XDataRuntimeException Property name can not be null or empty | Improve this Doc View Source IsCleared<T>(T, String) Test property value is cleared Declaration public static bool IsCleared<T>(this T obj, string prop) where T : class, IDataObject Parameters Type Name Description T obj Data object instance String prop Property name Returns Type Description Boolean Property is cleared Type Parameters Name Description T Data object type Exceptions Type Condition XDataRuntimeException Property name can not be null or empty | Improve this Doc View Source IsEmpty<T>(T, Expression<Func<T, Object>>) Test property value is empty Declaration public static bool IsEmpty<T>(this T obj, Expression<Func<T, object>> prop) where T : class, IDataObject Parameters Type Name Description T obj Data object instance Expression < Func <T, Object >> prop Property name expression Example: x => x.SomePropertyName Returns Type Description Boolean Property is empty Type Parameters Name Description T Data object type Exceptions Type Condition XDataRuntimeException Property name expression can not be null | Improve this Doc View Source IsEmpty<T>(T, String) Test property value is empty Declaration public static bool IsEmpty<T>(this T obj, string prop) where T : class, IDataObject Parameters Type Name Description T obj Data object instance String prop Property name Returns Type Description Boolean Property is empty Type Parameters Name Description T Data object type Exceptions Type Condition XDataRuntimeException Property name can not be null or empty | Improve this Doc View Source LoadLob<T>(T) Load Lob and Xml field values of data object Declaration public static T LoadLob<T>(this T obj) where T : class, IDataObject, new() Parameters Type Name Description T obj Object Returns Type Description T Enriched object Type Parameters Name Description T Object type | Improve this Doc View Source LoadLob<T>(T, Expression<Func<T, Object>>[]) Load Lob and Xml field values of data object Declaration public static T LoadLob<T>(this T obj, params Expression<Func<T, object>>[] properties) where T : class, IDataObject, new() Parameters Type Name Description T obj Object Expression < Func <T, Object >>[] properties Properties expressions Returns Type Description T Enriched object Type Parameters Name Description T Object type | Improve this Doc View Source LoadLob<T>(T, String[]) Load Lob and Xml field values of data object Declaration public static T LoadLob<T>(this T obj, params string[] properties) where T : class, IDataObject, new() Parameters Type Name Description T obj Object String [] properties Properties extensions Returns Type Description T Enriched object Type Parameters Name Description T Object type | Improve this Doc View Source Lock<T>(T) Lock object in database Declaration public static bool Lock<T>(this T obj) where T : class, IDataObject, new() Parameters Type Name Description T obj Data object instance Returns Type Description Boolean Lock success Type Parameters Name Description T Data object type See Also Lock(T) | Improve this Doc View Source Modify(Lob, Action<Byte[]>) Lob field modify Declaration public static Lob Modify(this Lob source, Action<byte[]> action) Parameters Type Name Description Lob source Source Lob Action < Byte []> action Modify action Returns Type Description Lob Modified Lob Exceptions Type Condition XDataRuntimeException Modify logic error See Also Lob Modify(Xml, Action<XDocument>) | Improve this Doc View Source Modify(Xml, Action<XDocument>) Xml field modify Declaration public static Xml Modify(this Xml source, Action<XDocument> action) Parameters Type Name Description Xml source Source document Action < XDocument > action Modify action Returns Type Description Xml Modified xml Examples invoice.Source.Modify(doc => doc.Element(\"invoice\").Attribute(\"state\").Value = \"ACTIVE\"); Exceptions Type Condition XDataRuntimeException Modify logic error See Also Xml Modify(Lob, Action<Byte[]>) | Improve this Doc View Source Modify<T>(T, Action<T>[]) Data object modification wrapper Declaration public static T Modify<T>(this T obj, params Action<T>[] actions) where T : class, IDataObject Parameters Type Name Description T obj Data object Action <T>[] actions Modification actions Returns Type Description T Modified data object Type Parameters Name Description T Data object type | Improve this Doc View Source PostData<T>(T, String, Func<Byte[]>) Post data to client Declaration public static void PostData<T>(this T obj, string message, Func<byte[]> data) where T : class, IDataObject, new() Parameters Type Name Description T obj Object context String message Message name Func < Byte []> data Data to post Type Parameters Name Description T Data object type | Improve this Doc View Source Refresh<T>(T) Refresh single data object from database Declaration public static bool Refresh<T>(this T obj) where T : class, IDataObject, new() Parameters Type Name Description T obj Data object instance Returns Type Description Boolean Success flag Type Parameters Name Description T Data object type | Improve this Doc View Source Refresh<T>(IRepository<T>) Refresh repository data Declaration public static IRepository<T> Refresh<T>(this IRepository<T> source) where T : class, IDataObject, new() Parameters Type Name Description IRepository <T> source Repository Returns Type Description IRepository <T> Repository Type Parameters Name Description T Data object type | Improve this Doc View Source SetAttachedHandlers<T>(T, AttachedHandler<T>[]) Attach extra handlers to object instance Declaration public static void SetAttachedHandlers<T>(this T obj, params AttachedHandler<T>[] handlers) where T : class, IDataObject, new() Parameters Type Name Description T obj Data object instance AttachedHandler <T>[] handlers Handlers Type Parameters Name Description T Data object type | Improve this Doc View Source SetCurrent<T>(T) Set object as repository current Declaration public static void SetCurrent<T>(this T obj) where T : class, IDataObject, new() Parameters Type Name Description T obj Data object instance Type Parameters Name Description T Data object type See Also Current | Improve this Doc View Source SetDeleted<T>(T, Boolean) Set deleted state to object Declaration public static T SetDeleted<T>(this T obj, bool setState) where T : class, IDataObject, new() Parameters Type Name Description T obj Data object instance Boolean setState Set or remove DataObjectState.Deleted state flag Returns Type Description T Object marked as deleted/restored Type Parameters Name Description T Data object type Exceptions Type Condition XDataRuntimeException No state attached to object See Also CheckState<T>(T, DataObjectState) GetState<T>(T) | Improve this Doc View Source SetDeleted<T>(ICollection<T>, Boolean) Set deleted state to each object in collection Declaration public static ICollection<T> SetDeleted<T>(this ICollection<T> collection, bool setState) where T : class, IDataObject, new() Parameters Type Name Description ICollection <T> collection Data object collection Boolean setState Set or remove DataObjectState.Deleted state flag Returns Type Description ICollection <T> Collection of objects marked as deleted/restored Type Parameters Name Description T Data object type Exceptions Type Condition XDataRuntimeException No state attached to object See Also CheckState<T>(T, DataObjectState) GetState<T>(T) | Improve this Doc View Source SetFilterValue<T, TRes>(IRepository<T>, Expression<Func<T, TRes>>, TRes) Set value to dynamically created runtime filter Declaration public static IRepository<T> SetFilterValue<T, TRes>(this IRepository<T> repository, Expression<Func<T, TRes>> propertyExpression, TRes filterValue) where T : class, IDataObject, new() Parameters Type Name Description IRepository <T> repository Repository Expression < Func <T, TRes>> propertyExpression Property name expression TRes filterValue Filter value Returns Type Description IRepository <T> Repository Type Parameters Name Description T Repository data object type TRes Property type | Improve this Doc View Source SetVar<T>(String, T) Set variable value Declaration public static Variable SetVar<T>(this string name, T value) Parameters Type Name Description String name Variable name T value Variable value Returns Type Description Variable Variable Type Parameters Name Description T Value type | Improve this Doc View Source Submit<T>(T, out T, DataSubmitFlag) Submit data object changes Declaration public static bool Submit<T>(this T obj, out T res, DataSubmitFlag flag = DataSubmitFlag.None) where T : class, IDataObject, new() Parameters Type Name Description T obj Data object instance T res Submitted object DataSubmitFlag flag Submit flag Returns Type Description Boolean Submit success Type Parameters Name Description T Data object type See Also Submit(ref T, DataSubmitFlag) | Improve this Doc View Source Submit<T>(T, Func<JsonSettings<T>, JsonSettings<T>>, out T, DataSubmitFlag) Submit data object changes Declaration public static bool Submit<T>(this T obj, Func<JsonSettings<T>, JsonSettings<T>> settings, out T res, DataSubmitFlag flag = DataSubmitFlag.None) where T : class, IDataObject, new() Parameters Type Name Description T obj Data object instance Func < JsonSettings <T>, JsonSettings <T>> settings JSON serialization settings T res Submitted object DataSubmitFlag flag Submit flag Returns Type Description Boolean Submit success Type Parameters Name Description T Data object type See Also Submit(ref T, DataSubmitFlag) | Improve this Doc View Source Submit<T>(T, DataSubmitFlag) Submit data object changes Declaration public static bool Submit<T>(this T obj, DataSubmitFlag flag = DataSubmitFlag.None) where T : class, IDataObject, new() Parameters Type Name Description T obj Data object instance DataSubmitFlag flag Submit flag Returns Type Description Boolean Submit success Type Parameters Name Description T Data object type See Also Submit(ref T, DataSubmitFlag) | Improve this Doc View Source ToArray<T>(IEnumerable<T>, Func<JsonSettings<T>, JsonSettings<T>>) Returns array of data objects with JSON serialization settings applied Declaration public static T[] ToArray<T>(this IEnumerable<T> sourceEnumerable, Func<JsonSettings<T>, JsonSettings<T>> settings) where T : class, IDataObject, new() Parameters Type Name Description IEnumerable <T> sourceEnumerable Source object sequence Func < JsonSettings <T>, JsonSettings <T>> settings JSON serialization settings Returns Type Description T[] Array of data objects with JSON serialization settings applied Type Parameters Name Description T Object type | Improve this Doc View Source WithJsonSettings<T>(T, Func<JsonSettings<T>, JsonSettings<T>>) Apply custom JSON serialization settings to single object Declaration public static T WithJsonSettings<T>(this T obj, Func<JsonSettings<T>, JsonSettings<T>> settings) where T : class, IDataObject, new() Parameters Type Name Description T obj Object to apply serialization settings Func < JsonSettings <T>, JsonSettings <T>> settings Serialization settings fill routine Returns Type Description T Object with custom serialization settings Type Parameters Name Description T ObjectType | Improve this Doc View Source WithJsonSettings<T>(ICollection<T>, Func<JsonSettings<T>, JsonSettings<T>>) Apply custom JSON serialization settings to collection Declaration public static ICollection<T> WithJsonSettings<T>(this ICollection<T> collection, Func<JsonSettings<T>, JsonSettings<T>> settings) where T : class, IDataObject, new() Parameters Type Name Description ICollection <T> collection Collection to apply serialization settings Func < JsonSettings <T>, JsonSettings <T>> settings Serialization settings fill routine Returns Type Description ICollection <T> Collection with custom serialization settings Type Parameters Name Description T ObjectType"
  },
  "api/XData.Database.FieldInfo.html": {
    "href": "api/XData.Database.FieldInfo.html",
    "title": "Class FieldInfo | XData website",
    "keywords": "Class FieldInfo Field information Inheritance Object FieldInfo Inherited Members Object.Equals(Object) Object.Equals(Object, Object) Object.GetHashCode() Object.GetType() Object.MemberwiseClone() Object.ReferenceEquals(Object, Object) Namespace : XData.Database Assembly : XData.docfx.dll Syntax [Serializable] public sealed class FieldInfo Properties | Improve this Doc View Source IsAutoIncrement Auto increment flag Declaration public bool IsAutoIncrement { get; set; } Property Value Type Description Boolean | Improve this Doc View Source IsPk Primary key flag Declaration public bool IsPk { get; set; } Property Value Type Description Boolean | Improve this Doc View Source Name Field name Declaration public string Name { get; set; } Property Value Type Description String | Improve this Doc View Source NativeDataType Field native data type Declaration public string NativeDataType { get; set; } Property Value Type Description String | Improve this Doc View Source Scale Field scale Declaration public int Scale { get; set; } Property Value Type Description Int32 | Improve this Doc View Source Size Field size Declaration public int Size { get; set; } Property Value Type Description Int32 | Improve this Doc View Source Type Field type Declaration public DbType Type { get; set; } Property Value Type Description DbType Methods | Improve this Doc View Source ToString() Returns a string that represents the current object. Declaration public override string ToString() Returns Type Description String A string that represents the current object. Overrides Object.ToString() Extension Methods SerializationExtensions.ToXml<T>(T) CollectionsExtensions.SetValue<TKey, T>(TKey, T) CollectionsExtensions.AsEnum<T>(T) DataObjectQueryableExtensions.CompareVariable(Object, FilterOperation, String) Processing.Do<T>(T, Action<IProcess<T>>[]) TypeExtensions.TryConvert<T, TResult>(T, Func<T, TResult>) TypeExtensions.TryConvert<T, TResult>(T, Func<T, TResult>, TResult) TypeExtensions.ChangeType<T>(Object) TypeExtensions.ChangeType(Object, Type) TypeExtensions.InvokeMethod<TRet>(Object, Type[], Expression<Func<TRet>>, BindingFlags) TypeExtensions.InvokeMethod(Object, Type[], Expression<Action>, BindingFlags) TypeExtensions.InvokeMethod<TRet>(Object, Expression<Func<TRet>>, BindingFlags) TypeExtensions.InvokeMethod(Object, Expression<Action>, BindingFlags) SqlBlockExtensions.SetExpression<TTag, TResult>(TTag, Expression<Func<IBlockQueryAdapter, TResult>>) QueryDescriptionExtensions.SetExpression<TTag, TResult>(TTag, Expression<Func<IQueryStructureAdapter, TResult>>)"
  },
  "api/XData.Database.Dialect.BaseSqlBuilder.html": {
    "href": "api/XData.Database.Dialect.BaseSqlBuilder.html",
    "title": "Class BaseSqlBuilder | XData website",
    "keywords": "Class BaseSqlBuilder SQL builder base class Inheritance Object BaseSqlBuilder Implements ISqlBuilder IEnumerable < Query > IEnumerable Inherited Members Object.Equals(Object) Object.Equals(Object, Object) Object.GetHashCode() Object.GetType() Object.MemberwiseClone() Object.ReferenceEquals(Object, Object) Object.ToString() Namespace : XData.Database.Dialect Assembly : XData.docfx.dll Syntax [DatabaseAdapter(\"NONE\")] public abstract class BaseSqlBuilder : ISqlBuilder, ISqlBuilderInternal, IEnumerable<Query>, IEnumerable Fields | Improve this Doc View Source SqlStrings SQL dialect specific format strings WARNING! Mast be filled in constructor! Declaration protected SortedList<SqlStringType, string> SqlStrings Field Value Type Description SortedList < SqlStringType , String > Properties | Improve this Doc View Source Config SQL dialect configuration Declaration protected IConfiguration Config { get; } Property Value Type Description IConfiguration | Improve this Doc View Source Context Context name Declaration protected string Context { get; } Property Value Type Description String | Improve this Doc View Source DialectOptions Dialect options WARNING! Mast to be filled in constructor! Declaration public virtual DialectOptions DialectOptions { get; } Property Value Type Description DialectOptions | Improve this Doc View Source Item[Enum] Predefined queries enumerator Declaration public Query this[Enum i] { get; } Parameters Type Name Description Enum i Predefined query enumeration key Property Value Type Description Query Query Exceptions Type Condition XDataAdapterException | Improve this Doc View Source ParameterPrefix Parameter prefix symbol Declaration public abstract string ParameterPrefix { get; } Property Value Type Description String | Improve this Doc View Source Queries List of predefined queries WARNING! Mast to be filled in constructor! Declaration protected List<Query> Queries { set; } Property Value Type Description List < Query > | Improve this Doc View Source SqlBlockVariablePrefix Declaration protected virtual string SqlBlockVariablePrefix { get; } Property Value Type Description String | Improve this Doc View Source SqlTypes List of supported SQL types WARNING! Mast to be filled in constructor! Declaration public DbType[] SqlTypes { get; protected set; } Property Value Type Description DbType [] | Improve this Doc View Source SqlTypeSizes List of supported type size applicable WARNING! Mast to be filled in constructor! Declaration public Dictionary<string, SqlTypeSize> SqlTypeSizes { get; protected set; } Property Value Type Description Dictionary < String , SqlTypeSize > | Improve this Doc View Source TypeNames List of supported column type names WARNING! Mast to be filled in constructor! Declaration public string[] TypeNames { get; protected set; } Property Value Type Description String [] | Improve this Doc View Source TypeSynonyms List of supported type synonyms WARNING! Mast to be filled in constructor! Declaration public string[] TypeSynonyms { get; protected set; } Property Value Type Description String [] Methods | Improve this Doc View Source AddOrderBy(IDataStructure, SortedList<String, Object>, ref StringBuilder, ref Query, ref List<Tuple<String, Type, String>>, ICollection<String>, ref SortedList<String, Tuple<String, String>>, ref Dictionary<String, Object>, Boolean) Add order by statement to query Declaration protected virtual void AddOrderBy(IDataStructure structure, SortedList<string, object> filterValues, ref StringBuilder strCommand, ref Query query, ref List<Tuple<string, Type, string>> withSources, ICollection<string> skipped, ref SortedList<string, Tuple<string, string>> fields, ref Dictionary<string, object> paramValues, bool doNotSkip) Parameters Type Name Description IDataStructure structure Structure metadata SortedList < String , Object > filterValues Filter values StringBuilder strCommand Query string builder Query query Query List < Tuple < String , Type , String >> withSources Common-Table-Expression (WITH) data sources ICollection < String > skipped Skipped sources collection SortedList < String , Tuple < String , String >> fields Parsed fields Dictionary < String , Object > paramValues Query parameter values Boolean doNotSkip Don't skip empty sources | Improve this Doc View Source AddReturning2Command(ref StringBuilder, String, SortedList<Tuple<String, String>, Tuple<String, Boolean, Boolean>>, Boolean, Boolean) Add returning auto increment identity column values statement in query Declaration protected abstract void AddReturning2Command(ref StringBuilder sb, string alias, SortedList<Tuple<string, string>, Tuple<string, bool, bool>> identity, bool defaultValues = false, bool close = false) Parameters Type Name Description StringBuilder sb Query string builder String alias Table alias SortedList < Tuple < String , String >, Tuple < String , Boolean , Boolean >> identity Identity column name and parameter name Boolean defaultValues Insert default values flag Boolean close Close values parenthesis flag | Improve this Doc View Source AddSkipLimitAndOrder(IDataStructure, SortedList<String, Object>, ref StringBuilder, Int32, String, ref Query, ref List<Tuple<String, Type, String>>, ICollection<String>, ref SortedList<String, Tuple<String, String>>, ref Dictionary<String, Object>, Boolean) Add skip, limit, and order statements to query Declaration protected abstract void AddSkipLimitAndOrder(IDataStructure structure, SortedList<string, object> filterValues, ref StringBuilder strCommand, int fromPosition, string selectAll, ref Query query, ref List<Tuple<string, Type, string>> withSources, ICollection<string> skipped, ref SortedList<string, Tuple<string, string>> fields, ref Dictionary<string, object> paramValues, bool doNotSkip = false) Parameters Type Name Description IDataStructure structure Structure metadata SortedList < String , Object > filterValues Filter values StringBuilder strCommand Query string builder Int32 fromPosition From statement start position String selectAll All fields list string Query query Query List < Tuple < String , Type , String >> withSources Common-Table-Expression (WITH) data sources ICollection < String > skipped Skipped sources collection SortedList < String , Tuple < String , String >> fields Parsed fields Dictionary < String , Object > paramValues Query parameter values Boolean doNotSkip Don't skip empty sources | Improve this Doc View Source Beautify(String) Returns formatted SQL string Declaration public static string Beautify(string sql) Parameters Type Name Description String sql SQL string to format Returns Type Description String Formatted SQL string | Improve this Doc View Source BeautifyRtf(String) Returns RTF formatted SQL string Declaration public static string BeautifyRtf(string sql) Parameters Type Name Description String sql SQL string to format Returns Type Description String RTF formatted SQL string | Improve this Doc View Source BuildSqlBlock(Expression<SqlBlockDefinition>, Expression<Func<ISqlParamAdapter, ISqlParam>>[]) Declaration public Query BuildSqlBlock(Expression<SqlBlockDefinition> sqlBlock, Expression<Func<ISqlParamAdapter, ISqlParam>>[] parameters) Parameters Type Name Description Expression < SqlBlockDefinition > sqlBlock Expression < Func < ISqlParamAdapter , ISqlParam >>[] parameters Returns Type Description Query | Improve this Doc View Source BuildSqlBlock<T>(Expression<SqlBlockDefinition<T>>, Expression<Func<ISqlParamAdapter, ISqlParam>>[], out Func<DataRow, T>) Declaration public Query BuildSqlBlock<T>(Expression<SqlBlockDefinition<T>> sqlBlock, Expression<Func<ISqlParamAdapter, ISqlParam>>[] parameters, out Func<DataRow, T> mapper) where T : class, new() Parameters Type Name Description Expression < SqlBlockDefinition <T>> sqlBlock Expression < Func < ISqlParamAdapter , ISqlParam >>[] parameters Func < DataRow , T> mapper Returns Type Description Query Type Parameters Name Description T | Improve this Doc View Source CompleteInsert(String, SortedList<Tuple<String, String>, Tuple<String, Boolean, Boolean>>, Type) Returns string contains SQL expression to complete insert statement Declaration protected virtual string CompleteInsert(string alias, SortedList<Tuple<string, string>, Tuple<string, bool, bool>> identity, Type objectType) Parameters Type Name Description String alias Base table alias SortedList < Tuple < String , String >, Tuple < String , Boolean , Boolean >> identity Identity fields and query parameters Type objectType Mapped object type Returns Type Description String SQL expression to complete insert statement | Improve this Doc View Source ConvertTextExpr(IField, String) Convert expression text for field native data type Declaration protected virtual string ConvertTextExpr(IField field, string exprText) Parameters Type Name Description IField field Field String exprText Expression text Returns Type Description String Expression text | Improve this Doc View Source ExtractXmlQuery(String, String, String[], IComparable[], String, KeyValuePair<String, String>[]) Returns query to extract xml data by XPath expression Declaration public Query ExtractXmlQuery(string table, string column, string[] tablePrimaryKey, IComparable[] primaryKeyValue, string path, params KeyValuePair<string, string>[] namespaces) Parameters Type Name Description String table Table name String column Xml column name String [] tablePrimaryKey Table primary key columns IComparable [] primaryKeyValue Table primary key values String path XPath expression KeyValuePair < String , String >[] namespaces XPath namespaces Returns Type Description Query XPath result Exceptions Type Condition XDataQueryStructureException Field not found | Improve this Doc View Source FormatConstValue(Object, out DbType) Declaration protected string FormatConstValue(object constVal, out DbType sqlType) Parameters Type Name Description Object constVal DbType sqlType Returns Type Description String | Improve this Doc View Source FormatFieldName(String, String) Format field name Declaration public static string FormatFieldName(string alias, string fieldName) Parameters Type Name Description String alias Source alias String fieldName Field name Returns Type Description String Formatted field name | Improve this Doc View Source FormatQuery(Query, Object[]) Returns formatted query string with parameter values Declaration public static string FormatQuery(Query query, params object[] paramValues) Parameters Type Name Description Query query Query Object [] paramValues Parameter values Returns Type Description String Formatted SQL string | Improve this Doc View Source FormatSql(SqlStringType, Object[]) Format SQL dialect specific syntax strings Hint: Override to realize ugly non standard syntax (if needed) Declaration protected virtual string FormatSql(SqlStringType sqlStringType, params object[] args) Parameters Type Name Description SqlStringType sqlStringType SQL syntax key Object [] args Syntax arguments Returns Type Description String | Improve this Doc View Source FormatStoredProcedure(StoredProcedure, Object[]) Returns formatted query string with parameter values Declaration public static string FormatStoredProcedure(StoredProcedure storedProcedure, params object[] paramValues) Parameters Type Name Description StoredProcedure storedProcedure Stored procedure Object [] paramValues Parameter values Returns Type Description String Formatted SQL string | Improve this Doc View Source GetAcquireBlobQuery(String, String, IEnumerable<String>, IComparable[], String) Returns query to acquire blob data Declaration public Query GetAcquireBlobQuery(string table, string column, IEnumerable<string> tablePrimaryKey, IComparable[] primaryKeyValue, string nativeSqlType = null) Parameters Type Name Description String table Table name String column Blob column name IEnumerable < String > tablePrimaryKey Table primary key columns IComparable [] primaryKeyValue Table primary key values String nativeSqlType Native SQL type name Returns Type Description Query Query | Improve this Doc View Source GetAcquireXmlQuery(String, String, String[], IComparable[]) Returns query to acquire xml data Declaration public Query GetAcquireXmlQuery(string table, string column, string[] tablePrimaryKey, IComparable[] primaryKeyValue) Parameters Type Name Description String table Table name String column Xml column name String [] tablePrimaryKey Table primary key columns IComparable [] primaryKeyValue Table primary key values Returns Type Description Query Query Exceptions Type Condition XDataQueryStructureException Field not found | Improve this Doc View Source GetAllQuery(IDataStructure) Returns query to check compliance of all repository objects Hint: Used in XData LINQ expressions Declaration public Query GetAllQuery(IDataStructure structure) Parameters Type Name Description IDataStructure structure Structure metadata Returns Type Description Query Query | Improve this Doc View Source GetAnyQuery(IDataStructure) Returns query to check existence of repository objects Hint: Used in XData LINQ expressions Declaration public Query GetAnyQuery(IDataStructure structure) Parameters Type Name Description IDataStructure structure Structure metadata Returns Type Description Query Query | Improve this Doc View Source GetBlobSizeQuery(String, String, String[], IComparable[]) Returns query to get Large Object size Declaration public Query GetBlobSizeQuery(string table, string column, string[] tablePrimaryKey, IComparable[] primaryKeyValue) Parameters Type Name Description String table Table name contained LOB String column LOB column name String [] tablePrimaryKey Primary key column names IComparable [] primaryKeyValue Primary key values Returns Type Description Query Query to get Large Object size | Improve this Doc View Source GetCall(IDataStructure, String) Declaration public StoredProcedure GetCall(IDataStructure structure, string userName) Parameters Type Name Description IDataStructure structure String userName Returns Type Description StoredProcedure Exceptions Type Condition XDataQueryStructureException XDataAdapterException stored procedure | Improve this Doc View Source GetClearQuery(IDataStructure) Returns query to clear all repository objects Declaration public Query GetClearQuery(IDataStructure structure) Parameters Type Name Description IDataStructure structure Structure metadata Returns Type Description Query Query Exceptions Type Condition XDataQueryStructureException | Improve this Doc View Source GetConnectionInfo(String, Dictionary<CredentialsType, String>) Declaration public XConnectionInfo GetConnectionInfo(string connectionString, Dictionary<CredentialsType, string> credentials = null) Parameters Type Name Description String connectionString Dictionary < CredentialsType , String > credentials Returns Type Description XConnectionInfo | Improve this Doc View Source GetConnectionString(String, String, Boolean, String, String, String) Compose specific connection string from parts Declaration protected abstract string GetConnectionString(string server, string schema, bool integratedSecurity, string user, string password, string partialConnectionString) Parameters Type Name Description String server Server name String schema Schema name Boolean integratedSecurity Integrated security flag String user User login String password User password String partialConnectionString Additional connection string settings Returns Type Description String Connection string | Improve this Doc View Source GetCountQuery(IDataStructure) Returns query to select count of data objects in repository Declaration public Query GetCountQuery(IDataStructure structure) Parameters Type Name Description IDataStructure structure Structure metadata Returns Type Description Query Query | Improve this Doc View Source GetDeleteQuery(IDataStructure, IDataObject, String, Boolean) Returns query to delete data object Declaration public Query GetDeleteQuery(IDataStructure structure, IDataObject data, string userName, bool ignoreConcurrency = true) Parameters Type Name Description IDataStructure structure Structure metadata IDataObject data Data object instance String userName User name Boolean ignoreConcurrency Ignore concurrency flag Returns Type Description Query Query Exceptions Type Condition XDataQueryStructureException | Improve this Doc View Source GetEnumerator() Predefined queries enumerator Declaration public IEnumerator<Query> GetEnumerator() Returns Type Description IEnumerator < Query > Predefined queries enumerator | Improve this Doc View Source GetExpressionText(IDataStructure, ExpressionContext, Type, Expression, out DbType) Compose SQL expression from XData LINQ expression Declaration public string GetExpressionText(IDataStructure structure, ExpressionContext context, Type queryType, Expression expression, out DbType sqlType) Parameters Type Name Description IDataStructure structure Structure metadata ExpressionContext context Expression context Type queryType Data query type Expression expression XData LINQ expression DbType sqlType Expression sql type Returns Type Description String SQL expression Exceptions Type Condition XDataQueryStructureException LINQ expression has unsupported type XDataQueryStructureException Property not found XDataQueryStructureException LINQ expression has unsupported method parameters XDataAdapterException | Improve this Doc View Source GetExprSize(IField) Declaration protected string GetExprSize(IField field) Parameters Type Name Description IField field Returns Type Description String | Improve this Doc View Source GetInsertQuery(IDataStructure, IDataObject, String, Boolean) Returns query to insert data object Declaration public Query GetInsertQuery(IDataStructure structure, IDataObject data, string userName, bool ignoreConcurrency = true) Parameters Type Name Description IDataStructure structure Structure metadata IDataObject data Data object instance String userName User name Boolean ignoreConcurrency Ignore concurrency flag Returns Type Description Query Query Exceptions Type Condition XDataQueryStructureException | Improve this Doc View Source GetLockQuery(IDataStructure) Returns query to lock single data object Declaration public Query GetLockQuery(IDataStructure structure) Parameters Type Name Description IDataStructure structure Structure metadata Returns Type Description Query Query | Improve this Doc View Source GetOrderByString(IDataStructure, SortedList<String, Object>, ref Query, ref List<Tuple<String, Type, String>>, ICollection<String>, ref SortedList<String, Tuple<String, String>>, ref Dictionary<String, Object>, Boolean, Boolean) Returns order by string Declaration protected string GetOrderByString(IDataStructure structure, SortedList<string, object> filterValues, ref Query query, ref List<Tuple<string, Type, string>> withSources, ICollection<string> skipped, ref SortedList<string, Tuple<string, string>> fields, ref Dictionary<string, object> paramValues, bool doNotSkip, bool useGrouping = false) Parameters Type Name Description IDataStructure structure Structure metadata SortedList < String , Object > filterValues Filter values Query query Query List < Tuple < String , Type , String >> withSources Common-Table-Expression (WITH) data sources ICollection < String > skipped Skipped sources collection SortedList < String , Tuple < String , String >> fields Parsed fields Dictionary < String , Object > paramValues Query parameter values Boolean doNotSkip Don't skip empty sources Boolean useGrouping Used in GROUP BY generation Returns Type Description String Order by string Exceptions Type Condition XDataQueryStructureException Field not found | Improve this Doc View Source GetParameterName(String) Formats field name as parameter name Declaration public virtual string GetParameterName(string fieldName) Parameters Type Name Description String fieldName Field name Returns Type Description String Parameter name | Improve this Doc View Source GetRefreshQuery(IDataStructure) Returns query to refresh single data object Declaration public Query GetRefreshQuery(IDataStructure structure) Parameters Type Name Description IDataStructure structure Structure metadata Returns Type Description Query Query | Improve this Doc View Source GetSafeConvertExpression(Type, Expression, Expression) Safe convert expression Declaration public virtual Expression GetSafeConvertExpression(Type type, Expression dataRow, Expression fieldName) Parameters Type Name Description Type type Type of expression Expression dataRow Data row expression Expression fieldName Field name expression Returns Type Description Expression Expression | Improve this Doc View Source GetSaveBlobQuery(String, String, IEnumerable<String>, IComparable[], ref Byte[], String) Returns query to save blob data Declaration public Query GetSaveBlobQuery(string table, string column, IEnumerable<string> tablePrimaryKey, IComparable[] primaryKeyValue, ref byte[] body, string nativeSqlType = null) Parameters Type Name Description String table Table name String column Blob column name IEnumerable < String > tablePrimaryKey Table primary key columns IComparable [] primaryKeyValue Table primary key values Byte [] body Blob body String nativeSqlType Native SQL type name Returns Type Description Query Query | Improve this Doc View Source GetSaveXmlQuery(String, String, String[], IComparable[], ref String) Returns query to save xml data Declaration public Query GetSaveXmlQuery(string table, string column, string[] tablePrimaryKey, IComparable[] primaryKeyValue, ref string body) Parameters Type Name Description String table Table name String column Xml column name String [] tablePrimaryKey Table primary key columns IComparable [] primaryKeyValue Table primary key values String body Blob body Returns Type Description Query Query Exceptions Type Condition XDataQueryStructureException Field not found | Improve this Doc View Source GetSelectQuery(IDataStructure, Boolean, Boolean) Returns query to select data objects Declaration public Query GetSelectQuery(IDataStructure structure, bool markProperties = false, bool doNotSkip = false) Parameters Type Name Description IDataStructure structure Structure metadata Boolean markProperties Mark properties with comments Boolean doNotSkip Don't skip sources Returns Type Description Query Query | Improve this Doc View Source GetSequenceName(String, String, String) Returns sequence name Declaration public string GetSequenceName(string context, string table, string column) Parameters Type Name Description String context Context name String table Table name String column Column name Returns Type Description String Sequence name | Improve this Doc View Source GetSqlTypeName(DbType) Returns SQL type name for System.DbType Declaration protected virtual string GetSqlTypeName(DbType dbType) Parameters Type Name Description DbType dbType System.DbType enumeration key Returns Type Description String SQL type name Exceptions Type Condition XDataAdapterException Type not supported | Improve this Doc View Source GetUpdateQuery(IDataStructure, IDataObject, String, Boolean) Returns query to update data object Declaration public Query GetUpdateQuery(IDataStructure structure, IDataObject data, string userName, bool ignoreConcurrency = true) Parameters Type Name Description IDataStructure structure Structure metadata IDataObject data Data object instance String userName User name Boolean ignoreConcurrency Ignore concurrency flag Returns Type Description Query Query Exceptions Type Condition XDataQueryStructureException | Improve this Doc View Source GetXmlNamespaces(KeyValuePair<String, String>[]) Returns Xml namespaces string Declaration protected abstract string GetXmlNamespaces(KeyValuePair<string, string>[] namespaces) Parameters Type Name Description KeyValuePair < String , String >[] namespaces Xml namespaces Returns Type Description String Xml namespaces string | Improve this Doc View Source Init() Dialect adapter initialization Declaration protected virtual void Init() | Improve this Doc View Source Init(String, IConfiguration, String) Dialect adapter initialization Declaration public void Init(string context, IConfiguration config, string sequence) Parameters Type Name Description String context Context name IConfiguration config Specific dialect adapter configuration Xml String sequence Sequence generator assembly qualified class name | Improve this Doc View Source ParseConnectionString(String, ref String, ref String, ref Boolean, ref String, ref String, out String) Parse specific connection string to parts Declaration protected abstract void ParseConnectionString(string connectionString, ref string server, ref string schema, ref bool integratedSecurity, ref string user, ref string password, out string partialConnectionString) Parameters Type Name Description String connectionString Connection string String server Server name String schema Schema name Boolean integratedSecurity Integrated security flag String user User login String password User password String partialConnectionString Additional connection string settings | Improve this Doc View Source PrepareTempTables(IDataStructure, ref StringBuilder, Query, ICollection<String>, Boolean, Boolean) Declaration protected virtual bool PrepareTempTables(IDataStructure structure, ref StringBuilder strCommand, Query query, ICollection<string> skippedSources, bool riseErrors, bool doNotSkip) Parameters Type Name Description IDataStructure structure StringBuilder strCommand Query query ICollection < String > skippedSources Boolean riseErrors Boolean doNotSkip Returns Type Description Boolean | Improve this Doc View Source RegisterResultSet(IResultSetDescription) Declaration protected virtual QueryParam RegisterResultSet(IResultSetDescription resultSet) Parameters Type Name Description IResultSetDescription resultSet Returns Type Description QueryParam | Improve this Doc View Source SequenceGeneration(out Boolean) Sequence generation supported Declaration public bool SequenceGeneration(out bool required) Parameters Type Name Description Boolean required Returns Type Description Boolean Sequence generation supported flag See Also GetSequenceName(String, String, String) SequenceRequired | Improve this Doc View Source SetQueryParameters(ref Query, IEnumerable<IParameterDescription>, SortedList<String, Object>, String, DialectOptions) Declaration public void SetQueryParameters(ref Query query, IEnumerable<IParameterDescription> parameters, SortedList<string, object> variableValues, string userName, DialectOptions dialectOptions) Parameters Type Name Description Query query IEnumerable < IParameterDescription > parameters SortedList < String , Object > variableValues String userName DialectOptions dialectOptions Exceptions Type Condition XDataAdapterException | Improve this Doc View Source SetQueryParameterValues(ref Query, SortedList<String, Object>) Set query parameter values Declaration public void SetQueryParameterValues(ref Query query, SortedList<string, object> paramValues) Parameters Type Name Description Query query Query SortedList < String , Object > paramValues Parameter values | Improve this Doc View Source ToDataSet<TSource>(String, IEnumerable<TSource>) Compose union structure over source object sequence Declaration public string ToDataSet<TSource>(string prefix, IEnumerable<TSource> source) Parameters Type Name Description String prefix Column prefix IEnumerable <TSource> source Source sequence Returns Type Description String Data source Type Parameters Name Description TSource Source type Explicit Interface Implementations | Improve this Doc View Source IEnumerable.GetEnumerator() Predefined queries enumerator Declaration IEnumerator IEnumerable.GetEnumerator() Returns Type Description IEnumerator Predefined queries enumerator Implements ISqlBuilder System.Collections.Generic.IEnumerable<T> System.Collections.IEnumerable Extension Methods SerializationExtensions.ToXml<T>(T) CollectionsExtensions.ToSortedSet<T>(IEnumerable<T>, IComparer<T>) CollectionsExtensions.SetValue<TKey, T>(TKey, T) CollectionsExtensions.AsEnum<T>(T) DataObjectQueryableExtensions.CompareVariable(Object, FilterOperation, String) JoinedEnumerable.Inner<TElement>(IEnumerable<TElement>) JoinedEnumerable.Outer<TElement>(IEnumerable<TElement>) JoinedEnumerable.LeftOuterJoin<TOuter, TInner, TKey, TResult>(IEnumerable<TOuter>, IEnumerable<TInner>, Func<TOuter, TKey>, Func<TInner, TKey>, Func<TOuter, TInner, TResult>, IEqualityComparer<TKey>) JoinedEnumerable.RightOuterJoin<TOuter, TInner, TKey, TResult>(IEnumerable<TOuter>, IEnumerable<TInner>, Func<TOuter, TKey>, Func<TInner, TKey>, Func<TOuter, TInner, TResult>, IEqualityComparer<TKey>) JoinedEnumerable.FullOuterJoin<TOuter, TInner, TKey, TResult>(IEnumerable<TOuter>, IEnumerable<TInner>, Func<TOuter, TKey>, Func<TInner, TKey>, Func<TOuter, TInner, TResult>, IEqualityComparer<TKey>) Processing.Do<T>(T, Action<IProcess<T>>[]) TypeExtensions.TryConvert<T, TResult>(T, Func<T, TResult>) TypeExtensions.TryConvert<T, TResult>(T, Func<T, TResult>, TResult) TypeExtensions.ChangeType<T>(Object) TypeExtensions.ChangeType(Object, Type) TypeExtensions.InvokeMethod<TRet>(Object, Type[], Expression<Func<TRet>>, BindingFlags) TypeExtensions.InvokeMethod(Object, Type[], Expression<Action>, BindingFlags) TypeExtensions.InvokeMethod<TRet>(Object, Expression<Func<TRet>>, BindingFlags) TypeExtensions.InvokeMethod(Object, Expression<Action>, BindingFlags) SqlBlockExtensions.SetExpression<TTag, TResult>(TTag, Expression<Func<IBlockQueryAdapter, TResult>>) QueryDescriptionExtensions.SetExpression<TTag, TResult>(TTag, Expression<Func<IQueryStructureAdapter, TResult>>) QueryDescriptionExtensions.ToDataSet<T>(IEnumerable<T>, String, ISqlBuilder)"
  },
  "api/XData.Database.Adapter.CallResult.html": {
    "href": "api/XData.Database.Adapter.CallResult.html",
    "title": "Class CallResult | XData website",
    "keywords": "Class CallResult Stored procedure call result Inheritance Object QueryResultBase CallResult Implements IEnumerable < QueryParam > IEnumerable Inherited Members QueryResultBase.AffectedRows QueryResultBase.Item[Int32] QueryResultBase.Item[String] QueryResultBase.ParamsCount QueryResultBase.Init(Int32, IDataParameterCollection) QueryResultBase.Init(Int32, IEnumerable<IDataParameter>) QueryResultBase.Init(Int32, IEnumerable<QueryParam>) QueryResultBase.GetEnumerator() QueryResultBase.IEnumerable.GetEnumerator() Object.Equals(Object) Object.Equals(Object, Object) Object.GetHashCode() Object.GetType() Object.MemberwiseClone() Object.ReferenceEquals(Object, Object) Object.ToString() Namespace : XData.Database.Adapter Assembly : XData.docfx.dll Syntax public sealed class CallResult : QueryResultBase, IEnumerable<QueryParam>, IEnumerable Constructors | Improve this Doc View Source CallResult(StoredProcedure, IEnumerable<IDataParameter>, IList<DataTable>) Stored procedure call result constructor Declaration public CallResult(StoredProcedure procedure, IEnumerable<IDataParameter> procedureParams, IList<DataTable> resultSets) Parameters Type Name Description StoredProcedure procedure Stored procedure IEnumerable < IDataParameter > procedureParams Procedure parameters IList < DataTable > resultSets Result sets list | Improve this Doc View Source CallResult(StoredProcedure, IEnumerable<QueryParam>, IList<DataTable>) Stored procedure call result constructor Declaration public CallResult(StoredProcedure procedure, IEnumerable<QueryParam> procedureParams, IList<DataTable> resultSets) Parameters Type Name Description StoredProcedure procedure Stored procedure IEnumerable < QueryParam > procedureParams Procedure parameters sequence IList < DataTable > resultSets Result sets list | Improve this Doc View Source CallResult(StoredProcedure, IDataParameterCollection, IList<DataTable>) Stored procedure call result constructor Declaration public CallResult(StoredProcedure procedure, IDataParameterCollection procedureParams, IList<DataTable> resultSets) Parameters Type Name Description StoredProcedure procedure Stored procedure IDataParameterCollection procedureParams Procedure parameters IList < DataTable > resultSets Result sets list Properties | Improve this Doc View Source ResultSets Stored procedure result sets Declaration public ReadOnlyCollection<DataTable> ResultSets { get; } Property Value Type Description ReadOnlyCollection < DataTable > Remarks Hint: Data table name contains result set name Methods | Improve this Doc View Source ParamInit(IDataParameter) Update out parameter value Declaration protected override QueryParam ParamInit(IDataParameter parameter) Parameters Type Name Description IDataParameter parameter Parameter Returns Type Description QueryParam Query parameter Overrides QueryResultBase.ParamInit(IDataParameter) Exceptions Type Condition XDataRuntimeException Implements System.Collections.Generic.IEnumerable<T> System.Collections.IEnumerable Extension Methods SerializationExtensions.ToXml<T>(T) CollectionsExtensions.ToSortedSet<T>(IEnumerable<T>, IComparer<T>) CollectionsExtensions.SetValue<TKey, T>(TKey, T) CollectionsExtensions.AsEnum<T>(T) DataObjectQueryableExtensions.CompareVariable(Object, FilterOperation, String) JoinedEnumerable.Inner<TElement>(IEnumerable<TElement>) JoinedEnumerable.Outer<TElement>(IEnumerable<TElement>) JoinedEnumerable.LeftOuterJoin<TOuter, TInner, TKey, TResult>(IEnumerable<TOuter>, IEnumerable<TInner>, Func<TOuter, TKey>, Func<TInner, TKey>, Func<TOuter, TInner, TResult>, IEqualityComparer<TKey>) JoinedEnumerable.RightOuterJoin<TOuter, TInner, TKey, TResult>(IEnumerable<TOuter>, IEnumerable<TInner>, Func<TOuter, TKey>, Func<TInner, TKey>, Func<TOuter, TInner, TResult>, IEqualityComparer<TKey>) JoinedEnumerable.FullOuterJoin<TOuter, TInner, TKey, TResult>(IEnumerable<TOuter>, IEnumerable<TInner>, Func<TOuter, TKey>, Func<TInner, TKey>, Func<TOuter, TInner, TResult>, IEqualityComparer<TKey>) Processing.Do<T>(T, Action<IProcess<T>>[]) TypeExtensions.TryConvert<T, TResult>(T, Func<T, TResult>) TypeExtensions.TryConvert<T, TResult>(T, Func<T, TResult>, TResult) TypeExtensions.ChangeType<T>(Object) TypeExtensions.ChangeType(Object, Type) TypeExtensions.InvokeMethod<TRet>(Object, Type[], Expression<Func<TRet>>, BindingFlags) TypeExtensions.InvokeMethod(Object, Type[], Expression<Action>, BindingFlags) TypeExtensions.InvokeMethod<TRet>(Object, Expression<Func<TRet>>, BindingFlags) TypeExtensions.InvokeMethod(Object, Expression<Action>, BindingFlags) SqlBlockExtensions.SetExpression<TTag, TResult>(TTag, Expression<Func<IBlockQueryAdapter, TResult>>) QueryDescriptionExtensions.SetExpression<TTag, TResult>(TTag, Expression<Func<IQueryStructureAdapter, TResult>>) QueryDescriptionExtensions.ToDataSet<T>(IEnumerable<T>, String, ISqlBuilder)"
  },
  "api/XData.CurrentObjectChanging-1.html": {
    "href": "api/XData.CurrentObjectChanging-1.html",
    "title": "Delegate CurrentObjectChanging<T> | XData website",
    "keywords": "Delegate CurrentObjectChanging<T> Assigning object as current event delegate type Namespace : XData Assembly : XData.docfx.dll Syntax public delegate bool CurrentObjectChanging<in T>(T obj) where T : class, IDataObject; Parameters Type Name Description T obj Changing is allowed Returns Type Description Boolean Type Parameters Name Description T Object type Extension Methods SerializationExtensions.ToXml<T>(T) CollectionsExtensions.SetValue<TKey, T>(TKey, T) CollectionsExtensions.AsEnum<T>(T) DataObjectQueryableExtensions.CompareVariable(Object, FilterOperation, String) Processing.Do<T>(T, Action<IProcess<T>>[]) TypeExtensions.TryConvert<T, TResult>(T, Func<T, TResult>) TypeExtensions.TryConvert<T, TResult>(T, Func<T, TResult>, TResult) TypeExtensions.ChangeType<T>(Object) TypeExtensions.ChangeType(Object, Type) TypeExtensions.InvokeMethod<TRet>(Object, Type[], Expression<Func<TRet>>, BindingFlags) TypeExtensions.InvokeMethod(Object, Type[], Expression<Action>, BindingFlags) TypeExtensions.InvokeMethod<TRet>(Object, Expression<Func<TRet>>, BindingFlags) TypeExtensions.InvokeMethod(Object, Expression<Action>, BindingFlags) SqlBlockExtensions.SetExpression<TTag, TResult>(TTag, Expression<Func<IBlockQueryAdapter, TResult>>) QueryDescriptionExtensions.SetExpression<TTag, TResult>(TTag, Expression<Func<IQueryStructureAdapter, TResult>>) See Also OnCurrentObjectChanging"
  },
  "api/XData.Calculate-1.html": {
    "href": "api/XData.Calculate-1.html",
    "title": "Delegate Calculate<T> | XData website",
    "keywords": "Delegate Calculate<T> XData LINQ-styled SQL expression delegate type Namespace : XData Assembly : XData.docfx.dll Syntax public delegate T Calculate<out T>(IQueryStructureAdapter adapter); Parameters Type Name Description IQueryStructureAdapter adapter Query structure adapter Returns Type Description T Type Parameters Name Description T Result type Extension Methods SerializationExtensions.ToXml<T>(T) CollectionsExtensions.SetValue<TKey, T>(TKey, T) CollectionsExtensions.AsEnum<T>(T) DataObjectQueryableExtensions.CompareVariable(Object, FilterOperation, String) Processing.Do<T>(T, Action<IProcess<T>>[]) TypeExtensions.TryConvert<T, TResult>(T, Func<T, TResult>) TypeExtensions.TryConvert<T, TResult>(T, Func<T, TResult>, TResult) TypeExtensions.ChangeType<T>(Object) TypeExtensions.ChangeType(Object, Type) TypeExtensions.InvokeMethod<TRet>(Object, Type[], Expression<Func<TRet>>, BindingFlags) TypeExtensions.InvokeMethod(Object, Type[], Expression<Action>, BindingFlags) TypeExtensions.InvokeMethod<TRet>(Object, Expression<Func<TRet>>, BindingFlags) TypeExtensions.InvokeMethod(Object, Expression<Action>, BindingFlags) SqlBlockExtensions.SetExpression<TTag, TResult>(TTag, Expression<Func<IBlockQueryAdapter, TResult>>) QueryDescriptionExtensions.SetExpression<TTag, TResult>(TTag, Expression<Func<IQueryStructureAdapter, TResult>>) See Also SqlExpressionAttribute ExpressionFilterAttribute PropertyExpressionAttribute"
  },
  "api/XData.RuntimeAssemblyLoader.html": {
    "href": "api/XData.RuntimeAssemblyLoader.html",
    "title": "Class RuntimeAssemblyLoader | XData website",
    "keywords": "Class RuntimeAssemblyLoader Inheritance Object AssemblyLoadContext RuntimeAssemblyLoader Inherited Members AssemblyLoadContext.GetAssemblyName(String) AssemblyLoadContext.GetLoadContext(Assembly) AssemblyLoadContext.LoadFromAssemblyName(AssemblyName) AssemblyLoadContext.LoadFromAssemblyPath(String) AssemblyLoadContext.LoadFromNativeImagePath(String, String) AssemblyLoadContext.LoadFromStream(Stream) AssemblyLoadContext.LoadFromStream(Stream, Stream) AssemblyLoadContext.LoadUnmanagedDllFromPath(String) AssemblyLoadContext.SetProfileOptimizationRoot(String) AssemblyLoadContext.StartProfileOptimization(String) AssemblyLoadContext.Default AssemblyLoadContext.Resolving AssemblyLoadContext.Unloading Object.Equals(Object) Object.Equals(Object, Object) Object.GetHashCode() Object.GetType() Object.MemberwiseClone() Object.ReferenceEquals(Object, Object) Object.ToString() Namespace : XData Assembly : XData.docfx.dll Syntax public class RuntimeAssemblyLoader : AssemblyLoadContext Constructors | Improve this Doc View Source RuntimeAssemblyLoader(String) Declaration public RuntimeAssemblyLoader(string folderPath) Parameters Type Name Description String folderPath Methods | Improve this Doc View Source Load(AssemblyName) Declaration protected override Assembly Load(AssemblyName assemblyName) Parameters Type Name Description AssemblyName assemblyName Returns Type Description Assembly Overrides AssemblyLoadContext.Load(AssemblyName) | Improve this Doc View Source LoadUnmanagedDll(String) Declaration protected override IntPtr LoadUnmanagedDll(string unmanagedDllName) Parameters Type Name Description String unmanagedDllName Returns Type Description IntPtr Overrides AssemblyLoadContext.LoadUnmanagedDll(String) Extension Methods SerializationExtensions.ToXml<T>(T) CollectionsExtensions.SetValue<TKey, T>(TKey, T) CollectionsExtensions.AsEnum<T>(T) DataObjectQueryableExtensions.CompareVariable(Object, FilterOperation, String) Processing.Do<T>(T, Action<IProcess<T>>[]) TypeExtensions.TryConvert<T, TResult>(T, Func<T, TResult>) TypeExtensions.TryConvert<T, TResult>(T, Func<T, TResult>, TResult) TypeExtensions.ChangeType<T>(Object) TypeExtensions.ChangeType(Object, Type) TypeExtensions.InvokeMethod<TRet>(Object, Type[], Expression<Func<TRet>>, BindingFlags) TypeExtensions.InvokeMethod(Object, Type[], Expression<Action>, BindingFlags) TypeExtensions.InvokeMethod<TRet>(Object, Expression<Func<TRet>>, BindingFlags) TypeExtensions.InvokeMethod(Object, Expression<Action>, BindingFlags) SqlBlockExtensions.SetExpression<TTag, TResult>(TTag, Expression<Func<IBlockQueryAdapter, TResult>>) QueryDescriptionExtensions.SetExpression<TTag, TResult>(TTag, Expression<Func<IQueryStructureAdapter, TResult>>)"
  },
  "api/XData.ResultSetIndexer.html": {
    "href": "api/XData.ResultSetIndexer.html",
    "title": "Class ResultSetIndexer | XData website",
    "keywords": "Class ResultSetIndexer SQL procedure call out result sets indexer Inheritance Object ResultSetIndexer Inherited Members Object.Equals(Object) Object.Equals(Object, Object) Object.GetHashCode() Object.GetType() Object.MemberwiseClone() Object.ReferenceEquals(Object, Object) Object.ToString() Namespace : XData Assembly : XData.docfx.dll Syntax public sealed class ResultSetIndexer Properties | Improve this Doc View Source Count Variables count Declaration public int Count { get; } Property Value Type Description Int32 | Improve this Doc View Source Item[String] Result set data rows Declaration public DataTable this[string name] { get; } Parameters Type Name Description String name Result set name Property Value Type Description DataTable Methods | Improve this Doc View Source Contains(String) Variables contains name Declaration public bool Contains(string name) Parameters Type Name Description String name Variable name Returns Type Description Boolean Contains flag | Improve this Doc View Source GetResultSet<T>(String) Returns typed result collection Declaration public IEnumerable<T> GetResultSet<T>(string name) where T : class Parameters Type Name Description String name Result set name Returns Type Description IEnumerable <T> Types result collection Type Parameters Name Description T Result set element mapped type Extension Methods SerializationExtensions.ToXml<T>(T) CollectionsExtensions.SetValue<TKey, T>(TKey, T) CollectionsExtensions.AsEnum<T>(T) DataObjectQueryableExtensions.CompareVariable(Object, FilterOperation, String) Processing.Do<T>(T, Action<IProcess<T>>[]) TypeExtensions.TryConvert<T, TResult>(T, Func<T, TResult>) TypeExtensions.TryConvert<T, TResult>(T, Func<T, TResult>, TResult) TypeExtensions.ChangeType<T>(Object) TypeExtensions.ChangeType(Object, Type) TypeExtensions.InvokeMethod<TRet>(Object, Type[], Expression<Func<TRet>>, BindingFlags) TypeExtensions.InvokeMethod(Object, Type[], Expression<Action>, BindingFlags) TypeExtensions.InvokeMethod<TRet>(Object, Expression<Func<TRet>>, BindingFlags) TypeExtensions.InvokeMethod(Object, Expression<Action>, BindingFlags) SqlBlockExtensions.SetExpression<TTag, TResult>(TTag, Expression<Func<IBlockQueryAdapter, TResult>>) QueryDescriptionExtensions.SetExpression<TTag, TResult>(TTag, Expression<Func<IQueryStructureAdapter, TResult>>)"
  },
  "api/XData.RepositoryTrigger-1.html": {
    "href": "api/XData.RepositoryTrigger-1.html",
    "title": "Delegate RepositoryTrigger<T> | XData website",
    "keywords": "Delegate RepositoryTrigger<T> RepositoryTrigger logic delegate type Namespace : XData Assembly : XData.docfx.dll Syntax public delegate bool RepositoryTrigger<T>(IRepository<T> repository, ref DataTriggerFlag flag) where T : class, IDataObject; Parameters Type Name Description IRepository <T> repository Repository DataTriggerFlag flag Trigger routing flag Returns Type Description Boolean Success flag Type Parameters Name Description T Object type Extension Methods SerializationExtensions.ToXml<T>(T) CollectionsExtensions.SetValue<TKey, T>(TKey, T) CollectionsExtensions.AsEnum<T>(T) DataObjectQueryableExtensions.CompareVariable(Object, FilterOperation, String) Processing.Do<T>(T, Action<IProcess<T>>[]) TypeExtensions.TryConvert<T, TResult>(T, Func<T, TResult>) TypeExtensions.TryConvert<T, TResult>(T, Func<T, TResult>, TResult) TypeExtensions.ChangeType<T>(Object) TypeExtensions.ChangeType(Object, Type) TypeExtensions.InvokeMethod<TRet>(Object, Type[], Expression<Func<TRet>>, BindingFlags) TypeExtensions.InvokeMethod(Object, Type[], Expression<Action>, BindingFlags) TypeExtensions.InvokeMethod<TRet>(Object, Expression<Func<TRet>>, BindingFlags) TypeExtensions.InvokeMethod(Object, Expression<Action>, BindingFlags) SqlBlockExtensions.SetExpression<TTag, TResult>(TTag, Expression<Func<IBlockQueryAdapter, TResult>>) QueryDescriptionExtensions.SetExpression<TTag, TResult>(TTag, Expression<Func<IQueryStructureAdapter, TResult>>) See Also BeforeClear AfterClear"
  },
  "api/XData.RepositoryIndexer.html": {
    "href": "api/XData.RepositoryIndexer.html",
    "title": "Class RepositoryIndexer | XData website",
    "keywords": "Class RepositoryIndexer Data object links (parents and childs) indexer Inheritance Object RepositoryIndexer Implements IEnumerable < IRepository > IEnumerable Inherited Members Object.Equals(Object) Object.Equals(Object, Object) Object.GetHashCode() Object.GetType() Object.MemberwiseClone() Object.ReferenceEquals(Object, Object) Object.ToString() Namespace : XData Assembly : XData.docfx.dll Syntax public sealed class RepositoryIndexer : IEnumerable<IRepository>, IEnumerable Properties | Improve this Doc View Source Count Indexer count Declaration public int Count { get; } Property Value Type Description Int32 | Improve this Doc View Source Item[String] Repository indexer Declaration public IRepository this[string alias] { get; } Parameters Type Name Description String alias Repository alias Property Value Type Description IRepository Methods | Improve this Doc View Source Contains(String) Indexer contains repository by alias Declaration public bool Contains(string alias) Parameters Type Name Description String alias Repository alias Returns Type Description Boolean Contains flag | Improve this Doc View Source GetEnumerator() Returns an enumerator that iterates through the collection. Declaration public IEnumerator<IRepository> GetEnumerator() Returns Type Description IEnumerator < IRepository > A IEnumerator<T> that can be used to iterate through the collection. Explicit Interface Implementations | Improve this Doc View Source IEnumerable.GetEnumerator() Returns an enumerator that iterates through a collection. Declaration IEnumerator IEnumerable.GetEnumerator() Returns Type Description IEnumerator An IEnumerator object that can be used to iterate through the collection. Implements System.Collections.Generic.IEnumerable<T> System.Collections.IEnumerable Extension Methods SerializationExtensions.ToXml<T>(T) CollectionsExtensions.ToSortedSet<T>(IEnumerable<T>, IComparer<T>) CollectionsExtensions.SetValue<TKey, T>(TKey, T) CollectionsExtensions.AsEnum<T>(T) DataObjectQueryableExtensions.CompareVariable(Object, FilterOperation, String) JoinedEnumerable.Inner<TElement>(IEnumerable<TElement>) JoinedEnumerable.Outer<TElement>(IEnumerable<TElement>) JoinedEnumerable.LeftOuterJoin<TOuter, TInner, TKey, TResult>(IEnumerable<TOuter>, IEnumerable<TInner>, Func<TOuter, TKey>, Func<TInner, TKey>, Func<TOuter, TInner, TResult>, IEqualityComparer<TKey>) JoinedEnumerable.RightOuterJoin<TOuter, TInner, TKey, TResult>(IEnumerable<TOuter>, IEnumerable<TInner>, Func<TOuter, TKey>, Func<TInner, TKey>, Func<TOuter, TInner, TResult>, IEqualityComparer<TKey>) JoinedEnumerable.FullOuterJoin<TOuter, TInner, TKey, TResult>(IEnumerable<TOuter>, IEnumerable<TInner>, Func<TOuter, TKey>, Func<TInner, TKey>, Func<TOuter, TInner, TResult>, IEqualityComparer<TKey>) Processing.Do<T>(T, Action<IProcess<T>>[]) TypeExtensions.TryConvert<T, TResult>(T, Func<T, TResult>) TypeExtensions.TryConvert<T, TResult>(T, Func<T, TResult>, TResult) TypeExtensions.ChangeType<T>(Object) TypeExtensions.ChangeType(Object, Type) TypeExtensions.InvokeMethod<TRet>(Object, Type[], Expression<Func<TRet>>, BindingFlags) TypeExtensions.InvokeMethod(Object, Type[], Expression<Action>, BindingFlags) TypeExtensions.InvokeMethod<TRet>(Object, Expression<Func<TRet>>, BindingFlags) TypeExtensions.InvokeMethod(Object, Expression<Action>, BindingFlags) SqlBlockExtensions.SetExpression<TTag, TResult>(TTag, Expression<Func<IBlockQueryAdapter, TResult>>) QueryDescriptionExtensions.SetExpression<TTag, TResult>(TTag, Expression<Func<IQueryStructureAdapter, TResult>>) QueryDescriptionExtensions.ToDataSet<T>(IEnumerable<T>, String, ISqlBuilder)"
  },
  "api/XData.Mapping.LinkAttribute.html": {
    "href": "api/XData.Mapping.LinkAttribute.html",
    "title": "Class LinkAttribute | XData website",
    "keywords": "Class LinkAttribute Base link attribute Inheritance Object Attribute FilterBaseAttribute FilterAttribute OptionalFilterAttribute LinkAttribute Inherited Members OptionalFilterAttribute.PrimaryFilter FilterAttribute.Source FilterAttribute.FieldName FilterAttribute.Operation FilterAttribute.Combination Attribute.Equals(Object) Attribute.GetCustomAttribute(Assembly, Type) Attribute.GetCustomAttribute(Assembly, Type, Boolean) Attribute.GetCustomAttribute(MemberInfo, Type) Attribute.GetCustomAttribute(MemberInfo, Type, Boolean) Attribute.GetCustomAttribute(Module, Type) Attribute.GetCustomAttribute(Module, Type, Boolean) Attribute.GetCustomAttribute(ParameterInfo, Type) Attribute.GetCustomAttribute(ParameterInfo, Type, Boolean) Attribute.GetCustomAttributes(Assembly) Attribute.GetCustomAttributes(Assembly, Boolean) Attribute.GetCustomAttributes(Assembly, Type) Attribute.GetCustomAttributes(Assembly, Type, Boolean) Attribute.GetCustomAttributes(MemberInfo) Attribute.GetCustomAttributes(MemberInfo, Boolean) Attribute.GetCustomAttributes(MemberInfo, Type) Attribute.GetCustomAttributes(MemberInfo, Type, Boolean) Attribute.GetCustomAttributes(Module) Attribute.GetCustomAttributes(Module, Boolean) Attribute.GetCustomAttributes(Module, Type) Attribute.GetCustomAttributes(Module, Type, Boolean) Attribute.GetCustomAttributes(ParameterInfo) Attribute.GetCustomAttributes(ParameterInfo, Boolean) Attribute.GetCustomAttributes(ParameterInfo, Type) Attribute.GetCustomAttributes(ParameterInfo, Type, Boolean) Attribute.GetHashCode() Attribute.IsDefaultAttribute() Attribute.IsDefined(Assembly, Type) Attribute.IsDefined(Assembly, Type, Boolean) Attribute.IsDefined(MemberInfo, Type) Attribute.IsDefined(MemberInfo, Type, Boolean) Attribute.IsDefined(Module, Type) Attribute.IsDefined(Module, Type, Boolean) Attribute.IsDefined(ParameterInfo, Type) Attribute.IsDefined(ParameterInfo, Type, Boolean) Attribute.Match(Object) Object.Equals(Object, Object) Object.GetType() Object.MemberwiseClone() Object.ReferenceEquals(Object, Object) Object.ToString() Namespace : XData.Mapping Assembly : XData.docfx.dll Syntax [AttributeUsage(AttributeTargets.Class, AllowMultiple = true)] public sealed class LinkAttribute : OptionalFilterAttribute Constructors | Improve this Doc View Source LinkAttribute(String, String, String, String) Base link attribute constructor Declaration public LinkAttribute(string linkedSource, string linkedFieldName, string source, string fieldName = \"\") Parameters Type Name Description String linkedSource Secondary source alias String linkedFieldName Secondary field name String source Primary source alias String fieldName Primary field name Exceptions Type Condition XDataRuntimeException Secondary source alias cannot be null or empty string XDataRuntimeException Secondary field name cannot be null or empty string Properties | Improve this Doc View Source FilterType Filter type Declaration public override FilterType FilterType { get; } Property Value Type Description FilterType Link Overrides FilterBaseAttribute.FilterType | Improve this Doc View Source LinkedFieldName Secondary field name Declaration public string LinkedFieldName { get; } Property Value Type Description String | Improve this Doc View Source LinkedSourceAlias Secondary source alias Declaration public string LinkedSourceAlias { get; } Property Value Type Description String | Improve this Doc View Source TypeId When implemented in a derived class, gets a unique identifier for this Attribute . Declaration public override object TypeId { get; } Property Value Type Description Object An Object that is a unique identifier for the attribute. Overrides Attribute.TypeId Extension Methods SerializationExtensions.ToXml<T>(T) CollectionsExtensions.SetValue<TKey, T>(TKey, T) CollectionsExtensions.AsEnum<T>(T) DataObjectQueryableExtensions.CompareVariable(Object, FilterOperation, String) Processing.Do<T>(T, Action<IProcess<T>>[]) TypeExtensions.TryConvert<T, TResult>(T, Func<T, TResult>) TypeExtensions.TryConvert<T, TResult>(T, Func<T, TResult>, TResult) TypeExtensions.ChangeType<T>(Object) TypeExtensions.ChangeType(Object, Type) TypeExtensions.InvokeMethod<TRet>(Object, Type[], Expression<Func<TRet>>, BindingFlags) TypeExtensions.InvokeMethod(Object, Type[], Expression<Action>, BindingFlags) TypeExtensions.InvokeMethod<TRet>(Object, Expression<Func<TRet>>, BindingFlags) TypeExtensions.InvokeMethod(Object, Expression<Action>, BindingFlags) SqlBlockExtensions.SetExpression<TTag, TResult>(TTag, Expression<Func<IBlockQueryAdapter, TResult>>) QueryDescriptionExtensions.SetExpression<TTag, TResult>(TTag, Expression<Func<IQueryStructureAdapter, TResult>>) See Also LinkAttribute OptionalFilterAttribute"
  },
  "api/XData.Mapping.Link-2.html": {
    "href": "api/XData.Mapping.Link-2.html",
    "title": "Class Link<TVal, TSrc> | XData website",
    "keywords": "Class Link<TVal, TSrc> Dictionary link wrapper Inheritance Object Link<TVal, TSrc> Inherited Members Object.Equals(Object) Object.Equals(Object, Object) Object.GetHashCode() Object.GetType() Object.MemberwiseClone() Object.ReferenceEquals(Object, Object) Object.ToString() Namespace : XData.Mapping Assembly : XData.docfx.dll Syntax public abstract class Link<TVal, TSrc> : ILink where TVal : IComparable<TVal> where TSrc : class, IDataObject, new() Type Parameters Name Description TVal Link value type TSrc Link source type Examples // declaration [Property(\"name\", \"S\"), DictionaryProperty(\"Name\", \"DocState\"), DictionaryProperty(\"Code\", \"DocStateCode\")] public Link<string, DocState> DocState { get; set; } // using newInvoice.DocState += dataScope.GetDictionaryValue<DocState>(x => x.Code == \"CREATED\"); // is the same as newInvoice.DocState.Source = dataScope.GetDictionaryValue<DocState>(x => x.Code == \"CREATED\"); Properties | Improve this Doc View Source Source Dictionary source data object Declaration public abstract TSrc Source { set; } Property Value Type Description TSrc | Improve this Doc View Source Value Dictionary value Declaration public TVal Value { get; protected set; } Property Value Type Description TVal Methods | Improve this Doc View Source IsNull() Check link for null value Declaration public bool IsNull() Returns Type Description Boolean Link is null | Improve this Doc View Source Key<TKey>(String) Declaration public abstract TKey Key<TKey>(string keyProperty) Parameters Type Name Description String keyProperty Returns Type Description TKey Type Parameters Name Description TKey Operators | Improve this Doc View Source Addition(Link<TVal, TSrc>, TSrc) Set link source Declaration public static Link<TVal, TSrc> operator +(Link<TVal, TSrc> link, TSrc source) Parameters Type Name Description Link <TVal, TSrc> link Link TSrc source Link source Returns Type Description Link <TVal, TSrc> Updated link | Improve this Doc View Source Implicit(Link<TVal, TSrc> to TVal) Implicitly returns dictionary value Declaration public static implicit operator TVal(Link<TVal, TSrc> val) Parameters Type Name Description Link <TVal, TSrc> val Dictionary property Returns Type Description TVal Value Extension Methods SerializationExtensions.ToXml<T>(T) CollectionsExtensions.SetValue<TKey, T>(TKey, T) CollectionsExtensions.AsEnum<T>(T) DataObjectQueryableExtensions.CompareVariable(Object, FilterOperation, String) Processing.Do<T>(T, Action<IProcess<T>>[]) TypeExtensions.TryConvert<T, TResult>(T, Func<T, TResult>) TypeExtensions.TryConvert<T, TResult>(T, Func<T, TResult>, TResult) TypeExtensions.ChangeType<T>(Object) TypeExtensions.ChangeType(Object, Type) TypeExtensions.InvokeMethod<TRet>(Object, Type[], Expression<Func<TRet>>, BindingFlags) TypeExtensions.InvokeMethod(Object, Type[], Expression<Action>, BindingFlags) TypeExtensions.InvokeMethod<TRet>(Object, Expression<Func<TRet>>, BindingFlags) TypeExtensions.InvokeMethod(Object, Expression<Action>, BindingFlags) SqlBlockExtensions.SetExpression<TTag, TResult>(TTag, Expression<Func<IBlockQueryAdapter, TResult>>) QueryDescriptionExtensions.SetExpression<TTag, TResult>(TTag, Expression<Func<IQueryStructureAdapter, TResult>>) See Also LinkPropertyAttribute Value Source Addition(Link<TVal, TSrc>, TSrc) Implicit(Link<TVal, TSrc> to TVal) GetDictionaryValue<T>(Expression<Func<T, Boolean>>, String, ISecuritySession, Variable[]) IsNull()"
  },
  "api/XData.Mapping.InnerViewAttribute.html": {
    "href": "api/XData.Mapping.InnerViewAttribute.html",
    "title": "Class InnerViewAttribute | XData website",
    "keywords": "Class InnerViewAttribute Data object inner view attribute Inheritance Object Attribute DataSourceAttribute InnerViewAttribute Inherited Members Attribute.Equals(Object) Attribute.GetCustomAttribute(Assembly, Type) Attribute.GetCustomAttribute(Assembly, Type, Boolean) Attribute.GetCustomAttribute(MemberInfo, Type) Attribute.GetCustomAttribute(MemberInfo, Type, Boolean) Attribute.GetCustomAttribute(Module, Type) Attribute.GetCustomAttribute(Module, Type, Boolean) Attribute.GetCustomAttribute(ParameterInfo, Type) Attribute.GetCustomAttribute(ParameterInfo, Type, Boolean) Attribute.GetCustomAttributes(Assembly) Attribute.GetCustomAttributes(Assembly, Boolean) Attribute.GetCustomAttributes(Assembly, Type) Attribute.GetCustomAttributes(Assembly, Type, Boolean) Attribute.GetCustomAttributes(MemberInfo) Attribute.GetCustomAttributes(MemberInfo, Boolean) Attribute.GetCustomAttributes(MemberInfo, Type) Attribute.GetCustomAttributes(MemberInfo, Type, Boolean) Attribute.GetCustomAttributes(Module) Attribute.GetCustomAttributes(Module, Boolean) Attribute.GetCustomAttributes(Module, Type) Attribute.GetCustomAttributes(Module, Type, Boolean) Attribute.GetCustomAttributes(ParameterInfo) Attribute.GetCustomAttributes(ParameterInfo, Boolean) Attribute.GetCustomAttributes(ParameterInfo, Type) Attribute.GetCustomAttributes(ParameterInfo, Type, Boolean) Attribute.GetHashCode() Attribute.IsDefaultAttribute() Attribute.IsDefined(Assembly, Type) Attribute.IsDefined(Assembly, Type, Boolean) Attribute.IsDefined(MemberInfo, Type) Attribute.IsDefined(MemberInfo, Type, Boolean) Attribute.IsDefined(Module, Type) Attribute.IsDefined(Module, Type, Boolean) Attribute.IsDefined(ParameterInfo, Type) Attribute.IsDefined(ParameterInfo, Type, Boolean) Attribute.Match(Object) Object.Equals(Object, Object) Object.GetType() Object.MemberwiseClone() Object.ReferenceEquals(Object, Object) Object.ToString() Namespace : XData.Mapping Assembly : XData.docfx.dll Syntax [AttributeUsage(AttributeTargets.Class, AllowMultiple = true)] public sealed class InnerViewAttribute : DataSourceAttribute Examples InnerView(\"H\", typeof(DocLastChange)) Constructors | Improve this Doc View Source InnerViewAttribute(String, Type) Data object inner view attribute Declaration public InnerViewAttribute(string alias, Type innerViewType) Parameters Type Name Description String alias Inner view alias Type innerViewType Object type represents inner view structure Exceptions Type Condition XDataRuntimeException Inner view alias cannot be null or empty string XDataRuntimeException Object type represents inner view structure cannot be null Properties | Improve this Doc View Source Alias Inner view alias Declaration public override string Alias { get; protected set; } Property Value Type Description String Overrides DataSourceAttribute.Alias | Improve this Doc View Source InnerViewType Object type represents inner view structure Declaration public Type InnerViewType { get; } Property Value Type Description Type | Improve this Doc View Source Type Source type Declaration public override DataSourceType Type { get; } Property Value Type Description DataSourceType InnerView Overrides DataSourceAttribute.Type | Improve this Doc View Source TypeId When implemented in a derived class, gets a unique identifier for this Attribute . Declaration public override object TypeId { get; } Property Value Type Description Object An Object that is a unique identifier for the attribute. Overrides Attribute.TypeId Extension Methods SerializationExtensions.ToXml<T>(T) CollectionsExtensions.SetValue<TKey, T>(TKey, T) CollectionsExtensions.AsEnum<T>(T) DataObjectQueryableExtensions.CompareVariable(Object, FilterOperation, String) Processing.Do<T>(T, Action<IProcess<T>>[]) TypeExtensions.TryConvert<T, TResult>(T, Func<T, TResult>) TypeExtensions.TryConvert<T, TResult>(T, Func<T, TResult>, TResult) TypeExtensions.ChangeType<T>(Object) TypeExtensions.ChangeType(Object, Type) TypeExtensions.InvokeMethod<TRet>(Object, Type[], Expression<Func<TRet>>, BindingFlags) TypeExtensions.InvokeMethod(Object, Type[], Expression<Action>, BindingFlags) TypeExtensions.InvokeMethod<TRet>(Object, Expression<Func<TRet>>, BindingFlags) TypeExtensions.InvokeMethod(Object, Expression<Action>, BindingFlags) SqlBlockExtensions.SetExpression<TTag, TResult>(TTag, Expression<Func<IBlockQueryAdapter, TResult>>) QueryDescriptionExtensions.SetExpression<TTag, TResult>(TTag, Expression<Func<IQueryStructureAdapter, TResult>>) See Also DataTableAttribute SubqueryAttribute SubqueryLinkAttribute"
  },
  "api/XData.Async.html": {
    "href": "api/XData.Async.html",
    "title": "Namespace XData.Async | XData website",
    "keywords": "Namespace XData.Async Classes AsyncExtensions"
  },
  "api/XData.Mapping.Dynamic.IStructureFlag.html": {
    "href": "api/XData.Mapping.Dynamic.IStructureFlag.html",
    "title": "Interface IStructureFlag | XData website",
    "keywords": "Interface IStructureFlag Dynamic structure flag interface Namespace : XData.Mapping.Dynamic Assembly : XData.docfx.dll Syntax public interface IStructureFlag Extension Methods SerializationExtensions.ToXml<T>(T) CollectionsExtensions.SetValue<TKey, T>(TKey, T) CollectionsExtensions.AsEnum<T>(T) DataObjectQueryableExtensions.CompareVariable(Object, FilterOperation, String) Processing.Do<T>(T, Action<IProcess<T>>[]) TypeExtensions.TryConvert<T, TResult>(T, Func<T, TResult>) TypeExtensions.TryConvert<T, TResult>(T, Func<T, TResult>, TResult) TypeExtensions.ChangeType<T>(Object) TypeExtensions.ChangeType(Object, Type) TypeExtensions.InvokeMethod<TRet>(Object, Type[], Expression<Func<TRet>>, BindingFlags) TypeExtensions.InvokeMethod(Object, Type[], Expression<Action>, BindingFlags) TypeExtensions.InvokeMethod<TRet>(Object, Expression<Func<TRet>>, BindingFlags) TypeExtensions.InvokeMethod(Object, Expression<Action>, BindingFlags) SqlBlockExtensions.SetExpression<TTag, TResult>(TTag, Expression<Func<IBlockQueryAdapter, TResult>>) QueryDescriptionExtensions.SetExpression<TTag, TResult>(TTag, Expression<Func<IQueryStructureAdapter, TResult>>)"
  },
  "api/XData.Mapping.Dynamic.IResultSetDescription.html": {
    "href": "api/XData.Mapping.Dynamic.IResultSetDescription.html",
    "title": "Interface IResultSetDescription | XData website",
    "keywords": "Interface IResultSetDescription Dynamic stored procedure result set description Namespace : XData.Mapping.Dynamic Assembly : XData.docfx.dll Syntax public interface IResultSetDescription Properties | Improve this Doc View Source Alias Stored procedure alias Declaration string Alias { get; } Property Value Type Description String | Improve this Doc View Source Name Result set name Declaration string Name { get; } Property Value Type Description String | Improve this Doc View Source Order Result set order Declaration int Order { get; } Property Value Type Description Int32 Methods | Improve this Doc View Source Clone() Clone result set description Declaration IResultSetDescription Clone() Returns Type Description IResultSetDescription Extension Methods SerializationExtensions.ToXml<T>(T) CollectionsExtensions.SetValue<TKey, T>(TKey, T) CollectionsExtensions.AsEnum<T>(T) DataObjectQueryableExtensions.CompareVariable(Object, FilterOperation, String) Processing.Do<T>(T, Action<IProcess<T>>[]) TypeExtensions.TryConvert<T, TResult>(T, Func<T, TResult>) TypeExtensions.TryConvert<T, TResult>(T, Func<T, TResult>, TResult) TypeExtensions.ChangeType<T>(Object) TypeExtensions.ChangeType(Object, Type) TypeExtensions.InvokeMethod<TRet>(Object, Type[], Expression<Func<TRet>>, BindingFlags) TypeExtensions.InvokeMethod(Object, Type[], Expression<Action>, BindingFlags) TypeExtensions.InvokeMethod<TRet>(Object, Expression<Func<TRet>>, BindingFlags) TypeExtensions.InvokeMethod(Object, Expression<Action>, BindingFlags) SqlBlockExtensions.SetExpression<TTag, TResult>(TTag, Expression<Func<IBlockQueryAdapter, TResult>>) QueryDescriptionExtensions.SetExpression<TTag, TResult>(TTag, Expression<Func<IQueryStructureAdapter, TResult>>) See Also Return<T>(String, String, Int32, Expression<Func<IQueryStructureAdapter, T>>)"
  },
  "api/XData.DataSource.Structure.ITempTable.html": {
    "href": "api/XData.DataSource.Structure.ITempTable.html",
    "title": "Interface ITempTable | XData website",
    "keywords": "Interface ITempTable Inherited Members ITableLike.Name ITableLike.Fields IDataSource.SourceType IDataSource.Alias IDataSource.IsBase IDataSource.GetFields() IDataSource.GetFields(Type) IDataSource.GetField(String, String, String) IDataSource.GetField(String, String, String, String) ICloneable.Clone() Namespace : XData.DataSource.Structure Assembly : XData.docfx.dll Syntax public interface ITempTable : ITableLike, IDataSource, ICloneable Extension Methods SerializationExtensions.ToXml<T>(T) CollectionsExtensions.SetValue<TKey, T>(TKey, T) CollectionsExtensions.AsEnum<T>(T) DataObjectQueryableExtensions.CompareVariable(Object, FilterOperation, String) Processing.Do<T>(T, Action<IProcess<T>>[]) TypeExtensions.TryConvert<T, TResult>(T, Func<T, TResult>) TypeExtensions.TryConvert<T, TResult>(T, Func<T, TResult>, TResult) TypeExtensions.ChangeType<T>(Object) TypeExtensions.ChangeType(Object, Type) TypeExtensions.InvokeMethod<TRet>(Object, Type[], Expression<Func<TRet>>, BindingFlags) TypeExtensions.InvokeMethod(Object, Type[], Expression<Action>, BindingFlags) TypeExtensions.InvokeMethod<TRet>(Object, Expression<Func<TRet>>, BindingFlags) TypeExtensions.InvokeMethod(Object, Expression<Action>, BindingFlags) SqlBlockExtensions.SetExpression<TTag, TResult>(TTag, Expression<Func<IBlockQueryAdapter, TResult>>) QueryDescriptionExtensions.SetExpression<TTag, TResult>(TTag, Expression<Func<IQueryStructureAdapter, TResult>>)"
  },
  "api/XData.DataSource.Structure.IExternalLink.html": {
    "href": "api/XData.DataSource.Structure.IExternalLink.html",
    "title": "Interface IExternalLink | XData website",
    "keywords": "Interface IExternalLink External link interface Inherited Members ICloneable.Clone() Namespace : XData.DataSource.Structure Assembly : XData.docfx.dll Syntax public interface IExternalLink : ICloneable Properties | Improve this Doc View Source ChildLinkType Child link type Declaration Type ChildLinkType { get; } Property Value Type Description Type | Improve this Doc View Source ChildProperty Child property Declaration string ChildProperty { get; } Property Value Type Description String | Improve this Doc View Source ChildType Child type Declaration Type ChildType { get; } Property Value Type Description Type | Improve this Doc View Source Combination Filter combination name Declaration string Combination { get; } Property Value Type Description String | Improve this Doc View Source DirectLink Direct link flag Declaration bool DirectLink { get; } Property Value Type Description Boolean | Improve this Doc View Source FilterName Filter name Declaration string FilterName { get; } Property Value Type Description String | Improve this Doc View Source MasterRefresh Master refresh flag Declaration bool MasterRefresh { get; } Property Value Type Description Boolean | Improve this Doc View Source Nullable Null value handling Declaration FilterNullable Nullable { get; } Property Value Type Description FilterNullable | Improve this Doc View Source Operation Filter operation Declaration FilterOperation Operation { get; } Property Value Type Description FilterOperation | Improve this Doc View Source PrimaryFilter Primary filter flag Declaration bool PrimaryFilter { get; } Property Value Type Description Boolean | Improve this Doc View Source PropertyName Property name Declaration string PropertyName { get; } Property Value Type Description String | Improve this Doc View Source TreeFilter Tree filter flag Declaration bool TreeFilter { get; } Property Value Type Description Boolean Extension Methods SerializationExtensions.ToXml<T>(T) CollectionsExtensions.SetValue<TKey, T>(TKey, T) CollectionsExtensions.AsEnum<T>(T) DataObjectQueryableExtensions.CompareVariable(Object, FilterOperation, String) Processing.Do<T>(T, Action<IProcess<T>>[]) TypeExtensions.TryConvert<T, TResult>(T, Func<T, TResult>) TypeExtensions.TryConvert<T, TResult>(T, Func<T, TResult>, TResult) TypeExtensions.ChangeType<T>(Object) TypeExtensions.ChangeType(Object, Type) TypeExtensions.InvokeMethod<TRet>(Object, Type[], Expression<Func<TRet>>, BindingFlags) TypeExtensions.InvokeMethod(Object, Type[], Expression<Action>, BindingFlags) TypeExtensions.InvokeMethod<TRet>(Object, Expression<Func<TRet>>, BindingFlags) TypeExtensions.InvokeMethod(Object, Expression<Action>, BindingFlags) SqlBlockExtensions.SetExpression<TTag, TResult>(TTag, Expression<Func<IBlockQueryAdapter, TResult>>) QueryDescriptionExtensions.SetExpression<TTag, TResult>(TTag, Expression<Func<IQueryStructureAdapter, TResult>>)"
  },
  "api/XData.DataSource.Structure.Field.html": {
    "href": "api/XData.DataSource.Structure.Field.html",
    "title": "Class Field | XData website",
    "keywords": "Class Field Field object Inheritance Object Field Implements IField ICloneable Inherited Members Object.Equals(Object) Object.Equals(Object, Object) Object.GetHashCode() Object.GetType() Object.MemberwiseClone() Object.ReferenceEquals(Object, Object) Object.ToString() Namespace : XData.DataSource.Structure Assembly : XData.docfx.dll Syntax [Serializable] [DataContract] public class Field : IField, ICloneable Properties | Improve this Doc View Source DefaultFeature Always use the default value (also when updating) Declaration [DataMember] public DefaultFeature DefaultFeature { get; set; } Property Value Type Description DefaultFeature | Improve this Doc View Source DefaultType Default source Declaration [DataMember] public DefaultType DefaultType { get; set; } Property Value Type Description DefaultType | Improve this Doc View Source DefaultValue Default value Declaration [DataMember] public object DefaultValue { get; set; } Property Value Type Description Object | Improve this Doc View Source EnumValues Enumeration values Declaration [DataMember] public KeyValuePair<long, string>[] EnumValues { get; set; } Property Value Type Description KeyValuePair < Int64 , String >[] | Improve this Doc View Source Exists Exists operation Declaration [DataMember] public ExistsOperation Exists { get; set; } Property Value Type Description ExistsOperation | Improve this Doc View Source ExprScale Expression scale Declaration [DataMember] public int ExprScale { get; set; } Property Value Type Description Int32 | Improve this Doc View Source ExprSize Expression size Declaration [DataMember] public int ExprSize { get; set; } Property Value Type Description Int32 | Improve this Doc View Source ExprText Expression text Declaration [DataMember] public string ExprText { get; set; } Property Value Type Description String | Improve this Doc View Source ExprType Expression type Declaration [DataMember] public DataExpressionType ExprType { get; set; } Property Value Type Description DataExpressionType | Improve this Doc View Source FieldName Field name Declaration [DataMember] public string FieldName { get; set; } Property Value Type Description String | Improve this Doc View Source Flags Flags Declaration [DataMember] public DataPropertyFlag Flags { get; set; } Property Value Type Description DataPropertyFlag | Improve this Doc View Source IsArray User defined type (UDT) collection is VARARRAY for field Declaration public bool IsArray { get; set; } Property Value Type Description Boolean | Improve this Doc View Source IsAutoIncrement Autoincrement field flag Declaration [DataMember] public bool IsAutoIncrement { get; set; } Property Value Type Description Boolean | Improve this Doc View Source IsSelectable Selectable flag Declaration [DataMember] public bool IsSelectable { get; set; } Property Value Type Description Boolean | Improve this Doc View Source IsTablePk Table primary key flag Declaration [DataMember] public bool IsTablePk { get; set; } Property Value Type Description Boolean | Improve this Doc View Source Name Property name Declaration [DataMember] public string Name { get; set; } Property Value Type Description String | Improve this Doc View Source NativeSqlType Native SQL type name Declaration [DataMember] public string NativeSqlType { get; set; } Property Value Type Description String Remarks Used to specify native SQL column type when conflicted with default type mapping WARNING! May be not supported by database adapter! | Improve this Doc View Source SqlType Sql type Declaration [DataMember] public DbType SqlType { get; set; } Property Value Type Description DbType | Improve this Doc View Source UdtElementTypeName User defined type (UDT) element type name for field Declaration [DataMember] public string UdtElementTypeName { get; set; } Property Value Type Description String | Improve this Doc View Source UdtMappedType User defined type (UDT) mapped type for field Declaration [DataMember] public Type UdtMappedType { get; set; } Property Value Type Description Type | Improve this Doc View Source UdtTypeName User defined type (UDT) name for field Declaration [DataMember] public string UdtTypeName { get; set; } Property Value Type Description String | Improve this Doc View Source UpdateWithExprText Update source expression text Declaration [DataMember] public string UpdateWithExprText { get; set; } Property Value Type Description String | Improve this Doc View Source UpdateWithExprType Update source expression type Declaration [DataMember] public DataExpressionType UpdateWithExprType { get; set; } Property Value Type Description DataExpressionType | Improve this Doc View Source XPath XML field value XPath Declaration [DataMember] public string XPath { get; set; } Property Value Type Description String Remarks Used to specify native SQL column type when conflicted with default type mapping WARNING! May be not supported by database adapter! Methods | Improve this Doc View Source Clone() Creates a new object that is a copy of the current instance. Declaration public object Clone() Returns Type Description Object A new object that is a copy of this instance. Implements IField System.ICloneable Extension Methods SerializationExtensions.ToXml<T>(T) CollectionsExtensions.SetValue<TKey, T>(TKey, T) CollectionsExtensions.AsEnum<T>(T) DataObjectQueryableExtensions.CompareVariable(Object, FilterOperation, String) Processing.Do<T>(T, Action<IProcess<T>>[]) TypeExtensions.TryConvert<T, TResult>(T, Func<T, TResult>) TypeExtensions.TryConvert<T, TResult>(T, Func<T, TResult>, TResult) TypeExtensions.ChangeType<T>(Object) TypeExtensions.ChangeType(Object, Type) TypeExtensions.InvokeMethod<TRet>(Object, Type[], Expression<Func<TRet>>, BindingFlags) TypeExtensions.InvokeMethod(Object, Type[], Expression<Action>, BindingFlags) TypeExtensions.InvokeMethod<TRet>(Object, Expression<Func<TRet>>, BindingFlags) TypeExtensions.InvokeMethod(Object, Expression<Action>, BindingFlags) SqlBlockExtensions.SetExpression<TTag, TResult>(TTag, Expression<Func<IBlockQueryAdapter, TResult>>) QueryDescriptionExtensions.SetExpression<TTag, TResult>(TTag, Expression<Func<IQueryStructureAdapter, TResult>>)"
  },
  "api/XData.Database.SqlBlock.ISqlVariable.html": {
    "href": "api/XData.Database.SqlBlock.ISqlVariable.html",
    "title": "Interface ISqlVariable | XData website",
    "keywords": "Interface ISqlVariable SQL variable description Namespace : XData.Database.SqlBlock Assembly : XData.docfx.dll Syntax public interface ISqlVariable Methods | Improve this Doc View Source Var<T>(String, DbType) SQL variable value Declaration ISqlValue Var<T>(string name, DbType dbType) Parameters Type Name Description String name Variable name DbType dbType Database type Returns Type Description ISqlValue SQL value description Type Parameters Name Description T Variable mapped type | Improve this Doc View Source Var<T>(String, DbType, Int32) SQL variable value Declaration ISqlValue Var<T>(string name, DbType dbType, int length) Parameters Type Name Description String name Variable name DbType dbType Database type Int32 length Database type length Returns Type Description ISqlValue SQL value description Type Parameters Name Description T Variable mapped type | Improve this Doc View Source Var<T>(String, DbType, Int32, Int32) SQL variable value Declaration ISqlValue Var<T>(string name, DbType dbType, int length, int scale) Parameters Type Name Description String name Variable name DbType dbType Database type Int32 length Database type length Int32 scale Database type scale Returns Type Description ISqlValue SQL value description Type Parameters Name Description T Variable mapped type | Improve this Doc View Source Var<T>(String, Expression<Action<ISqlTableAdapter>>[]) SQL variable value Declaration ISqlValue Var<T>(string name, params Expression<Action<ISqlTableAdapter>>[] fields) Parameters Type Name Description String name Variable name Expression < Action < ISqlTableAdapter >>[] fields Table variable fields description Returns Type Description ISqlValue SQL value description Type Parameters Name Description T Variable mapped type | Improve this Doc View Source Var<T>(String, String) Sql variable value Declaration ISqlValue Var<T>(string name, string nativeSqlType) Parameters Type Name Description String name Variable name String nativeSqlType Native database type name Returns Type Description ISqlValue Sql value description Type Parameters Name Description T Variable mapped type | Improve this Doc View Source Var<T>(String, String, Int32) SQL variable value Declaration ISqlValue Var<T>(string name, string nativeSqlType, int length) Parameters Type Name Description String name Variable name String nativeSqlType Native database type name Int32 length Database type length Returns Type Description ISqlValue SQL value description Type Parameters Name Description T Variable mapped type | Improve this Doc View Source Var<T>(String, String, Int32, Int32) SQL variable value Declaration ISqlValue Var<T>(string name, string nativeSqlType, int length, int scale) Parameters Type Name Description String name Variable name String nativeSqlType Native database type name Int32 length Database type length Int32 scale Database type scale Returns Type Description ISqlValue SQL value description Type Parameters Name Description T Variable mapped type Extension Methods SerializationExtensions.ToXml<T>(T) CollectionsExtensions.SetValue<TKey, T>(TKey, T) CollectionsExtensions.AsEnum<T>(T) DataObjectQueryableExtensions.CompareVariable(Object, FilterOperation, String) Processing.Do<T>(T, Action<IProcess<T>>[]) TypeExtensions.TryConvert<T, TResult>(T, Func<T, TResult>) TypeExtensions.TryConvert<T, TResult>(T, Func<T, TResult>, TResult) TypeExtensions.ChangeType<T>(Object) TypeExtensions.ChangeType(Object, Type) TypeExtensions.InvokeMethod<TRet>(Object, Type[], Expression<Func<TRet>>, BindingFlags) TypeExtensions.InvokeMethod(Object, Type[], Expression<Action>, BindingFlags) TypeExtensions.InvokeMethod<TRet>(Object, Expression<Func<TRet>>, BindingFlags) TypeExtensions.InvokeMethod(Object, Expression<Action>, BindingFlags) SqlBlockExtensions.SetExpression<TTag, TResult>(TTag, Expression<Func<IBlockQueryAdapter, TResult>>) QueryDescriptionExtensions.SetExpression<TTag, TResult>(TTag, Expression<Func<IQueryStructureAdapter, TResult>>)"
  },
  "api/XData.Database.SqlBlock.IPropertyMergeAdapter.html": {
    "href": "api/XData.Database.SqlBlock.IPropertyMergeAdapter.html",
    "title": "Interface IPropertyMergeAdapter | XData website",
    "keywords": "Interface IPropertyMergeAdapter Dynamic structure adapter for SQL block queries Inherited Members IPropertyMappingAdapter.Key() IPropertyMappingAdapter.Group(DataGrouping) IPropertyMappingAdapter.Group(Int32) IPropertyMappingAdapter.Hidden() IPropertyMappingAdapter.OrderBy(Int32, Boolean) IPropertyMappingAdapter.OrderBy(Int32) IMergeAttributeAdapter.Source(String) IMergeAttributeAdapter.Link() IMergeAttributeAdapter.Update() IMergeAttributeAdapter.Insert() IMergeAttributeAdapter.Insert(DefaultType) IMergeAttributeAdapter.Insert(DefaultType, Object) Namespace : XData.Database.SqlBlock Assembly : XData.docfx.dll Syntax public interface IPropertyMergeAdapter : IPropertyMappingAdapter, IMergeAttributeAdapter Extension Methods SerializationExtensions.ToXml<T>(T) CollectionsExtensions.SetValue<TKey, T>(TKey, T) CollectionsExtensions.AsEnum<T>(T) DataObjectQueryableExtensions.CompareVariable(Object, FilterOperation, String) Processing.Do<T>(T, Action<IProcess<T>>[]) TypeExtensions.TryConvert<T, TResult>(T, Func<T, TResult>) TypeExtensions.TryConvert<T, TResult>(T, Func<T, TResult>, TResult) TypeExtensions.ChangeType<T>(Object) TypeExtensions.ChangeType(Object, Type) TypeExtensions.InvokeMethod<TRet>(Object, Type[], Expression<Func<TRet>>, BindingFlags) TypeExtensions.InvokeMethod(Object, Type[], Expression<Action>, BindingFlags) TypeExtensions.InvokeMethod<TRet>(Object, Expression<Func<TRet>>, BindingFlags) TypeExtensions.InvokeMethod(Object, Expression<Action>, BindingFlags) SqlBlockExtensions.SetExpression<TTag, TResult>(TTag, Expression<Func<IBlockQueryAdapter, TResult>>) QueryDescriptionExtensions.SetExpression<TTag, TResult>(TTag, Expression<Func<IQueryStructureAdapter, TResult>>)"
  },
  "api/XData.Database.SqlBlock.ISqlVarAdapter.html": {
    "href": "api/XData.Database.SqlBlock.ISqlVarAdapter.html",
    "title": "Interface ISqlVarAdapter | XData website",
    "keywords": "Interface ISqlVarAdapter SQL variable value adapter Namespace : XData.Database.SqlBlock Assembly : XData.docfx.dll Syntax public interface ISqlVarAdapter Methods | Improve this Doc View Source Var<T>(String) SQL variable value Declaration ISqlValue<T> Var<T>(string name) Parameters Type Name Description String name Variable name Returns Type Description ISqlValue <T> SQL value description Type Parameters Name Description T Variable mapped type Extension Methods SerializationExtensions.ToXml<T>(T) CollectionsExtensions.SetValue<TKey, T>(TKey, T) CollectionsExtensions.AsEnum<T>(T) DataObjectQueryableExtensions.CompareVariable(Object, FilterOperation, String) Processing.Do<T>(T, Action<IProcess<T>>[]) TypeExtensions.TryConvert<T, TResult>(T, Func<T, TResult>) TypeExtensions.TryConvert<T, TResult>(T, Func<T, TResult>, TResult) TypeExtensions.ChangeType<T>(Object) TypeExtensions.ChangeType(Object, Type) TypeExtensions.InvokeMethod<TRet>(Object, Type[], Expression<Func<TRet>>, BindingFlags) TypeExtensions.InvokeMethod(Object, Type[], Expression<Action>, BindingFlags) TypeExtensions.InvokeMethod<TRet>(Object, Expression<Func<TRet>>, BindingFlags) TypeExtensions.InvokeMethod(Object, Expression<Action>, BindingFlags) SqlBlockExtensions.SetExpression<TTag, TResult>(TTag, Expression<Func<IBlockQueryAdapter, TResult>>) QueryDescriptionExtensions.SetExpression<TTag, TResult>(TTag, Expression<Func<IQueryStructureAdapter, TResult>>)"
  },
  "api/XData.Database.SqlBlock.ISqlBlockAdapter.html": {
    "href": "api/XData.Database.SqlBlock.ISqlBlockAdapter.html",
    "title": "Interface ISqlBlockAdapter | XData website",
    "keywords": "Interface ISqlBlockAdapter SQL block adapter Namespace : XData.Database.SqlBlock Assembly : XData.docfx.dll Syntax public interface ISqlBlockAdapter Methods | Improve this Doc View Source Block(Expression<Func<ISqlBlockAdapter, ISqlBlock>>[]) Complex SQL block fences BEGIN...END Declaration ISqlBlock Block(params Expression<Func<ISqlBlockAdapter, ISqlBlock>>[] blocks) Parameters Type Name Description Expression < Func < ISqlBlockAdapter , ISqlBlock >>[] blocks Contained SQL blocks Returns Type Description ISqlBlock SQL block description See Also ExecuteSqlBlock ( IDataScope , Expression < SqlBlockDefinition >, Expression < Func < ISqlParamAdapter , ISqlParam >>[]) GetSqlBlockData<T> ( IDataScope , Expression < SqlBlockDefinition <T>>, Expression < Func < ISqlParamAdapter , ISqlParam >>[]) | Improve this Doc View Source Block(String) Custom SQL block Declaration ISqlBlock Block(string customSqlBlock) Parameters Type Name Description String customSqlBlock Custom SQL block code Returns Type Description ISqlBlock SQL block description See Also ExecuteSqlBlock ( IDataScope , Expression < SqlBlockDefinition >, Expression < Func < ISqlParamAdapter , ISqlParam >>[]) GetSqlBlockData<T> ( IDataScope , Expression < SqlBlockDefinition <T>>, Expression < Func < ISqlParamAdapter , ISqlParam >>[]) | Improve this Doc View Source Block<T>(Expression<Func<ISqlBlockAdapter<T>, ISqlBlock>>[]) Complex SQL block fences BEGIN...END Declaration ISqlBlock Block<T>(params Expression<Func<ISqlBlockAdapter<T>, ISqlBlock>>[] blocks) where T : class, new() Parameters Type Name Description Expression < Func < ISqlBlockAdapter <T>, ISqlBlock >>[] blocks Contained SQL blocks Returns Type Description ISqlBlock SQL block description Type Parameters Name Description T Returned object type See Also GetSqlBlockData<T> ( IDataScope , Expression < SqlBlockDefinition <T>>, Expression < Func < ISqlParamAdapter , ISqlParam >>[]) | Improve this Doc View Source Declare(Expression<Func<ISqlVariable, ISqlValue>>[]) Declare variables SQL block Declaration ISqlBlock Declare(params Expression<Func<ISqlVariable, ISqlValue>>[] variables) Parameters Type Name Description Expression < Func < ISqlVariable , ISqlValue >>[] variables Variable declaration descriptions Returns Type Description ISqlBlock SQL block description See Also ExecuteSqlBlock ( IDataScope , Expression < SqlBlockDefinition >, Expression < Func < ISqlParamAdapter , ISqlParam >>[]) GetSqlBlockData<T> ( IDataScope , Expression < SqlBlockDefinition <T>>, Expression < Func < ISqlParamAdapter , ISqlParam >>[]) | Improve this Doc View Source Delete(Expression<Func<IBlockQueryStructure, IBlockQueryStructure>>) DELETE SQL block Declaration ISqlBlock Delete(Expression<Func<IBlockQueryStructure, IBlockQueryStructure>> query) Parameters Type Name Description Expression < Func < IBlockQueryStructure , IBlockQueryStructure >> query Delete query structure Returns Type Description ISqlBlock SQL block description See Also ExecuteSqlBlock ( IDataScope , Expression < SqlBlockDefinition >, Expression < Func < ISqlParamAdapter , ISqlParam >>[]) GetSqlBlockData<T> ( IDataScope , Expression < SqlBlockDefinition <T>>, Expression < Func < ISqlParamAdapter , ISqlParam >>[]) | Improve this Doc View Source ForEach<T>(Expression<Func<IBlockQueryStructure, IBlockQueryDescription<T>>>, String, Expression<Func<ISqlBlockAdapter, ISqlBlock>>, Expression<Action<ILoopVariableAdapter<T>>>[]) Cursor iteration SQL block Declaration ISqlBlock ForEach<T>(Expression<Func<IBlockQueryStructure, IBlockQueryDescription<T>>> selectQuery, string cursorName, Expression<Func<ISqlBlockAdapter, ISqlBlock>> body, params Expression<Action<ILoopVariableAdapter<T>>>[] mapping) where T : class Parameters Type Name Description Expression < Func < IBlockQueryStructure , IBlockQueryDescription <T>>> selectQuery Cursor query description String cursorName Cursor name Expression < Func < ISqlBlockAdapter , ISqlBlock >> body Loop body SQL block Expression < Action < ILoopVariableAdapter <T>>>[] mapping Loop variables mapping Returns Type Description ISqlBlock SQL block description Type Parameters Name Description T Cursor mapped type See Also ExecuteSqlBlock ( IDataScope , Expression < SqlBlockDefinition >, Expression < Func < ISqlParamAdapter , ISqlParam >>[]) GetSqlBlockData<T> ( IDataScope , Expression < SqlBlockDefinition <T>>, Expression < Func < ISqlParamAdapter , ISqlParam >>[]) | Improve this Doc View Source If(Expression<Func<IBlockQueryStructure, IBlockQueryStructure>>, FilterOperation, Expression<Func<ISqlBlockAdapter, ISqlBlock>>[]) IF [NOT] EXISTS(...) SQL block Declaration ISqlBlock If(Expression<Func<IBlockQueryStructure, IBlockQueryStructure>> existsStructure, FilterOperation operation, params Expression<Func<ISqlBlockAdapter, ISqlBlock>>[] parts) Parameters Type Name Description Expression < Func < IBlockQueryStructure , IBlockQueryStructure >> existsStructure Exists select structure FilterOperation operation Comparision operation ( Exists or NotExists only) Expression < Func < ISqlBlockAdapter , ISqlBlock >>[] parts True-part SQL block and (optionally) false-part SQL block Returns Type Description ISqlBlock SQL block description See Also ExecuteSqlBlock ( IDataScope , Expression < SqlBlockDefinition >, Expression < Func < ISqlParamAdapter , ISqlParam >>[]) GetSqlBlockData<T> ( IDataScope , Expression < SqlBlockDefinition <T>>, Expression < Func < ISqlParamAdapter , ISqlParam >>[]) | Improve this Doc View Source If<T>(Expression<Func<ISqlValueAdapter, ISqlValue<T>>>, Expression<Func<ISqlValueAdapter, ISqlValue<T>>>, FilterOperation, Expression<Func<ISqlBlockAdapter, ISqlBlock>>[]) IF SQL block Declaration ISqlBlock If<T>(Expression<Func<ISqlValueAdapter, ISqlValue<T>>> check, Expression<Func<ISqlValueAdapter, ISqlValue<T>>> value, FilterOperation oper, params Expression<Func<ISqlBlockAdapter, ISqlBlock>>[] parts) Parameters Type Name Description Expression < Func < ISqlValueAdapter , ISqlValue <T>>> check SQL value to check Expression < Func < ISqlValueAdapter , ISqlValue <T>>> value SQL value to compare with check Can be null to describe IS NULL or NOT IS NULL comparisons FilterOperation oper Comparision operation Expression < Func < ISqlBlockAdapter , ISqlBlock >>[] parts True-part SQL block and (optionally) false-part SQL block Returns Type Description ISqlBlock SQL block description Type Parameters Name Description T See Also ExecuteSqlBlock ( IDataScope , Expression < SqlBlockDefinition >, Expression < Func < ISqlParamAdapter , ISqlParam >>[]) GetSqlBlockData<T> ( IDataScope , Expression < SqlBlockDefinition <T>>, Expression < Func < ISqlParamAdapter , ISqlParam >>[]) | Improve this Doc View Source Insert<TResult>(String, DataTable, Expression<Func<ISetBlockAdapter, TResult>>) INSERT INTO...VALUES(...),VALUES(...)... SQL block Declaration ISqlBlock Insert<TResult>(string tableName, DataTable data, Expression<Func<ISetBlockAdapter, TResult>> mapper) where TResult : class Parameters Type Name Description String tableName Table to insert DataTable data Data table filled by data Access data by Data<T>(String) method inside expressions Expression < Func < ISetBlockAdapter , TResult>> mapper Fields to insert values mapper Returns Type Description ISqlBlock SQL block description Type Parameters Name Description TResult See Also Data<T>(String) ExecuteSqlBlock ( IDataScope , Expression < SqlBlockDefinition >, Expression < Func < ISqlParamAdapter , ISqlParam >>[]) GetSqlBlockData<T> ( IDataScope , Expression < SqlBlockDefinition <T>>, Expression < Func < ISqlParamAdapter , ISqlParam >>[]) | Improve this Doc View Source Insert<T>(String, Expression<Func<IBlockQueryStructure, IBlockQueryDescription<T>>>) INSERT INTO... SELECT SQL block Declaration ISqlBlock Insert<T>(string tableName, Expression<Func<IBlockQueryStructure, IBlockQueryDescription<T>>> selectQuery) where T : class Parameters Type Name Description String tableName Table to insert Expression < Func < IBlockQueryStructure , IBlockQueryDescription <T>>> selectQuery Select query description Use same fields order as in fields parameter Returns Type Description ISqlBlock SQL block description Type Parameters Name Description T See Also ExecuteSqlBlock ( IDataScope , Expression < SqlBlockDefinition >, Expression < Func < ISqlParamAdapter , ISqlParam >>[]) GetSqlBlockData<T> ( IDataScope , Expression < SqlBlockDefinition <T>>, Expression < Func < ISqlParamAdapter , ISqlParam >>[]) | Improve this Doc View Source Insert<TResult>(String, Expression<Func<ISetBlockAdapter, TResult>>) Single INSERT INTO...VALUES SQL block Declaration ISqlBlock Insert<TResult>(string tableName, Expression<Func<ISetBlockAdapter, TResult>> mapper) where TResult : class Parameters Type Name Description String tableName Table to insert Expression < Func < ISetBlockAdapter , TResult>> mapper Fields to insert values mapper Returns Type Description ISqlBlock SQL block description Type Parameters Name Description TResult See Also ExecuteSqlBlock ( IDataScope , Expression < SqlBlockDefinition >, Expression < Func < ISqlParamAdapter , ISqlParam >>[]) GetSqlBlockData<T> ( IDataScope , Expression < SqlBlockDefinition <T>>, Expression < Func < ISqlParamAdapter , ISqlParam >>[]) | Improve this Doc View Source Merge<T>(String, String, String, Expression<Func<IMergeBlockAdapter, T>>) MERGE SQL block Declaration ISqlBlock Merge<T>(string tableName, string targetAlias, string sourceAlias, Expression<Func<IMergeBlockAdapter, T>> mapper) where T : class Parameters Type Name Description String tableName Table name to merge with String targetAlias Target table alias String sourceAlias Data source alias Expression < Func < IMergeBlockAdapter , T>> mapper Data source mapper Use Link() , Update() and Insert() structure flags to set merge role of data source columns Returns Type Description ISqlBlock SQL block description Type Parameters Name Description T See Also ExecuteSqlBlock ( IDataScope , Expression < SqlBlockDefinition >, Expression < Func < ISqlParamAdapter , ISqlParam >>[]) GetSqlBlockData<T> ( IDataScope , Expression < SqlBlockDefinition <T>>, Expression < Func < ISqlParamAdapter , ISqlParam >>[]) | Improve this Doc View Source Merge<T, TSource>(String, String, Expression<Func<IBlockQueryStructure, IBlockQueryDescription<TSource>>>, String, Expression<Func<IMergeBlockAdapter, T>>) MERGE SQL block Declaration ISqlBlock Merge<T, TSource>(string tableName, string targetAlias, Expression<Func<IBlockQueryStructure, IBlockQueryDescription<TSource>>> sourceQuery, string sourceAlias, Expression<Func<IMergeBlockAdapter, T>> mapper) where T : class where TSource : class Parameters Type Name Description String tableName Table name to merge with String targetAlias Target table alias Expression < Func < IBlockQueryStructure , IBlockQueryDescription <TSource>>> sourceQuery Source subquery description String sourceAlias Data source alias Expression < Func < IMergeBlockAdapter , T>> mapper Data source mapper Use Link() , Update() and Insert() structure flags to set merge role of data source columns Returns Type Description ISqlBlock SQL block description Type Parameters Name Description T TSource See Also ExecuteSqlBlock ( IDataScope , Expression < SqlBlockDefinition >, Expression < Func < ISqlParamAdapter , ISqlParam >>[]) GetSqlBlockData<T> ( IDataScope , Expression < SqlBlockDefinition <T>>, Expression < Func < ISqlParamAdapter , ISqlParam >>[]) | Improve this Doc View Source SetVar(Expression<Func<ISetSqlVarAdapter, ISqlValue>>[]) SQL variables initialization SQL block Declaration ISqlBlock SetVar(params Expression<Func<ISetSqlVarAdapter, ISqlValue>>[] variables) Parameters Type Name Description Expression < Func < ISetSqlVarAdapter , ISqlValue >>[] variables Variable value descriptions Returns Type Description ISqlBlock SQL block description See Also Declare(Expression<Func<ISqlVariable, ISqlValue>>[]) ExecuteSqlBlock ( IDataScope , Expression < SqlBlockDefinition >, Expression < Func < ISqlParamAdapter , ISqlParam >>[]) GetSqlBlockData<T> ( IDataScope , Expression < SqlBlockDefinition <T>>, Expression < Func < ISqlParamAdapter , ISqlParam >>[]) | Improve this Doc View Source SetVar<TValue>(Expression<Func<IBlockQueryStructure, IBlockQueryDescription<TValue>>>, Expression<Func<ISqlVarAdapter, ISqlValue>>[]) SQL variables initialization using SELECT... INTO statement SQL block Declaration ISqlBlock SetVar<TValue>(Expression<Func<IBlockQueryStructure, IBlockQueryDescription<TValue>>> selectQuery, params Expression<Func<ISqlVarAdapter, ISqlValue>>[] variables) Parameters Type Name Description Expression < Func < IBlockQueryStructure , IBlockQueryDescription <TValue>>> selectQuery Query description used as data source Expression < Func < ISqlVarAdapter , ISqlValue >>[] variables Variable value descriptions Returns Type Description ISqlBlock SQL block description Type Parameters Name Description TValue See Also Declare(Expression<Func<ISqlVariable, ISqlValue>>[]) ExecuteSqlBlock ( IDataScope , Expression < SqlBlockDefinition >, Expression < Func < ISqlParamAdapter , ISqlParam >>[]) GetSqlBlockData<T> ( IDataScope , Expression < SqlBlockDefinition <T>>, Expression < Func < ISqlParamAdapter , ISqlParam >>[]) | Improve this Doc View Source Update<T>(Expression<Func<IBlockQueryStructure, IBlockQueryStructure>>, Expression<Func<ISetBlockAdapter, T>>) UPDATE SQL block Declaration ISqlBlock Update<T>(Expression<Func<IBlockQueryStructure, IBlockQueryStructure>> query, Expression<Func<ISetBlockAdapter, T>> setExpr) where T : class Parameters Type Name Description Expression < Func < IBlockQueryStructure , IBlockQueryStructure >> query SQL block query description Expression < Func < ISetBlockAdapter , T>> setExpr Set expression description Returns Type Description ISqlBlock SQL block description Type Parameters Name Description T See Also ExecuteSqlBlock ( IDataScope , Expression < SqlBlockDefinition >, Expression < Func < ISqlParamAdapter , ISqlParam >>[]) GetSqlBlockData<T> ( IDataScope , Expression < SqlBlockDefinition <T>>, Expression < Func < ISqlParamAdapter , ISqlParam >>[]) Extension Methods SerializationExtensions.ToXml<T>(T) CollectionsExtensions.SetValue<TKey, T>(TKey, T) CollectionsExtensions.AsEnum<T>(T) DataObjectQueryableExtensions.CompareVariable(Object, FilterOperation, String) Processing.Do<T>(T, Action<IProcess<T>>[]) TypeExtensions.TryConvert<T, TResult>(T, Func<T, TResult>) TypeExtensions.TryConvert<T, TResult>(T, Func<T, TResult>, TResult) TypeExtensions.ChangeType<T>(Object) TypeExtensions.ChangeType(Object, Type) TypeExtensions.InvokeMethod<TRet>(Object, Type[], Expression<Func<TRet>>, BindingFlags) TypeExtensions.InvokeMethod(Object, Type[], Expression<Action>, BindingFlags) TypeExtensions.InvokeMethod<TRet>(Object, Expression<Func<TRet>>, BindingFlags) TypeExtensions.InvokeMethod(Object, Expression<Action>, BindingFlags) SqlBlockExtensions.SetExpression<TTag, TResult>(TTag, Expression<Func<IBlockQueryAdapter, TResult>>) QueryDescriptionExtensions.SetExpression<TTag, TResult>(TTag, Expression<Func<IQueryStructureAdapter, TResult>>)"
  },
  "api/XData.Database.SqlBlock.IMergeAttributeAdapter.html": {
    "href": "api/XData.Database.SqlBlock.IMergeAttributeAdapter.html",
    "title": "Interface IMergeAttributeAdapter | XData website",
    "keywords": "Interface IMergeAttributeAdapter Merge role structure adapter Namespace : XData.Database.SqlBlock Assembly : XData.docfx.dll Syntax public interface IMergeAttributeAdapter Methods | Improve this Doc View Source Insert() SQL value is used to insert into field on merge Declaration IStructureFlag Insert() Returns Type Description IStructureFlag Structure flag | Improve this Doc View Source Insert(DefaultType) SQL value is used to insert into field on merge Declaration IStructureFlag Insert(DefaultType defaultType) Parameters Type Name Description DefaultType defaultType Default value type Returns Type Description IStructureFlag Structure flag | Improve this Doc View Source Insert(DefaultType, Object) SQL value is used to insert into field on merge Declaration IStructureFlag Insert(DefaultType defaultType, object defaultValue) Parameters Type Name Description DefaultType defaultType Default value type Object defaultValue Default value Returns Type Description IStructureFlag Structure flag | Improve this Doc View Source Link() SQL value linked to field on merge Declaration IStructureFlag Link() Returns Type Description IStructureFlag Structure flag | Improve this Doc View Source Source(String) SQL value linked to field on merge Declaration IStructureFlag Source(string fieldName) Parameters Type Name Description String fieldName Default value Returns Type Description IStructureFlag Structure flag | Improve this Doc View Source Update() SQL value is used to update field on merge Declaration IStructureFlag Update() Returns Type Description IStructureFlag Structure flag Extension Methods SerializationExtensions.ToXml<T>(T) CollectionsExtensions.SetValue<TKey, T>(TKey, T) CollectionsExtensions.AsEnum<T>(T) DataObjectQueryableExtensions.CompareVariable(Object, FilterOperation, String) Processing.Do<T>(T, Action<IProcess<T>>[]) TypeExtensions.TryConvert<T, TResult>(T, Func<T, TResult>) TypeExtensions.TryConvert<T, TResult>(T, Func<T, TResult>, TResult) TypeExtensions.ChangeType<T>(Object) TypeExtensions.ChangeType(Object, Type) TypeExtensions.InvokeMethod<TRet>(Object, Type[], Expression<Func<TRet>>, BindingFlags) TypeExtensions.InvokeMethod(Object, Type[], Expression<Action>, BindingFlags) TypeExtensions.InvokeMethod<TRet>(Object, Expression<Func<TRet>>, BindingFlags) TypeExtensions.InvokeMethod(Object, Expression<Action>, BindingFlags) SqlBlockExtensions.SetExpression<TTag, TResult>(TTag, Expression<Func<IBlockQueryAdapter, TResult>>) QueryDescriptionExtensions.SetExpression<TTag, TResult>(TTag, Expression<Func<IQueryStructureAdapter, TResult>>)"
  },
  "api/XData.Database.ITransaction.html": {
    "href": "api/XData.Database.ITransaction.html",
    "title": "Interface ITransaction | XData website",
    "keywords": "Interface ITransaction Transaction wrapper interface Inherited Members IDisposable.Dispose() Namespace : XData.Database Assembly : XData.docfx.dll Syntax public interface ITransaction : IDisposable Methods | Improve this Doc View Source Commit() Commit transaction Declaration bool Commit() Returns Type Description Boolean Success flag Extension Methods SerializationExtensions.ToXml<T>(T) CollectionsExtensions.SetValue<TKey, T>(TKey, T) CollectionsExtensions.AsEnum<T>(T) DataObjectQueryableExtensions.CompareVariable(Object, FilterOperation, String) Processing.Do<T>(T, Action<IProcess<T>>[]) TypeExtensions.TryConvert<T, TResult>(T, Func<T, TResult>) TypeExtensions.TryConvert<T, TResult>(T, Func<T, TResult>, TResult) TypeExtensions.ChangeType<T>(Object) TypeExtensions.ChangeType(Object, Type) TypeExtensions.InvokeMethod<TRet>(Object, Type[], Expression<Func<TRet>>, BindingFlags) TypeExtensions.InvokeMethod(Object, Type[], Expression<Action>, BindingFlags) TypeExtensions.InvokeMethod<TRet>(Object, Expression<Func<TRet>>, BindingFlags) TypeExtensions.InvokeMethod(Object, Expression<Action>, BindingFlags) SqlBlockExtensions.SetExpression<TTag, TResult>(TTag, Expression<Func<IBlockQueryAdapter, TResult>>) QueryDescriptionExtensions.SetExpression<TTag, TResult>(TTag, Expression<Func<IQueryStructureAdapter, TResult>>)"
  },
  "api/XData.Database.Dialect.ExpressionContext.html": {
    "href": "api/XData.Database.Dialect.ExpressionContext.html",
    "title": "Class ExpressionContext | XData website",
    "keywords": "Class ExpressionContext SQL expression context Inheritance Object ExpressionContext Inherited Members Object.Equals(Object) Object.Equals(Object, Object) Object.GetHashCode() Object.GetType() Object.MemberwiseClone() Object.ReferenceEquals(Object, Object) Object.ToString() Namespace : XData.Database.Dialect Assembly : XData.docfx.dll Syntax public class ExpressionContext Properties | Improve this Doc View Source OuterQueries Subquery outer queries Declaration public Dictionary<string, IDataQuery> OuterQueries { get; set; } Property Value Type Description Dictionary < String , IDataQuery > | Improve this Doc View Source Query Expression context query Declaration public IDataQuery Query { get; } Property Value Type Description IDataQuery Extension Methods SerializationExtensions.ToXml<T>(T) CollectionsExtensions.SetValue<TKey, T>(TKey, T) CollectionsExtensions.AsEnum<T>(T) DataObjectQueryableExtensions.CompareVariable(Object, FilterOperation, String) Processing.Do<T>(T, Action<IProcess<T>>[]) TypeExtensions.TryConvert<T, TResult>(T, Func<T, TResult>) TypeExtensions.TryConvert<T, TResult>(T, Func<T, TResult>, TResult) TypeExtensions.ChangeType<T>(Object) TypeExtensions.ChangeType(Object, Type) TypeExtensions.InvokeMethod<TRet>(Object, Type[], Expression<Func<TRet>>, BindingFlags) TypeExtensions.InvokeMethod(Object, Type[], Expression<Action>, BindingFlags) TypeExtensions.InvokeMethod<TRet>(Object, Expression<Func<TRet>>, BindingFlags) TypeExtensions.InvokeMethod(Object, Expression<Action>, BindingFlags) SqlBlockExtensions.SetExpression<TTag, TResult>(TTag, Expression<Func<IBlockQueryAdapter, TResult>>) QueryDescriptionExtensions.SetExpression<TTag, TResult>(TTag, Expression<Func<IQueryStructureAdapter, TResult>>)"
  },
  "api/XData.Database.Adapter.QueryResult.html": {
    "href": "api/XData.Database.Adapter.QueryResult.html",
    "title": "Class QueryResult | XData website",
    "keywords": "Class QueryResult SQL query result Inheritance Object QueryResultBase QueryResult Implements IEnumerable < QueryParam > IEnumerable Inherited Members QueryResultBase.AffectedRows QueryResultBase.Item[Int32] QueryResultBase.Item[String] QueryResultBase.ParamsCount QueryResultBase.Init(Int32, IDataParameterCollection) QueryResultBase.Init(Int32, IEnumerable<IDataParameter>) QueryResultBase.Init(Int32, IEnumerable<QueryParam>) QueryResultBase.GetEnumerator() QueryResultBase.IEnumerable.GetEnumerator() Object.Equals(Object) Object.Equals(Object, Object) Object.GetHashCode() Object.GetType() Object.MemberwiseClone() Object.ReferenceEquals(Object, Object) Object.ToString() Namespace : XData.Database.Adapter Assembly : XData.docfx.dll Syntax public sealed class QueryResult : QueryResultBase, IEnumerable<QueryParam>, IEnumerable Constructors | Improve this Doc View Source QueryResult(Query, Int32, IEnumerable<QueryParam>) SQL query result constructor Declaration public QueryResult(Query query, int affectedRows, IEnumerable<QueryParam> queryParams) Parameters Type Name Description Query query Query instance Int32 affectedRows Affected rows IEnumerable < QueryParam > queryParams Query parameter sequence | Improve this Doc View Source QueryResult(Query, Int32, IDataParameterCollection) SQL query result constructor Declaration public QueryResult(Query query, int affectedRows, IDataParameterCollection queryParams) Parameters Type Name Description Query query Query instance Int32 affectedRows Affected rows IDataParameterCollection queryParams Query parameters Methods | Improve this Doc View Source ParamInit(IDataParameter) Update out parameter value Declaration protected override QueryParam ParamInit(IDataParameter parameter) Parameters Type Name Description IDataParameter parameter Parameter Returns Type Description QueryParam Query parameter Overrides QueryResultBase.ParamInit(IDataParameter) Exceptions Type Condition XDataRuntimeException Implements System.Collections.Generic.IEnumerable<T> System.Collections.IEnumerable Extension Methods SerializationExtensions.ToXml<T>(T) CollectionsExtensions.ToSortedSet<T>(IEnumerable<T>, IComparer<T>) CollectionsExtensions.SetValue<TKey, T>(TKey, T) CollectionsExtensions.AsEnum<T>(T) DataObjectQueryableExtensions.CompareVariable(Object, FilterOperation, String) JoinedEnumerable.Inner<TElement>(IEnumerable<TElement>) JoinedEnumerable.Outer<TElement>(IEnumerable<TElement>) JoinedEnumerable.LeftOuterJoin<TOuter, TInner, TKey, TResult>(IEnumerable<TOuter>, IEnumerable<TInner>, Func<TOuter, TKey>, Func<TInner, TKey>, Func<TOuter, TInner, TResult>, IEqualityComparer<TKey>) JoinedEnumerable.RightOuterJoin<TOuter, TInner, TKey, TResult>(IEnumerable<TOuter>, IEnumerable<TInner>, Func<TOuter, TKey>, Func<TInner, TKey>, Func<TOuter, TInner, TResult>, IEqualityComparer<TKey>) JoinedEnumerable.FullOuterJoin<TOuter, TInner, TKey, TResult>(IEnumerable<TOuter>, IEnumerable<TInner>, Func<TOuter, TKey>, Func<TInner, TKey>, Func<TOuter, TInner, TResult>, IEqualityComparer<TKey>) Processing.Do<T>(T, Action<IProcess<T>>[]) TypeExtensions.TryConvert<T, TResult>(T, Func<T, TResult>) TypeExtensions.TryConvert<T, TResult>(T, Func<T, TResult>, TResult) TypeExtensions.ChangeType<T>(Object) TypeExtensions.ChangeType(Object, Type) TypeExtensions.InvokeMethod<TRet>(Object, Type[], Expression<Func<TRet>>, BindingFlags) TypeExtensions.InvokeMethod(Object, Type[], Expression<Action>, BindingFlags) TypeExtensions.InvokeMethod<TRet>(Object, Expression<Func<TRet>>, BindingFlags) TypeExtensions.InvokeMethod(Object, Expression<Action>, BindingFlags) SqlBlockExtensions.SetExpression<TTag, TResult>(TTag, Expression<Func<IBlockQueryAdapter, TResult>>) QueryDescriptionExtensions.SetExpression<TTag, TResult>(TTag, Expression<Func<IQueryStructureAdapter, TResult>>) QueryDescriptionExtensions.ToDataSet<T>(IEnumerable<T>, String, ISqlBuilder)"
  },
  "api/XData.Database.Adapter.BaseDatabaseAdapter-2.html": {
    "href": "api/XData.Database.Adapter.BaseDatabaseAdapter-2.html",
    "title": "Class BaseDatabaseAdapter<TConnection, TParameter> | XData website",
    "keywords": "Class BaseDatabaseAdapter<TConnection, TParameter> Database adapter base class Inheritance Object BaseDatabaseAdapter<TConnection, TParameter> Implements IDatabaseAdapter IDisposable Inherited Members Object.Equals(Object) Object.Equals(Object, Object) Object.GetHashCode() Object.GetType() Object.MemberwiseClone() Object.ReferenceEquals(Object, Object) Object.ToString() Namespace : XData.Database.Adapter Assembly : XData.docfx.dll Syntax [DatabaseAdapter(\"NONE\")] public abstract class BaseDatabaseAdapter<TConnection, TParameter> : IDatabaseAdapter, IDisposable where TConnection : DbConnection, new() where TParameter : IDbDataParameter, new() Type Parameters Name Description TConnection TParameter Properties | Improve this Doc View Source Config Adapter configuration Declaration protected IConfiguration Config { get; } Property Value Type Description IConfiguration | Improve this Doc View Source ConnectType Adapter name Declaration public string ConnectType { get; } Property Value Type Description String | Improve this Doc View Source Context Database context name Declaration protected string Context { get; } Property Value Type Description String | Improve this Doc View Source DialectAdapter SQL dialect adapter instance Declaration protected ISqlBuilder DialectAdapter { get; } Property Value Type Description ISqlBuilder | Improve this Doc View Source Initialized Declaration protected bool Initialized { get; } Property Value Type Description Boolean | Improve this Doc View Source NotSupported Check adapter supports user defined types (UDT) Declaration public virtual DialectOptions NotSupported { get; } Property Value Type Description DialectOptions Methods | Improve this Doc View Source AddSavePoint(Guid, IDbTransaction, String) Add named save point Declaration protected abstract void AddSavePoint(Guid layer, IDbTransaction transaction, string savePoint) Parameters Type Name Description Guid layer Layer IDbTransaction transaction Transaction String savePoint Save point name | Improve this Doc View Source BeginTransaction(Guid, Boolean, IsolationLevel) Begin transaction Declaration public string BeginTransaction(Guid layer, bool read = false, IsolationLevel isolation = IsolationLevel.ReadCommitted) Parameters Type Name Description Guid layer Layer Boolean read Read only transaction flag IsolationLevel isolation Transaction isolation level Returns Type Description String Transaction key Exceptions Type Condition XDataSqlException SQL exceptions while beginning transaction. | Improve this Doc View Source Call(Guid, StoredProcedure, CancellationToken) Calls stored procedure Declaration public CallResult Call(Guid layer, StoredProcedure procedure, CancellationToken token) Parameters Type Name Description Guid layer Layer StoredProcedure procedure Stored procedure CancellationToken token Cancellation token Returns Type Description CallResult CallResult Exceptions Type Condition XDataSqlException | Improve this Doc View Source Close(Guid) Close database connection Declaration public void Close(Guid layer) Parameters Type Name Description Guid layer Exceptions Type Condition XDataSqlException SQL exceptions while closing connection | Improve this Doc View Source Commit(Guid, String) Commit transaction Declaration public bool Commit(Guid layer, string transactionId) Parameters Type Name Description Guid layer Layer String transactionId Transaction key Returns Type Description Boolean Success flag | Improve this Doc View Source CreateCommand(TConnection) Create specific SQL command Declaration protected virtual IDbCommand CreateCommand(TConnection connection) Parameters Type Name Description TConnection connection SQL connection Returns Type Description IDbCommand SQL command Remarks Override this when some special command parameters are required | Improve this Doc View Source CreateParameter(Guid, QueryParam) Create common parameter Declaration protected virtual TParameter CreateParameter(Guid layer, QueryParam parameter) Parameters Type Name Description Guid layer Layer QueryParam parameter Query parameter Returns Type Description TParameter Parameter | Improve this Doc View Source Dispose() IDisposable realization Declaration public void Dispose() | Improve this Doc View Source ExecuteNonQuery(Guid, Enum, Object[]) Executes SQL expression with no result set Declaration public QueryResult ExecuteNonQuery(Guid layer, Enum queryIndex, params object[] paramValues) Parameters Type Name Description Guid layer Layer Enum queryIndex Predefined query enumeration key Object [] paramValues Query parameter values Returns Type Description QueryResult Query result Exceptions Type Condition XDataSqlException wrong SQL query parameters | Improve this Doc View Source ExecuteNonQuery(Guid, Query) Executes SQL expression with no result set Declaration public QueryResult ExecuteNonQuery(Guid layer, Query query) Parameters Type Name Description Guid layer Layer Query query Query Returns Type Description QueryResult Query result Exceptions Type Condition XDataSqlException wrong SQL query XDataConcurrencyException concurrency exception | Improve this Doc View Source ExecuteScalar(Guid, Enum, Object[]) Executes scalar returning query Declaration public object ExecuteScalar(Guid layer, Enum queryIndex, params object[] paramValues) Parameters Type Name Description Guid layer Layer Enum queryIndex Predefined query enumeration key Object [] paramValues Query parameter values Returns Type Description Object Scalar value Exceptions Type Condition XDataSqlException wrong SQL query parameters | Improve this Doc View Source ExecuteScalar(Guid, Query) Executes scalar returning query Declaration public object ExecuteScalar(Guid layer, Query query) Parameters Type Name Description Guid layer Layer Query query Query Returns Type Description Object Reader Exceptions Type Condition XDataSqlException wrong SQL query XDataConcurrencyException concurrency exception | Improve this Doc View Source FillTable(Guid, Enum, CommandBehavior, Object[]) Executes query and fill data table Declaration public DataTable FillTable(Guid layer, Enum queryIndex, CommandBehavior behavior, params object[] paramValues) Parameters Type Name Description Guid layer Layer Enum queryIndex Predefined query enumeration key CommandBehavior behavior Command behavior Object [] paramValues Query parameter values Returns Type Description DataTable Filled data table Exceptions Type Condition XDataSqlException wrong SQL query parameters | Improve this Doc View Source FillTable(Guid, Enum, Object[]) Executes query and fill data table Declaration public DataTable FillTable(Guid layer, Enum queryIndex, params object[] paramValues) Parameters Type Name Description Guid layer Layer Enum queryIndex Predefined query enumeration key Object [] paramValues Query parameter values Returns Type Description DataTable Filled data table Exceptions Type Condition XDataSqlException wrong SQL query parameters | Improve this Doc View Source FillTable(Guid, Query, CancellationToken, CommandBehavior) Executes query and fill data table Declaration public DataTable FillTable(Guid layer, Query query, CancellationToken token, CommandBehavior behavior = CommandBehavior.Default) Parameters Type Name Description Guid layer Layer Query query Query CancellationToken token Cancellation token CommandBehavior behavior Command behavior Returns Type Description DataTable Filled data table Exceptions Type Condition XDataSqlException wrong SQL query | Improve this Doc View Source FixFieldDataType(DataRow) Convert field data type Declaration protected virtual Type FixFieldDataType(DataRow columnInfo) Parameters Type Name Description DataRow columnInfo Field description from schema table Returns Type Description Type Correct data type | Improve this Doc View Source GetConnection(Guid) Database connection Declaration protected DbConnection GetConnection(Guid layer) Parameters Type Name Description Guid layer Returns Type Description DbConnection | Improve this Doc View Source GetNativeType(DbType) Declaration protected string GetNativeType(DbType type) Parameters Type Name Description DbType type Returns Type Description String Exceptions Type Condition XDataAdapterException | Improve this Doc View Source GetParameterValue(QueryParam) Returns parameter value Declaration public object GetParameterValue(QueryParam parameter) Parameters Type Name Description QueryParam parameter Query parameter Returns Type Description Object Parameter value | Improve this Doc View Source GetParameterValue<T>(QueryParam) Declaration public T GetParameterValue<T>(QueryParam parameter) Parameters Type Name Description QueryParam parameter Returns Type Description T Type Parameters Name Description T Exceptions Type Condition XDataAdapterException | Improve this Doc View Source GetProcedureCall(ref IDbCommand, StoredProcedure, String, Boolean) Declaration protected virtual void GetProcedureCall(ref IDbCommand command, StoredProcedure procedure, string getResultName = null, bool closeCursor = false) Parameters Type Name Description IDbCommand command StoredProcedure procedure String getResultName Boolean closeCursor | Improve this Doc View Source GetSqlType(String, ref Int32, ref Int32, Int32) Declaration protected DbType GetSqlType(string typeName, ref int size, ref int scale, int precision) Parameters Type Name Description String typeName Int32 size Int32 scale Int32 precision Returns Type Description DbType Exceptions Type Condition XDataAdapterException Type not supported | Improve this Doc View Source GetTableFieldInfo(Guid, String) Declaration public abstract ReadOnlyCollection<FieldInfo> GetTableFieldInfo(Guid layer, string table) Parameters Type Name Description Guid layer String table Returns Type Description ReadOnlyCollection < FieldInfo > | Improve this Doc View Source GetTablesInfo(Guid) Declaration public abstract ReadOnlyCollection<TableInfo> GetTablesInfo(Guid layer) Parameters Type Name Description Guid layer Returns Type Description ReadOnlyCollection < TableInfo > | Improve this Doc View Source GetUtdParameter(QueryParam) Create and initialize user data type (UDT) parameter Hint: Override this method to use UDT stored procedure parameters Declaration protected virtual IDataParameter GetUtdParameter(QueryParam parameter) Parameters Type Name Description QueryParam parameter Stored procedure parameter Returns Type Description IDataParameter IDataParameter Exceptions Type Condition XDataAdapterException User Defined Type (UTD) | Improve this Doc View Source Init() Adapter initialization Declaration protected abstract void Init() | Improve this Doc View Source Init(ISqlBuilder, String, String, IConfiguration) Adapter initialization logic Declaration public void Init(ISqlBuilder dialectAdapter, string context, string connectionString, IConfiguration config) Parameters Type Name Description ISqlBuilder dialectAdapter SQL dialect adapter String context Context name String connectionString Database connection string IConfiguration config Adapter configuration | Improve this Doc View Source InitConnection(DbConnection) Declaration protected virtual void InitConnection(DbConnection connection) Parameters Type Name Description DbConnection connection | Improve this Doc View Source InTransaction(Guid) Connection have not committed transaction flag Declaration public bool InTransaction(Guid layer) Parameters Type Name Description Guid layer Returns Type Description Boolean | Improve this Doc View Source IsConcurrencyError(Exception) Check exception is a concurrency exception Declaration protected virtual bool IsConcurrencyError(Exception exception) Parameters Type Name Description Exception exception Exception Returns Type Description Boolean Exception is a concurrency exception | Improve this Doc View Source IsOpen(Guid) Connection is open flag Declaration public bool IsOpen(Guid layer) Parameters Type Name Description Guid layer Returns Type Description Boolean | Improve this Doc View Source ReadNativeValue<T>(String, Object) Read native SQL value Declaration protected virtual T ReadNativeValue<T>(string nativeSqlType, object value) Parameters Type Name Description String nativeSqlType Native SQL type name Object value Value Returns Type Description T Mapped value Type Parameters Name Description T Mapped type Exceptions Type Condition XDataAdapterException | Improve this Doc View Source ReadUtd<T>(Object) Read data from wrapped user defined type (UTD) Declaration protected virtual T ReadUtd<T>(object utdObject) where T : class Parameters Type Name Description Object utdObject Wrapped value Returns Type Description T Unwrapped value Type Parameters Name Description T Type mapped to user defined type (UTD) Exceptions Type Condition XDataAdapterException User Defined Type (UTD) | Improve this Doc View Source ReadUtdCollection<T>(Object) Read data from wrapped user defined type (UTD) Declaration protected virtual ICollection<T> ReadUtdCollection<T>(object utdCollection) Parameters Type Name Description Object utdCollection Wrapped collection Returns Type Description ICollection <T> Unwrapped collection Type Parameters Name Description T Collection element type mapped to user defined type (UTD) Exceptions Type Condition XDataAdapterException User Defined Type (UTD) | Improve this Doc View Source RegisterResultSet(String) Register result set parameter of stored procedure Declaration protected virtual IDbDataParameter RegisterResultSet(string resultSetName) Parameters Type Name Description String resultSetName Result set name Returns Type Description IDbDataParameter Result set parameter Remarks WARNING! Override this method to register result sets as out parameters Exceptions Type Condition XDataAdapterException RegisterResultSet See Also ResultSets MultipleRecordsetProceduresSupported RegisterRecordsetRequired | Improve this Doc View Source Rollback(Guid, String) Rollback transaction Declaration public bool Rollback(Guid layer, string transactionId) Parameters Type Name Description Guid layer Layer String transactionId Transaction key Returns Type Description Boolean Success flag | Improve this Doc View Source RollbackToSavePoint(Guid, IDbTransaction, String) Rollback to named save point Declaration protected abstract void RollbackToSavePoint(Guid layer, IDbTransaction transaction, string savePoint) Parameters Type Name Description Guid layer Layer IDbTransaction transaction Transaction String savePoint Save point name | Improve this Doc View Source SafeConvert<T>(Object) Safe conversion for Db specific types Declaration public virtual T SafeConvert<T>(object data) Parameters Type Name Description Object data Source data Returns Type Description T Source data converted to type Type Parameters Name Description T Result type Remarks Override this to convert some specific Db related types See Also SafeTypeConvert | Improve this Doc View Source SelectParameterValue<T>(QueryParam) Declaration public IEnumerable<T> SelectParameterValue<T>(QueryParam parameter) Parameters Type Name Description QueryParam parameter Returns Type Description IEnumerable <T> Type Parameters Name Description T Exceptions Type Condition XDataAdapterException | Improve this Doc View Source Test(Guid, Query) Test query syntax WARNING! Throws a error if test failed! Declaration public void Test(Guid layer, Query query) Parameters Type Name Description Guid layer Layer Query query Query Exceptions Type Condition XDataSqlException wrong SQL query | Improve this Doc View Source WrapUtd<T>(T, String) Wrap data to user defined type (UTD) Declaration protected virtual object WrapUtd<T>(T value, string utdTypeName) where T : class Parameters Type Name Description T value Value to wrap String utdTypeName User defined type name Returns Type Description Object Wrapped value Type Parameters Name Description T Type mapped to user defined type (UTD) Exceptions Type Condition XDataAdapterException User Defined Type (UTD) | Improve this Doc View Source WrapUtdCollection<T>(T[], Boolean, String, String) Wrap data to collection (table or array) user defined type (UTD) Declaration protected virtual object WrapUtdCollection<T>(T[] value, bool isArray, string utdTypeName, string utdElementName = null) Parameters Type Name Description T[] value Collection to wrap Boolean isArray Use VARARRAY String utdTypeName User defined type name for collection String utdElementName User defined type name for element (set to null for scalar type collection) Returns Type Description Object Wrapped collection Type Parameters Name Description T Collection element type mapped to user defined type (UTD) Exceptions Type Condition XDataAdapterException User Defined Type (UTD) Implements IDatabaseAdapter System.IDisposable Extension Methods SerializationExtensions.ToXml<T>(T) CollectionsExtensions.SetValue<TKey, T>(TKey, T) CollectionsExtensions.AsEnum<T>(T) DataObjectQueryableExtensions.CompareVariable(Object, FilterOperation, String) Processing.Do<T>(T, Action<IProcess<T>>[]) TypeExtensions.TryConvert<T, TResult>(T, Func<T, TResult>) TypeExtensions.TryConvert<T, TResult>(T, Func<T, TResult>, TResult) TypeExtensions.ChangeType<T>(Object) TypeExtensions.ChangeType(Object, Type) TypeExtensions.InvokeMethod<TRet>(Object, Type[], Expression<Func<TRet>>, BindingFlags) TypeExtensions.InvokeMethod(Object, Type[], Expression<Action>, BindingFlags) TypeExtensions.InvokeMethod<TRet>(Object, Expression<Func<TRet>>, BindingFlags) TypeExtensions.InvokeMethod(Object, Expression<Action>, BindingFlags) SqlBlockExtensions.SetExpression<TTag, TResult>(TTag, Expression<Func<IBlockQueryAdapter, TResult>>) QueryDescriptionExtensions.SetExpression<TTag, TResult>(TTag, Expression<Func<IQueryStructureAdapter, TResult>>)"
  },
  "api/XData.DataStructureFlag.html": {
    "href": "api/XData.DataStructureFlag.html",
    "title": "Enum DataStructureFlag | XData website",
    "keywords": "Enum DataStructureFlag Data object structure flags Namespace : XData Assembly : XData.docfx.dll Syntax [Flags] public enum DataStructureFlag Fields Name Description Grouping Grouped Data object None Common editable Data object ReadOnly Read only Data object Tree Tree organized Data object See Also Flags None Tree Grouping ReadOnly Extension Methods SerializationExtensions.ToXml<DataStructureFlag>() CollectionsExtensions.SetValue<DataStructureFlag, T>(T) CollectionsExtensions.AsEnum<DataStructureFlag>() DataObjectQueryableExtensions.CompareVariable(FilterOperation, String) Processing.Do<DataStructureFlag>(Action<IProcess<DataStructureFlag>>[]) TypeExtensions.ChangeType<T>() TypeExtensions.ChangeType(Type) TypeExtensions.InvokeMethod<TRet>(Type[], Expression<Func<TRet>>, BindingFlags) TypeExtensions.InvokeMethod(Type[], Expression<Action>, BindingFlags) TypeExtensions.InvokeMethod<TRet>(Expression<Func<TRet>>, BindingFlags) TypeExtensions.InvokeMethod(Expression<Action>, BindingFlags) TypeExtensions.ConvertTo<T>() TypeExtensions.EqualValue(Enum) SqlBlockExtensions.SetExpression<DataStructureFlag, TResult>(Expression<Func<IBlockQueryAdapter, TResult>>) QueryDescriptionExtensions.SetExpression<DataStructureFlag, TResult>(Expression<Func<IQueryStructureAdapter, TResult>>)"
  },
  "api/XData.Database.SqlBlock.SqlBlockExtensions.html": {
    "href": "api/XData.Database.SqlBlock.SqlBlockExtensions.html",
    "title": "Class SqlBlockExtensions | XData website",
    "keywords": "Class SqlBlockExtensions Sql block extensions Inheritance Object SqlBlockExtensions Inherited Members Object.Equals(Object) Object.Equals(Object, Object) Object.GetHashCode() Object.GetType() Object.MemberwiseClone() Object.ReferenceEquals(Object, Object) Object.ToString() Namespace : XData.Database.SqlBlock Assembly : XData.docfx.dll Syntax public static class SqlBlockExtensions Methods | Improve this Doc View Source Case<T, TResult>(IBlockQueryAdapter, Expression<Func<IBlockQueryAdapter, T>>, Expression<Func<IBlockQueryAdapter, TResult>>, TaggedExpression<T, TResult>[]) Case Declaration public static TResult Case<T, TResult>(this IBlockQueryAdapter adapter, Expression<Func<IBlockQueryAdapter, T>> expression, Expression<Func<IBlockQueryAdapter, TResult>> elseValue, params TaggedExpression<T, TResult>[] switchValues) Parameters Type Name Description IBlockQueryAdapter adapter Source query structure adapter Expression < Func < IBlockQueryAdapter , T>> expression Case expression Expression < Func < IBlockQueryAdapter , TResult>> elseValue Else value TaggedExpression <T, TResult>[] switchValues Case switch values Returns Type Description TResult Case result Type Parameters Name Description T SQL case source data mapped type TResult SQL case result mapped type Exceptions Type Condition XDataRuntimeException Function accessible in XData LINQ expressions only | Improve this Doc View Source DateDiff<T>(IBlockQueryAdapter, Expression<Func<IBlockQueryAdapter, DateTime>>, Expression<Func<IBlockQueryAdapter, DateTime>>, DateDiffKind) Dates difference Declaration public static T DateDiff<T>(this IBlockQueryAdapter adapter, Expression<Func<IBlockQueryAdapter, DateTime>> finalDate, Expression<Func<IBlockQueryAdapter, DateTime>> startDate, DateDiffKind kind) Parameters Type Name Description IBlockQueryAdapter adapter Source query structure adapter Expression < Func < IBlockQueryAdapter , DateTime >> finalDate Final date Expression < Func < IBlockQueryAdapter , DateTime >> startDate Start date DateDiffKind kind Dates differences kind Returns Type Description T Dates difference Type Parameters Name Description T SQL function DateDiff result data mapped type Exceptions Type Condition XDataRuntimeException Function accessible in XData LINQ expressions only | Improve this Doc View Source ExecuteSqlBlock(IDataScope, Expression<SqlBlockDefinition>, Expression<Func<ISqlParamAdapter, ISqlParam>>[]) Execute SQL block Declaration public static QueryResult ExecuteSqlBlock(this IDataScope dataScope, Expression<SqlBlockDefinition> block, params Expression<Func<ISqlParamAdapter, ISqlParam>>[] parameters) Parameters Type Name Description IDataScope dataScope Data scope Expression < SqlBlockDefinition > block Sql block structure Expression < Func < ISqlParamAdapter , ISqlParam >>[] parameters Sql block parameters Returns Type Description QueryResult SQL block executed over database | Improve this Doc View Source Exists(IBlockQueryAdapter, String) Exists Declaration public static bool Exists(this IBlockQueryAdapter adapter, string subQueryAlias) Parameters Type Name Description IBlockQueryAdapter adapter Source query structure adapter String subQueryAlias Subquery alias Returns Type Description Boolean Exceptions Type Condition XDataRuntimeException Function accessible in XData LINQ expressions only | Improve this Doc View Source GetSqlBlockData<T>(IDataScope, Expression<SqlBlockDefinition<T>>, Expression<Func<ISqlParamAdapter, ISqlParam>>[]) Select SQL block data Declaration public static IEnumerable<T> GetSqlBlockData<T>(this IDataScope dataScope, Expression<SqlBlockDefinition<T>> block, params Expression<Func<ISqlParamAdapter, ISqlParam>>[] parameters) where T : class, new() Parameters Type Name Description IDataScope dataScope Data scope layer Expression < SqlBlockDefinition <T>> block Sql block structure Expression < Func < ISqlParamAdapter , ISqlParam >>[] parameters Sql block parameters Returns Type Description IEnumerable <T> SQL block data selected and mapped Type Parameters Name Description T SQL block result mapped type | Improve this Doc View Source HasFlag<T>(IBlockQueryAdapter, Expression<Func<IBlockQueryAdapter, T>>, Expression<Func<IBlockQueryAdapter, T>>, Expression<Func<IBlockQueryAdapter, T>>, Expression<Func<IBlockQueryAdapter, T>>) Bit mask has flag Declaration public static T HasFlag<T>(this IBlockQueryAdapter adapter, Expression<Func<IBlockQueryAdapter, T>> expression, Expression<Func<IBlockQueryAdapter, T>> flagValue, Expression<Func<IBlockQueryAdapter, T>> trueValue, Expression<Func<IBlockQueryAdapter, T>> falseValue) Parameters Type Name Description IBlockQueryAdapter adapter Source query structure adapter Expression < Func < IBlockQueryAdapter , T>> expression Expression to test Expression < Func < IBlockQueryAdapter , T>> flagValue Flag value Expression < Func < IBlockQueryAdapter , T>> trueValue Result if flag exists Expression < Func < IBlockQueryAdapter , T>> falseValue Result if flag not exists Returns Type Description T Bit mask has flag than trueValue else falseValue Type Parameters Name Description T SQL bitmask flag test result data mapped type Exceptions Type Condition XDataRuntimeException Function accessible in XData LINQ expressions only | Improve this Doc View Source SetExpression<TTag, TResult>(TTag, Expression<Func<IBlockQueryAdapter, TResult>>) Set expression to tag Declaration public static TaggedExpression<TTag, TResult> SetExpression<TTag, TResult>(this TTag key, Expression<Func<IBlockQueryAdapter, TResult>> expression) Parameters Type Name Description TTag key Tag value Expression < Func < IBlockQueryAdapter , TResult>> expression Expression Returns Type Description TaggedExpression <TTag, TResult> Tagged expression Type Parameters Name Description TTag Tag type TResult Expression result | Improve this Doc View Source SqlExpr<TResult>(IBlockQueryAdapter, String, Expression<Func<IBlockQueryAdapter, TResult>>[]) Plain SQL expression with XData LINQ expression placeholders Declaration public static TResult SqlExpr<TResult>(this IBlockQueryAdapter adapter, string format, params Expression<Func<IBlockQueryAdapter, TResult>>[] expressions) Parameters Type Name Description IBlockQueryAdapter adapter Source query structure adapter String format SQL expression body in Format(String, Object[]) style Expression < Func < IBlockQueryAdapter , TResult>>[] expressions XData LINQ parameter expressions Returns Type Description TResult SQL expression result Type Parameters Name Description TResult SQL expression result mapped type Remarks WARNING! Plain SQL expressions can use specific SQL dialect features! Data mapping may be not compatible with other database engines! Exceptions Type Condition XDataRuntimeException Function accessible in XData LINQ expressions only | Improve this Doc View Source SqlFn<TResult>(IBlockQueryAdapter, String, Expression<Func<IBlockQueryAdapter, Object>>[]) SQL function call Declaration public static TResult SqlFn<TResult>(this IBlockQueryAdapter adapter, string name, params Expression<Func<IBlockQueryAdapter, object>>[] parameters) Parameters Type Name Description IBlockQueryAdapter adapter Source query structure adapter String name SQL function full qualified name Expression < Func < IBlockQueryAdapter , Object >>[] parameters Function parameters descriptions Returns Type Description TResult Function call result Type Parameters Name Description TResult SQL function result mapped type Exceptions Type Condition XDataRuntimeException Function accessible in XData LINQ expressions only | Improve this Doc View Source SqlParam<TResult>(IBlockQueryAdapter, String, DbType, Expression<Func<IProcedureParameterAdapter, IProcedureParameterFlag>>[]) SQL parameter definition Declaration public static TResult SqlParam<TResult>(this IBlockQueryAdapter adapter, string binding, DbType type, params Expression<Func<IProcedureParameterAdapter, IProcedureParameterFlag>>[] attributes) Parameters Type Name Description IBlockQueryAdapter adapter Query structure adapter String binding Parameter data binding name DbType type Parameter database type Expression < Func < IProcedureParameterAdapter , IProcedureParameterFlag >>[] attributes Parameter mapping attributes Returns Type Description TResult Parameter Type Parameters Name Description TResult Parameter mapped type Exceptions Type Condition XDataRuntimeException Function accessible in XData LINQ expressions only"
  },
  "api/XData.Database.SqlBlock.SqlBlockDefinition.html": {
    "href": "api/XData.Database.SqlBlock.SqlBlockDefinition.html",
    "title": "Delegate SqlBlockDefinition | XData website",
    "keywords": "Delegate SqlBlockDefinition SQL block definition expression type Namespace : XData.Database.SqlBlock Assembly : XData.docfx.dll Syntax public delegate ISqlBlock SqlBlockDefinition(ISqlBlockAdapter adapter); Parameters Type Name Description ISqlBlockAdapter adapter SQL block adapter interface Returns Type Description ISqlBlock SQL block definition Extension Methods SerializationExtensions.ToXml<T>(T) CollectionsExtensions.SetValue<TKey, T>(TKey, T) CollectionsExtensions.AsEnum<T>(T) DataObjectQueryableExtensions.CompareVariable(Object, FilterOperation, String) Processing.Do<T>(T, Action<IProcess<T>>[]) TypeExtensions.TryConvert<T, TResult>(T, Func<T, TResult>) TypeExtensions.TryConvert<T, TResult>(T, Func<T, TResult>, TResult) TypeExtensions.ChangeType<T>(Object) TypeExtensions.ChangeType(Object, Type) TypeExtensions.InvokeMethod<TRet>(Object, Type[], Expression<Func<TRet>>, BindingFlags) TypeExtensions.InvokeMethod(Object, Type[], Expression<Action>, BindingFlags) TypeExtensions.InvokeMethod<TRet>(Object, Expression<Func<TRet>>, BindingFlags) TypeExtensions.InvokeMethod(Object, Expression<Action>, BindingFlags) SqlBlockExtensions.SetExpression<TTag, TResult>(TTag, Expression<Func<IBlockQueryAdapter, TResult>>) QueryDescriptionExtensions.SetExpression<TTag, TResult>(TTag, Expression<Func<IQueryStructureAdapter, TResult>>)"
  },
  "api/XData.Database.SqlBlock.ISqlParam.html": {
    "href": "api/XData.Database.SqlBlock.ISqlParam.html",
    "title": "Interface ISqlParam | XData website",
    "keywords": "Interface ISqlParam SQL block parameter interface Namespace : XData.Database.SqlBlock Assembly : XData.docfx.dll Syntax public interface ISqlParam Methods | Improve this Doc View Source Set<T>(T) Set SQL block parameter value Declaration ISqlParam Set<T>(T value) Parameters Type Name Description T value Parameter value Returns Type Description ISqlParam SQL block parameter Type Parameters Name Description T Type of parameter value Extension Methods SerializationExtensions.ToXml<T>(T) CollectionsExtensions.SetValue<TKey, T>(TKey, T) CollectionsExtensions.AsEnum<T>(T) DataObjectQueryableExtensions.CompareVariable(Object, FilterOperation, String) Processing.Do<T>(T, Action<IProcess<T>>[]) TypeExtensions.TryConvert<T, TResult>(T, Func<T, TResult>) TypeExtensions.TryConvert<T, TResult>(T, Func<T, TResult>, TResult) TypeExtensions.ChangeType<T>(Object) TypeExtensions.ChangeType(Object, Type) TypeExtensions.InvokeMethod<TRet>(Object, Type[], Expression<Func<TRet>>, BindingFlags) TypeExtensions.InvokeMethod(Object, Type[], Expression<Action>, BindingFlags) TypeExtensions.InvokeMethod<TRet>(Object, Expression<Func<TRet>>, BindingFlags) TypeExtensions.InvokeMethod(Object, Expression<Action>, BindingFlags) SqlBlockExtensions.SetExpression<TTag, TResult>(TTag, Expression<Func<IBlockQueryAdapter, TResult>>) QueryDescriptionExtensions.SetExpression<TTag, TResult>(TTag, Expression<Func<IQueryStructureAdapter, TResult>>)"
  },
  "api/XData.Database.Adapter.QueryParam.html": {
    "href": "api/XData.Database.Adapter.QueryParam.html",
    "title": "Class QueryParam | XData website",
    "keywords": "Class QueryParam SQL query parameter Inheritance Object QueryParam Inherited Members Object.Equals(Object) Object.Equals(Object, Object) Object.GetHashCode() Object.GetType() Object.MemberwiseClone() Object.ReferenceEquals(Object, Object) Namespace : XData.Database.Adapter Assembly : XData.docfx.dll Syntax public class QueryParam Constructors | Improve this Doc View Source QueryParam(String, Object, DbType, Int32) Query parameter constructor Declaration public QueryParam(string name, object value = null, DbType type = DbType.String, int length = 0) Parameters Type Name Description String name Parameter name Object value Parameter value DbType type Parameter data type Int32 length Parameter value max length | Improve this Doc View Source QueryParam(QueryParam, Object) Query parameter copy constructor Declaration public QueryParam(QueryParam param, object value = null) Parameters Type Name Description QueryParam param Parameter name Object value Parameter value Properties | Improve this Doc View Source Direction Parameter direction Declaration public ParameterDirection Direction { get; set; } Property Value Type Description ParameterDirection | Improve this Doc View Source IsArray Collection type array flag Set to true to use with VARARRAY collections WARNING! Using UDT can be not supported or limited by adapter! Declaration public bool IsArray { get; set; } Property Value Type Description Boolean | Improve this Doc View Source IsResultSet Parameter is result set Declaration public bool IsResultSet { get; set; } Property Value Type Description Boolean | Improve this Doc View Source Length Parameter value max length Declaration public int Length { get; } Property Value Type Description Int32 | Improve this Doc View Source Name Parameter name Declaration public string Name { get; } Property Value Type Description String | Improve this Doc View Source NativeSqlType Parameter native SQL type Declaration public string NativeSqlType { get; set; } Property Value Type Description String | Improve this Doc View Source Type Parameter data type Declaration public DbType Type { get; } Property Value Type Description DbType | Improve this Doc View Source UdtElementTypeName Single object (or collection element) user defined type (UDT) SQL type name WARNING! Specify full qualified type name! WARNING! Using UDT can be not supported or limited by adapter! Declaration public string UdtElementTypeName { get; set; } Property Value Type Description String | Improve this Doc View Source UdtMappedType Class type mapped with user defined type (UDT) SQL type name This type properties are mapped to SQL type by name (case insensitive) WARNING! Beware to use property data types not supported by adapter or user defined type (UDT)! WARNING! Using UDT can be not supported or limited by adapter! Declaration public Type UdtMappedType { get; set; } Property Value Type Description Type | Improve this Doc View Source UdtTypeName Collection user defined type (UDT) SQL type name WARNING! Specify full qualified type name! WARNING! Using UDT can be not supported or limited by adapter! Declaration public string UdtTypeName { get; set; } Property Value Type Description String | Improve this Doc View Source Value Parameter value Declaration public object Value { get; } Property Value Type Description Object Methods | Improve this Doc View Source ToString() Returns a String that represents the current Object . Declaration public override string ToString() Returns Type Description String A String that represents the current Object . Overrides Object.ToString() Extension Methods SerializationExtensions.ToXml<T>(T) CollectionsExtensions.SetValue<TKey, T>(TKey, T) CollectionsExtensions.AsEnum<T>(T) DataObjectQueryableExtensions.CompareVariable(Object, FilterOperation, String) Processing.Do<T>(T, Action<IProcess<T>>[]) TypeExtensions.TryConvert<T, TResult>(T, Func<T, TResult>) TypeExtensions.TryConvert<T, TResult>(T, Func<T, TResult>, TResult) TypeExtensions.ChangeType<T>(Object) TypeExtensions.ChangeType(Object, Type) TypeExtensions.InvokeMethod<TRet>(Object, Type[], Expression<Func<TRet>>, BindingFlags) TypeExtensions.InvokeMethod(Object, Type[], Expression<Action>, BindingFlags) TypeExtensions.InvokeMethod<TRet>(Object, Expression<Func<TRet>>, BindingFlags) TypeExtensions.InvokeMethod(Object, Expression<Action>, BindingFlags) SqlBlockExtensions.SetExpression<TTag, TResult>(TTag, Expression<Func<IBlockQueryAdapter, TResult>>) QueryDescriptionExtensions.SetExpression<TTag, TResult>(TTag, Expression<Func<IQueryStructureAdapter, TResult>>)"
  },
  "api/XData.ClearAttachedHandler.html": {
    "href": "api/XData.ClearAttachedHandler.html",
    "title": "Delegate ClearAttachedHandler | XData website",
    "keywords": "Delegate ClearAttachedHandler Clear attached handler delegate Namespace : XData Assembly : XData.docfx.dll Syntax public delegate bool ClearAttachedHandler(DataSubmitFlag flag = DataSubmitFlag.None); Parameters Type Name Description DataSubmitFlag flag Submit flag Returns Type Description Boolean Extension Methods SerializationExtensions.ToXml<T>(T) CollectionsExtensions.SetValue<TKey, T>(TKey, T) CollectionsExtensions.AsEnum<T>(T) DataObjectQueryableExtensions.CompareVariable(Object, FilterOperation, String) Processing.Do<T>(T, Action<IProcess<T>>[]) TypeExtensions.TryConvert<T, TResult>(T, Func<T, TResult>) TypeExtensions.TryConvert<T, TResult>(T, Func<T, TResult>, TResult) TypeExtensions.ChangeType<T>(Object) TypeExtensions.ChangeType(Object, Type) TypeExtensions.InvokeMethod<TRet>(Object, Type[], Expression<Func<TRet>>, BindingFlags) TypeExtensions.InvokeMethod(Object, Type[], Expression<Action>, BindingFlags) TypeExtensions.InvokeMethod<TRet>(Object, Expression<Func<TRet>>, BindingFlags) TypeExtensions.InvokeMethod(Object, Expression<Action>, BindingFlags) SqlBlockExtensions.SetExpression<TTag, TResult>(TTag, Expression<Func<IBlockQueryAdapter, TResult>>) QueryDescriptionExtensions.SetExpression<TTag, TResult>(TTag, Expression<Func<IQueryStructureAdapter, TResult>>)"
  },
  "api/XData.VariableIndexer.html": {
    "href": "api/XData.VariableIndexer.html",
    "title": "Class VariableIndexer | XData website",
    "keywords": "Class VariableIndexer Data object variables indexer Inheritance Object VariableIndexer Inherited Members Object.Equals(Object) Object.Equals(Object, Object) Object.GetHashCode() Object.GetType() Object.MemberwiseClone() Object.ReferenceEquals(Object, Object) Object.ToString() Namespace : XData Assembly : XData.docfx.dll Syntax public sealed class VariableIndexer Constructors | Improve this Doc View Source VariableIndexer(IEnumerable<Variable>) Variable indexer constructor Declaration public VariableIndexer(IEnumerable<Variable> variables) Parameters Type Name Description IEnumerable < Variable > variables Variables sequence Properties | Improve this Doc View Source Count Variables count Declaration public int Count { get; } Property Value Type Description Int32 | Improve this Doc View Source Item[String] Variable indexer Declaration public object this[string name] { get; } Parameters Type Name Description String name Variable name Property Value Type Description Object Variable Methods | Improve this Doc View Source Contains(String) Variables contains name Declaration public bool Contains(string name) Parameters Type Name Description String name Variable name Returns Type Description Boolean Contains flag | Improve this Doc View Source Set(IEnumerable<Variable>) Set variables values Declaration public VariableIndexer Set(IEnumerable<Variable> variables) Parameters Type Name Description IEnumerable < Variable > variables Variables sequence Returns Type Description VariableIndexer | Improve this Doc View Source Set(String, String) Set variable value Declaration public VariableIndexer Set(string name, string value) Parameters Type Name Description String name Variable name String value Variable value Returns Type Description VariableIndexer | Improve this Doc View Source Set(Variable) Set variable value Declaration public VariableIndexer Set(Variable variable) Parameters Type Name Description Variable variable Variable Returns Type Description VariableIndexer | Improve this Doc View Source Set(VariableIndexer) Set variables values Declaration public VariableIndexer Set(VariableIndexer variables) Parameters Type Name Description VariableIndexer variables Variable indexer Returns Type Description VariableIndexer Extension Methods SerializationExtensions.ToXml<T>(T) CollectionsExtensions.SetValue<TKey, T>(TKey, T) CollectionsExtensions.AsEnum<T>(T) DataObjectQueryableExtensions.CompareVariable(Object, FilterOperation, String) Processing.Do<T>(T, Action<IProcess<T>>[]) TypeExtensions.TryConvert<T, TResult>(T, Func<T, TResult>) TypeExtensions.TryConvert<T, TResult>(T, Func<T, TResult>, TResult) TypeExtensions.ChangeType<T>(Object) TypeExtensions.ChangeType(Object, Type) TypeExtensions.InvokeMethod<TRet>(Object, Type[], Expression<Func<TRet>>, BindingFlags) TypeExtensions.InvokeMethod(Object, Type[], Expression<Action>, BindingFlags) TypeExtensions.InvokeMethod<TRet>(Object, Expression<Func<TRet>>, BindingFlags) TypeExtensions.InvokeMethod(Object, Expression<Action>, BindingFlags) SqlBlockExtensions.SetExpression<TTag, TResult>(TTag, Expression<Func<IBlockQueryAdapter, TResult>>) QueryDescriptionExtensions.SetExpression<TTag, TResult>(TTag, Expression<Func<IQueryStructureAdapter, TResult>>)"
  },
  "api/XData.Mapping.WithAttribute.html": {
    "href": "api/XData.Mapping.WithAttribute.html",
    "title": "Class WithAttribute | XData website",
    "keywords": "Class WithAttribute Common-Table-Expression (WITH) Subquery data source Inheritance Object Attribute DataSourceAttribute WithAttribute Inherited Members Attribute.Equals(Object) Attribute.GetCustomAttribute(Assembly, Type) Attribute.GetCustomAttribute(Assembly, Type, Boolean) Attribute.GetCustomAttribute(MemberInfo, Type) Attribute.GetCustomAttribute(MemberInfo, Type, Boolean) Attribute.GetCustomAttribute(Module, Type) Attribute.GetCustomAttribute(Module, Type, Boolean) Attribute.GetCustomAttribute(ParameterInfo, Type) Attribute.GetCustomAttribute(ParameterInfo, Type, Boolean) Attribute.GetCustomAttributes(Assembly) Attribute.GetCustomAttributes(Assembly, Boolean) Attribute.GetCustomAttributes(Assembly, Type) Attribute.GetCustomAttributes(Assembly, Type, Boolean) Attribute.GetCustomAttributes(MemberInfo) Attribute.GetCustomAttributes(MemberInfo, Boolean) Attribute.GetCustomAttributes(MemberInfo, Type) Attribute.GetCustomAttributes(MemberInfo, Type, Boolean) Attribute.GetCustomAttributes(Module) Attribute.GetCustomAttributes(Module, Boolean) Attribute.GetCustomAttributes(Module, Type) Attribute.GetCustomAttributes(Module, Type, Boolean) Attribute.GetCustomAttributes(ParameterInfo) Attribute.GetCustomAttributes(ParameterInfo, Boolean) Attribute.GetCustomAttributes(ParameterInfo, Type) Attribute.GetCustomAttributes(ParameterInfo, Type, Boolean) Attribute.GetHashCode() Attribute.IsDefaultAttribute() Attribute.IsDefined(Assembly, Type) Attribute.IsDefined(Assembly, Type, Boolean) Attribute.IsDefined(MemberInfo, Type) Attribute.IsDefined(MemberInfo, Type, Boolean) Attribute.IsDefined(Module, Type) Attribute.IsDefined(Module, Type, Boolean) Attribute.IsDefined(ParameterInfo, Type) Attribute.IsDefined(ParameterInfo, Type, Boolean) Attribute.Match(Object) Object.Equals(Object, Object) Object.GetType() Object.MemberwiseClone() Object.ReferenceEquals(Object, Object) Object.ToString() Namespace : XData.Mapping Assembly : XData.docfx.dll Syntax public sealed class WithAttribute : DataSourceAttribute Constructors | Improve this Doc View Source WithAttribute(String, Type, WithRecursiveType, String[]) Common-Table-Expression (WITH) Subquery data source constructor Declaration public WithAttribute(string alias, Type subqueryType, WithRecursiveType withType = WithRecursiveType.RecursiveUnion, params string[] properties) Parameters Type Name Description String alias Common-Table-Expression alias Type subqueryType Subquery type WithRecursiveType withType Recursive connection type (if applicable) String [] properties Common-Table-Expression (WITH) Subquery property order Properties | Improve this Doc View Source Alias Data source alias Declaration public override string Alias { get; protected set; } Property Value Type Description String Overrides DataSourceAttribute.Alias | Improve this Doc View Source Properties Common-Table-Expression (WITH) Subquery property order Declaration public string[] Properties { get; } Property Value Type Description String [] | Improve this Doc View Source SubqueryType Subquery type Declaration public Type SubqueryType { get; } Property Value Type Description Type | Improve this Doc View Source Type Data source type Declaration public override DataSourceType Type { get; } Property Value Type Description DataSourceType Overrides DataSourceAttribute.Type | Improve this Doc View Source TypeId When implemented in a derived class, gets a unique identifier for this Attribute . Declaration public override object TypeId { get; } Property Value Type Description Object An Object that is a unique identifier for the attribute. Overrides Attribute.TypeId | Improve this Doc View Source WithType Common-Table-Expression (WITH) Subquery type Declaration public WithRecursiveType WithType { get; } Property Value Type Description WithRecursiveType Extension Methods SerializationExtensions.ToXml<T>(T) CollectionsExtensions.SetValue<TKey, T>(TKey, T) CollectionsExtensions.AsEnum<T>(T) DataObjectQueryableExtensions.CompareVariable(Object, FilterOperation, String) Processing.Do<T>(T, Action<IProcess<T>>[]) TypeExtensions.TryConvert<T, TResult>(T, Func<T, TResult>) TypeExtensions.TryConvert<T, TResult>(T, Func<T, TResult>, TResult) TypeExtensions.ChangeType<T>(Object) TypeExtensions.ChangeType(Object, Type) TypeExtensions.InvokeMethod<TRet>(Object, Type[], Expression<Func<TRet>>, BindingFlags) TypeExtensions.InvokeMethod(Object, Type[], Expression<Action>, BindingFlags) TypeExtensions.InvokeMethod<TRet>(Object, Expression<Func<TRet>>, BindingFlags) TypeExtensions.InvokeMethod(Object, Expression<Action>, BindingFlags) SqlBlockExtensions.SetExpression<TTag, TResult>(TTag, Expression<Func<IBlockQueryAdapter, TResult>>) QueryDescriptionExtensions.SetExpression<TTag, TResult>(TTag, Expression<Func<IQueryStructureAdapter, TResult>>)"
  },
  "api/XData.Mapping.Dynamic.IFilterDescription.html": {
    "href": "api/XData.Mapping.Dynamic.IFilterDescription.html",
    "title": "Interface IFilterDescription | XData website",
    "keywords": "Interface IFilterDescription Dynamic query filter description Namespace : XData.Mapping.Dynamic Assembly : XData.docfx.dll Syntax public interface IFilterDescription Extension Methods SerializationExtensions.ToXml<T>(T) CollectionsExtensions.SetValue<TKey, T>(TKey, T) CollectionsExtensions.AsEnum<T>(T) DataObjectQueryableExtensions.CompareVariable(Object, FilterOperation, String) Processing.Do<T>(T, Action<IProcess<T>>[]) TypeExtensions.TryConvert<T, TResult>(T, Func<T, TResult>) TypeExtensions.TryConvert<T, TResult>(T, Func<T, TResult>, TResult) TypeExtensions.ChangeType<T>(Object) TypeExtensions.ChangeType(Object, Type) TypeExtensions.InvokeMethod<TRet>(Object, Type[], Expression<Func<TRet>>, BindingFlags) TypeExtensions.InvokeMethod(Object, Type[], Expression<Action>, BindingFlags) TypeExtensions.InvokeMethod<TRet>(Object, Expression<Func<TRet>>, BindingFlags) TypeExtensions.InvokeMethod(Object, Expression<Action>, BindingFlags) SqlBlockExtensions.SetExpression<TTag, TResult>(TTag, Expression<Func<IBlockQueryAdapter, TResult>>) QueryDescriptionExtensions.SetOperation<T>(T, FilterOperation) QueryDescriptionExtensions.AsPrimary<T>(T) QueryDescriptionExtensions.SetCombination<T>(T, String) QueryDescriptionExtensions.SetExpression<TTag, TResult>(TTag, Expression<Func<IQueryStructureAdapter, TResult>>)"
  },
  "api/XData.Mapping.Dynamic.IFilterAdapter.html": {
    "href": "api/XData.Mapping.Dynamic.IFilterAdapter.html",
    "title": "Interface IFilterAdapter | XData website",
    "keywords": "Interface IFilterAdapter Filter description adapter Namespace : XData.Mapping.Dynamic Assembly : XData.docfx.dll Syntax public interface IFilterAdapter Methods | Improve this Doc View Source Combination(String, Combination) Filter combination description Declaration IFilterDescription Combination(string name, Combination combination) Parameters Type Name Description String name Filter combination name Combination combination Filter combination logic Returns Type Description IFilterDescription Filter description | Improve this Doc View Source Combination(String, Combination, String) Filter combination description Declaration IFilterDescription Combination(string name, Combination combination, string parent) Parameters Type Name Description String name Filter combination name Combination combination Filter combination logic String parent Parent filter combination name Returns Type Description IFilterDescription Filter description Extension Methods SerializationExtensions.ToXml<T>(T) CollectionsExtensions.SetValue<TKey, T>(TKey, T) CollectionsExtensions.AsEnum<T>(T) DataObjectQueryableExtensions.CompareVariable(Object, FilterOperation, String) Processing.Do<T>(T, Action<IProcess<T>>[]) TypeExtensions.TryConvert<T, TResult>(T, Func<T, TResult>) TypeExtensions.TryConvert<T, TResult>(T, Func<T, TResult>, TResult) TypeExtensions.ChangeType<T>(Object) TypeExtensions.ChangeType(Object, Type) TypeExtensions.InvokeMethod<TRet>(Object, Type[], Expression<Func<TRet>>, BindingFlags) TypeExtensions.InvokeMethod(Object, Type[], Expression<Action>, BindingFlags) TypeExtensions.InvokeMethod<TRet>(Object, Expression<Func<TRet>>, BindingFlags) TypeExtensions.InvokeMethod(Object, Expression<Action>, BindingFlags) SqlBlockExtensions.SetExpression<TTag, TResult>(TTag, Expression<Func<IBlockQueryAdapter, TResult>>) QueryDescriptionExtensions.SetExpression<TTag, TResult>(TTag, Expression<Func<IQueryStructureAdapter, TResult>>)"
  },
  "api/XData.Mapping.Dynamic.IExternalLinkFlag.html": {
    "href": "api/XData.Mapping.Dynamic.IExternalLinkFlag.html",
    "title": "Interface IExternalLinkFlag | XData website",
    "keywords": "Interface IExternalLinkFlag Dynamic structure external link flag interface Namespace : XData.Mapping.Dynamic Assembly : XData.docfx.dll Syntax public interface IExternalLinkFlag Extension Methods SerializationExtensions.ToXml<T>(T) CollectionsExtensions.SetValue<TKey, T>(TKey, T) CollectionsExtensions.AsEnum<T>(T) DataObjectQueryableExtensions.CompareVariable(Object, FilterOperation, String) Processing.Do<T>(T, Action<IProcess<T>>[]) TypeExtensions.TryConvert<T, TResult>(T, Func<T, TResult>) TypeExtensions.TryConvert<T, TResult>(T, Func<T, TResult>, TResult) TypeExtensions.ChangeType<T>(Object) TypeExtensions.ChangeType(Object, Type) TypeExtensions.InvokeMethod<TRet>(Object, Type[], Expression<Func<TRet>>, BindingFlags) TypeExtensions.InvokeMethod(Object, Type[], Expression<Action>, BindingFlags) TypeExtensions.InvokeMethod<TRet>(Object, Expression<Func<TRet>>, BindingFlags) TypeExtensions.InvokeMethod(Object, Expression<Action>, BindingFlags) SqlBlockExtensions.SetExpression<TTag, TResult>(TTag, Expression<Func<IBlockQueryAdapter, TResult>>) QueryDescriptionExtensions.SetExpression<TTag, TResult>(TTag, Expression<Func<IQueryStructureAdapter, TResult>>)"
  },
  "api/XData.IWorkScope-1.html": {
    "href": "api/XData.IWorkScope-1.html",
    "title": "Interface IWorkScope<T> | XData website",
    "keywords": "Interface IWorkScope<T> Work set export/apply child object structure descriptor interface Namespace : XData Assembly : XData.WorkSet.docfx.dll Syntax public interface IWorkScope<T> Type Parameters Name Description T Parent object type Methods | Improve this Doc View Source With<TChild>(Expression<Func<T, TChild[]>>, Expression<Func<TChild, Guid>>) Work set export/apply child object structure descriptor Declaration IWorkScope<T> With<TChild>(Expression<Func<T, TChild[]>> childProperty, Expression<Func<TChild, Guid>> keyProperty) Parameters Type Name Description Expression < Func <T, TChild[]>> childProperty Child array property Expression < Func <TChild, Guid >> keyProperty Child work set key property Returns Type Description IWorkScope <T> Structure descriptor Type Parameters Name Description TChild Child object type | Improve this Doc View Source With<TChild>(Expression<Func<T, TChild[]>>, Expression<Func<TChild, Guid>>, Expression<Func<TChild, Boolean>>) Work set export/apply child object structure descriptor Declaration IWorkScope<T> With<TChild>(Expression<Func<T, TChild[]>> childProperty, Expression<Func<TChild, Guid>> keyProperty, Expression<Func<TChild, bool>> deletedProperty) Parameters Type Name Description Expression < Func <T, TChild[]>> childProperty Child array property Expression < Func <TChild, Guid >> keyProperty Child work set key property Expression < Func <TChild, Boolean >> deletedProperty Child deleted flag property Returns Type Description IWorkScope <T> Structure descriptor Type Parameters Name Description TChild Child object type | Improve this Doc View Source With<TChild>(Expression<Func<T, TChild[]>>, Expression<Func<TChild, Guid>>, Expression<Func<TChild, Boolean>>, Expression<Func<IWorkScope<TChild>, IWorkScope<TChild>>>) Work set export/apply child object structure descriptor Declaration IWorkScope<T> With<TChild>(Expression<Func<T, TChild[]>> childProperty, Expression<Func<TChild, Guid>> keyProperty, Expression<Func<TChild, bool>> deletedProperty, Expression<Func<IWorkScope<TChild>, IWorkScope<TChild>>> childs) Parameters Type Name Description Expression < Func <T, TChild[]>> childProperty Child array property Expression < Func <TChild, Guid >> keyProperty Child work set key property Expression < Func <TChild, Boolean >> deletedProperty Child deleted flag property Expression < Func < IWorkScope <TChild>, IWorkScope <TChild>>> childs Childs structure descriptor Returns Type Description IWorkScope <T> Structure descriptor Type Parameters Name Description TChild Child object type | Improve this Doc View Source With<TChild>(Expression<Func<T, TChild[]>>, Expression<Func<TChild, Guid>>, Expression<Func<TChild, Boolean>>, String) Work set export/apply child object structure descriptor Declaration IWorkScope<T> With<TChild>(Expression<Func<T, TChild[]>> childProperty, Expression<Func<TChild, Guid>> keyProperty, Expression<Func<TChild, bool>> deletedProperty, string alias) Parameters Type Name Description Expression < Func <T, TChild[]>> childProperty Child array property Expression < Func <TChild, Guid >> keyProperty Child work set key property Expression < Func <TChild, Boolean >> deletedProperty Child deleted flag property String alias Child repository alias Returns Type Description IWorkScope <T> Structure descriptor Type Parameters Name Description TChild Child object type | Improve this Doc View Source With<TChild>(Expression<Func<T, TChild[]>>, Expression<Func<TChild, Guid>>, Expression<Func<TChild, Boolean>>, String, Expression<Func<IWorkScope<TChild>, IWorkScope<TChild>>>) Work set export/apply child object structure descriptor Declaration IWorkScope<T> With<TChild>(Expression<Func<T, TChild[]>> childProperty, Expression<Func<TChild, Guid>> keyProperty, Expression<Func<TChild, bool>> deletedProperty, string alias, Expression<Func<IWorkScope<TChild>, IWorkScope<TChild>>> childs) Parameters Type Name Description Expression < Func <T, TChild[]>> childProperty Child array property Expression < Func <TChild, Guid >> keyProperty Child work set key property Expression < Func <TChild, Boolean >> deletedProperty Child deleted flag property String alias Child repository alias Expression < Func < IWorkScope <TChild>, IWorkScope <TChild>>> childs Childs structure descriptor Returns Type Description IWorkScope <T> Structure descriptor Type Parameters Name Description TChild Child object type | Improve this Doc View Source With<TChild>(Expression<Func<T, TChild[]>>, Expression<Func<TChild, Guid>>, Expression<Func<IWorkScope<TChild>, IWorkScope<TChild>>>) Work set export/apply child object structure descriptor Declaration IWorkScope<T> With<TChild>(Expression<Func<T, TChild[]>> childProperty, Expression<Func<TChild, Guid>> keyProperty, Expression<Func<IWorkScope<TChild>, IWorkScope<TChild>>> childs) Parameters Type Name Description Expression < Func <T, TChild[]>> childProperty Child array property Expression < Func <TChild, Guid >> keyProperty Child work set key property Expression < Func < IWorkScope <TChild>, IWorkScope <TChild>>> childs Childs structure descriptor Returns Type Description IWorkScope <T> Structure descriptor Type Parameters Name Description TChild Child object type | Improve this Doc View Source With<TChild>(Expression<Func<T, TChild[]>>, Expression<Func<TChild, Guid>>, String) Work set export/apply child object structure descriptor Declaration IWorkScope<T> With<TChild>(Expression<Func<T, TChild[]>> childProperty, Expression<Func<TChild, Guid>> keyProperty, string alias) Parameters Type Name Description Expression < Func <T, TChild[]>> childProperty Child array property Expression < Func <TChild, Guid >> keyProperty Child work set key property String alias Child repository alias Returns Type Description IWorkScope <T> Structure descriptor Type Parameters Name Description TChild Child object type | Improve this Doc View Source With<TChild>(Expression<Func<T, TChild[]>>, Expression<Func<TChild, Guid>>, String, Expression<Func<IWorkScope<TChild>, IWorkScope<TChild>>>) Work set export/apply child object structure descriptor Declaration IWorkScope<T> With<TChild>(Expression<Func<T, TChild[]>> childProperty, Expression<Func<TChild, Guid>> keyProperty, string alias, Expression<Func<IWorkScope<TChild>, IWorkScope<TChild>>> childs) Parameters Type Name Description Expression < Func <T, TChild[]>> childProperty Child array property Expression < Func <TChild, Guid >> keyProperty Child work set key property String alias Child repository alias Expression < Func < IWorkScope <TChild>, IWorkScope <TChild>>> childs Childs structure descriptor Returns Type Description IWorkScope <T> Structure descriptor Type Parameters Name Description TChild Child object type | Improve this Doc View Source With<TChild>(Expression<Func<T, TChild>>, Expression<Func<TChild, Guid>>) Work set export/apply child object structure descriptor Declaration IWorkScope<T> With<TChild>(Expression<Func<T, TChild>> childProperty, Expression<Func<TChild, Guid>> keyProperty) Parameters Type Name Description Expression < Func <T, TChild>> childProperty Single child property Expression < Func <TChild, Guid >> keyProperty Child work set key property Returns Type Description IWorkScope <T> Structure descriptor Type Parameters Name Description TChild Child object type | Improve this Doc View Source With<TChild>(Expression<Func<T, TChild>>, Expression<Func<TChild, Guid>>, Expression<Func<TChild, Boolean>>) Work set export/apply child object structure descriptor Declaration IWorkScope<T> With<TChild>(Expression<Func<T, TChild>> childProperty, Expression<Func<TChild, Guid>> keyProperty, Expression<Func<TChild, bool>> deletedProperty) Parameters Type Name Description Expression < Func <T, TChild>> childProperty Single child property Expression < Func <TChild, Guid >> keyProperty Child work set key property Expression < Func <TChild, Boolean >> deletedProperty Child deleted flag property Returns Type Description IWorkScope <T> Structure descriptor Type Parameters Name Description TChild Child object type | Improve this Doc View Source With<TChild>(Expression<Func<T, TChild>>, Expression<Func<TChild, Guid>>, Expression<Func<TChild, Boolean>>, Expression<Func<IWorkScope<TChild>, IWorkScope<TChild>>>) Work set export/apply child object structure descriptor Declaration IWorkScope<T> With<TChild>(Expression<Func<T, TChild>> childProperty, Expression<Func<TChild, Guid>> keyProperty, Expression<Func<TChild, bool>> deletedProperty, Expression<Func<IWorkScope<TChild>, IWorkScope<TChild>>> childs) Parameters Type Name Description Expression < Func <T, TChild>> childProperty Single child property Expression < Func <TChild, Guid >> keyProperty Child work set key property Expression < Func <TChild, Boolean >> deletedProperty Child deleted flag property Expression < Func < IWorkScope <TChild>, IWorkScope <TChild>>> childs Childs structure descriptor Returns Type Description IWorkScope <T> Structure descriptor Type Parameters Name Description TChild Child object type | Improve this Doc View Source With<TChild>(Expression<Func<T, TChild>>, Expression<Func<TChild, Guid>>, Expression<Func<TChild, Boolean>>, String) Work set export/apply child object structure descriptor Declaration IWorkScope<T> With<TChild>(Expression<Func<T, TChild>> childProperty, Expression<Func<TChild, Guid>> keyProperty, Expression<Func<TChild, bool>> deletedProperty, string alias) Parameters Type Name Description Expression < Func <T, TChild>> childProperty Single child property Expression < Func <TChild, Guid >> keyProperty Child work set key property Expression < Func <TChild, Boolean >> deletedProperty Child deleted flag property String alias Child repository alias Returns Type Description IWorkScope <T> Structure descriptor Type Parameters Name Description TChild Child object type | Improve this Doc View Source With<TChild>(Expression<Func<T, TChild>>, Expression<Func<TChild, Guid>>, Expression<Func<TChild, Boolean>>, String, Expression<Func<IWorkScope<TChild>, IWorkScope<TChild>>>) Work set export/apply child object structure descriptor Declaration IWorkScope<T> With<TChild>(Expression<Func<T, TChild>> childProperty, Expression<Func<TChild, Guid>> keyProperty, Expression<Func<TChild, bool>> deletedProperty, string alias, Expression<Func<IWorkScope<TChild>, IWorkScope<TChild>>> childs) Parameters Type Name Description Expression < Func <T, TChild>> childProperty Single child property Expression < Func <TChild, Guid >> keyProperty Child work set key property Expression < Func <TChild, Boolean >> deletedProperty Child deleted flag property String alias Child repository alias Expression < Func < IWorkScope <TChild>, IWorkScope <TChild>>> childs Childs structure descriptor Returns Type Description IWorkScope <T> Structure descriptor Type Parameters Name Description TChild Child object type | Improve this Doc View Source With<TChild>(Expression<Func<T, TChild>>, Expression<Func<TChild, Guid>>, Expression<Func<IWorkScope<TChild>, IWorkScope<TChild>>>) Work set export/apply child object structure descriptor Declaration IWorkScope<T> With<TChild>(Expression<Func<T, TChild>> childProperty, Expression<Func<TChild, Guid>> keyProperty, Expression<Func<IWorkScope<TChild>, IWorkScope<TChild>>> childs) Parameters Type Name Description Expression < Func <T, TChild>> childProperty Single child property Expression < Func <TChild, Guid >> keyProperty Child work set key property Expression < Func < IWorkScope <TChild>, IWorkScope <TChild>>> childs Childs structure descriptor Returns Type Description IWorkScope <T> Structure descriptor Type Parameters Name Description TChild Child object type | Improve this Doc View Source With<TChild>(Expression<Func<T, TChild>>, Expression<Func<TChild, Guid>>, String) Work set export/apply child object structure descriptor Declaration IWorkScope<T> With<TChild>(Expression<Func<T, TChild>> childProperty, Expression<Func<TChild, Guid>> keyProperty, string alias) Parameters Type Name Description Expression < Func <T, TChild>> childProperty Single child property Expression < Func <TChild, Guid >> keyProperty Child work set key property String alias Child repository alias Returns Type Description IWorkScope <T> Structure descriptor Type Parameters Name Description TChild Child object type | Improve this Doc View Source With<TChild>(Expression<Func<T, TChild>>, Expression<Func<TChild, Guid>>, String, Expression<Func<IWorkScope<TChild>, IWorkScope<TChild>>>) Work set export/apply child object structure descriptor Declaration IWorkScope<T> With<TChild>(Expression<Func<T, TChild>> childProperty, Expression<Func<TChild, Guid>> keyProperty, string alias, Expression<Func<IWorkScope<TChild>, IWorkScope<TChild>>> childs) Parameters Type Name Description Expression < Func <T, TChild>> childProperty Single child property Expression < Func <TChild, Guid >> keyProperty Child work set key property String alias Child repository alias Expression < Func < IWorkScope <TChild>, IWorkScope <TChild>>> childs Childs structure descriptor Returns Type Description IWorkScope <T> Structure descriptor Type Parameters Name Description TChild Child object type Extension Methods SerializationExtensions.ToXml<T>(T) CollectionsExtensions.SetValue<TKey, T>(TKey, T) CollectionsExtensions.AsEnum<T>(T) DataObjectQueryableExtensions.CompareVariable(Object, FilterOperation, String) Processing.Do<T>(T, Action<IProcess<T>>[]) TypeExtensions.TryConvert<T, TResult>(T, Func<T, TResult>) TypeExtensions.TryConvert<T, TResult>(T, Func<T, TResult>, TResult) TypeExtensions.ChangeType<T>(Object) TypeExtensions.ChangeType(Object, Type) TypeExtensions.InvokeMethod<TRet>(Object, Type[], Expression<Func<TRet>>, BindingFlags) TypeExtensions.InvokeMethod(Object, Type[], Expression<Action>, BindingFlags) TypeExtensions.InvokeMethod<TRet>(Object, Expression<Func<TRet>>, BindingFlags) TypeExtensions.InvokeMethod(Object, Expression<Action>, BindingFlags) SqlBlockExtensions.SetExpression<TTag, TResult>(TTag, Expression<Func<IBlockQueryAdapter, TResult>>) QueryDescriptionExtensions.SetExpression<TTag, TResult>(TTag, Expression<Func<IQueryStructureAdapter, TResult>>) See Also Root<T>(Expression<Func<T, Guid>>, Expression<Func<T, Guid>>) Export<TRoot>(Guid, Guid, Expression<Func<IWorkScope<TRoot>>>) Apply<TRoot>(TRoot, Expression<Func<IWorkScope<TRoot>>>)"
  },
  "api/XData.ISqlObject.html": {
    "href": "api/XData.ISqlObject.html",
    "title": "Interface ISqlObject | XData website",
    "keywords": "Interface ISqlObject SQL (sub)query part interface Namespace : XData Assembly : XData.docfx.dll Syntax public interface ISqlObject Remarks Mapping object as subquery Hint: Use abstract classes to map subquery Extension Methods SerializationExtensions.ToXml<T>(T) CollectionsExtensions.SetValue<TKey, T>(TKey, T) CollectionsExtensions.AsEnum<T>(T) DataObjectQueryableExtensions.CompareVariable(Object, FilterOperation, String) Processing.Do<T>(T, Action<IProcess<T>>[]) TypeExtensions.TryConvert<T, TResult>(T, Func<T, TResult>) TypeExtensions.TryConvert<T, TResult>(T, Func<T, TResult>, TResult) TypeExtensions.ChangeType<T>(Object) TypeExtensions.ChangeType(Object, Type) TypeExtensions.InvokeMethod<TRet>(Object, Type[], Expression<Func<TRet>>, BindingFlags) TypeExtensions.InvokeMethod(Object, Type[], Expression<Action>, BindingFlags) TypeExtensions.InvokeMethod<TRet>(Object, Expression<Func<TRet>>, BindingFlags) TypeExtensions.InvokeMethod(Object, Expression<Action>, BindingFlags) SqlBlockExtensions.SetExpression<TTag, TResult>(TTag, Expression<Func<IBlockQueryAdapter, TResult>>) QueryDescriptionExtensions.SetExpression<TTag, TResult>(TTag, Expression<Func<IQueryStructureAdapter, TResult>>) QueryDescriptionExtensions.GetProperty(ISqlObject, String)"
  },
  "api/XData.Interfaces.ContextConfig.html": {
    "href": "api/XData.Interfaces.ContextConfig.html",
    "title": "Class ContextConfig | XData website",
    "keywords": "Class ContextConfig Context config section Inheritance Object ContextConfig Inherited Members Object.Equals(Object) Object.Equals(Object, Object) Object.GetHashCode() Object.GetType() Object.MemberwiseClone() Object.ReferenceEquals(Object, Object) Namespace : XData.Interfaces Assembly : XData.docfx.dll Syntax public sealed class ContextConfig Remarks WARNING! All attributes are required! Examples <context name=\"TEST\" adapter=\"MSSQL\"/> Properties | Improve this Doc View Source AdapterName Context adapter name Declaration public string AdapterName { get; set; } Property Value Type Description String Remarks Mast be the same as Name | Improve this Doc View Source ConcurrencyErrorId Concurrency error id Declaration public string ConcurrencyErrorId { get; set; } Property Value Type Description String | Improve this Doc View Source ConnectionString Connection string Declaration public string ConnectionString { get; set; } Property Value Type Description String Remarks Received from ConnectionStrings configuration section by name same as Name | Improve this Doc View Source DialectName Dialect adapter name Declaration public string DialectName { get; set; } Property Value Type Description String Remarks Mast be the same as Name | Improve this Doc View Source IsDefault Default context flag Declaration public bool IsDefault { get; set; } Property Value Type Description Boolean | Improve this Doc View Source Name Context name Declaration public string Name { get; set; } Property Value Type Description String | Improve this Doc View Source SequenceNameRule Sequence name rule class name Declaration public string SequenceNameRule { get; set; } Property Value Type Description String Methods | Improve this Doc View Source ToString() Returns a string that represents the current object. Declaration public override string ToString() Returns Type Description String A string that represents the current object. Overrides Object.ToString() Extension Methods SerializationExtensions.ToXml<T>(T) CollectionsExtensions.SetValue<TKey, T>(TKey, T) CollectionsExtensions.AsEnum<T>(T) DataObjectQueryableExtensions.CompareVariable(Object, FilterOperation, String) Processing.Do<T>(T, Action<IProcess<T>>[]) TypeExtensions.TryConvert<T, TResult>(T, Func<T, TResult>) TypeExtensions.TryConvert<T, TResult>(T, Func<T, TResult>, TResult) TypeExtensions.ChangeType<T>(Object) TypeExtensions.ChangeType(Object, Type) TypeExtensions.InvokeMethod<TRet>(Object, Type[], Expression<Func<TRet>>, BindingFlags) TypeExtensions.InvokeMethod(Object, Type[], Expression<Action>, BindingFlags) TypeExtensions.InvokeMethod<TRet>(Object, Expression<Func<TRet>>, BindingFlags) TypeExtensions.InvokeMethod(Object, Expression<Action>, BindingFlags) SqlBlockExtensions.SetExpression<TTag, TResult>(TTag, Expression<Func<IBlockQueryAdapter, TResult>>) QueryDescriptionExtensions.SetExpression<TTag, TResult>(TTag, Expression<Func<IQueryStructureAdapter, TResult>>) See Also Name AdapterName ConnectionString IsDefault SequenceNameRule"
  },
  "api/XData.IDataOptions.html": {
    "href": "api/XData.IDataOptions.html",
    "title": "Interface IDataOptions | XData website",
    "keywords": "Interface IDataOptions XData options interface Namespace : XData Assembly : XData.docfx.dll Syntax public interface IDataOptions Methods | Improve this Doc View Source AddAdapter(String, String, IConfiguration) Add supported SQL adapter description Declaration IDataOptions AddAdapter(string name, string assemblyName, IConfiguration options = null) Parameters Type Name Description String name Adapter name String assemblyName Assembly name of adapter plugin IConfiguration options Adapter options (xml) see concrete adapter readme for details Returns Type Description IDataOptions XData options interface | Improve this Doc View Source AddContext(String, String, String, String, Boolean, String, String) Add context description Declaration IDataOptions AddContext(string name, string dialect, string adapter, string connectionString, bool isDefault, string sequence = null, string concurrencyErrorId = null) Parameters Type Name Description String name Context name String dialect Dialect name String adapter Adapter or proxy name String connectionString Connection string Boolean isDefault Default context flag String sequence (optional) Assembly qualified type name implements ISequenceNameRule String concurrencyErrorId (optional) Concurrency error id Returns Type Description IDataOptions XData options interface | Improve this Doc View Source AddDialect(String, String, IConfiguration) Add supported SQL dialect description Declaration IDataOptions AddDialect(string name, string assemblyName, IConfiguration options = null) Parameters Type Name Description String name Dialect name String assemblyName Assembly name of dialect plugin IConfiguration options Dialect options (xml) see concrete dialect readme for details Returns Type Description IDataOptions XData options interface | Improve this Doc View Source AddProxy(String, String) Add proxy adapter description Declaration IDataOptions AddProxy(string name, string endpoint) Parameters Type Name Description String name Proxy name String endpoint WCF client endpoint name Returns Type Description IDataOptions XData options interface | Improve this Doc View Source SetLifeTmeLimit(Int32) Set XData cache lifetime limit in minutes Declaration IDataOptions SetLifeTmeLimit(int minutes) Parameters Type Name Description Int32 minutes XData cache lifetime limit Returns Type Description IDataOptions XData options interface | Improve this Doc View Source SetMonitoringContext(String) Set monitoring context (optional, manual configuration) Declaration IDataOptions SetMonitoringContext(string monitoringContext) Parameters Type Name Description String monitoringContext Returns Type Description IDataOptions XData options interface | Improve this Doc View Source SetSecurityContext(String) Set security context (optional, manual configuration) Declaration IDataOptions SetSecurityContext(string securityContext) Parameters Type Name Description String securityContext Security context Returns Type Description IDataOptions XData options interface | Improve this Doc View Source UseCredentials(String, KeyValuePair<CredentialsType, String>[]) Set database credentials Declaration IDataOptions UseCredentials(string context, params KeyValuePair<CredentialsType, string>[] credentials) Parameters Type Name Description String context Context name KeyValuePair < CredentialsType , String >[] credentials Credentials Returns Type Description IDataOptions XData options interface Extension Methods SerializationExtensions.ToXml<T>(T) CollectionsExtensions.SetValue<TKey, T>(TKey, T) CollectionsExtensions.AsEnum<T>(T) DataObjectQueryableExtensions.CompareVariable(Object, FilterOperation, String) Processing.Do<T>(T, Action<IProcess<T>>[]) TypeExtensions.TryConvert<T, TResult>(T, Func<T, TResult>) TypeExtensions.TryConvert<T, TResult>(T, Func<T, TResult>, TResult) TypeExtensions.ChangeType<T>(Object) TypeExtensions.ChangeType(Object, Type) TypeExtensions.InvokeMethod<TRet>(Object, Type[], Expression<Func<TRet>>, BindingFlags) TypeExtensions.InvokeMethod(Object, Type[], Expression<Action>, BindingFlags) TypeExtensions.InvokeMethod<TRet>(Object, Expression<Func<TRet>>, BindingFlags) TypeExtensions.InvokeMethod(Object, Expression<Action>, BindingFlags) SqlBlockExtensions.SetExpression<TTag, TResult>(TTag, Expression<Func<IBlockQueryAdapter, TResult>>) QueryDescriptionExtensions.SetExpression<TTag, TResult>(TTag, Expression<Func<IQueryStructureAdapter, TResult>>)"
  },
  "api/XData.Extensions.Processing.html": {
    "href": "api/XData.Extensions.Processing.html",
    "title": "Class Processing | XData website",
    "keywords": "Class Processing Object processing Inheritance Object Processing Inherited Members Object.Equals(Object) Object.Equals(Object, Object) Object.GetHashCode() Object.GetType() Object.MemberwiseClone() Object.ReferenceEquals(Object, Object) Object.ToString() Namespace : XData.Extensions Assembly : XData.docfx.dll Syntax public static class Processing Methods | Improve this Doc View Source Do<T>(T, Action<IProcess<T>>[]) Object processing method Declaration public static T Do<T>(this T source, params Action<IProcess<T>>[] actions) Parameters Type Name Description T source Source object Action < IProcess <T>>[] actions Actions of processing Returns Type Description T Source object after processing Type Parameters Name Description T Object type"
  },
  "api/XData.Extensions.JoinedEnumerable.html": {
    "href": "api/XData.Extensions.JoinedEnumerable.html",
    "title": "Class JoinedEnumerable | XData website",
    "keywords": "Class JoinedEnumerable Joined enumerable extensions class Inheritance Object JoinedEnumerable Inherited Members Object.Equals(Object) Object.Equals(Object, Object) Object.GetHashCode() Object.GetType() Object.MemberwiseClone() Object.ReferenceEquals(Object, Object) Object.ToString() Namespace : XData.Extensions Assembly : XData.docfx.dll Syntax public static class JoinedEnumerable Methods | Improve this Doc View Source FullOuterJoin<TOuter, TInner, TKey, TResult>(IEnumerable<TOuter>, IEnumerable<TInner>, Func<TOuter, TKey>, Func<TInner, TKey>, Func<TOuter, TInner, TResult>, IEqualityComparer<TKey>) Full outer join extension Declaration public static IEnumerable<TResult> FullOuterJoin<TOuter, TInner, TKey, TResult>(this IEnumerable<TOuter> outer, IEnumerable<TInner> inner, Func<TOuter, TKey> outerKeySelector, Func<TInner, TKey> innerKeySelector, Func<TOuter, TInner, TResult> resultSelector, IEqualityComparer<TKey> comparer = null) Parameters Type Name Description IEnumerable <TOuter> outer Outer enumerable IEnumerable <TInner> inner Inner enumerable Func <TOuter, TKey> outerKeySelector Outer key selector Func <TInner, TKey> innerKeySelector Inner key selector Func <TOuter, TInner, TResult> resultSelector Result selector IEqualityComparer <TKey> comparer Key type comparer Returns Type Description IEnumerable <TResult> Joined sequence Type Parameters Name Description TOuter Outer enumerable type TInner Inner enumerable type TKey Join key type TResult Result sequence type See Also Join<TOuter, TInner, TKey, TResult>(JoinedEnumerable<TOuter>, IEnumerable<TInner>, Func<TOuter, TKey>, Func<TInner, TKey>, Func<TOuter, TInner, TResult>, IEqualityComparer<TKey>) | Improve this Doc View Source Inner<TElement>(IEnumerable<TElement>) Mark enumerable as inner Declaration public static JoinedEnumerable<TElement> Inner<TElement>(this IEnumerable<TElement> source) Parameters Type Name Description IEnumerable <TElement> source Source sequence Returns Type Description JoinedEnumerable <TElement> Joined inner enumerable Type Parameters Name Description TElement Element type See Also Outer<TElement>(IEnumerable<TElement>) Join<TOuter, TInner, TKey, TResult>(JoinedEnumerable<TOuter>, IEnumerable<TInner>, Func<TOuter, TKey>, Func<TInner, TKey>, Func<TOuter, TInner, TResult>, IEqualityComparer<TKey>) | Improve this Doc View Source Join<TOuter, TInner, TKey, TResult>(JoinedEnumerable<TOuter>, IEnumerable<TInner>, Func<TOuter, TKey>, Func<TInner, TKey>, Func<TOuter, TInner, TResult>, IEqualityComparer<TKey>) Join extension for Joined enumerable Declaration public static IEnumerable<TResult> Join<TOuter, TInner, TKey, TResult>(this JoinedEnumerable<TOuter> outer, IEnumerable<TInner> inner, Func<TOuter, TKey> outerKeySelector, Func<TInner, TKey> innerKeySelector, Func<TOuter, TInner, TResult> resultSelector, IEqualityComparer<TKey> comparer = null) Parameters Type Name Description JoinedEnumerable <TOuter> outer Outer enumerable IEnumerable <TInner> inner Inner enumerable Func <TOuter, TKey> outerKeySelector Outer key selector Func <TInner, TKey> innerKeySelector Inner key selector Func <TOuter, TInner, TResult> resultSelector Result selector IEqualityComparer <TKey> comparer Key type comparer Returns Type Description IEnumerable <TResult> Joined sequence Type Parameters Name Description TOuter Outer enumerable type TInner Inner enumerable type TKey Join key type TResult Result sequence type Exceptions Type Condition XDataRuntimeException Argument null See Also Inner<TElement>(IEnumerable<TElement>) Outer<TElement>(IEnumerable<TElement>) LeftOuterJoin<TOuter, TInner, TKey, TResult>(IEnumerable<TOuter>, IEnumerable<TInner>, Func<TOuter, TKey>, Func<TInner, TKey>, Func<TOuter, TInner, TResult>, IEqualityComparer<TKey>) RightOuterJoin<TOuter, TInner, TKey, TResult>(IEnumerable<TOuter>, IEnumerable<TInner>, Func<TOuter, TKey>, Func<TInner, TKey>, Func<TOuter, TInner, TResult>, IEqualityComparer<TKey>) FullOuterJoin<TOuter, TInner, TKey, TResult>(IEnumerable<TOuter>, IEnumerable<TInner>, Func<TOuter, TKey>, Func<TInner, TKey>, Func<TOuter, TInner, TResult>, IEqualityComparer<TKey>) | Improve this Doc View Source LeftOuterJoin<TOuter, TInner, TKey, TResult>(IEnumerable<TOuter>, IEnumerable<TInner>, Func<TOuter, TKey>, Func<TInner, TKey>, Func<TOuter, TInner, TResult>, IEqualityComparer<TKey>) Left outer join extension Declaration public static IEnumerable<TResult> LeftOuterJoin<TOuter, TInner, TKey, TResult>(this IEnumerable<TOuter> outer, IEnumerable<TInner> inner, Func<TOuter, TKey> outerKeySelector, Func<TInner, TKey> innerKeySelector, Func<TOuter, TInner, TResult> resultSelector, IEqualityComparer<TKey> comparer = null) Parameters Type Name Description IEnumerable <TOuter> outer Outer enumerable IEnumerable <TInner> inner Inner enumerable Func <TOuter, TKey> outerKeySelector Outer key selector Func <TInner, TKey> innerKeySelector Inner key selector Func <TOuter, TInner, TResult> resultSelector Result selector IEqualityComparer <TKey> comparer Key type comparer Returns Type Description IEnumerable <TResult> Joined sequence Type Parameters Name Description TOuter Outer enumerable type TInner Inner enumerable type TKey Join key type TResult Result sequence type See Also Join<TOuter, TInner, TKey, TResult>(JoinedEnumerable<TOuter>, IEnumerable<TInner>, Func<TOuter, TKey>, Func<TInner, TKey>, Func<TOuter, TInner, TResult>, IEqualityComparer<TKey>) | Improve this Doc View Source Outer<TElement>(IEnumerable<TElement>) Mark enumerable as outer Declaration public static JoinedEnumerable<TElement> Outer<TElement>(this IEnumerable<TElement> source) Parameters Type Name Description IEnumerable <TElement> source Source sequence Returns Type Description JoinedEnumerable <TElement> Joined inner enumerable Type Parameters Name Description TElement Element type See Also Inner<TElement>(IEnumerable<TElement>) Join<TOuter, TInner, TKey, TResult>(JoinedEnumerable<TOuter>, IEnumerable<TInner>, Func<TOuter, TKey>, Func<TInner, TKey>, Func<TOuter, TInner, TResult>, IEqualityComparer<TKey>) | Improve this Doc View Source RightOuterJoin<TOuter, TInner, TKey, TResult>(IEnumerable<TOuter>, IEnumerable<TInner>, Func<TOuter, TKey>, Func<TInner, TKey>, Func<TOuter, TInner, TResult>, IEqualityComparer<TKey>) Right outer join extension Declaration public static IEnumerable<TResult> RightOuterJoin<TOuter, TInner, TKey, TResult>(this IEnumerable<TOuter> outer, IEnumerable<TInner> inner, Func<TOuter, TKey> outerKeySelector, Func<TInner, TKey> innerKeySelector, Func<TOuter, TInner, TResult> resultSelector, IEqualityComparer<TKey> comparer = null) Parameters Type Name Description IEnumerable <TOuter> outer Outer enumerable IEnumerable <TInner> inner Inner enumerable Func <TOuter, TKey> outerKeySelector Outer key selector Func <TInner, TKey> innerKeySelector Inner key selector Func <TOuter, TInner, TResult> resultSelector Result selector IEqualityComparer <TKey> comparer Key type comparer Returns Type Description IEnumerable <TResult> Joined sequence Type Parameters Name Description TOuter Outer enumerable type TInner Inner enumerable type TKey Join key type TResult Result sequence type See Also Join<TOuter, TInner, TKey, TResult>(JoinedEnumerable<TOuter>, IEnumerable<TInner>, Func<TOuter, TKey>, Func<TInner, TKey>, Func<TOuter, TInner, TResult>, IEqualityComparer<TKey>) See Also JoinedEnumerable <T>"
  },
  "api/XData.Exceptions.XDataRuntimeException.html": {
    "href": "api/XData.Exceptions.XDataRuntimeException.html",
    "title": "Class XDataRuntimeException | XData website",
    "keywords": "Class XDataRuntimeException XData runtime exception Inheritance Object Exception ApplicationException XDataException XDataRuntimeException Implements ISerializable Inherited Members Exception.GetBaseException() Exception.GetObjectData(SerializationInfo, StreamingContext) Exception.GetType() Exception.ToString() Exception.Data Exception.HelpLink Exception.HResult Exception.InnerException Exception.Message Exception.Source Exception.StackTrace Exception.TargetSite Exception.SerializeObjectState Object.Equals(Object) Object.Equals(Object, Object) Object.GetHashCode() Object.MemberwiseClone() Object.ReferenceEquals(Object, Object) Namespace : XData.Exceptions Assembly : XData.docfx.dll Syntax [Serializable] public sealed class XDataRuntimeException : XDataException, ISerializable Constructors | Improve this Doc View Source XDataRuntimeException(XDataRuntimeExceptionType) XData runtime exception Declaration public XDataRuntimeException(XDataRuntimeExceptionType type) Parameters Type Name Description XDataRuntimeExceptionType type Exception type | Improve this Doc View Source XDataRuntimeException(XDataRuntimeExceptionType, Exception) XData runtime exception Declaration public XDataRuntimeException(XDataRuntimeExceptionType type, Exception exception) Parameters Type Name Description XDataRuntimeExceptionType type Exception type Exception exception Inner exception | Improve this Doc View Source XDataRuntimeException(XDataRuntimeExceptionType, Exception, Type) XData runtime exception Declaration public XDataRuntimeException(XDataRuntimeExceptionType type, Exception exception, Type dataObjectType) Parameters Type Name Description XDataRuntimeExceptionType type Exception type Exception exception Inner exception Type dataObjectType Data object type | Improve this Doc View Source XDataRuntimeException(XDataRuntimeExceptionType, Exception, Type, AdditionalInfo[]) XData runtime exception Declaration public XDataRuntimeException(XDataRuntimeExceptionType type, Exception exception, Type dataObjectType, params AdditionalInfo[] addInfo) Parameters Type Name Description XDataRuntimeExceptionType type Exception type Exception exception Inner exception Type dataObjectType Data object type AdditionalInfo [] addInfo Additional information | Improve this Doc View Source XDataRuntimeException(XDataRuntimeExceptionType, String) XData runtime exception Declaration public XDataRuntimeException(XDataRuntimeExceptionType type, string details) Parameters Type Name Description XDataRuntimeExceptionType type Exception type String details Exception details info | Improve this Doc View Source XDataRuntimeException(XDataRuntimeExceptionType, String, Type) XData runtime exception Declaration public XDataRuntimeException(XDataRuntimeExceptionType type, string details, Type dataObjectType) Parameters Type Name Description XDataRuntimeExceptionType type Exception type String details Exception details info Type dataObjectType Data object type | Improve this Doc View Source XDataRuntimeException(XDataRuntimeExceptionType, String, Type, AdditionalInfo[]) XData runtime exception Declaration public XDataRuntimeException(XDataRuntimeExceptionType type, string details, Type dataObjectType, params AdditionalInfo[] addInfo) Parameters Type Name Description XDataRuntimeExceptionType type Exception type String details Exception details info Type dataObjectType Data object type AdditionalInfo [] addInfo Additional info | Improve this Doc View Source XDataRuntimeException(XDataRuntimeExceptionType, Type) XData runtime exception Declaration public XDataRuntimeException(XDataRuntimeExceptionType type, Type dataObjectType) Parameters Type Name Description XDataRuntimeExceptionType type Exception type Type dataObjectType Data object type Properties | Improve this Doc View Source DataObjectType Data object type Declaration public Type DataObjectType { get; } Property Value Type Description Type | Improve this Doc View Source DetailsInfo Exception details info Declaration public string DetailsInfo { get; } Property Value Type Description String | Improve this Doc View Source Type Type of exception Declaration public XDataRuntimeExceptionType Type { get; } Property Value Type Description XDataRuntimeExceptionType Implements System.Runtime.Serialization.ISerializable Extension Methods SerializationExtensions.ToXml<T>(T) CollectionsExtensions.SetValue<TKey, T>(TKey, T) CollectionsExtensions.AsEnum<T>(T) DataObjectQueryableExtensions.CompareVariable(Object, FilterOperation, String) Processing.Do<T>(T, Action<IProcess<T>>[]) TypeExtensions.TryConvert<T, TResult>(T, Func<T, TResult>) TypeExtensions.TryConvert<T, TResult>(T, Func<T, TResult>, TResult) TypeExtensions.ChangeType<T>(Object) TypeExtensions.ChangeType(Object, Type) TypeExtensions.InvokeMethod<TRet>(Object, Type[], Expression<Func<TRet>>, BindingFlags) TypeExtensions.InvokeMethod(Object, Type[], Expression<Action>, BindingFlags) TypeExtensions.InvokeMethod<TRet>(Object, Expression<Func<TRet>>, BindingFlags) TypeExtensions.InvokeMethod(Object, Expression<Action>, BindingFlags) SqlBlockExtensions.SetExpression<TTag, TResult>(TTag, Expression<Func<IBlockQueryAdapter, TResult>>) QueryDescriptionExtensions.SetExpression<TTag, TResult>(TTag, Expression<Func<IQueryStructureAdapter, TResult>>)"
  },
  "api/XData.Exceptions.XDataQueryStructureExceptionType.html": {
    "href": "api/XData.Exceptions.XDataQueryStructureExceptionType.html",
    "title": "Enum XDataQueryStructureExceptionType | XData website",
    "keywords": "Enum XDataQueryStructureExceptionType Query structure exception types Namespace : XData.Exceptions Assembly : XData.docfx.dll Syntax public enum XDataQueryStructureExceptionType Fields Name Description AddTreeFilterError Tree filter (START WITH) generation failed AddTreeLinkError Tree link (CONNECT BY PRIOR) filter generation failed CallNonProcedureBasedStructureError Call of non procedure based structure DictionaryTableHasComplexPrimaryKeyError Dictionary table has complex primary key DictionaryTableHasNoPrimaryKeyError Dictionary table has no primary key EmptyQueryError Empty query text generated error FieldNotFoundError Field not found FilterCombinationNotFoundError Filter combination not found FindPropertyError Property not found error GetParentStructureError Parent structure type not found error HierarchyOnComplexPrimaryKeyTableError Table with hierarchy has complex primary key HierarchyOnNoPrimaryKeyTableError Table with hierarchy has no primary key IdPropertyNotFoundError Id property not found InnerViewNotFoundError No inner view found for alias LinkedPropertyNotFoundError Linked property not found LinkToProcedureFoundError SQL stored procedure can not be linked LinqExpressionCannotBeParsedError LINQ expression can not be parsed LinqExpressionHasUnknownMethodError LINQ expression contains unknown method error LinqExpressionHasUnsupportedMethodError LINQ expression contains unsupported method LinqExpressionHasUnsupportedMethodParametersError LINQ expression contains unsupported method parameter count error LinqExpressionHasUnsupportedTypeError LINQ expression contains unsupported in this case expression type NoDataSourceMappingFoundError Data source mapping not found NoElementsAtPositionError Sequence contains no elements at position error NoElementsError Sequence contains no elements error NoMappingFoundError No mapping found for data object NoneBasedObjectHasTablesError Can't build data object based on NONE table contains other tables error NoPropertyMappingFoundError Property mapping not found NoSelectedFieldsFoundError Selected fields list is empty error PropertyEnumValueNotFoundError Property enum values not found PropertyNotFoundError Property not found (or not mapped) ResultSetMappingExpressionError SQL stored procedure / function result set expression mapping used ResultSetNotRegisteredError Result set not registered RuntimeFilterUsedInsideDynamicQuery Runtime filter used inside dynamic query SubqueryAliasDuplicatedError Subquery alias duplicated SubqueryNotFoundError No subquery found for alias TableNotFoundError Table source not found WrongDataSourceTypeError Wrong data source type used WrongLoadChildPropertyTypeError Serialize child repository wrong target property type Extension Methods SerializationExtensions.ToXml<XDataQueryStructureExceptionType>() CollectionsExtensions.SetValue<XDataQueryStructureExceptionType, T>(T) CollectionsExtensions.AsEnum<XDataQueryStructureExceptionType>() DataObjectQueryableExtensions.CompareVariable(FilterOperation, String) Processing.Do<XDataQueryStructureExceptionType>(Action<IProcess<XDataQueryStructureExceptionType>>[]) TypeExtensions.ChangeType<T>() TypeExtensions.ChangeType(Type) TypeExtensions.InvokeMethod<TRet>(Type[], Expression<Func<TRet>>, BindingFlags) TypeExtensions.InvokeMethod(Type[], Expression<Action>, BindingFlags) TypeExtensions.InvokeMethod<TRet>(Expression<Func<TRet>>, BindingFlags) TypeExtensions.InvokeMethod(Expression<Action>, BindingFlags) TypeExtensions.ConvertTo<T>() TypeExtensions.EqualValue(Enum) SqlBlockExtensions.SetExpression<XDataQueryStructureExceptionType, TResult>(Expression<Func<IBlockQueryAdapter, TResult>>) QueryDescriptionExtensions.SetExpression<XDataQueryStructureExceptionType, TResult>(Expression<Func<IQueryStructureAdapter, TResult>>)"
  },
  "api/XData.DataTriggerFlag.html": {
    "href": "api/XData.DataTriggerFlag.html",
    "title": "Enum DataTriggerFlag | XData website",
    "keywords": "Enum DataTriggerFlag Data trigger result flags Namespace : XData Assembly : XData.docfx.dll Syntax [Flags] public enum DataTriggerFlag Fields Name Description None Standard trigger result Refresh Refresh representation layer flag Skip Skip standard submitting See Also Trigger <T> RepositoryTrigger <T> None Skip Refresh Extension Methods SerializationExtensions.ToXml<DataTriggerFlag>() CollectionsExtensions.SetValue<DataTriggerFlag, T>(T) CollectionsExtensions.AsEnum<DataTriggerFlag>() DataObjectQueryableExtensions.CompareVariable(FilterOperation, String) Processing.Do<DataTriggerFlag>(Action<IProcess<DataTriggerFlag>>[]) TypeExtensions.ChangeType<T>() TypeExtensions.ChangeType(Type) TypeExtensions.InvokeMethod<TRet>(Type[], Expression<Func<TRet>>, BindingFlags) TypeExtensions.InvokeMethod(Type[], Expression<Action>, BindingFlags) TypeExtensions.InvokeMethod<TRet>(Expression<Func<TRet>>, BindingFlags) TypeExtensions.InvokeMethod(Expression<Action>, BindingFlags) TypeExtensions.ConvertTo<T>() TypeExtensions.EqualValue(Enum) SqlBlockExtensions.SetExpression<DataTriggerFlag, TResult>(Expression<Func<IBlockQueryAdapter, TResult>>) QueryDescriptionExtensions.SetExpression<DataTriggerFlag, TResult>(Expression<Func<IQueryStructureAdapter, TResult>>)"
  },
  "api/XData.DataSubmitFlag.html": {
    "href": "api/XData.DataSubmitFlag.html",
    "title": "Enum DataSubmitFlag | XData website",
    "keywords": "Enum DataSubmitFlag Data submit options Namespace : XData Assembly : XData.docfx.dll Syntax [Flags] [DataContract] public enum DataSubmitFlag Fields Name Description IgnoreConcurrency Ignore concurrency conflicts None Standard submit Silent Silent submit See Also Submit(ref T, DataSubmitFlag) Submit(IEnumerable<T>, DataSubmitFlag) None Silent IgnoreConcurrency Extension Methods SerializationExtensions.ToXml<DataSubmitFlag>() CollectionsExtensions.SetValue<DataSubmitFlag, T>(T) CollectionsExtensions.AsEnum<DataSubmitFlag>() DataObjectQueryableExtensions.CompareVariable(FilterOperation, String) Processing.Do<DataSubmitFlag>(Action<IProcess<DataSubmitFlag>>[]) TypeExtensions.ChangeType<T>() TypeExtensions.ChangeType(Type) TypeExtensions.InvokeMethod<TRet>(Type[], Expression<Func<TRet>>, BindingFlags) TypeExtensions.InvokeMethod(Type[], Expression<Action>, BindingFlags) TypeExtensions.InvokeMethod<TRet>(Expression<Func<TRet>>, BindingFlags) TypeExtensions.InvokeMethod(Expression<Action>, BindingFlags) TypeExtensions.ConvertTo<T>() TypeExtensions.EqualValue(Enum) SqlBlockExtensions.SetExpression<DataSubmitFlag, TResult>(Expression<Func<IBlockQueryAdapter, TResult>>) QueryDescriptionExtensions.SetExpression<DataSubmitFlag, TResult>(Expression<Func<IQueryStructureAdapter, TResult>>)"
  },
  "api/XData.DataSource.Structure.IXmlSource.html": {
    "href": "api/XData.DataSource.Structure.IXmlSource.html",
    "title": "Interface IXmlSource | XData website",
    "keywords": "Interface IXmlSource XML data source Inherited Members ITableLike.Name ITableLike.Fields IDataSource.SourceType IDataSource.Alias IDataSource.IsBase IDataSource.GetFields() IDataSource.GetFields(Type) IDataSource.GetField(String, String, String) IDataSource.GetField(String, String, String, String) ICloneable.Clone() Namespace : XData.DataSource.Structure Assembly : XData.docfx.dll Syntax public interface IXmlSource : ITableLike, IDataSource, ICloneable Properties | Improve this Doc View Source RootXPath Table name Declaration string RootXPath { get; } Property Value Type Description String Extension Methods SerializationExtensions.ToXml<T>(T) CollectionsExtensions.SetValue<TKey, T>(TKey, T) CollectionsExtensions.AsEnum<T>(T) DataObjectQueryableExtensions.CompareVariable(Object, FilterOperation, String) Processing.Do<T>(T, Action<IProcess<T>>[]) TypeExtensions.TryConvert<T, TResult>(T, Func<T, TResult>) TypeExtensions.TryConvert<T, TResult>(T, Func<T, TResult>, TResult) TypeExtensions.ChangeType<T>(Object) TypeExtensions.ChangeType(Object, Type) TypeExtensions.InvokeMethod<TRet>(Object, Type[], Expression<Func<TRet>>, BindingFlags) TypeExtensions.InvokeMethod(Object, Type[], Expression<Action>, BindingFlags) TypeExtensions.InvokeMethod<TRet>(Object, Expression<Func<TRet>>, BindingFlags) TypeExtensions.InvokeMethod(Object, Expression<Action>, BindingFlags) SqlBlockExtensions.SetExpression<TTag, TResult>(TTag, Expression<Func<IBlockQueryAdapter, TResult>>) QueryDescriptionExtensions.SetExpression<TTag, TResult>(TTag, Expression<Func<IQueryStructureAdapter, TResult>>)"
  },
  "api/XData.FilterOperation.html": {
    "href": "api/XData.FilterOperation.html",
    "title": "Enum FilterOperation | XData website",
    "keywords": "Enum FilterOperation Filter operation Namespace : XData Assembly : XData.docfx.dll Syntax public enum FilterOperation Fields Name Description Contains Contains (contains) fulltext filter operation Equal Equal (=) filter operation Exists Exists (exists (...)) filter operation GreaterThan Greater Then (>) filter operation GreaterThanOrEqual Greater Then or Equal (>=) filter operation In In sequence (in (...)) filter operation LessThan Less Then (<) filter operation LessThanOrEqual Less Then or Equal (<=) filter operation Like Like (like) filter operation NotContains Not Contains (not contains) fulltext filter operation NotEqual Not Equal (!=) filter operation NotExists Not Exists (not exists (...)) filter operation NotIn Not In sequence (not in (...)) filter operation NotLike Not Like (not like) filter operation OuterJoin Outer join (outer join) filter operation See Also Operation Operation Equal NotEqual LessThan GreaterThan LessThanOrEqual GreaterThanOrEqual In NotIn Exists NotExists Like NotLike OuterJoin Contains NotContains Extension Methods SerializationExtensions.ToXml<FilterOperation>() CollectionsExtensions.SetValue<FilterOperation, T>(T) CollectionsExtensions.AsEnum<FilterOperation>() DataObjectQueryableExtensions.CompareVariable(FilterOperation, String) Processing.Do<FilterOperation>(Action<IProcess<FilterOperation>>[]) TypeExtensions.ChangeType<T>() TypeExtensions.ChangeType(Type) TypeExtensions.InvokeMethod<TRet>(Type[], Expression<Func<TRet>>, BindingFlags) TypeExtensions.InvokeMethod(Type[], Expression<Action>, BindingFlags) TypeExtensions.InvokeMethod<TRet>(Expression<Func<TRet>>, BindingFlags) TypeExtensions.InvokeMethod(Expression<Action>, BindingFlags) TypeExtensions.ConvertTo<T>() TypeExtensions.EqualValue(Enum) SqlBlockExtensions.SetExpression<FilterOperation, TResult>(Expression<Func<IBlockQueryAdapter, TResult>>) QueryDescriptionExtensions.SetExpression<FilterOperation, TResult>(Expression<Func<IQueryStructureAdapter, TResult>>)"
  },
  "api/XData.Extensions.DataObjectQueryableExtensions.html": {
    "href": "api/XData.Extensions.DataObjectQueryableExtensions.html",
    "title": "Class DataObjectQueryableExtensions | XData website",
    "keywords": "Class DataObjectQueryableExtensions XData LINQ query extensions Inheritance Object DataObjectQueryableExtensions Inherited Members Object.Equals(Object) Object.Equals(Object, Object) Object.GetHashCode() Object.GetType() Object.MemberwiseClone() Object.ReferenceEquals(Object, Object) Object.ToString() Namespace : XData.Extensions Assembly : XData.docfx.dll Syntax public static class DataObjectQueryableExtensions Methods | Improve this Doc View Source CompareToCurrentDate(DateTime, FilterOperation) Compare value to current date Declaration public static bool CompareToCurrentDate(this DateTime source, FilterOperation operation) Parameters Type Name Description DateTime source Source property FilterOperation operation Comparison operation Returns Type Description Boolean Comparison result Exceptions Type Condition XDataQueryStructureException LINQ expression has unsupported method parameters See Also CompareToCurrentDateTime(DateTime, FilterOperation) CompareToCurrentDateTimeUtc(DateTime, FilterOperation) | Improve this Doc View Source CompareToCurrentDate(Nullable<DateTime>, FilterOperation) Compare value to current date Declaration public static bool CompareToCurrentDate(this DateTime? source, FilterOperation operation) Parameters Type Name Description Nullable < DateTime > source Source property FilterOperation operation Comparison operation Returns Type Description Boolean Comparison result Exceptions Type Condition XDataQueryStructureException LINQ expression has unsupported method parameters See Also CompareToCurrentDate(DateTime, FilterOperation) CompareToCurrentDateTime(DateTime, FilterOperation) CompareToCurrentDateTimeUtc(DateTime, FilterOperation) | Improve this Doc View Source CompareToCurrentDateTime(DateTime, FilterOperation) Compare value to current date and time Declaration public static bool CompareToCurrentDateTime(this DateTime source, FilterOperation operation) Parameters Type Name Description DateTime source Source property FilterOperation operation Comparison operation Returns Type Description Boolean Comparison result Exceptions Type Condition XDataQueryStructureException LINQ expression has unsupported method parameters See Also CompareToCurrentDate(DateTime, FilterOperation) CompareToCurrentDateTimeUtc(DateTime, FilterOperation) | Improve this Doc View Source CompareToCurrentDateTime(Nullable<DateTime>, FilterOperation) Compare value to current date and time Declaration public static bool CompareToCurrentDateTime(this DateTime? source, FilterOperation operation) Parameters Type Name Description Nullable < DateTime > source Source property FilterOperation operation Comparison operation Returns Type Description Boolean Comparison result Exceptions Type Condition XDataQueryStructureException LINQ expression has unsupported method parameters See Also CompareToCurrentDate(DateTime, FilterOperation) CompareToCurrentDateTime(DateTime, FilterOperation) CompareToCurrentDateTimeUtc(DateTime, FilterOperation) | Improve this Doc View Source CompareToCurrentDateTimeUtc(DateTime, FilterOperation) Compare value to current date and time UTC Declaration public static bool CompareToCurrentDateTimeUtc(this DateTime source, FilterOperation operation) Parameters Type Name Description DateTime source Source property FilterOperation operation Comparison operation Returns Type Description Boolean Comparison result Exceptions Type Condition XDataQueryStructureException LINQ expression has unsupported method parameters See Also CompareToCurrentDate(DateTime, FilterOperation) CompareToCurrentDateTime(DateTime, FilterOperation) | Improve this Doc View Source CompareToCurrentDateTimeUtc(Nullable<DateTime>, FilterOperation) Compare value to current date and time UTC Declaration public static bool CompareToCurrentDateTimeUtc(this DateTime? source, FilterOperation operation) Parameters Type Name Description Nullable < DateTime > source Source property FilterOperation operation Comparison operation Returns Type Description Boolean Comparison result Exceptions Type Condition XDataQueryStructureException LINQ expression has unsupported method parameters See Also CompareToCurrentDate(DateTime, FilterOperation) CompareToCurrentDateTime(DateTime, FilterOperation) CompareToCurrentDateTimeUtc(DateTime, FilterOperation) | Improve this Doc View Source CompareVariable(Object, FilterOperation, String) Compare value to variable value WARNING! Method accessible only in XData LINQ expressions! Declaration public static bool CompareVariable(this object source, FilterOperation operation, string variableName) Parameters Type Name Description Object source Source property FilterOperation operation Comparison operation String variableName Variable name Returns Type Description Boolean Comparison result Exceptions Type Condition XDataRuntimeException Function is accessible in XData LINQ expressions only | Improve this Doc View Source Like(String, String) Like Declaration public static bool Like(this string source, string pattern) Parameters Type Name Description String source Source property String pattern Like pattern Returns Type Description Boolean Like result Exceptions Type Condition XDataRuntimeException Like pattern can not be null or empty See Also Like(String, String, Char) | Improve this Doc View Source Like(String, String, Char) Like Declaration public static bool Like(this string source, string pattern, char escapeChar) Parameters Type Name Description String source Source property String pattern Like pattern Char escapeChar Escape character Returns Type Description Boolean Like result Exceptions Type Condition XDataRuntimeException Like pattern can not be null or empty See Also Like(String, String)"
  },
  "api/XData.Extensions.CollectionsExtensions.html": {
    "href": "api/XData.Extensions.CollectionsExtensions.html",
    "title": "Class CollectionsExtensions | XData website",
    "keywords": "Class CollectionsExtensions Collections extension functions Inheritance Object CollectionsExtensions Inherited Members Object.Equals(Object) Object.Equals(Object, Object) Object.GetHashCode() Object.GetType() Object.MemberwiseClone() Object.ReferenceEquals(Object, Object) Object.ToString() Namespace : XData.Extensions Assembly : XData.docfx.dll Syntax public static class CollectionsExtensions Methods | Improve this Doc View Source AsEnum<T>(T) Returns single item enumerable Declaration public static IEnumerable<T> AsEnum<T>(this T item) Parameters Type Name Description T item Item Returns Type Description IEnumerable <T> Single item enumerable Type Parameters Name Description T Item type | Improve this Doc View Source Clear<T>(List<T>, Action<T>) Clear list content with action call on every element Declaration public static void Clear<T>(this List<T> list, Action<T> action) Parameters Type Name Description List <T> list List Action <T> action Action Type Parameters Name Description T List element type | Improve this Doc View Source GetOrAdd<T>(IList<T>, Func<T, Boolean>, Func<T>) Returns first found element by predicate or add selector result and return it Declaration public static T GetOrAdd<T>(this IList<T> list, Func<T, bool> predicate, Func<T> selector) Parameters Type Name Description IList <T> list List Func <T, Boolean > predicate Find element predicate Func <T> selector Create element logic Returns Type Description T Found or crested element Type Parameters Name Description T Element type Exceptions Type Condition XDataRuntimeException Argument is null | Improve this Doc View Source HasSameValuesAs(ICollection<TaggedValue>, ICollection<TaggedValue>) Dictionary comparison test Declaration public static bool HasSameValuesAs(this ICollection<TaggedValue> source, ICollection<TaggedValue> other) Parameters Type Name Description ICollection < TaggedValue > source Source dictionary ICollection < TaggedValue > other Matched dictionary Returns Type Description Boolean | Improve this Doc View Source HasSameValuesAs<TKey, TValue>(ICollection<KeyValuePair<TKey, TValue>>, ICollection<KeyValuePair<TKey, TValue>>) Dictionary comparison test Declaration public static bool HasSameValuesAs<TKey, TValue>(this ICollection<KeyValuePair<TKey, TValue>> source, ICollection<KeyValuePair<TKey, TValue>> other) where TValue : IComparable Parameters Type Name Description ICollection < KeyValuePair <TKey, TValue>> source Source dictionary ICollection < KeyValuePair <TKey, TValue>> other Matched dictionary Returns Type Description Boolean Type Parameters Name Description TKey Type of dictionary key TValue Type of dictionary value | Improve this Doc View Source HasSameValuesAs<TKey, TValue>(IDictionary<TKey, TValue>, IDictionary<TKey, TValue>) Dictionary comparison test Declaration public static bool HasSameValuesAs<TKey, TValue>(this IDictionary<TKey, TValue> source, IDictionary<TKey, TValue> other) where TValue : IEquatable<TValue> Parameters Type Name Description IDictionary <TKey, TValue> source Source dictionary IDictionary <TKey, TValue> other Matched dictionary Returns Type Description Boolean Type Parameters Name Description TKey Type of dictionary key TValue Type of dictionary value | Improve this Doc View Source IsEmpty(ICollection<IComparable>) IComparable array IsEmpty helper Declaration public static bool IsEmpty(this ICollection<IComparable> fields) Parameters Type Name Description ICollection < IComparable > fields Array of values Returns Type Description Boolean Any of fields is null or DBNull | Improve this Doc View Source RemoveAll<TKey, TValue>(ConcurrentDictionary<TKey, TValue>, Func<TKey, Boolean>) Remove all elements matched predicate Declaration public static void RemoveAll<TKey, TValue>(this ConcurrentDictionary<TKey, TValue> collection, Func<TKey, bool> predicate) Parameters Type Name Description ConcurrentDictionary <TKey, TValue> collection Concurrent dictionary Func <TKey, Boolean > predicate Filtering predicate Type Parameters Name Description TKey Key type TValue Value type | Improve this Doc View Source SetValue<TKey, T>(TKey, T) Named value pair builder Declaration public static KeyValuePair<TKey, T> SetValue<TKey, T>(this TKey name, T value) Parameters Type Name Description TKey name Name T value Value Returns Type Description KeyValuePair <TKey, T> Named value pair Type Parameters Name Description TKey Key type T Value type | Improve this Doc View Source ToDictionary<TKey, TValue>(IEnumerable<KeyValuePair<TKey, TValue>>) ToDictionary helper Declaration public static Dictionary<TKey, TValue> ToDictionary<TKey, TValue>(this IEnumerable<KeyValuePair<TKey, TValue>> pairs) Parameters Type Name Description IEnumerable < KeyValuePair <TKey, TValue>> pairs KeyValuePair collection Returns Type Description Dictionary <TKey, TValue> Typed Dictionary Type Parameters Name Description TKey Dictionary key type TValue Dictionary value type | Improve this Doc View Source ToDictionary<TKey, TValue>(IEnumerable<IGrouping<TKey, TValue>>) ToDictionary groupings helper Declaration public static Dictionary<TKey, List<TValue>> ToDictionary<TKey, TValue>(this IEnumerable<IGrouping<TKey, TValue>> groupings) Parameters Type Name Description IEnumerable < IGrouping <TKey, TValue>> groupings Groupings Returns Type Description Dictionary <TKey, List <TValue>> Typed Dictionary Type Parameters Name Description TKey Dictionary key type TValue Dictionary value type | Improve this Doc View Source ToSortedList<TKey, TValue>(IEnumerable<KeyValuePair<TKey, TValue>>) ToSortedList helper Declaration public static SortedList<TKey, TValue> ToSortedList<TKey, TValue>(this IEnumerable<KeyValuePair<TKey, TValue>> pairs) where TKey : IComparable Parameters Type Name Description IEnumerable < KeyValuePair <TKey, TValue>> pairs KeyValuePair collection Returns Type Description SortedList <TKey, TValue> Typed SortedList Type Parameters Name Description TKey Dictionary key type TValue Dictionary value type | Improve this Doc View Source ToSortedList<TKey, TValue>(IEnumerable<IGrouping<TKey, TValue>>) ToSortedList groupings helper Declaration public static SortedList<TKey, List<TValue>> ToSortedList<TKey, TValue>(this IEnumerable<IGrouping<TKey, TValue>> groupings) where TKey : IComparable Parameters Type Name Description IEnumerable < IGrouping <TKey, TValue>> groupings Groupings Returns Type Description SortedList <TKey, List <TValue>> Typed SortedList Type Parameters Name Description TKey SortedList key type TValue SortedList value type | Improve this Doc View Source ToSortedSet<T>(IEnumerable<T>, IComparer<T>) ToSortedSet helper Declaration public static SortedSet<T> ToSortedSet<T>(this IEnumerable<T> source, IComparer<T> comparer = null) Parameters Type Name Description IEnumerable <T> source Source sequence IComparer <T> comparer Source type comparer Returns Type Description SortedSet <T> Typed SortedSet Type Parameters Name Description T SortedSet type Remarks If comparer is not set GetInstance() used WARNING! To use Indexer<T> one of IComparable<T> properties of source type mast be marked by IndexAttribute | Improve this Doc View Source TryGetValue<TKey, TValue>(IEnumerable<KeyValuePair<TKey, TValue>>, TKey) Try get value helper Declaration public static object TryGetValue<TKey, TValue>(this IEnumerable<KeyValuePair<TKey, TValue>> source, TKey key) where TKey : IEquatable<TKey> Parameters Type Name Description IEnumerable < KeyValuePair <TKey, TValue>> source Sequence of key value pairs TKey key Key value Returns Type Description Object Type Parameters Name Description TKey Key type TValue Value type"
  },
  "api/XData.Exceptions.XDataAdapterExceptionType.html": {
    "href": "api/XData.Exceptions.XDataAdapterExceptionType.html",
    "title": "Enum XDataAdapterExceptionType | XData website",
    "keywords": "Enum XDataAdapterExceptionType XData adapter exception types Namespace : XData.Exceptions Assembly : XData.docfx.dll Syntax public enum XDataAdapterExceptionType Fields Name Description AdapterClassNotFoundError Adapter class not found AdapterConstructorFailedError Adapter constructor failed ComplexPrimaryKeyNotSupportedError Complex primary key is not supported in this case FunctionIsNotSupportedError Function is not supported GetSqlSyntaxTemplateError SQL syntax not provided by adapter error SqlBlockProceduralSyntaxNotSupportedError SQL block procedural syntax is not supported SqlBuilderClassNotFoundError Sql builder class not found SqlBuilderConstructorFailedError Sql builder constructor failed SyntaxNotSupportedError SQL syntax construction is not supported TypeNotSupportedError Data type is not supported Extension Methods SerializationExtensions.ToXml<XDataAdapterExceptionType>() CollectionsExtensions.SetValue<XDataAdapterExceptionType, T>(T) CollectionsExtensions.AsEnum<XDataAdapterExceptionType>() DataObjectQueryableExtensions.CompareVariable(FilterOperation, String) Processing.Do<XDataAdapterExceptionType>(Action<IProcess<XDataAdapterExceptionType>>[]) TypeExtensions.ChangeType<T>() TypeExtensions.ChangeType(Type) TypeExtensions.InvokeMethod<TRet>(Type[], Expression<Func<TRet>>, BindingFlags) TypeExtensions.InvokeMethod(Type[], Expression<Action>, BindingFlags) TypeExtensions.InvokeMethod<TRet>(Expression<Func<TRet>>, BindingFlags) TypeExtensions.InvokeMethod(Expression<Action>, BindingFlags) TypeExtensions.ConvertTo<T>() TypeExtensions.EqualValue(Enum) SqlBlockExtensions.SetExpression<XDataAdapterExceptionType, TResult>(Expression<Func<IBlockQueryAdapter, TResult>>) QueryDescriptionExtensions.SetExpression<XDataAdapterExceptionType, TResult>(Expression<Func<IQueryStructureAdapter, TResult>>)"
  },
  "api/XData.DataSource.Structure.RuntimeFilter.html": {
    "href": "api/XData.DataSource.Structure.RuntimeFilter.html",
    "title": "Class RuntimeFilter | XData website",
    "keywords": "Class RuntimeFilter Runtime value filter Inheritance Object RuntimeFilter Inherited Members Object.Equals(Object) Object.Equals(Object, Object) Object.GetHashCode() Object.GetType() Object.MemberwiseClone() Object.ReferenceEquals(Object, Object) Object.ToString() Namespace : XData.DataSource.Structure Assembly : XData.docfx.dll Syntax public sealed class RuntimeFilter Constructors | Improve this Doc View Source RuntimeFilter(String, String) Runtime filter constructor Declaration public RuntimeFilter(string propertyName, string filterName = null) Parameters Type Name Description String propertyName Filter property name String filterName Filter name Properties | Improve this Doc View Source Combination Filter combination name Declaration public string Combination { get; set; } Property Value Type Description String | Improve this Doc View Source Name Filter name Declaration public string Name { get; } Property Value Type Description String | Improve this Doc View Source Nullable Filter null value handling Declaration public FilterNullable Nullable { get; set; } Property Value Type Description FilterNullable | Improve this Doc View Source Operation Filter operation Declaration public FilterOperation Operation { get; set; } Property Value Type Description FilterOperation | Improve this Doc View Source PrimaryFilter Primary filter flag Declaration public bool PrimaryFilter { get; set; } Property Value Type Description Boolean | Improve this Doc View Source PropertyName Property name Declaration public string PropertyName { get; } Property Value Type Description String Operators | Improve this Doc View Source Implicit(String to RuntimeFilter) Cast operator for runtime filter based on property Declaration public static implicit operator RuntimeFilter(string propertyName) Parameters Type Name Description String propertyName Property name Returns Type Description RuntimeFilter | Improve this Doc View Source Implicit(FilterName to RuntimeFilter) Cast operator for named runtime filter Declaration public static implicit operator RuntimeFilter(FilterName filterName) Parameters Type Name Description FilterName filterName Filter name Returns Type Description RuntimeFilter Extension Methods SerializationExtensions.ToXml<T>(T) CollectionsExtensions.SetValue<TKey, T>(TKey, T) CollectionsExtensions.AsEnum<T>(T) DataObjectQueryableExtensions.CompareVariable(Object, FilterOperation, String) Processing.Do<T>(T, Action<IProcess<T>>[]) TypeExtensions.TryConvert<T, TResult>(T, Func<T, TResult>) TypeExtensions.TryConvert<T, TResult>(T, Func<T, TResult>, TResult) TypeExtensions.ChangeType<T>(Object) TypeExtensions.ChangeType(Object, Type) TypeExtensions.InvokeMethod<TRet>(Object, Type[], Expression<Func<TRet>>, BindingFlags) TypeExtensions.InvokeMethod(Object, Type[], Expression<Action>, BindingFlags) TypeExtensions.InvokeMethod<TRet>(Object, Expression<Func<TRet>>, BindingFlags) TypeExtensions.InvokeMethod(Object, Expression<Action>, BindingFlags) SqlBlockExtensions.SetExpression<TTag, TResult>(TTag, Expression<Func<IBlockQueryAdapter, TResult>>) QueryDescriptionExtensions.SetExpression<TTag, TResult>(TTag, Expression<Func<IQueryStructureAdapter, TResult>>)"
  },
  "api/XData.DataSource.Structure.IInnerViewLink.html": {
    "href": "api/XData.DataSource.Structure.IInnerViewLink.html",
    "title": "Interface IInnerViewLink | XData website",
    "keywords": "Interface IInnerViewLink Inner view link interface Inherited Members IInnerLink.LinkedSourceAlias IInnerLink.LinkedField IInnerLink.GetIsLink() IInnerLink.GetAliases() IOptionalFilter.Primary IFilter.FilterType IFilter.SourceAlias IFilter.Field IFilter.Operation ICloneable.Clone() Namespace : XData.DataSource.Structure Assembly : XData.docfx.dll Syntax public interface IInnerViewLink : IInnerLink, IOptionalFilter, IFilter, ICloneable Properties | Improve this Doc View Source LinkedAlias Linked source alias Declaration string LinkedAlias { get; } Property Value Type Description String Extension Methods SerializationExtensions.ToXml<T>(T) CollectionsExtensions.SetValue<TKey, T>(TKey, T) CollectionsExtensions.AsEnum<T>(T) DataObjectQueryableExtensions.CompareVariable(Object, FilterOperation, String) Processing.Do<T>(T, Action<IProcess<T>>[]) TypeExtensions.TryConvert<T, TResult>(T, Func<T, TResult>) TypeExtensions.TryConvert<T, TResult>(T, Func<T, TResult>, TResult) TypeExtensions.ChangeType<T>(Object) TypeExtensions.ChangeType(Object, Type) TypeExtensions.InvokeMethod<TRet>(Object, Type[], Expression<Func<TRet>>, BindingFlags) TypeExtensions.InvokeMethod(Object, Type[], Expression<Action>, BindingFlags) TypeExtensions.InvokeMethod<TRet>(Object, Expression<Func<TRet>>, BindingFlags) TypeExtensions.InvokeMethod(Object, Expression<Action>, BindingFlags) SqlBlockExtensions.SetExpression<TTag, TResult>(TTag, Expression<Func<IBlockQueryAdapter, TResult>>) QueryDescriptionExtensions.SetExpression<TTag, TResult>(TTag, Expression<Func<IQueryStructureAdapter, TResult>>)"
  },
  "api/XData.DataSource.Structure.IInnerLink.html": {
    "href": "api/XData.DataSource.Structure.IInnerLink.html",
    "title": "Interface IInnerLink | XData website",
    "keywords": "Interface IInnerLink Link interface Inherited Members IOptionalFilter.Primary IFilter.FilterType IFilter.SourceAlias IFilter.Field IFilter.Operation ICloneable.Clone() Namespace : XData.DataSource.Structure Assembly : XData.docfx.dll Syntax public interface IInnerLink : IOptionalFilter, IFilter, ICloneable Properties | Improve this Doc View Source LinkedField Linked field Declaration string LinkedField { get; } Property Value Type Description String | Improve this Doc View Source LinkedSourceAlias Linked source alias Declaration string LinkedSourceAlias { get; } Property Value Type Description String Methods | Improve this Doc View Source GetAliases() Link aliases Declaration string[] GetAliases() Returns Type Description String [] | Improve this Doc View Source GetIsLink() Link flag Declaration bool GetIsLink() Returns Type Description Boolean Extension Methods SerializationExtensions.ToXml<T>(T) CollectionsExtensions.SetValue<TKey, T>(TKey, T) CollectionsExtensions.AsEnum<T>(T) DataObjectQueryableExtensions.CompareVariable(Object, FilterOperation, String) Processing.Do<T>(T, Action<IProcess<T>>[]) TypeExtensions.TryConvert<T, TResult>(T, Func<T, TResult>) TypeExtensions.TryConvert<T, TResult>(T, Func<T, TResult>, TResult) TypeExtensions.ChangeType<T>(Object) TypeExtensions.ChangeType(Object, Type) TypeExtensions.InvokeMethod<TRet>(Object, Type[], Expression<Func<TRet>>, BindingFlags) TypeExtensions.InvokeMethod(Object, Type[], Expression<Action>, BindingFlags) TypeExtensions.InvokeMethod<TRet>(Object, Expression<Func<TRet>>, BindingFlags) TypeExtensions.InvokeMethod(Object, Expression<Action>, BindingFlags) SqlBlockExtensions.SetExpression<TTag, TResult>(TTag, Expression<Func<IBlockQueryAdapter, TResult>>) QueryDescriptionExtensions.SetExpression<TTag, TResult>(TTag, Expression<Func<IQueryStructureAdapter, TResult>>)"
  },
  "api/XData.DataSource.Structure.DataStructureState.html": {
    "href": "api/XData.DataSource.Structure.DataStructureState.html",
    "title": "Class DataStructureState | XData website",
    "keywords": "Class DataStructureState Data structure state Inheritance Object DataStructureState Implements IEquatable < DataStructureState > Inherited Members Object.Equals(Object) Object.Equals(Object, Object) Object.GetHashCode() Object.GetType() Object.MemberwiseClone() Object.ReferenceEquals(Object, Object) Object.ToString() Namespace : XData.DataSource.Structure Assembly : XData.docfx.dll Syntax [Serializable] [DataContract] public sealed class DataStructureState : IEquatable<DataStructureState> Properties | Improve this Doc View Source Alias Subquery alias Declaration [DataMember] public string Alias { get; set; } Property Value Type Description String | Improve this Doc View Source Context Structure context Declaration [DataMember] public string Context { get; set; } Property Value Type Description String | Improve this Doc View Source Distinct Distinct flag Declaration [DataMember] public bool Distinct { get; set; } Property Value Type Description Boolean | Improve this Doc View Source Filters Filter combinations Declaration [DataMember] public FilterCombinationState Filters { get; set; } Property Value Type Description FilterCombinationState | Improve this Doc View Source FilterValues Filter values Declaration [DataMember] public TaggedValue[] FilterValues { get; set; } Property Value Type Description TaggedValue [] | Improve this Doc View Source Grouping Grouping Declaration [DataMember] public Grouping[] Grouping { get; set; } Property Value Type Description Grouping [] | Improve this Doc View Source IsReadOnly Read only flag Declaration [DataMember] public bool IsReadOnly { get; set; } Property Value Type Description Boolean | Improve this Doc View Source Limit Limit count Declaration [DataMember] public int Limit { get; set; } Property Value Type Description Int32 | Improve this Doc View Source Name Table name Declaration [DataMember] public string Name { get; set; } Property Value Type Description String | Improve this Doc View Source OrderBy Order Declaration [DataMember] public Order[] OrderBy { get; set; } Property Value Type Description Order [] | Improve this Doc View Source Reverse Reverse order flag Declaration [DataMember] public bool Reverse { get; set; } Property Value Type Description Boolean | Improve this Doc View Source Skip Skip count Declaration [DataMember] public int Skip { get; set; } Property Value Type Description Int32 | Improve this Doc View Source Sources Dynamic sources states Declaration [DataMember] public DataStructureState[] Sources { get; set; } Property Value Type Description DataStructureState [] | Improve this Doc View Source SourceTypeType Source type Declaration [DataMember] public DataSourceType SourceTypeType { get; set; } Property Value Type Description DataSourceType | Improve this Doc View Source StructureType Structure type name Declaration [DataMember] public string StructureType { get; set; } Property Value Type Description String | Improve this Doc View Source Union Union combination Declaration [DataMember] public DataCombination Union { get; set; } Property Value Type Description DataCombination | Improve this Doc View Source Variables Variables Declaration [DataMember] public TaggedValue[] Variables { get; set; } Property Value Type Description TaggedValue [] Methods | Improve this Doc View Source Equals(DataStructureState) DataStructureState equality check Declaration public bool Equals(DataStructureState other) Parameters Type Name Description DataStructureState other DataStructureState instance to compare Returns Type Description Boolean Instances are contains the same data Implements System.IEquatable<T> Extension Methods SerializationExtensions.ToXml<T>(T) CollectionsExtensions.SetValue<TKey, T>(TKey, T) CollectionsExtensions.AsEnum<T>(T) DataObjectQueryableExtensions.CompareVariable(Object, FilterOperation, String) Processing.Do<T>(T, Action<IProcess<T>>[]) TypeExtensions.TryConvert<T, TResult>(T, Func<T, TResult>) TypeExtensions.TryConvert<T, TResult>(T, Func<T, TResult>, TResult) TypeExtensions.ChangeType<T>(Object) TypeExtensions.ChangeType(Object, Type) TypeExtensions.InvokeMethod<TRet>(Object, Type[], Expression<Func<TRet>>, BindingFlags) TypeExtensions.InvokeMethod(Object, Type[], Expression<Action>, BindingFlags) TypeExtensions.InvokeMethod<TRet>(Object, Expression<Func<TRet>>, BindingFlags) TypeExtensions.InvokeMethod(Object, Expression<Action>, BindingFlags) SqlBlockExtensions.SetExpression<TTag, TResult>(TTag, Expression<Func<IBlockQueryAdapter, TResult>>) QueryDescriptionExtensions.SetExpression<TTag, TResult>(TTag, Expression<Func<IQueryStructureAdapter, TResult>>)"
  },
  "api/XData.Database.Dialect.SqlStringType.html": {
    "href": "api/XData.Database.Dialect.SqlStringType.html",
    "title": "Enum SqlStringType | XData website",
    "keywords": "Enum SqlStringType SQL dialect specific format strings types Namespace : XData.Database.Dialect Assembly : XData.docfx.dll Syntax public enum SqlStringType Fields Name Description AcquireBlob AcquireXml AfterDelete AfterInsert AfterUpdate All Any BeforeDelete BeforeInsert BeforeUpdate BooleanConstant Ceiling CheckConcurrency Clear ClearComplete ClearDeclare ClearField ClearSaveKeys Coalesce CompleteInsert Concat Conditional Convert Date DateFormat DateTimeAdd DateTimeAddDays DateTimeAddHours DateTimeAddMilliseconds DateTimeAddMinutes DateTimeAddMonths DateTimeAddSeconds DateTimeAddYears DateTimeDaysInMonth DateTimeIsLeapYear Day DayOfWeek DayOfYear Days DaysTotal DictionaryTableName EmptyBlob EmptyGuid EmptyXml EndsWith Except ExtractXml ExtractXmlWithNamespaces FieldFormat Floor GetBlobSize GetForeignKey GroupConvert GroupField GroupXmlField Hour Hours IndexOf InitInsert InsertValues Intersect IsNullOrEmpty IsNullOrWhiteSpace Length Lock LockPk LockPkJoin MaxSize Millisecond Minute Minutes ModifiedHintAfter ModifiedHintBefore ModifiedTableName Month Months NewGuid NoneSelect Now PadLeft PadRight Power Random Remove Returning Round RowId RowIdArray RowIdFill RowIterator SaveBlob SaveXml Second Seconds SelectField SelectHintBefore SelectXmlField SequenceNextVal SkipInsert SqlBlockDeclare SqlBlockDefault SqlBlockDelete SqlBlockExternalLoopVar SqlBlockForEach SqlBlockIf SqlBlockIfExists SqlBlockInsert SqlBlockMerge SqlBlockQuote SqlBlockReturn SqlBlockSelectInto SqlBlockUpdate SqlBlockVarAssign SqlParameter SqlScalarFunction SqlTableFunction Sqrt StartsWith Substring TableName TempTableCreate TempTableDrop TimeOfDay TimeSpanFormat ToBoolean ToDateTime Today ToDecimal ToInt16 ToInt32 ToInt64 ToString ToStringFormat ToXml TreeOrder Trim TrimEnd TrimStart UtcNow With WithRecursive XmlAsString XmlSourceName Year Years Extension Methods SerializationExtensions.ToXml<SqlStringType>() CollectionsExtensions.SetValue<SqlStringType, T>(T) CollectionsExtensions.AsEnum<SqlStringType>() DataObjectQueryableExtensions.CompareVariable(FilterOperation, String) Processing.Do<SqlStringType>(Action<IProcess<SqlStringType>>[]) TypeExtensions.ChangeType<T>() TypeExtensions.ChangeType(Type) TypeExtensions.InvokeMethod<TRet>(Type[], Expression<Func<TRet>>, BindingFlags) TypeExtensions.InvokeMethod(Type[], Expression<Action>, BindingFlags) TypeExtensions.InvokeMethod<TRet>(Expression<Func<TRet>>, BindingFlags) TypeExtensions.InvokeMethod(Expression<Action>, BindingFlags) TypeExtensions.ConvertTo<T>() TypeExtensions.EqualValue(Enum) SqlBlockExtensions.SetExpression<SqlStringType, TResult>(Expression<Func<IBlockQueryAdapter, TResult>>) QueryDescriptionExtensions.SetExpression<SqlStringType, TResult>(Expression<Func<IQueryStructureAdapter, TResult>>)"
  },
  "api/XData.Database.Adapter.StoredProcedure.html": {
    "href": "api/XData.Database.Adapter.StoredProcedure.html",
    "title": "Class StoredProcedure | XData website",
    "keywords": "Class StoredProcedure SQL stored procedure Inheritance Object StoredProcedure Implements IEnumerable < QueryParam > IEnumerable Inherited Members Object.Equals(Object) Object.Equals(Object, Object) Object.GetHashCode() Object.GetType() Object.MemberwiseClone() Object.ReferenceEquals(Object, Object) Namespace : XData.Database.Adapter Assembly : XData.docfx.dll Syntax public sealed class StoredProcedure : IEnumerable<QueryParam>, IEnumerable Constructors | Improve this Doc View Source StoredProcedure(String, QueryParam[]) Procedure constructor Declaration public StoredProcedure(string name, params QueryParam[] par) Parameters Type Name Description String name Procedure name QueryParam [] par Parameters Properties | Improve this Doc View Source Hint Procedure hint Declaration public HintInfo Hint { get; set; } Property Value Type Description HintInfo | Improve this Doc View Source Item[Int32] Query parameters by index Declaration public QueryParam this[int i] { get; } Parameters Type Name Description Int32 i Parameter index Property Value Type Description QueryParam Query parameter | Improve this Doc View Source Item[String] Procedure parameters by name Declaration public QueryParam this[string name] { get; set; } Parameters Type Name Description String name Parameter name Property Value Type Description QueryParam Procedure parameter | Improve this Doc View Source Name SQL stored procedure name Declaration public string Name { get; } Property Value Type Description String | Improve this Doc View Source ResultSets Stored procedure result sets names Declaration public IList<string> ResultSets { get; } Property Value Type Description IList < String > Methods | Improve this Doc View Source GetEnumerator() Query parameters enumeration Declaration public IEnumerator<QueryParam> GetEnumerator() Returns Type Description IEnumerator < QueryParam > Query parameters enumeration | Improve this Doc View Source ToString() Returns a String that represents the current Object . Declaration public override string ToString() Returns Type Description String A String that represents the current Object . Overrides Object.ToString() Operators | Improve this Doc View Source Implicit(String to StoredProcedure) Stored procedure name Declaration public static implicit operator StoredProcedure(string s) Parameters Type Name Description String s Procedure name Returns Type Description StoredProcedure Stored procedure Explicit Interface Implementations | Improve this Doc View Source IEnumerable.GetEnumerator() Query parameters enumeration Declaration IEnumerator IEnumerable.GetEnumerator() Returns Type Description IEnumerator Query parameters enumeration Implements System.Collections.Generic.IEnumerable<T> System.Collections.IEnumerable Extension Methods SerializationExtensions.ToXml<T>(T) CollectionsExtensions.ToSortedSet<T>(IEnumerable<T>, IComparer<T>) CollectionsExtensions.SetValue<TKey, T>(TKey, T) CollectionsExtensions.AsEnum<T>(T) DataObjectQueryableExtensions.CompareVariable(Object, FilterOperation, String) JoinedEnumerable.Inner<TElement>(IEnumerable<TElement>) JoinedEnumerable.Outer<TElement>(IEnumerable<TElement>) JoinedEnumerable.LeftOuterJoin<TOuter, TInner, TKey, TResult>(IEnumerable<TOuter>, IEnumerable<TInner>, Func<TOuter, TKey>, Func<TInner, TKey>, Func<TOuter, TInner, TResult>, IEqualityComparer<TKey>) JoinedEnumerable.RightOuterJoin<TOuter, TInner, TKey, TResult>(IEnumerable<TOuter>, IEnumerable<TInner>, Func<TOuter, TKey>, Func<TInner, TKey>, Func<TOuter, TInner, TResult>, IEqualityComparer<TKey>) JoinedEnumerable.FullOuterJoin<TOuter, TInner, TKey, TResult>(IEnumerable<TOuter>, IEnumerable<TInner>, Func<TOuter, TKey>, Func<TInner, TKey>, Func<TOuter, TInner, TResult>, IEqualityComparer<TKey>) Processing.Do<T>(T, Action<IProcess<T>>[]) TypeExtensions.TryConvert<T, TResult>(T, Func<T, TResult>) TypeExtensions.TryConvert<T, TResult>(T, Func<T, TResult>, TResult) TypeExtensions.ChangeType<T>(Object) TypeExtensions.ChangeType(Object, Type) TypeExtensions.InvokeMethod<TRet>(Object, Type[], Expression<Func<TRet>>, BindingFlags) TypeExtensions.InvokeMethod(Object, Type[], Expression<Action>, BindingFlags) TypeExtensions.InvokeMethod<TRet>(Object, Expression<Func<TRet>>, BindingFlags) TypeExtensions.InvokeMethod(Object, Expression<Action>, BindingFlags) SqlBlockExtensions.SetExpression<TTag, TResult>(TTag, Expression<Func<IBlockQueryAdapter, TResult>>) QueryDescriptionExtensions.SetExpression<TTag, TResult>(TTag, Expression<Func<IQueryStructureAdapter, TResult>>) QueryDescriptionExtensions.ToDataSet<T>(IEnumerable<T>, String, ISqlBuilder)"
  },
  "api/XData.Database.Adapter.DatabaseAdapterAttribute.html": {
    "href": "api/XData.Database.Adapter.DatabaseAdapterAttribute.html",
    "title": "Class DatabaseAdapterAttribute | XData website",
    "keywords": "Class DatabaseAdapterAttribute Database adapter attribute Inheritance Object Attribute DatabaseAdapterAttribute Implements IDatabaseAdapterMetadata Inherited Members Attribute.Equals(Object) Attribute.GetCustomAttribute(Assembly, Type) Attribute.GetCustomAttribute(Assembly, Type, Boolean) Attribute.GetCustomAttribute(MemberInfo, Type) Attribute.GetCustomAttribute(MemberInfo, Type, Boolean) Attribute.GetCustomAttribute(Module, Type) Attribute.GetCustomAttribute(Module, Type, Boolean) Attribute.GetCustomAttribute(ParameterInfo, Type) Attribute.GetCustomAttribute(ParameterInfo, Type, Boolean) Attribute.GetCustomAttributes(Assembly) Attribute.GetCustomAttributes(Assembly, Boolean) Attribute.GetCustomAttributes(Assembly, Type) Attribute.GetCustomAttributes(Assembly, Type, Boolean) Attribute.GetCustomAttributes(MemberInfo) Attribute.GetCustomAttributes(MemberInfo, Boolean) Attribute.GetCustomAttributes(MemberInfo, Type) Attribute.GetCustomAttributes(MemberInfo, Type, Boolean) Attribute.GetCustomAttributes(Module) Attribute.GetCustomAttributes(Module, Boolean) Attribute.GetCustomAttributes(Module, Type) Attribute.GetCustomAttributes(Module, Type, Boolean) Attribute.GetCustomAttributes(ParameterInfo) Attribute.GetCustomAttributes(ParameterInfo, Boolean) Attribute.GetCustomAttributes(ParameterInfo, Type) Attribute.GetCustomAttributes(ParameterInfo, Type, Boolean) Attribute.GetHashCode() Attribute.IsDefaultAttribute() Attribute.IsDefined(Assembly, Type) Attribute.IsDefined(Assembly, Type, Boolean) Attribute.IsDefined(MemberInfo, Type) Attribute.IsDefined(MemberInfo, Type, Boolean) Attribute.IsDefined(Module, Type) Attribute.IsDefined(Module, Type, Boolean) Attribute.IsDefined(ParameterInfo, Type) Attribute.IsDefined(ParameterInfo, Type, Boolean) Attribute.Match(Object) Attribute.TypeId Object.Equals(Object, Object) Object.GetType() Object.MemberwiseClone() Object.ReferenceEquals(Object, Object) Object.ToString() Namespace : XData.Database.Adapter Assembly : XData.docfx.dll Syntax [AttributeUsage(AttributeTargets.Class)] public class DatabaseAdapterAttribute : Attribute, IDatabaseAdapterMetadata Constructors | Improve this Doc View Source DatabaseAdapterAttribute(String) Database adapter attribute constructor Declaration public DatabaseAdapterAttribute(string adapterDatabase) Parameters Type Name Description String adapterDatabase Connection type Properties | Improve this Doc View Source Database Database connection type Declaration public string Database { get; } Property Value Type Description String Implements IDatabaseAdapterMetadata Extension Methods SerializationExtensions.ToXml<T>(T) CollectionsExtensions.SetValue<TKey, T>(TKey, T) CollectionsExtensions.AsEnum<T>(T) DataObjectQueryableExtensions.CompareVariable(Object, FilterOperation, String) Processing.Do<T>(T, Action<IProcess<T>>[]) TypeExtensions.TryConvert<T, TResult>(T, Func<T, TResult>) TypeExtensions.TryConvert<T, TResult>(T, Func<T, TResult>, TResult) TypeExtensions.ChangeType<T>(Object) TypeExtensions.ChangeType(Object, Type) TypeExtensions.InvokeMethod<TRet>(Object, Type[], Expression<Func<TRet>>, BindingFlags) TypeExtensions.InvokeMethod(Object, Type[], Expression<Action>, BindingFlags) TypeExtensions.InvokeMethod<TRet>(Object, Expression<Func<TRet>>, BindingFlags) TypeExtensions.InvokeMethod(Object, Expression<Action>, BindingFlags) SqlBlockExtensions.SetExpression<TTag, TResult>(TTag, Expression<Func<IBlockQueryAdapter, TResult>>) QueryDescriptionExtensions.SetExpression<TTag, TResult>(TTag, Expression<Func<IQueryStructureAdapter, TResult>>)"
  },
  "api/XData.CredentialsType.html": {
    "href": "api/XData.CredentialsType.html",
    "title": "Enum CredentialsType | XData website",
    "keywords": "Enum CredentialsType Database credentials type Namespace : XData Assembly : XData.docfx.dll Syntax public enum CredentialsType Fields Name Description DbIntegratedSecurity Database integrated security DbLogin Database login DbPassword Database login password DbSchema Database schema name DbServer Database server name Extension Methods SerializationExtensions.ToXml<CredentialsType>() CollectionsExtensions.SetValue<CredentialsType, T>(T) CollectionsExtensions.AsEnum<CredentialsType>() DataObjectQueryableExtensions.CompareVariable(FilterOperation, String) Processing.Do<CredentialsType>(Action<IProcess<CredentialsType>>[]) TypeExtensions.ChangeType<T>() TypeExtensions.ChangeType(Type) TypeExtensions.InvokeMethod<TRet>(Type[], Expression<Func<TRet>>, BindingFlags) TypeExtensions.InvokeMethod(Type[], Expression<Action>, BindingFlags) TypeExtensions.InvokeMethod<TRet>(Expression<Func<TRet>>, BindingFlags) TypeExtensions.InvokeMethod(Expression<Action>, BindingFlags) TypeExtensions.ConvertTo<T>() TypeExtensions.EqualValue(Enum) SqlBlockExtensions.SetExpression<CredentialsType, TResult>(Expression<Func<IBlockQueryAdapter, TResult>>) QueryDescriptionExtensions.SetExpression<CredentialsType, TResult>(Expression<Func<IQueryStructureAdapter, TResult>>)"
  },
  "api/XData.Security.html": {
    "href": "api/XData.Security.html",
    "title": "Namespace XData.Security | XData website",
    "keywords": "Namespace XData.Security Classes SecuritySession Security session base class"
  },
  "api/XData.Security.SecuritySession.html": {
    "href": "api/XData.Security.SecuritySession.html",
    "title": "Class SecuritySession | XData website",
    "keywords": "Class SecuritySession Security session base class Inheritance Object SecuritySession Namespace : XData.Security Assembly : XData.Security.docfx.dll Syntax public abstract class SecuritySession : ISecuritySession Constructors | Improve this Doc View Source SecuritySession(String, String[], Boolean) Security session constructor Declaration public SecuritySession(string userName, string[] roles, bool isSupervisor = false) Parameters Type Name Description String userName User name String [] roles User roles Boolean isSupervisor Supervisor flag Properties | Improve this Doc View Source IsSupervisor Current user is supervisor flag Declaration public bool IsSupervisor { get; set; } Property Value Type Description Boolean | Improve this Doc View Source Roles Current user roles list Declaration public string[] Roles { get; protected set; } Property Value Type Description String [] | Improve this Doc View Source UserName Current user name Declaration public string UserName { get; protected set; } Property Value Type Description String Methods | Improve this Doc View Source Action<T>(Expression<Func<CustomLogic<T>>>) Custom action name access helper Declaration protected static string Action<T>(Expression<Func<CustomLogic<T>>> expr) where T : class, IDataObject, new() Parameters Type Name Description Expression < Func < CustomLogic <T>>> expr Custom logic expression Returns Type Description String Custom action name Type Parameters Name Description T Data object type | Improve this Doc View Source FilterGrantedObjects<T>(String, Expression) Converts initial IQueryable expression filtering granted objects only Declaration public Expression FilterGrantedObjects<T>(string context, Expression allDataExpr) where T : class, IDataObject, new() Parameters Type Name Description String context Context name Expression allDataExpr Initial IQueryable expression Returns Type Description Expression Modified IQueryable expression Type Parameters Name Description T Data object type | Improve this Doc View Source GetGrantedActions<T>(String) Returns list of granted actions for current user Declaration public string[] GetGrantedActions<T>(string context = null) where T : class, IDataObject, new() Parameters Type Name Description String context Context name Returns Type Description String [] Actions list Type Parameters Name Description T Data object type | Improve this Doc View Source GetRestrictedProperties<T>(String) Returns list of restricted properties for current user Declaration public string[] GetRestrictedProperties<T>(string context = null) where T : class, IDataObject, new() Parameters Type Name Description String context Context name Returns Type Description String [] Properties name list Type Parameters Name Description T Data object type | Improve this Doc View Source InitializeSession() Session initialization Declaration protected abstract void InitializeSession() See Also RegisterGrantedActions(String, Type, IEnumerable<KeyValuePair<String, String[]>>) RegisterRestrictedProperties(String, Type, IEnumerable<KeyValuePair<String, String[]>>) RegisterSecurityFilters(String, Type, IEnumerable<KeyValuePair<String, Expression>>) | Improve this Doc View Source Property<T>(Expression<Func<T, Object>>) Property name access helper Declaration protected static string Property<T>(Expression<Func<T, object>> expr) where T : class, IDataObject, new() Parameters Type Name Description Expression < Func <T, Object >> expr Property expression Returns Type Description String Property name Type Parameters Name Description T Data object type | Improve this Doc View Source RegisterGrantedActions(String, Type, IEnumerable<KeyValuePair<String, String[]>>) Granted actions registration Declaration protected void RegisterGrantedActions(string context, Type type, IEnumerable<KeyValuePair<string, string[]>> actions) Parameters Type Name Description String context Context name Type type Data type to grant actions IEnumerable < KeyValuePair < String , String []>> actions Granted actions | Improve this Doc View Source RegisterRestrictedProperties(String, Type, IEnumerable<KeyValuePair<String, String[]>>) Restricted properties registration Declaration protected void RegisterRestrictedProperties(string context, Type type, IEnumerable<KeyValuePair<string, string[]>> restricted) Parameters Type Name Description String context Context name Type type Data type to restrict property access IEnumerable < KeyValuePair < String , String []>> restricted Restricted properties | Improve this Doc View Source RegisterSecurityFilters(String, Type, IEnumerable<KeyValuePair<String, Expression>>) Security filters registration Declaration protected void RegisterSecurityFilters(string context, Type type, IEnumerable<KeyValuePair<string, Expression>> filters) Parameters Type Name Description String context Context name Type type Data type to filter data IEnumerable < KeyValuePair < String , Expression >> filters Security filters Extension Methods SerializationExtensions.ToXml<T>(T) CollectionsExtensions.SetValue<TKey, T>(TKey, T) CollectionsExtensions.AsEnum<T>(T) DataObjectQueryableExtensions.CompareVariable(Object, FilterOperation, String) Processing.Do<T>(T, Action<IProcess<T>>[]) TypeExtensions.TryConvert<T, TResult>(T, Func<T, TResult>) TypeExtensions.TryConvert<T, TResult>(T, Func<T, TResult>, TResult) TypeExtensions.ChangeType<T>(Object) TypeExtensions.ChangeType(Object, Type) TypeExtensions.InvokeMethod<TRet>(Object, Type[], Expression<Func<TRet>>, BindingFlags) TypeExtensions.InvokeMethod(Object, Type[], Expression<Action>, BindingFlags) TypeExtensions.InvokeMethod<TRet>(Object, Expression<Func<TRet>>, BindingFlags) TypeExtensions.InvokeMethod(Object, Expression<Action>, BindingFlags) SqlBlockExtensions.SetExpression<TTag, TResult>(TTag, Expression<Func<IBlockQueryAdapter, TResult>>) QueryDescriptionExtensions.SetExpression<TTag, TResult>(TTag, Expression<Func<IQueryStructureAdapter, TResult>>)"
  },
  "api/XData.LockAttachedHandler-1.html": {
    "href": "api/XData.LockAttachedHandler-1.html",
    "title": "Delegate LockAttachedHandler<T> | XData website",
    "keywords": "Delegate LockAttachedHandler<T> Lock object attached handler delegate Namespace : XData Assembly : XData.docfx.dll Syntax public delegate bool LockAttachedHandler<in T>(T obj) where T : class, IDataObject; Parameters Type Name Description T obj Object instance Returns Type Description Boolean Type Parameters Name Description T Object type Extension Methods SerializationExtensions.ToXml<T>(T) CollectionsExtensions.SetValue<TKey, T>(TKey, T) CollectionsExtensions.AsEnum<T>(T) DataObjectQueryableExtensions.CompareVariable(Object, FilterOperation, String) Processing.Do<T>(T, Action<IProcess<T>>[]) TypeExtensions.TryConvert<T, TResult>(T, Func<T, TResult>) TypeExtensions.TryConvert<T, TResult>(T, Func<T, TResult>, TResult) TypeExtensions.ChangeType<T>(Object) TypeExtensions.ChangeType(Object, Type) TypeExtensions.InvokeMethod<TRet>(Object, Type[], Expression<Func<TRet>>, BindingFlags) TypeExtensions.InvokeMethod(Object, Type[], Expression<Action>, BindingFlags) TypeExtensions.InvokeMethod<TRet>(Object, Expression<Func<TRet>>, BindingFlags) TypeExtensions.InvokeMethod(Object, Expression<Action>, BindingFlags) SqlBlockExtensions.SetExpression<TTag, TResult>(TTag, Expression<Func<IBlockQueryAdapter, TResult>>) QueryDescriptionExtensions.SetExpression<TTag, TResult>(TTag, Expression<Func<IQueryStructureAdapter, TResult>>)"
  },
  "api/XData.Json.html": {
    "href": "api/XData.Json.html",
    "title": "Namespace XData.Json | XData website",
    "keywords": "Namespace XData.Json Classes JsonDataObjectConverter<T> JsonSettings<T> JSON serialization settings Enums HideFlags Serialization hide flag for properties LinkMode Link serialization mode"
  },
  "api/XData.Database.SqlBlock.ISetSqlVarAdapter.html": {
    "href": "api/XData.Database.SqlBlock.ISetSqlVarAdapter.html",
    "title": "Interface ISetSqlVarAdapter | XData website",
    "keywords": "Interface ISetSqlVarAdapter SQL variable assignment adapter Namespace : XData.Database.SqlBlock Assembly : XData.docfx.dll Syntax public interface ISetSqlVarAdapter Methods | Improve this Doc View Source Var<T>(String, Expression<Func<ISqlValueAdapter, ISqlValue<T>>>) SQL variable value assignment Declaration ISqlValue<T> Var<T>(string name, Expression<Func<ISqlValueAdapter, ISqlValue<T>>> value) Parameters Type Name Description String name Variable name Expression < Func < ISqlValueAdapter , ISqlValue <T>>> value Value assignment Returns Type Description ISqlValue <T> SQL value description Type Parameters Name Description T Value type Extension Methods SerializationExtensions.ToXml<T>(T) CollectionsExtensions.SetValue<TKey, T>(TKey, T) CollectionsExtensions.AsEnum<T>(T) DataObjectQueryableExtensions.CompareVariable(Object, FilterOperation, String) Processing.Do<T>(T, Action<IProcess<T>>[]) TypeExtensions.TryConvert<T, TResult>(T, Func<T, TResult>) TypeExtensions.TryConvert<T, TResult>(T, Func<T, TResult>, TResult) TypeExtensions.ChangeType<T>(Object) TypeExtensions.ChangeType(Object, Type) TypeExtensions.InvokeMethod<TRet>(Object, Type[], Expression<Func<TRet>>, BindingFlags) TypeExtensions.InvokeMethod(Object, Type[], Expression<Action>, BindingFlags) TypeExtensions.InvokeMethod<TRet>(Object, Expression<Func<TRet>>, BindingFlags) TypeExtensions.InvokeMethod(Object, Expression<Action>, BindingFlags) SqlBlockExtensions.SetExpression<TTag, TResult>(TTag, Expression<Func<IBlockQueryAdapter, TResult>>) QueryDescriptionExtensions.SetExpression<TTag, TResult>(TTag, Expression<Func<IQueryStructureAdapter, TResult>>)"
  },
  "api/XData.Database.SqlBlock.IExpressionMergeAdapter.html": {
    "href": "api/XData.Database.SqlBlock.IExpressionMergeAdapter.html",
    "title": "Interface IExpressionMergeAdapter | XData website",
    "keywords": "Interface IExpressionMergeAdapter Expression structure adapter for SQL block queries Inherited Members IExpressionPropertyAdapter.Size(Int32) IExpressionPropertyAdapter.Size(Int32, Int32) IExpressionPropertyAdapter.NativeSqlType(String) IExpressionPropertyAdapter.Exists() IExpressionPropertyAdapter.Exists(ExistsOperation) IPropertyMappingAdapter.Key() IPropertyMappingAdapter.Group(DataGrouping) IPropertyMappingAdapter.Group(Int32) IPropertyMappingAdapter.Hidden() IPropertyMappingAdapter.OrderBy(Int32, Boolean) IPropertyMappingAdapter.OrderBy(Int32) IMergeAttributeAdapter.Source(String) IMergeAttributeAdapter.Link() IMergeAttributeAdapter.Update() IMergeAttributeAdapter.Insert() IMergeAttributeAdapter.Insert(DefaultType) IMergeAttributeAdapter.Insert(DefaultType, Object) Namespace : XData.Database.SqlBlock Assembly : XData.docfx.dll Syntax public interface IExpressionMergeAdapter : IExpressionPropertyAdapter, IPropertyMappingAdapter, IMergeAttributeAdapter Extension Methods SerializationExtensions.ToXml<T>(T) CollectionsExtensions.SetValue<TKey, T>(TKey, T) CollectionsExtensions.AsEnum<T>(T) DataObjectQueryableExtensions.CompareVariable(Object, FilterOperation, String) Processing.Do<T>(T, Action<IProcess<T>>[]) TypeExtensions.TryConvert<T, TResult>(T, Func<T, TResult>) TypeExtensions.TryConvert<T, TResult>(T, Func<T, TResult>, TResult) TypeExtensions.ChangeType<T>(Object) TypeExtensions.ChangeType(Object, Type) TypeExtensions.InvokeMethod<TRet>(Object, Type[], Expression<Func<TRet>>, BindingFlags) TypeExtensions.InvokeMethod(Object, Type[], Expression<Action>, BindingFlags) TypeExtensions.InvokeMethod<TRet>(Object, Expression<Func<TRet>>, BindingFlags) TypeExtensions.InvokeMethod(Object, Expression<Action>, BindingFlags) SqlBlockExtensions.SetExpression<TTag, TResult>(TTag, Expression<Func<IBlockQueryAdapter, TResult>>) QueryDescriptionExtensions.SetExpression<TTag, TResult>(TTag, Expression<Func<IQueryStructureAdapter, TResult>>)"
  },
  "api/XData.CurrentObjectChanged-1.html": {
    "href": "api/XData.CurrentObjectChanged-1.html",
    "title": "Delegate CurrentObjectChanged<T> | XData website",
    "keywords": "Delegate CurrentObjectChanged<T> Object assigned as current event delegate type Namespace : XData Assembly : XData.docfx.dll Syntax public delegate void CurrentObjectChanged<in T>(T obj) where T : class, IDataObject; Parameters Type Name Description T obj Changing is allowed Type Parameters Name Description T Object type Extension Methods SerializationExtensions.ToXml<T>(T) CollectionsExtensions.SetValue<TKey, T>(TKey, T) CollectionsExtensions.AsEnum<T>(T) DataObjectQueryableExtensions.CompareVariable(Object, FilterOperation, String) Processing.Do<T>(T, Action<IProcess<T>>[]) TypeExtensions.TryConvert<T, TResult>(T, Func<T, TResult>) TypeExtensions.TryConvert<T, TResult>(T, Func<T, TResult>, TResult) TypeExtensions.ChangeType<T>(Object) TypeExtensions.ChangeType(Object, Type) TypeExtensions.InvokeMethod<TRet>(Object, Type[], Expression<Func<TRet>>, BindingFlags) TypeExtensions.InvokeMethod(Object, Type[], Expression<Action>, BindingFlags) TypeExtensions.InvokeMethod<TRet>(Object, Expression<Func<TRet>>, BindingFlags) TypeExtensions.InvokeMethod(Object, Expression<Action>, BindingFlags) SqlBlockExtensions.SetExpression<TTag, TResult>(TTag, Expression<Func<IBlockQueryAdapter, TResult>>) QueryDescriptionExtensions.SetExpression<TTag, TResult>(TTag, Expression<Func<IQueryStructureAdapter, TResult>>) See Also OnCurrentObjectChanged"
  },
  "api/XData.Actions.html": {
    "href": "api/XData.Actions.html",
    "title": "Class Actions | XData website",
    "keywords": "Class Actions Standard actions used by security Inheritance Object Actions Inherited Members Object.Equals(Object) Object.Equals(Object, Object) Object.GetHashCode() Object.GetType() Object.MemberwiseClone() Object.ReferenceEquals(Object, Object) Object.ToString() Namespace : XData Assembly : XData.docfx.dll Syntax public static class Actions Fields | Improve this Doc View Source All All actions (CRUD and custom actions) Declaration public const string All = \"`ALL`\" Field Value Type Description String | Improve this Doc View Source Create Create action Declaration public const string Create = \"`CREATE`\" Field Value Type Description String | Improve this Doc View Source CRUD CRUD actions Declaration public const string CRUD = \"`CRUD`\" Field Value Type Description String | Improve this Doc View Source Delete Delete action Declaration public const string Delete = \"`DELETE`\" Field Value Type Description String | Improve this Doc View Source Update Update action Declaration public const string Update = \"`UPDATE`\" Field Value Type Description String"
  },
  "api/XData.Mapping.Dynamic.IRepositoryPropertyMappingAdapter-2.html": {
    "href": "api/XData.Mapping.Dynamic.IRepositoryPropertyMappingAdapter-2.html",
    "title": "Interface IRepositoryPropertyMappingAdapter<T, TValue> | XData website",
    "keywords": "Interface IRepositoryPropertyMappingAdapter<T, TValue> Repository property mapping adapter Inherited Members IRepositoryReadOnlyPropertyMappingAdapter.ConcurrencyToken() IRepositoryReadOnlyPropertyMappingAdapter.OuterFlag() IPropertyMappingAdapter.Key() IPropertyMappingAdapter.Group(DataGrouping) IPropertyMappingAdapter.Group(Int32) IPropertyMappingAdapter.Hidden() IPropertyMappingAdapter.OrderBy(Int32, Boolean) IPropertyMappingAdapter.OrderBy(Int32) Namespace : XData.Mapping.Dynamic Assembly : XData.docfx.dll Syntax public interface IRepositoryPropertyMappingAdapter<T, TValue> : IRepositoryReadOnlyPropertyMappingAdapter, IPropertyMappingAdapter where T : class, ISqlObject, new() Type Parameters Name Description T TValue Methods | Improve this Doc View Source Default(DefaultType) Default value description Declaration IStructureFlag Default(DefaultType source) Parameters Type Name Description DefaultType source Default value algorithm Returns Type Description IStructureFlag Property default value description | Improve this Doc View Source Default(DefaultType, TValue) Default value description Declaration IStructureFlag Default(DefaultType source, TValue value) Parameters Type Name Description DefaultType source Default value algorithm TValue value Default value Returns Type Description IStructureFlag Property default value description | Improve this Doc View Source Default(DefaultType, TValue, DefaultFeature) Default value description Declaration IStructureFlag Default(DefaultType source, TValue value, DefaultFeature features) Parameters Type Name Description DefaultType source Default value algorithm TValue value Default value DefaultFeature features Default extended features Returns Type Description IStructureFlag Property default value description | Improve this Doc View Source Default(DefaultType, DefaultFeature) Default value description Declaration IStructureFlag Default(DefaultType source, DefaultFeature features) Parameters Type Name Description DefaultType source Default value algorithm DefaultFeature features Default extended features Returns Type Description IStructureFlag Property default value description | Improve this Doc View Source UpdateWith(Expression<Func<IQueryStructureAdapter, TValue>>) Update value source description Declaration IStructureFlag UpdateWith(Expression<Func<IQueryStructureAdapter, TValue>> expr) Parameters Type Name Description Expression < Func < IQueryStructureAdapter , TValue>> expr Update value expression definition Returns Type Description IStructureFlag Update value source description | Improve this Doc View Source UpdateWith(String, Type, String, DataGrouping, Expression<Func<ISubqueryLinkAdapter, IStructureFlag>>[]) Update value source description Declaration IStructureFlag UpdateWith(string alias, Type subqueryType, string property, DataGrouping grouping = DataGrouping.None, params Expression<Func<ISubqueryLinkAdapter, IStructureFlag>>[] attributes) Parameters Type Name Description String alias Subquery alias Type subqueryType Subquery type String property Subquery selected property DataGrouping grouping Subquery selected property aggregate function Expression < Func < ISubqueryLinkAdapter , IStructureFlag >>[] attributes Subquery links Returns Type Description IStructureFlag Update value source description | Improve this Doc View Source UpdateWith(DataExpressionType, String) Update value source description Declaration IStructureFlag UpdateWith(DataExpressionType type, string exprText) Parameters Type Name Description DataExpressionType type Update value source expression type String exprText Expression text alias Returns Type Description IStructureFlag Update value source description | Improve this Doc View Source UpdateWith<TDObj>(String, IQueryDescription<TDObj>, Expression<Func<TDObj, TValue>>, DataGrouping, Expression<Func<ISubqueryLinkAdapter<T, TDObj>, IStructureFlag>>[]) Update value source description Declaration IStructureFlag UpdateWith<TDObj>(string alias, IQueryDescription<TDObj> sub, Expression<Func<TDObj, TValue>> property, DataGrouping grouping = DataGrouping.None, params Expression<Func<ISubqueryLinkAdapter<T, TDObj>, IStructureFlag>>[] attributes) where TDObj : class Parameters Type Name Description String alias Subquery alias IQueryDescription <TDObj> sub Subquery definition Expression < Func <TDObj, TValue>> property Subquery selected property expression DataGrouping grouping Subquery selected property aggregate function Expression < Func < ISubqueryLinkAdapter <T, TDObj>, IStructureFlag >>[] attributes Subquery links Returns Type Description IStructureFlag Update value source description Type Parameters Name Description TDObj | Improve this Doc View Source UpdateWith<TDObj>(String, IQueryDescription<TDObj>, String, DataGrouping, Expression<Func<ISubqueryLinkAdapter<T, TDObj>, IStructureFlag>>[]) Update value source description Declaration IStructureFlag UpdateWith<TDObj>(string alias, IQueryDescription<TDObj> sub, string property, DataGrouping grouping = DataGrouping.None, params Expression<Func<ISubqueryLinkAdapter<T, TDObj>, IStructureFlag>>[] attributes) where TDObj : class Parameters Type Name Description String alias Subquery alias IQueryDescription <TDObj> sub Subquery definition String property Subquery selected property DataGrouping grouping Subquery selected property aggregate function Expression < Func < ISubqueryLinkAdapter <T, TDObj>, IStructureFlag >>[] attributes Subquery links Returns Type Description IStructureFlag Update value source description Type Parameters Name Description TDObj Extension Methods SerializationExtensions.ToXml<T>(T) CollectionsExtensions.SetValue<TKey, T>(TKey, T) CollectionsExtensions.AsEnum<T>(T) DataObjectQueryableExtensions.CompareVariable(Object, FilterOperation, String) Processing.Do<T>(T, Action<IProcess<T>>[]) TypeExtensions.TryConvert<T, TResult>(T, Func<T, TResult>) TypeExtensions.TryConvert<T, TResult>(T, Func<T, TResult>, TResult) TypeExtensions.ChangeType<T>(Object) TypeExtensions.ChangeType(Object, Type) TypeExtensions.InvokeMethod<TRet>(Object, Type[], Expression<Func<TRet>>, BindingFlags) TypeExtensions.InvokeMethod(Object, Type[], Expression<Action>, BindingFlags) TypeExtensions.InvokeMethod<TRet>(Object, Expression<Func<TRet>>, BindingFlags) TypeExtensions.InvokeMethod(Object, Expression<Action>, BindingFlags) SqlBlockExtensions.SetExpression<TTag, TResult>(TTag, Expression<Func<IBlockQueryAdapter, TResult>>) QueryDescriptionExtensions.SetExpression<TTag, TResult>(TTag, Expression<Func<IQueryStructureAdapter, TResult>>)"
  },
  "api/XData.Mapping.Dynamic.QueryDescriptionExtensions.html": {
    "href": "api/XData.Mapping.Dynamic.QueryDescriptionExtensions.html",
    "title": "Class QueryDescriptionExtensions | XData website",
    "keywords": "Class QueryDescriptionExtensions Query description extensions Inheritance Object QueryDescriptionExtensions Inherited Members Object.Equals(Object) Object.Equals(Object, Object) Object.GetHashCode() Object.GetType() Object.MemberwiseClone() Object.ReferenceEquals(Object, Object) Object.ToString() Namespace : XData.Mapping.Dynamic Assembly : XData.docfx.dll Syntax public static class QueryDescriptionExtensions Methods | Improve this Doc View Source AsPrimary<T>(T) Set primary filter flag to filter description Declaration public static T AsPrimary<T>(this T desc) where T : IFilterDescription Parameters Type Name Description T desc Filter description Returns Type Description T Filter description Type Parameters Name Description T Filter description type Exceptions Type Condition XDataRuntimeException desc argument can not be null | Improve this Doc View Source Case<T, TResult>(IQueryStructureAdapter, Expression<Func<IQueryStructureAdapter, T>>, Expression<Func<IQueryStructureAdapter, TResult>>, TaggedExpression<T, TResult>[]) Case Declaration public static TResult Case<T, TResult>(this IQueryStructureAdapter adapter, Expression<Func<IQueryStructureAdapter, T>> expression, Expression<Func<IQueryStructureAdapter, TResult>> elseValue, params TaggedExpression<T, TResult>[] switchValues) Parameters Type Name Description IQueryStructureAdapter adapter Source query structure adapter Expression < Func < IQueryStructureAdapter , T>> expression Case expression Expression < Func < IQueryStructureAdapter , TResult>> elseValue Else value TaggedExpression <T, TResult>[] switchValues Case switch values Returns Type Description TResult Case result Type Parameters Name Description T TResult Exceptions Type Condition XDataRuntimeException Function accessible in XData LINQ expressions only | Improve this Doc View Source DateDiff<T>(IQueryStructureAdapter, Expression<Func<IQueryStructureAdapter, DateTime>>, Expression<Func<IQueryStructureAdapter, DateTime>>, DateDiffKind) Dates difference Declaration public static T DateDiff<T>(this IQueryStructureAdapter adapter, Expression<Func<IQueryStructureAdapter, DateTime>> finalDate, Expression<Func<IQueryStructureAdapter, DateTime>> startDate, DateDiffKind kind) Parameters Type Name Description IQueryStructureAdapter adapter Source query structure adapter Expression < Func < IQueryStructureAdapter , DateTime >> finalDate Final date Expression < Func < IQueryStructureAdapter , DateTime >> startDate Start date DateDiffKind kind Dates differences kind Returns Type Description T Dates difference Type Parameters Name Description T Exceptions Type Condition XDataRuntimeException Function accessible in XData LINQ expressions only | Improve this Doc View Source Exists(IQueryStructureAdapter, String) Exists Declaration public static bool Exists(this IQueryStructureAdapter adapter, string subQueryAlias) Parameters Type Name Description IQueryStructureAdapter adapter Source query structure adapter String subQueryAlias Subquery alias Returns Type Description Boolean Exceptions Type Condition XDataRuntimeException Function accessible in XData LINQ expressions only | Improve this Doc View Source GetProperty(ISqlObject, String) Property get handler used in XData mapping Declaration public static object GetProperty(this ISqlObject obj, string property) Parameters Type Name Description ISqlObject obj Object String property Property name Returns Type Description Object Property | Improve this Doc View Source GetVariable<TResult>(IQueryStructureAdapter, String) Declaration public static TResult GetVariable<TResult>(this IQueryStructureAdapter adapter, string variableName) Parameters Type Name Description IQueryStructureAdapter adapter String variableName Returns Type Description TResult Type Parameters Name Description TResult | Improve this Doc View Source HasFlag<T>(IQueryStructureAdapter, Expression<Func<IQueryStructureAdapter, T>>, Expression<Func<IQueryStructureAdapter, T>>, Expression<Func<IQueryStructureAdapter, T>>, Expression<Func<IQueryStructureAdapter, T>>) Bit mask has flag Declaration public static T HasFlag<T>(this IQueryStructureAdapter adapter, Expression<Func<IQueryStructureAdapter, T>> expression, Expression<Func<IQueryStructureAdapter, T>> flagValue, Expression<Func<IQueryStructureAdapter, T>> trueValue, Expression<Func<IQueryStructureAdapter, T>> falseValue) Parameters Type Name Description IQueryStructureAdapter adapter Source query structure adapter Expression < Func < IQueryStructureAdapter , T>> expression Expression to test Expression < Func < IQueryStructureAdapter , T>> flagValue Flag value Expression < Func < IQueryStructureAdapter , T>> trueValue Result if flag exists Expression < Func < IQueryStructureAdapter , T>> falseValue Result if flag not exists Returns Type Description T Bit mask has flag than trueValue else falseValue Type Parameters Name Description T Exceptions Type Condition XDataRuntimeException Function accessible in XData LINQ expressions only | Improve this Doc View Source SetCombination<T>(T, String) Set combination name to filter description Declaration public static T SetCombination<T>(this T desc, string combinationName) where T : IFilterDescription Parameters Type Name Description T desc Filter description String combinationName Filter combination name Returns Type Description T Filter description Type Parameters Name Description T Filter description type Exceptions Type Condition XDataRuntimeException desc argument can not be null | Improve this Doc View Source SetExpression<TTag, TResult>(TTag, Expression<Func<IQueryStructureAdapter, TResult>>) Set expression to tag Declaration public static TaggedExpression<TTag, TResult> SetExpression<TTag, TResult>(this TTag key, Expression<Func<IQueryStructureAdapter, TResult>> expression) Parameters Type Name Description TTag key Tag value Expression < Func < IQueryStructureAdapter , TResult>> expression Expression Returns Type Description TaggedExpression <TTag, TResult> Tagged expression Type Parameters Name Description TTag Tag type TResult Expression result | Improve this Doc View Source SetOperation<T>(T, FilterOperation) Set filter or link operation Declaration public static T SetOperation<T>(this T desc, FilterOperation operation) where T : IFilterDescription Parameters Type Name Description T desc Filter description FilterOperation operation Filter operation Returns Type Description T Filter description Type Parameters Name Description T Filter description type Exceptions Type Condition XDataRuntimeException desc argument can not be null or empty See Also FilterOperation | Improve this Doc View Source SqlExpr<TResult>(IQueryStructureAdapter, String, Expression<Func<IQueryStructureAdapter, Object>>[]) Plain SQL expression with XData LINQ expression placeholders Declaration public static TResult SqlExpr<TResult>(this IQueryStructureAdapter adapter, string format, params Expression<Func<IQueryStructureAdapter, object>>[] expressions) Parameters Type Name Description IQueryStructureAdapter adapter Source query structure adapter String format SQL expression body in Format(String, Object[]) style Expression < Func < IQueryStructureAdapter , Object >>[] expressions XData LINQ parameter expressions Returns Type Description TResult SQL expression result Type Parameters Name Description TResult Remarks WARNING! Plain SQL expressions can use specific SQL dialect features! Data mapping may be not compatible with other database engines! Exceptions Type Condition XDataRuntimeException Function accessible in XData LINQ expressions only | Improve this Doc View Source SqlFn<TResult>(IQueryStructureAdapter, String, Expression<Func<IQueryStructureAdapter, Object>>[]) SQL function call Declaration public static TResult SqlFn<TResult>(this IQueryStructureAdapter adapter, string name, params Expression<Func<IQueryStructureAdapter, object>>[] parameters) Parameters Type Name Description IQueryStructureAdapter adapter Source query structure adapter String name SQL function full qualified name Expression < Func < IQueryStructureAdapter , Object >>[] parameters Function parameters descriptions Returns Type Description TResult Function call result Type Parameters Name Description TResult Exceptions Type Condition XDataRuntimeException Function accessible in XData LINQ expressions only | Improve this Doc View Source SqlParam<TResult>(IQueryStructureAdapter, String, DbType, Expression<Func<IProcedureParameterAdapter, IProcedureParameterFlag>>[]) SQL parameter definition Declaration public static TResult SqlParam<TResult>(this IQueryStructureAdapter adapter, string binding, DbType type, params Expression<Func<IProcedureParameterAdapter, IProcedureParameterFlag>>[] attributes) Parameters Type Name Description IQueryStructureAdapter adapter Query structure adapter String binding Parameter data binding name DbType type Parameter database type Expression < Func < IProcedureParameterAdapter , IProcedureParameterFlag >>[] attributes Parameter mapping attributes Returns Type Description TResult Parameter Type Parameters Name Description TResult Parameter mapped type Exceptions Type Condition XDataRuntimeException Function accessible in XData LINQ expressions only | Improve this Doc View Source ToDataSet<T>(IEnumerable<T>, String, ISqlBuilder) Composes data source text from sequence Declaration public static string ToDataSet<T>(this IEnumerable<T> source, string prefix, ISqlBuilder builder) Parameters Type Name Description IEnumerable <T> source Source sequence String prefix Source column prefix ISqlBuilder builder SQL dialect adapter Returns Type Description String Data source text Type Parameters Name Description T Source object type Remarks Used to compose synthetic data source from object sequence var ds = Enumerable.Range(1,3).ToDataSet(\"val\", XDataManager.GetContext().DialectAdapter); // for MSSQL dialect ds will contains \"(select 1 as val union select 2 as val union select 3 as val)\" // for Oracle dialect ds will contains \"(select 1 as val from dual union select 2 as val from dual union select 3 as val from dual)\" // Enumeration types can be used as var ds = Enum.GetValues(typeof(SomeEnumType)).Cast<int>().ToDataSet(\"val\", XDataManager.GetContext().DialectAdapter); // Object types properties are represented as fields var test = new []{new {Id=1, Name=\"Test\"}, new {Id=2, Name=\"Another\"}}; var ds = test.ToDataSet(\"X\", XDataManager.GetContext().DialectAdapter); // for MSSQL dialect ds will contains \"(select 1 as X_Id, 'Test' as X_Name union select 2 as X_Id, 'Another' as X_Name)\""
  },
  "api/XData.Mapping.Dynamic.IPropertyMappingAdapter.html": {
    "href": "api/XData.Mapping.Dynamic.IPropertyMappingAdapter.html",
    "title": "Interface IPropertyMappingAdapter | XData website",
    "keywords": "Interface IPropertyMappingAdapter Basic dynamic structure adapter Namespace : XData.Mapping.Dynamic Assembly : XData.docfx.dll Syntax public interface IPropertyMappingAdapter Methods | Improve this Doc View Source Group(Int32) Property grouping modifier Declaration IStructureFlag Group(int groupOrder) Parameters Type Name Description Int32 groupOrder Property grouping option Returns Type Description IStructureFlag Property grouping description | Improve this Doc View Source Group(DataGrouping) Property grouping modifier Declaration IStructureFlag Group(DataGrouping grouping) Parameters Type Name Description DataGrouping grouping Property grouping option Returns Type Description IStructureFlag Property key description Remarks Used as property description attribute | Improve this Doc View Source Hidden() Column is hidden column flag Declaration IStructureFlag Hidden() Returns Type Description IStructureFlag | Improve this Doc View Source Key() Property is key modifier Declaration IStructureFlag Key() Returns Type Description IStructureFlag Property key description Remarks Used as property description attribute | Improve this Doc View Source OrderBy(Int32) Property order by modifier Declaration IStructureFlag OrderBy(int order) Parameters Type Name Description Int32 order Property oder by option Returns Type Description IStructureFlag Property oder by description | Improve this Doc View Source OrderBy(Int32, Boolean) Property order by modifier Declaration IStructureFlag OrderBy(int order, bool desc) Parameters Type Name Description Int32 order Property oder by option Boolean desc Descent order flag Returns Type Description IStructureFlag Property oder by description Extension Methods SerializationExtensions.ToXml<T>(T) CollectionsExtensions.SetValue<TKey, T>(TKey, T) CollectionsExtensions.AsEnum<T>(T) DataObjectQueryableExtensions.CompareVariable(Object, FilterOperation, String) Processing.Do<T>(T, Action<IProcess<T>>[]) TypeExtensions.TryConvert<T, TResult>(T, Func<T, TResult>) TypeExtensions.TryConvert<T, TResult>(T, Func<T, TResult>, TResult) TypeExtensions.ChangeType<T>(Object) TypeExtensions.ChangeType(Object, Type) TypeExtensions.InvokeMethod<TRet>(Object, Type[], Expression<Func<TRet>>, BindingFlags) TypeExtensions.InvokeMethod(Object, Type[], Expression<Action>, BindingFlags) TypeExtensions.InvokeMethod<TRet>(Object, Expression<Func<TRet>>, BindingFlags) TypeExtensions.InvokeMethod(Object, Expression<Action>, BindingFlags) SqlBlockExtensions.SetExpression<TTag, TResult>(TTag, Expression<Func<IBlockQueryAdapter, TResult>>) QueryDescriptionExtensions.SetExpression<TTag, TResult>(TTag, Expression<Func<IQueryStructureAdapter, TResult>>)"
  },
  "api/XData.Mapping.Dynamic.IProcedureParameterFlag.html": {
    "href": "api/XData.Mapping.Dynamic.IProcedureParameterFlag.html",
    "title": "Interface IProcedureParameterFlag | XData website",
    "keywords": "Interface IProcedureParameterFlag Procedure parameter mapping flag Namespace : XData.Mapping.Dynamic Assembly : XData.docfx.dll Syntax public interface IProcedureParameterFlag Extension Methods SerializationExtensions.ToXml<T>(T) CollectionsExtensions.SetValue<TKey, T>(TKey, T) CollectionsExtensions.AsEnum<T>(T) DataObjectQueryableExtensions.CompareVariable(Object, FilterOperation, String) Processing.Do<T>(T, Action<IProcess<T>>[]) TypeExtensions.TryConvert<T, TResult>(T, Func<T, TResult>) TypeExtensions.TryConvert<T, TResult>(T, Func<T, TResult>, TResult) TypeExtensions.ChangeType<T>(Object) TypeExtensions.ChangeType(Object, Type) TypeExtensions.InvokeMethod<TRet>(Object, Type[], Expression<Func<TRet>>, BindingFlags) TypeExtensions.InvokeMethod(Object, Type[], Expression<Action>, BindingFlags) TypeExtensions.InvokeMethod<TRet>(Object, Expression<Func<TRet>>, BindingFlags) TypeExtensions.InvokeMethod(Object, Expression<Action>, BindingFlags) SqlBlockExtensions.SetExpression<TTag, TResult>(TTag, Expression<Func<IBlockQueryAdapter, TResult>>) QueryDescriptionExtensions.SetExpression<TTag, TResult>(TTag, Expression<Func<IQueryStructureAdapter, TResult>>)"
  },
  "api/XData.Mapping.Dynamic.IExternalLinkDefinitionAdapter-1.html": {
    "href": "api/XData.Mapping.Dynamic.IExternalLinkDefinitionAdapter-1.html",
    "title": "Interface IExternalLinkDefinitionAdapter<T> | XData website",
    "keywords": "Interface IExternalLinkDefinitionAdapter<T> External link definition adapter Namespace : XData.Mapping.Dynamic Assembly : XData.docfx.dll Syntax public interface IExternalLinkDefinitionAdapter<T> where T : class, ISqlObject, new() Type Parameters Name Description T Parent data object type Methods | Improve this Doc View Source ExternalLink<TChild>(Expression<Func<T, Object>>, Expression<Func<IExternalLinkAdapter<T, TChild>, IExternalLinkFlag>>[]) External link definition Declaration IExternalLinkDefinition ExternalLink<TChild>(Expression<Func<T, object>> parent, params Expression<Func<IExternalLinkAdapter<T, TChild>, IExternalLinkFlag>>[] linkFlags) where TChild : class, IDataObject, new() Parameters Type Name Description Expression < Func <T, Object >> parent Link parent object property Expression < Func < IExternalLinkAdapter <T, TChild>, IExternalLinkFlag >>[] linkFlags External link flags Returns Type Description IExternalLinkDefinition External link definition Type Parameters Name Description TChild External link repository data object type | Improve this Doc View Source ExternalLink<TChild>(Expression<Func<IExternalLinkAdapter<T, TChild>, IExternalLinkFlag>>[]) External link definition Declaration IExternalLinkDefinition ExternalLink<TChild>(params Expression<Func<IExternalLinkAdapter<T, TChild>, IExternalLinkFlag>>[] linkFlags) where TChild : class, IDataObject, new() Parameters Type Name Description Expression < Func < IExternalLinkAdapter <T, TChild>, IExternalLinkFlag >>[] linkFlags External link flags Returns Type Description IExternalLinkDefinition External link definition Type Parameters Name Description TChild External link repository data object type | Improve this Doc View Source ExternalLink<TChild>(String, Expression<Func<IExternalLinkAdapter<T, TChild>, IExternalLinkFlag>>[]) External link definition Declaration IExternalLinkDefinition ExternalLink<TChild>(string property, params Expression<Func<IExternalLinkAdapter<T, TChild>, IExternalLinkFlag>>[] linkFlags) where TChild : class, IDataObject, new() Parameters Type Name Description String property Link property name Expression < Func < IExternalLinkAdapter <T, TChild>, IExternalLinkFlag >>[] linkFlags External link flags Returns Type Description IExternalLinkDefinition External link definition Type Parameters Name Description TChild External link repository data object type Extension Methods SerializationExtensions.ToXml<T>(T) CollectionsExtensions.SetValue<TKey, T>(TKey, T) CollectionsExtensions.AsEnum<T>(T) DataObjectQueryableExtensions.CompareVariable(Object, FilterOperation, String) Processing.Do<T>(T, Action<IProcess<T>>[]) TypeExtensions.TryConvert<T, TResult>(T, Func<T, TResult>) TypeExtensions.TryConvert<T, TResult>(T, Func<T, TResult>, TResult) TypeExtensions.ChangeType<T>(Object) TypeExtensions.ChangeType(Object, Type) TypeExtensions.InvokeMethod<TRet>(Object, Type[], Expression<Func<TRet>>, BindingFlags) TypeExtensions.InvokeMethod(Object, Type[], Expression<Action>, BindingFlags) TypeExtensions.InvokeMethod<TRet>(Object, Expression<Func<TRet>>, BindingFlags) TypeExtensions.InvokeMethod(Object, Expression<Action>, BindingFlags) SqlBlockExtensions.SetExpression<TTag, TResult>(TTag, Expression<Func<IBlockQueryAdapter, TResult>>) QueryDescriptionExtensions.SetExpression<TTag, TResult>(TTag, Expression<Func<IQueryStructureAdapter, TResult>>)"
  },
  "api/XData.Mapping.Dynamic.IExternalLinkDefinition.html": {
    "href": "api/XData.Mapping.Dynamic.IExternalLinkDefinition.html",
    "title": "Interface IExternalLinkDefinition | XData website",
    "keywords": "Interface IExternalLinkDefinition Dynamic structure external link definition interface Namespace : XData.Mapping.Dynamic Assembly : XData.docfx.dll Syntax public interface IExternalLinkDefinition Extension Methods SerializationExtensions.ToXml<T>(T) CollectionsExtensions.SetValue<TKey, T>(TKey, T) CollectionsExtensions.AsEnum<T>(T) DataObjectQueryableExtensions.CompareVariable(Object, FilterOperation, String) Processing.Do<T>(T, Action<IProcess<T>>[]) TypeExtensions.TryConvert<T, TResult>(T, Func<T, TResult>) TypeExtensions.TryConvert<T, TResult>(T, Func<T, TResult>, TResult) TypeExtensions.ChangeType<T>(Object) TypeExtensions.ChangeType(Object, Type) TypeExtensions.InvokeMethod<TRet>(Object, Type[], Expression<Func<TRet>>, BindingFlags) TypeExtensions.InvokeMethod(Object, Type[], Expression<Action>, BindingFlags) TypeExtensions.InvokeMethod<TRet>(Object, Expression<Func<TRet>>, BindingFlags) TypeExtensions.InvokeMethod(Object, Expression<Action>, BindingFlags) SqlBlockExtensions.SetExpression<TTag, TResult>(TTag, Expression<Func<IBlockQueryAdapter, TResult>>) QueryDescriptionExtensions.SetExpression<TTag, TResult>(TTag, Expression<Func<IQueryStructureAdapter, TResult>>)"
  },
  "api/XData.IRepository.html": {
    "href": "api/XData.IRepository.html",
    "title": "Interface IRepository | XData website",
    "keywords": "Interface IRepository Data repository (data object collection) basic interface Inherited Members IDataQuery.Alias IDataQuery.Layer IDataQuery.Context IDataQuery.Variables IDataQuery.Keys IDataQuery.Token IQueryable.ElementType IQueryable.Expression IQueryable.Provider IEnumerable.GetEnumerator() IDisposable.Dispose() Namespace : XData Assembly : XData.docfx.dll Syntax public interface IRepository : IDataQuery, IOrderedQueryable, IQueryable, IEnumerable, IDisposable Properties | Improve this Doc View Source Count Get repository object count Declaration long Count { get; } Property Value Type Description Int64 | Improve this Doc View Source Editable Get editable state of repository objects Declaration bool Editable { get; } Property Value Type Description Boolean | Improve this Doc View Source FixedQuery Data repository fixed query Declaration bool FixedQuery { get; set; } Property Value Type Description Boolean Remarks Used to cache record set once (at first call) and have an access to cached data multiple times Hint: Useful when needed to read the same data multiple times according dynamic rules and all records count approximately equal or less then requests count Examples var q = dataScope.GetRepository<Some>().Where(x => x.SomeField == 1); q.FixedQuery = true; q.FirstOrDefault(x => x.OtherField == 3); //Queried across the cached data | Improve this Doc View Source HasCurrentRecord Check current record is assigned Declaration bool HasCurrentRecord { get; } Property Value Type Description Boolean | Improve this Doc View Source Manual Manual repository flag Declaration bool Manual { get; set; } Property Value Type Description Boolean Remarks Manual repositories can be filled by attached objects only Hint: Use manual repositories to build logic filled repositories Hint: Use manual repositories as mock repositories for testing Hint: Object attaching (see Attach(T, DataObjectState, IEnumerable<KeyValuePair<String, Object>>, AttachedHandler<T>[]) ) set Manual property to True automatically WARNING! Detach objects (see Detach(Predicate<T>) ) NOT set Manual property to False automatically! See Also Attach(T, DataObjectState, IEnumerable<KeyValuePair<String, Object>>, AttachedHandler<T>[]) Detach(Predicate<T>) SetAttachedHandlers(ref T, AttachedHandler<T>[]) SetAttachedHandlers(RepositoryAttachedHandler<T>[]) | Improve this Doc View Source ShowSubtree Data repository tree modifier Declaration bool ShowSubtree { get; set; } Property Value Type Description Boolean Remarks Used to show/hide subtree related items in slave view when master is tree When ShowSubtree = false - slave contains selected node child items only When ShowSubtree = true - selected node and it's subtree child items Works with DirectLink : External links marked as DirectLink is filled while ShowSubtree is false and omitted otherwise See Also DirectLink Methods | Improve this Doc View Source Clear(DataSubmitFlag) Clear repository objects Declaration bool Clear(DataSubmitFlag flag = DataSubmitFlag.None) Parameters Type Name Description DataSubmitFlag flag Returns Type Description Boolean Remarks All objects corresponded current repository limitations will be deleted through single operation WARNING! Trigger logic BeforeDelete and AfterDelete are not used in this case! Use BeforeClear and AfterClear instead! | Improve this Doc View Source CloseChilds() Close child repositories Declaration void CloseChilds() | Improve this Doc View Source DetachChild<TChild>(String) Detach child repository Declaration void DetachChild<TChild>(string alias = null) where TChild : class, IDataObject, new() Parameters Type Name Description String alias Type Parameters Name Description TChild | Improve this Doc View Source FindParent<TParent>(out IRepository<TParent>, String) Find parent repository Declaration bool FindParent<TParent>(out IRepository<TParent> parent, string alias = null) where TParent : class, IDataObject, new() Parameters Type Name Description IRepository <TParent> parent Parent repository String alias Parent repository alias Returns Type Description Boolean Find success Type Parameters Name Description TParent Parent repository type | Improve this Doc View Source GetChild<TChild>(String, ISecuritySession, Variable[]) Get a child repository Declaration IRepository<TChild> GetChild<TChild>(string alias = null, ISecuritySession security = null, params Variable[] variables) where TChild : class, IDataObject, new() Parameters Type Name Description String alias Child alias ISecuritySession security Security session Variable [] variables Child variables Returns Type Description IRepository <TChild> Repository Type Parameters Name Description TChild Child type Remarks If child repository not exists it will be created and linked to base repository as a child When alias parameter value is not set child object type name used as child repository alias See Also DetachChild<TChild>(String) CloseChilds() | Improve this Doc View Source Refresh() Refresh repository data cache Declaration void Refresh() Extension Methods DataObjectExtensions.GetParameter<T>(IDataQuery, String) DataObjectExtensions.GetResultSet<TRes>(IDataQuery, String) DataObjectExtensions.GetResultSet<TRes>(IDataQuery, Expression<Func<IEnumerable<TRes>>>) SerializationExtensions.ToXml<T>(T) AsyncExtensions.GetParameterAsync<T>(IDataQuery, String) AsyncExtensions.GetResultSetAsync<TRes>(IDataQuery, String) AsyncExtensions.GetResultSetAsync<TRes>(IDataQuery, Expression<Func<IEnumerable<TRes>>>) CollectionsExtensions.SetValue<TKey, T>(TKey, T) CollectionsExtensions.AsEnum<T>(T) DataObjectQueryableExtensions.CompareVariable(Object, FilterOperation, String) Processing.Do<T>(T, Action<IProcess<T>>[]) TypeExtensions.TryConvert<T, TResult>(T, Func<T, TResult>) TypeExtensions.TryConvert<T, TResult>(T, Func<T, TResult>, TResult) TypeExtensions.ChangeType<T>(Object) TypeExtensions.ChangeType(Object, Type) TypeExtensions.InvokeMethod<TRet>(Object, Type[], Expression<Func<TRet>>, BindingFlags) TypeExtensions.InvokeMethod(Object, Type[], Expression<Action>, BindingFlags) TypeExtensions.InvokeMethod<TRet>(Object, Expression<Func<TRet>>, BindingFlags) TypeExtensions.InvokeMethod(Object, Expression<Action>, BindingFlags) SqlBlockExtensions.SetExpression<TTag, TResult>(TTag, Expression<Func<IBlockQueryAdapter, TResult>>) QueryDescriptionExtensions.SetExpression<TTag, TResult>(TTag, Expression<Func<IQueryStructureAdapter, TResult>>) See Also IRepository <T>"
  },
  "api/XData.IRepository-1.html": {
    "href": "api/XData.IRepository-1.html",
    "title": "Interface IRepository<T> | XData website",
    "keywords": "Interface IRepository<T> Data repository (data object collection) type specific interface Inherited Members IDataQuery<T>.GetFilterValue(RuntimeFilter) IEnumerable<T>.GetEnumerator() IRepository.ShowSubtree IRepository.FixedQuery IRepository.DetachChild<TChild>(String) IRepository.Clear(DataSubmitFlag) IRepository.CloseChilds() IRepository.Refresh() IRepository.GetChild<TChild>(String, ISecuritySession, Variable[]) IRepository.FindParent<TParent>(IRepository<TParent>, String) IRepository.Count IRepository.Editable IRepository.HasCurrentRecord IRepository.Manual IDataQuery.Alias IDataQuery.Layer IDataQuery.Context IDataQuery.Variables IDataQuery.Keys IDataQuery.Token IQueryable.ElementType IQueryable.Expression IQueryable.Provider IDisposable.Dispose() Namespace : XData Assembly : XData.docfx.dll Syntax public interface IRepository<T> : IDataQuery<T>, IOrderedQueryable<T>, IQueryable<T>, IEnumerable<T>, IRepository, IDataQuery, IOrderedQueryable, IQueryable, IEnumerable, IDisposable where T : class, IDataObject Type Parameters Name Description T Remarks Hint: Its possible to use any DI container with XData: // example with Autofac syntax // register Container.Register(() => dataScope.GetRepository<Invoice>()).As<IRepository<Invoice>>(); Container.Register(() => dataScope.GetRepository<Invoice>().GetChild<InvoiceSpec>()).As<IRepository<InvoiceSpec>>(); // resolve var spec = Container.Resolve<IRepository<InvoiceSpec>>(); //spec is linked with Invoice repository as a slave! Properties | Improve this Doc View Source Current Get/set current data object Declaration T Current { get; set; } Property Value Type Description T Current data object instance Exceptions Type Condition XDataQueryStructureException object not mapped properly. Methods | Improve this Doc View Source Add<TFrom>(IEnumerable<TFrom>, Mapping<TFrom, T>, DataSubmitFlag) Copy objects from source repository Declaration bool Add<TFrom>(IEnumerable<TFrom> source, Mapping<TFrom, T> mapping = null, DataSubmitFlag flag = DataSubmitFlag.None) where TFrom : class Parameters Type Name Description IEnumerable <TFrom> source Source repository Mapping <TFrom, T> mapping Data mapping DataSubmitFlag flag Submit flag Returns Type Description Boolean Success flag Type Parameters Name Description TFrom Exceptions Type Condition XDataRuntimeException \"source\" parameter is null. XDataQueryStructureException mapping error. See Also Mapping <TFrom, T> | Improve this Doc View Source Attach(T, DataObjectState, IEnumerable<KeyValuePair<String, Object>>, AttachedHandler<T>[]) Attach object to repository Declaration IRepository<T> Attach(T obj, DataObjectState state = DataObjectState.Original, IEnumerable<KeyValuePair<string, object>> originalValues = null, params AttachedHandler<T>[] handlers) Parameters Type Name Description T obj Object instance DataObjectState state Object state IEnumerable < KeyValuePair < String , Object >> originalValues Original property values AttachedHandler <T>[] handlers Attached handlers Returns Type Description IRepository <T> Repository Remarks Hint: Object attaching set Manual property to True automatically Hint: The originalValues parameter can contain only necessary not null valued properties Hint: Use SetValue<TKey, T>(TKey, T) to fill originalValues parameter Hint: Use AttachedHandler<T> convert operators to attach object specific handlers (SubmitObjectAttachedHandler<Invoice>)((ref Invoice i, DataSubmitFlag f) => true) WARNING! Use repository SetAttachedHandlers(RepositoryAttachedHandler<T>[]) method to apply same handler for all objects! Exceptions Type Condition XDataQueryStructureException no DataObjectAttribute found in data object mapping. XDataRuntimeException type loading error. See Also SetValue<TKey, T> (TKey, T) Detach(Predicate<T>) | Improve this Doc View Source AttachNewObjects(IEnumerable<T>, AttachedHandler<T>[]) Attach object to repository Declaration IEnumerable<T> AttachNewObjects(IEnumerable<T> source, params AttachedHandler<T>[] handlers) Parameters Type Name Description IEnumerable <T> source Object sequence AttachedHandler <T>[] handlers Attached handlers Returns Type Description IEnumerable <T> Repository Remarks Hint: Object attaching set Manual property to True automatically Hint: The originalValues parameter can contain only necessary not null valued properties Hint: Use SetValue<TKey, T>(TKey, T) to fill originalValues parameter Hint: Use AttachedHandler<T> convert operators to attach object specific handlers (SubmitObjectAttachedHandler<Invoice>)((ref Invoice i, DataSubmitFlag f) => true) WARNING! Use repository SetAttachedHandlers(RepositoryAttachedHandler<T>[]) method to apply same handler for all objects! Exceptions Type Condition XDataQueryStructureException no DataObjectAttribute found in data object mapping. XDataRuntimeException type loading error. See Also SetValue<TKey, T> (TKey, T) Detach(Predicate<T>) | Improve this Doc View Source Clear(Expression<Func<T, Boolean>>, DataSubmitFlag) Clear repository objects Declaration bool Clear(Expression<Func<T, bool>> predicate, DataSubmitFlag flag = DataSubmitFlag.None) Parameters Type Name Description Expression < Func <T, Boolean >> predicate DataSubmitFlag flag Returns Type Description Boolean Remarks All objects corresponded current repository limitations will be deleted through single operation WARNING! Trigger logic BeforeDelete and AfterDelete are not used in this case! Use BeforeClear and AfterClear instead! Exceptions Type Condition XDataQueryStructureException no DataObjectAttribute found in data object mapping. XDataRuntimeException type loading error. | Improve this Doc View Source ClearAttachedObjects() Clear attached objects Declaration IRepository<T> ClearAttachedObjects() Returns Type Description IRepository <T> Repository Remarks WARNING! Clear attached objects NOT set Manual property to False automatically! Exceptions Type Condition XDataQueryStructureException no DataObjectAttribute found in data object mapping. XDataRuntimeException type loading error. | Improve this Doc View Source Detach(Predicate<T>) Detach virtual objects from repository Declaration IRepository<T> Detach(Predicate<T> predicate) Parameters Type Name Description Predicate <T> predicate Object search predicate to detach Returns Type Description IRepository <T> Repository Exceptions Type Condition XDataQueryStructureException no DataObjectAttribute found in data object mapping. XDataRuntimeException type loading error. See Also Attach(T, DataObjectState, IEnumerable<KeyValuePair<String, Object>>, AttachedHandler<T>[]) Detach(Predicate<T>) | Improve this Doc View Source Execute(String, IEnumerable<T>, IDictionary<String, Action<Byte[]>>, IDictionary<String, Func<Byte[], Byte[]>>) Run custom logic over object instances Declaration bool Execute(string key, IEnumerable<T> objects, IDictionary<string, Action<byte[]>> post = null, IDictionary<string, Func<byte[], byte[]>> callback = null) Parameters Type Name Description String key Logic key IEnumerable <T> objects Object instances IDictionary < String , Action < Byte []>> post Post data handler IDictionary < String , Func < Byte [], Byte []>> callback Callback handler Returns Type Description Boolean Success flag Exceptions Type Condition XDataQueryStructureException no DataObjectAttribute found in data object mapping. XDataRuntimeException type loading error. See Also CustomLogic <T> Execute<T> (T, Expression < Func < CustomLogic <T>>>, IDictionary < String , Action < Byte []>>, IDictionary < String , Func < Byte [], Byte []>>) Execute<T>(ICollection<T>, Expression<Func<CustomLogic<T>>>, IDictionary<String, Action<Byte[]>>, IDictionary<String, Func<Byte[], Byte[]>>) | Improve this Doc View Source GetChild<TChild>(Expression<Func<T, TChild[]>>, String, ISecuritySession, Variable[]) Get a child repository Declaration IRepository<TChild> GetChild<TChild>(Expression<Func<T, TChild[]>> property, string alias = null, ISecuritySession security = null, params Variable[] variables) where TChild : class, IDataObject, new() Parameters Type Name Description Expression < Func <T, TChild[]>> property Property to store child entities String alias Child alias ISecuritySession security Security session Variable [] variables Child variables Returns Type Description IRepository <TChild> Repository Type Parameters Name Description TChild Child type Remarks If child repository not exists it will be created and linked to base repository as a child When alias parameter value is not set child object type name used as child repository alias Exceptions Type Condition XDataQueryStructureException no DataObjectAttribute found in data object mapping. XDataRuntimeException type loading error. See Also DetachChild<TChild> ( String ) CloseChilds () | Improve this Doc View Source GetChild<TChild>(Expression<Func<T, TChild>>, String, ISecuritySession, Variable[]) Get a child repository Declaration IRepository<TChild> GetChild<TChild>(Expression<Func<T, TChild>> property, string alias = null, ISecuritySession security = null, params Variable[] variables) where TChild : class, IDataObject, new() Parameters Type Name Description Expression < Func <T, TChild>> property Property to store child entity (1-to-1) String alias Child alias ISecuritySession security Security session Variable [] variables Child variables Returns Type Description IRepository <TChild> Repository Type Parameters Name Description TChild Child type Remarks If child repository not exists it will be created and linked to base repository as a child When alias parameter value is not set child object type name used as child repository alias Exceptions Type Condition XDataQueryStructureException no DataObjectAttribute found in data object mapping. XDataRuntimeException type loading error. See Also DetachChild<TChild> ( String ) CloseChilds () | Improve this Doc View Source Lock(T) Lock object in database Declaration bool Lock(T obj) Parameters Type Name Description T obj Data object instance Returns Type Description Boolean Success flag Exceptions Type Condition XDataRuntimeException \"obj\" parameter is null. See Also Lock<T> (T) | Improve this Doc View Source New() Get new instance of data object Declaration T New() Returns Type Description T Data object instance Exceptions Type Condition XDataQueryStructureException object not mapped properly. | Improve this Doc View Source New(Action<T>[]) Get new instance of data object Declaration T New(params Action<T>[] init) Parameters Type Name Description Action <T>[] init Data object initialization actions Returns Type Description T Data object instance Exceptions Type Condition XDataQueryStructureException object not mapped properly. | Improve this Doc View Source Refresh(ref T) Refresh object data from database Declaration bool Refresh(ref T obj) Parameters Type Name Description T obj Data object instance Returns Type Description Boolean Success flag Exceptions Type Condition XDataRuntimeException \"obj\" parameter is null. XDataQueryStructureException object not mapped properly. See Also Refresh<T> (T) | Improve this Doc View Source Reset() Reset repository structure and filter values Declaration IRepository<T> Reset() Returns Type Description IRepository <T> Self repository link Exceptions Type Condition XDataQueryStructureException no DataObjectAttribute found in data object mapping. XDataRuntimeException type loading error. See Also RuntimeFilter GetFilterValue ( RuntimeFilter ) SetFilterValue(RuntimeFilter, Object) | Improve this Doc View Source SetAttachedHandlers(ref T, AttachedHandler<T>[]) Attach extra handlers to single object Declaration void SetAttachedHandlers(ref T obj, params AttachedHandler<T>[] handlers) Parameters Type Name Description T obj Object instance AttachedHandler <T>[] handlers Attached handlers Remarks Hint: Use AttachedHandler<T> convert operators to attach object specific handlers (SubmitObjectAttachedHandler<Invoice>)((ref Invoice i, DataSubmitFlag f) => true) WARNING! Use repository SetAttachedHandlers(RepositoryAttachedHandler<T>[]) method to apply same handler for all objects! Exceptions Type Condition XDataQueryStructureException no DataObjectAttribute found in data object mapping. XDataRuntimeException type loading error. See Also Attach(T, DataObjectState, IEnumerable<KeyValuePair<String, Object>>, AttachedHandler<T>[]) SetAttachedHandlers(RepositoryAttachedHandler<T>[]) SetAttachedHandlers<T> (T, AttachedHandler <T>[]) | Improve this Doc View Source SetAttachedHandlers(RepositoryAttachedHandler<T>[]) Attach extra handlers to repository Declaration IRepository<T> SetAttachedHandlers(params RepositoryAttachedHandler<T>[] handlers) Parameters Type Name Description RepositoryAttachedHandler <T>[] handlers Attached handlers Returns Type Description IRepository <T> Repository Remarks Hint: Use RepositoryAttachedHandler<T> convert operators to attach object specific handlers (SubmitObjectAttachedHandler<Invoice>)((ref Invoice i, DataSubmitFlag f) => true) Exceptions Type Condition XDataQueryStructureException no DataObjectAttribute found in data object mapping. XDataRuntimeException type loading error. | Improve this Doc View Source SetFilterValue(RuntimeFilter, Object) Set metadata defined RuntimeFilter value Declaration IRepository<T> SetFilterValue(RuntimeFilter filter, object val) Parameters Type Name Description RuntimeFilter filter Filter Object val Filter value Returns Type Description IRepository <T> Self repository link Remarks Hint: Set val = null to clear filter Exceptions Type Condition XDataRuntimeException \"filter\" parameter is null. See Also RuntimeFilter Reset() GetFilterValue ( RuntimeFilter ) | Improve this Doc View Source Submit(ref T, DataSubmitFlag) Save single data object changes Declaration bool Submit(ref T obj, DataSubmitFlag flag = DataSubmitFlag.None) Parameters Type Name Description T obj Data object instance DataSubmitFlag flag Submit flag Returns Type Description Boolean Success flag Exceptions Type Condition XDataRuntimeException \"objects\" is null. See Also Submit<T> (T, DataSubmitFlag ) | Improve this Doc View Source Submit(IEnumerable<T>, DataSubmitFlag) Save multiple data objects changes Declaration bool Submit(IEnumerable<T> objects, DataSubmitFlag flag = DataSubmitFlag.None) Parameters Type Name Description IEnumerable <T> objects Data object sequence DataSubmitFlag flag Submit flag Returns Type Description Boolean Success flag Exceptions Type Condition XDataRuntimeException \"objects\" is null or empty sequence. See Also DataSubmitFlag Events | Improve this Doc View Source OnCurrentObjectChanged Event fired when repository current object is changed Declaration event CurrentObjectChanged<T> OnCurrentObjectChanged Event Type Type Description CurrentObjectChanged <T> Exceptions Type Condition XDataRuntimeException custom logic fires exception. | Improve this Doc View Source OnCurrentObjectChanging Event fired when repository current object changing occurred Declaration event CurrentObjectChanging<T> OnCurrentObjectChanging Event Type Type Description CurrentObjectChanging <T> Exceptions Type Condition XDataRuntimeException custom logic fires exception. | Improve this Doc View Source OnInit Event fired when repository is initialized Declaration event InitRepository<T> OnInit Event Type Type Description InitRepository <T> Exceptions Type Condition XDataRuntimeException custom logic fires exception. | Improve this Doc View Source OnInitObject Event fired when object is initialized Declaration event InitObject<T> OnInitObject Event Type Type Description InitObject <T> Exceptions Type Condition XDataRuntimeException custom logic fires exception. | Improve this Doc View Source OnInvalidate Event fired when repository need to be refreshed Declaration event InvalidateRepository<T> OnInvalidate Event Type Type Description InvalidateRepository <T> Exceptions Type Condition XDataRuntimeException custom logic fires exception. | Improve this Doc View Source OnInvalidateObject Event fired when object need to be refreshed Declaration event InvalidateObject<T> OnInvalidateObject Event Type Type Description InvalidateObject <T> Exceptions Type Condition XDataRuntimeException custom logic fires exception. Extension Methods DataObjectExtensions.AsString<T>(IQueryable<T>) DataObjectExtensions.GetParameter<T>(IDataQuery, String) DataObjectExtensions.GetResultSet<TRes>(IDataQuery, String) DataObjectExtensions.GetResultSet<TRes>(IDataQuery, Expression<Func<IEnumerable<TRes>>>) SerializationExtensions.ToXml<T>(T) AsyncExtensions.AllAsync<T>(IQueryable<T>, Expression<Func<T, Boolean>>) AsyncExtensions.AllAsync<T>(IQueryable<T>, Expression<Func<T, Boolean>>, CancellationToken) AsyncExtensions.AllAsync<T>(IDataQuery<T>, Expression<Func<T, Boolean>>) AsyncExtensions.AnyAsync<T>(IQueryable<T>) AsyncExtensions.AnyAsync<T>(IQueryable<T>, Expression<Func<T, Boolean>>) AsyncExtensions.AnyAsync<T>(IQueryable<T>, Expression<Func<T, Boolean>>, CancellationToken) AsyncExtensions.AnyAsync<T>(IDataQuery<T>, Expression<Func<T, Boolean>>) AsyncExtensions.AverageAsync<T>(IQueryable<T>, Expression<Func<T, Single>>) AsyncExtensions.AverageAsync<T>(IQueryable<T>, Expression<Func<T, Single>>, CancellationToken) AsyncExtensions.AverageAsync<T>(IDataQuery<T>, Expression<Func<T, Single>>) AsyncExtensions.AverageAsync<T>(IQueryable<T>, Expression<Func<T, Double>>) AsyncExtensions.AverageAsync<T>(IQueryable<T>, Expression<Func<T, Double>>, CancellationToken) AsyncExtensions.AverageAsync<T>(IDataQuery<T>, Expression<Func<T, Double>>) AsyncExtensions.AverageAsync<T>(IQueryable<T>, Expression<Func<T, Decimal>>) AsyncExtensions.AverageAsync<T>(IQueryable<T>, Expression<Func<T, Decimal>>, CancellationToken) AsyncExtensions.AverageAsync<T>(IDataQuery<T>, Expression<Func<T, Decimal>>) AsyncExtensions.AverageAsync<T>(IQueryable<T>, Expression<Func<T, Int32>>) AsyncExtensions.AverageAsync<T>(IQueryable<T>, Expression<Func<T, Int32>>, CancellationToken) AsyncExtensions.AverageAsync<T>(IDataQuery<T>, Expression<Func<T, Int32>>) AsyncExtensions.AverageAsync<T>(IQueryable<T>, Expression<Func<T, Int64>>) AsyncExtensions.AverageAsync<T>(IQueryable<T>, Expression<Func<T, Int64>>, CancellationToken) AsyncExtensions.AverageAsync<T>(IDataQuery<T>, Expression<Func<T, Int64>>) AsyncExtensions.AverageAsync<T>(IQueryable<T>, Expression<Func<T, Nullable<Single>>>) AsyncExtensions.AverageAsync<T>(IQueryable<T>, Expression<Func<T, Nullable<Single>>>, CancellationToken) AsyncExtensions.AverageAsync<T>(IDataQuery<T>, Expression<Func<T, Nullable<Single>>>) AsyncExtensions.AverageAsync<T>(IQueryable<T>, Expression<Func<T, Nullable<Double>>>) AsyncExtensions.AverageAsync<T>(IQueryable<T>, Expression<Func<T, Nullable<Double>>>, CancellationToken) AsyncExtensions.AverageAsync<T>(IDataQuery<T>, Expression<Func<T, Nullable<Double>>>) AsyncExtensions.AverageAsync<T>(IQueryable<T>, Expression<Func<T, Nullable<Decimal>>>) AsyncExtensions.AverageAsync<T>(IQueryable<T>, Expression<Func<T, Nullable<Decimal>>>, CancellationToken) AsyncExtensions.AverageAsync<T>(IDataQuery<T>, Expression<Func<T, Nullable<Decimal>>>) AsyncExtensions.AverageAsync<T>(IQueryable<T>, Expression<Func<T, Nullable<Int32>>>) AsyncExtensions.AverageAsync<T>(IQueryable<T>, Expression<Func<T, Nullable<Int32>>>, CancellationToken) AsyncExtensions.AverageAsync<T>(IDataQuery<T>, Expression<Func<T, Nullable<Int32>>>) AsyncExtensions.AverageAsync<T>(IQueryable<T>, Expression<Func<T, Nullable<Int64>>>) AsyncExtensions.AverageAsync<T>(IQueryable<T>, Expression<Func<T, Nullable<Int64>>>, CancellationToken) AsyncExtensions.AverageAsync<T>(IDataQuery<T>, Expression<Func<T, Nullable<Int64>>>) AsyncExtensions.ContainsAsync<T>(IQueryable<T>, T, Func<T, Object>[]) AsyncExtensions.ContainsAsync<T>(IQueryable<T>, T, IEqualityComparer<T>) AsyncExtensions.ContainsAsync<T>(IQueryable<T>, T, IEqualityComparer<T>, CancellationToken) AsyncExtensions.ContainsAsync<T>(IDataQuery<T>, T, IEqualityComparer<T>) AsyncExtensions.ContainsAsync<T>(IDataQuery<T>, T) AsyncExtensions.CountAsync<T>(IQueryable<T>) AsyncExtensions.CountAsync<T>(IQueryable<T>, Expression<Func<T, Boolean>>) AsyncExtensions.CountAsync<T>(IQueryable<T>, Expression<Func<T, Boolean>>, CancellationToken) AsyncExtensions.CountAsync<T>(IDataQuery<T>) AsyncExtensions.CountAsync<T>(IDataQuery<T>, Expression<Func<T, Boolean>>) AsyncExtensions.LongCountAsync<T>(IQueryable<T>) AsyncExtensions.LongCountAsync<T>(IQueryable<T>, Expression<Func<T, Boolean>>) AsyncExtensions.LongCountAsync<T>(IQueryable<T>, Expression<Func<T, Boolean>>, CancellationToken) AsyncExtensions.LongCountAsync<T>(IDataQuery<T>) AsyncExtensions.LongCountAsync<T>(IDataQuery<T>, Expression<Func<T, Boolean>>) AsyncExtensions.FirstAsync<T>(IQueryable<T>) AsyncExtensions.FirstAsync<T>(IQueryable<T>, Expression<Func<T, Boolean>>) AsyncExtensions.FirstAsync<T>(IQueryable<T>, Expression<Func<T, Boolean>>, CancellationToken) AsyncExtensions.FirstAsync<T>(IDataQuery<T>) AsyncExtensions.FirstAsync<T>(IDataQuery<T>, Expression<Func<T, Boolean>>) AsyncExtensions.FirstOrDefaultAsync<T>(IQueryable<T>) AsyncExtensions.FirstOrDefaultAsync<T>(IQueryable<T>, Expression<Func<T, Boolean>>) AsyncExtensions.FirstOrDefaultAsync<T>(IQueryable<T>, Expression<Func<T, Boolean>>, CancellationToken) AsyncExtensions.FirstOrDefaultAsync<T>(IDataQuery<T>) AsyncExtensions.FirstOrDefaultAsync<T>(IDataQuery<T>, Expression<Func<T, Boolean>>) AsyncExtensions.ForEachAsync<T>(IQueryable<T>, Func<T, Task>) AsyncExtensions.ForEachAsync<T>(IQueryable<T>, Func<T, Task>, CancellationToken) AsyncExtensions.ForEachAsync<T>(IDataQuery<T>, Func<T, Task>) AsyncExtensions.ForEachAsync<T>(IQueryable<T>, Action<T>) AsyncExtensions.ForEachAsync<T>(IQueryable<T>, Action<T>, CancellationToken) AsyncExtensions.ForEachAsync<T>(IDataQuery<T>, Action<T>) AsyncExtensions.LastAsync<T>(IQueryable<T>) AsyncExtensions.LastAsync<T>(IQueryable<T>, Expression<Func<T, Boolean>>) AsyncExtensions.LastAsync<T>(IQueryable<T>, Expression<Func<T, Boolean>>, CancellationToken) AsyncExtensions.LastAsync<T>(IDataQuery<T>) AsyncExtensions.LastAsync<T>(IDataQuery<T>, Expression<Func<T, Boolean>>) AsyncExtensions.LastOrDefaultAsync<T>(IQueryable<T>) AsyncExtensions.LastOrDefaultAsync<T>(IQueryable<T>, Expression<Func<T, Boolean>>) AsyncExtensions.LastOrDefaultAsync<T>(IQueryable<T>, Expression<Func<T, Boolean>>, CancellationToken) AsyncExtensions.LastOrDefaultAsync<T>(IDataQuery<T>) AsyncExtensions.LastOrDefaultAsync<T>(IDataQuery<T>, Expression<Func<T, Boolean>>) AsyncExtensions.MaxAsync<T, TResult>(IQueryable<T>, Expression<Func<T, TResult>>) AsyncExtensions.MaxAsync<T, TResult>(IQueryable<T>, Expression<Func<T, TResult>>, CancellationToken) AsyncExtensions.MaxAsync<T, TResult>(IDataQuery<T>, Expression<Func<T, TResult>>) AsyncExtensions.MinAsync<T, TResult>(IQueryable<T>, Expression<Func<T, TResult>>) AsyncExtensions.MinAsync<T, TResult>(IQueryable<T>, Expression<Func<T, TResult>>, CancellationToken) AsyncExtensions.MinAsync<T, TResult>(IDataQuery<T>, Expression<Func<T, TResult>>) AsyncExtensions.GetParameterAsync<T>(IDataQuery, String) AsyncExtensions.GetResultSetAsync<TRes>(IDataQuery, String) AsyncExtensions.GetResultSetAsync<TRes>(IDataQuery, Expression<Func<IEnumerable<TRes>>>) AsyncExtensions.SingleAsync<T>(IQueryable<T>) AsyncExtensions.SingleAsync<T>(IQueryable<T>, Expression<Func<T, Boolean>>) AsyncExtensions.SingleAsync<T>(IQueryable<T>, Expression<Func<T, Boolean>>, CancellationToken) AsyncExtensions.SingleAsync<T>(IDataQuery<T>) AsyncExtensions.SingleAsync<T>(IDataQuery<T>, Expression<Func<T, Boolean>>) AsyncExtensions.SingleOrDefaultAsync<T>(IQueryable<T>) AsyncExtensions.SingleOrDefaultAsync<T>(IQueryable<T>, Expression<Func<T, Boolean>>) AsyncExtensions.SingleOrDefaultAsync<T>(IQueryable<T>, Expression<Func<T, Boolean>>, CancellationToken) AsyncExtensions.SingleOrDefaultAsync<T>(IDataQuery<T>) AsyncExtensions.SingleOrDefaultAsync<T>(IDataQuery<T>, Expression<Func<T, Boolean>>) AsyncExtensions.SumAsync<T>(IQueryable<T>, Expression<Func<T, Single>>) AsyncExtensions.SumAsync<T>(IQueryable<T>, Expression<Func<T, Single>>, CancellationToken) AsyncExtensions.SumAsync<T>(IDataQuery<T>, Expression<Func<T, Single>>) AsyncExtensions.SumAsync<T>(IQueryable<T>, Expression<Func<T, Double>>) AsyncExtensions.SumAsync<T>(IQueryable<T>, Expression<Func<T, Double>>, CancellationToken) AsyncExtensions.SumAsync<T>(IDataQuery<T>, Expression<Func<T, Double>>) AsyncExtensions.SumAsync<T>(IQueryable<T>, Expression<Func<T, Decimal>>) AsyncExtensions.SumAsync<T>(IQueryable<T>, Expression<Func<T, Decimal>>, CancellationToken) AsyncExtensions.SumAsync<T>(IDataQuery<T>, Expression<Func<T, Decimal>>) AsyncExtensions.SumAsync<T>(IQueryable<T>, Expression<Func<T, Int32>>) AsyncExtensions.SumAsync<T>(IQueryable<T>, Expression<Func<T, Int32>>, CancellationToken) AsyncExtensions.SumAsync<T>(IDataQuery<T>, Expression<Func<T, Int32>>) AsyncExtensions.SumAsync<T>(IQueryable<T>, Expression<Func<T, Int64>>) AsyncExtensions.SumAsync<T>(IQueryable<T>, Expression<Func<T, Int64>>, CancellationToken) AsyncExtensions.SumAsync<T>(IDataQuery<T>, Expression<Func<T, Int64>>) AsyncExtensions.SumAsync<T>(IQueryable<T>, Expression<Func<T, Nullable<Single>>>) AsyncExtensions.SumAsync<T>(IQueryable<T>, Expression<Func<T, Nullable<Single>>>, CancellationToken) AsyncExtensions.SumAsync<T>(IDataQuery<T>, Expression<Func<T, Nullable<Single>>>) AsyncExtensions.SumAsync<T>(IQueryable<T>, Expression<Func<T, Nullable<Double>>>) AsyncExtensions.SumAsync<T>(IQueryable<T>, Expression<Func<T, Nullable<Double>>>, CancellationToken) AsyncExtensions.SumAsync<T>(IDataQuery<T>, Expression<Func<T, Nullable<Double>>>) AsyncExtensions.SumAsync<T>(IQueryable<T>, Expression<Func<T, Nullable<Decimal>>>) AsyncExtensions.SumAsync<T>(IQueryable<T>, Expression<Func<T, Nullable<Decimal>>>, CancellationToken) AsyncExtensions.SumAsync<T>(IDataQuery<T>, Expression<Func<T, Nullable<Decimal>>>) AsyncExtensions.SumAsync<T>(IQueryable<T>, Expression<Func<T, Nullable<Int32>>>) AsyncExtensions.SumAsync<T>(IQueryable<T>, Expression<Func<T, Nullable<Int32>>>, CancellationToken) AsyncExtensions.SumAsync<T>(IDataQuery<T>, Expression<Func<T, Nullable<Int32>>>) AsyncExtensions.SumAsync<T>(IQueryable<T>, Expression<Func<T, Nullable<Int64>>>) AsyncExtensions.SumAsync<T>(IQueryable<T>, Expression<Func<T, Nullable<Int64>>>, CancellationToken) AsyncExtensions.SumAsync<T>(IDataQuery<T>, Expression<Func<T, Nullable<Int64>>>) AsyncExtensions.ToArrayAsync<T>(IQueryable<T>) AsyncExtensions.ToArrayAsync<T>(IQueryable<T>, CancellationToken) AsyncExtensions.ToArrayAsync<T>(IDataQuery<T>) AsyncExtensions.ToDictionaryAsync<T, TKey, TValue>(IQueryable<T>, Func<T, TKey>, Func<T, TValue>) AsyncExtensions.ToDictionaryAsync<T, TKey, TValue>(IQueryable<T>, Func<T, TKey>, Func<T, TValue>, CancellationToken) AsyncExtensions.ToDictionaryAsync<T, TKey, TValue>(IDataQuery<T>, Func<T, TKey>, Func<T, TValue>) AsyncExtensions.ToListAsync<T>(IQueryable<T>) AsyncExtensions.ToListAsync<T>(IQueryable<T>, CancellationToken) AsyncExtensions.ToListAsync<T>(IDataQuery<T>) CollectionsExtensions.ToSortedSet<T>(IEnumerable<T>, IComparer<T>) CollectionsExtensions.SetValue<TKey, T>(TKey, T) CollectionsExtensions.AsEnum<T>(T) DataObjectQueryableExtensions.CompareVariable(Object, FilterOperation, String) JoinedEnumerable.Inner<TElement>(IEnumerable<TElement>) JoinedEnumerable.Outer<TElement>(IEnumerable<TElement>) JoinedEnumerable.LeftOuterJoin<TOuter, TInner, TKey, TResult>(IEnumerable<TOuter>, IEnumerable<TInner>, Func<TOuter, TKey>, Func<TInner, TKey>, Func<TOuter, TInner, TResult>, IEqualityComparer<TKey>) JoinedEnumerable.RightOuterJoin<TOuter, TInner, TKey, TResult>(IEnumerable<TOuter>, IEnumerable<TInner>, Func<TOuter, TKey>, Func<TInner, TKey>, Func<TOuter, TInner, TResult>, IEqualityComparer<TKey>) JoinedEnumerable.FullOuterJoin<TOuter, TInner, TKey, TResult>(IEnumerable<TOuter>, IEnumerable<TInner>, Func<TOuter, TKey>, Func<TInner, TKey>, Func<TOuter, TInner, TResult>, IEqualityComparer<TKey>) Processing.Do<T>(T, Action<IProcess<T>>[]) TypeExtensions.TryConvert<T, TResult>(T, Func<T, TResult>) TypeExtensions.TryConvert<T, TResult>(T, Func<T, TResult>, TResult) TypeExtensions.ChangeType<T>(Object) TypeExtensions.ChangeType(Object, Type) TypeExtensions.InvokeMethod<TRet>(Object, Type[], Expression<Func<TRet>>, BindingFlags) TypeExtensions.InvokeMethod(Object, Type[], Expression<Action>, BindingFlags) TypeExtensions.InvokeMethod<TRet>(Object, Expression<Func<TRet>>, BindingFlags) TypeExtensions.InvokeMethod(Object, Expression<Action>, BindingFlags) SqlBlockExtensions.SetExpression<TTag, TResult>(TTag, Expression<Func<IBlockQueryAdapter, TResult>>) QueryDescriptionExtensions.SetExpression<TTag, TResult>(TTag, Expression<Func<IQueryStructureAdapter, TResult>>) QueryDescriptionExtensions.ToDataSet<T>(IEnumerable<T>, String, ISqlBuilder) See Also IDataObject AsString<T> ( IQueryable <T>) GetRepository<T> (T) GetRepository<T>(String, ISecuritySession, Variable[])"
  },
  "api/XData.InitRepository-1.html": {
    "href": "api/XData.InitRepository-1.html",
    "title": "Delegate InitRepository<T> | XData website",
    "keywords": "Delegate InitRepository<T> Repository initialization delegate type Namespace : XData Assembly : XData.docfx.dll Syntax public delegate void InitRepository<T>(IRepository<T> repository) where T : class, IDataObject; Parameters Type Name Description IRepository <T> repository Repository instance Type Parameters Name Description T Object type Extension Methods SerializationExtensions.ToXml<T>(T) CollectionsExtensions.SetValue<TKey, T>(TKey, T) CollectionsExtensions.AsEnum<T>(T) DataObjectQueryableExtensions.CompareVariable(Object, FilterOperation, String) Processing.Do<T>(T, Action<IProcess<T>>[]) TypeExtensions.TryConvert<T, TResult>(T, Func<T, TResult>) TypeExtensions.TryConvert<T, TResult>(T, Func<T, TResult>, TResult) TypeExtensions.ChangeType<T>(Object) TypeExtensions.ChangeType(Object, Type) TypeExtensions.InvokeMethod<TRet>(Object, Type[], Expression<Func<TRet>>, BindingFlags) TypeExtensions.InvokeMethod(Object, Type[], Expression<Action>, BindingFlags) TypeExtensions.InvokeMethod<TRet>(Object, Expression<Func<TRet>>, BindingFlags) TypeExtensions.InvokeMethod(Object, Expression<Action>, BindingFlags) SqlBlockExtensions.SetExpression<TTag, TResult>(TTag, Expression<Func<IBlockQueryAdapter, TResult>>) QueryDescriptionExtensions.SetExpression<TTag, TResult>(TTag, Expression<Func<IQueryStructureAdapter, TResult>>) See Also InitRepository OnInit"
  },
  "api/XData.SubmitObjectAttachedHandler-1.html": {
    "href": "api/XData.SubmitObjectAttachedHandler-1.html",
    "title": "Delegate SubmitObjectAttachedHandler<T> | XData website",
    "keywords": "Delegate SubmitObjectAttachedHandler<T> Submit object attached handler delegate Namespace : XData Assembly : XData.docfx.dll Syntax public delegate bool SubmitObjectAttachedHandler<T>(ref T obj, DataSubmitFlag flag) where T : class, IDataObject; Parameters Type Name Description T obj Object instance DataSubmitFlag flag Submit flag Returns Type Description Boolean Type Parameters Name Description T Object type Extension Methods SerializationExtensions.ToXml<T>(T) CollectionsExtensions.SetValue<TKey, T>(TKey, T) CollectionsExtensions.AsEnum<T>(T) DataObjectQueryableExtensions.CompareVariable(Object, FilterOperation, String) Processing.Do<T>(T, Action<IProcess<T>>[]) TypeExtensions.TryConvert<T, TResult>(T, Func<T, TResult>) TypeExtensions.TryConvert<T, TResult>(T, Func<T, TResult>, TResult) TypeExtensions.ChangeType<T>(Object) TypeExtensions.ChangeType(Object, Type) TypeExtensions.InvokeMethod<TRet>(Object, Type[], Expression<Func<TRet>>, BindingFlags) TypeExtensions.InvokeMethod(Object, Type[], Expression<Action>, BindingFlags) TypeExtensions.InvokeMethod<TRet>(Object, Expression<Func<TRet>>, BindingFlags) TypeExtensions.InvokeMethod(Object, Expression<Action>, BindingFlags) SqlBlockExtensions.SetExpression<TTag, TResult>(TTag, Expression<Func<IBlockQueryAdapter, TResult>>) QueryDescriptionExtensions.SetExpression<TTag, TResult>(TTag, Expression<Func<IQueryStructureAdapter, TResult>>)"
  },
  "api/XData.Mapping.SubqueryAttribute.html": {
    "href": "api/XData.Mapping.SubqueryAttribute.html",
    "title": "Class SubqueryAttribute | XData website",
    "keywords": "Class SubqueryAttribute Data object subquery attribute Inheritance Object Attribute DataSourceAttribute SubqueryAttribute Inherited Members Attribute.Equals(Object) Attribute.GetCustomAttribute(Assembly, Type) Attribute.GetCustomAttribute(Assembly, Type, Boolean) Attribute.GetCustomAttribute(MemberInfo, Type) Attribute.GetCustomAttribute(MemberInfo, Type, Boolean) Attribute.GetCustomAttribute(Module, Type) Attribute.GetCustomAttribute(Module, Type, Boolean) Attribute.GetCustomAttribute(ParameterInfo, Type) Attribute.GetCustomAttribute(ParameterInfo, Type, Boolean) Attribute.GetCustomAttributes(Assembly) Attribute.GetCustomAttributes(Assembly, Boolean) Attribute.GetCustomAttributes(Assembly, Type) Attribute.GetCustomAttributes(Assembly, Type, Boolean) Attribute.GetCustomAttributes(MemberInfo) Attribute.GetCustomAttributes(MemberInfo, Boolean) Attribute.GetCustomAttributes(MemberInfo, Type) Attribute.GetCustomAttributes(MemberInfo, Type, Boolean) Attribute.GetCustomAttributes(Module) Attribute.GetCustomAttributes(Module, Boolean) Attribute.GetCustomAttributes(Module, Type) Attribute.GetCustomAttributes(Module, Type, Boolean) Attribute.GetCustomAttributes(ParameterInfo) Attribute.GetCustomAttributes(ParameterInfo, Boolean) Attribute.GetCustomAttributes(ParameterInfo, Type) Attribute.GetCustomAttributes(ParameterInfo, Type, Boolean) Attribute.GetHashCode() Attribute.IsDefaultAttribute() Attribute.IsDefined(Assembly, Type) Attribute.IsDefined(Assembly, Type, Boolean) Attribute.IsDefined(MemberInfo, Type) Attribute.IsDefined(MemberInfo, Type, Boolean) Attribute.IsDefined(Module, Type) Attribute.IsDefined(Module, Type, Boolean) Attribute.IsDefined(ParameterInfo, Type) Attribute.IsDefined(ParameterInfo, Type, Boolean) Attribute.Match(Object) Object.Equals(Object, Object) Object.GetType() Object.MemberwiseClone() Object.ReferenceEquals(Object, Object) Object.ToString() Namespace : XData.Mapping Assembly : XData.docfx.dll Syntax [AttributeUsage(AttributeTargets.Class, AllowMultiple = true)] public sealed class SubqueryAttribute : DataSourceAttribute Examples Subquery(\"A\", typeof(DocSpecAmounts), \"Amount\", Grouping = DataGrouping.Sum) Constructors | Improve this Doc View Source SubqueryAttribute(String, Type, String) Data object subquery attribute Declaration public SubqueryAttribute(string alias, Type subqueryType, string propertyName) Parameters Type Name Description String alias Subquery alias Type subqueryType Object type represents subquery structure String propertyName Subquery selected property Exceptions Type Condition XDataRuntimeException Subquery alias cannot be null or empty string XDataRuntimeException Object type represents subquery structure cannot be null XDataRuntimeException Subquery selected property cannot be null or empty string Properties | Improve this Doc View Source Alias Subquery alias Declaration public override string Alias { get; protected set; } Property Value Type Description String Overrides DataSourceAttribute.Alias | Improve this Doc View Source Grouping Subquery grouping mode Declaration public DataGrouping Grouping { get; set; } Property Value Type Description DataGrouping Remarks Subquery selected property (see PropertyName ) aggregate function Grouping in subquery mast to be defined by GroupOrder WARNING! Do not use properties inside grouped subqueries! Use ColumnAttribute instead! | Improve this Doc View Source PropertyName Subquery selected property Declaration public string PropertyName { get; } Property Value Type Description String Remarks Only one property (or column) can be selected from subquery | Improve this Doc View Source SubqueryType Object type represents subquery structure Declaration public Type SubqueryType { get; } Property Value Type Description Type | Improve this Doc View Source Type Data source type Declaration public override DataSourceType Type { get; } Property Value Type Description DataSourceType Subquery Overrides DataSourceAttribute.Type | Improve this Doc View Source TypeId When implemented in a derived class, gets a unique identifier for this Attribute . Declaration public override object TypeId { get; } Property Value Type Description Object An Object that is a unique identifier for the attribute. Overrides Attribute.TypeId Extension Methods SerializationExtensions.ToXml<T>(T) CollectionsExtensions.SetValue<TKey, T>(TKey, T) CollectionsExtensions.AsEnum<T>(T) DataObjectQueryableExtensions.CompareVariable(Object, FilterOperation, String) Processing.Do<T>(T, Action<IProcess<T>>[]) TypeExtensions.TryConvert<T, TResult>(T, Func<T, TResult>) TypeExtensions.TryConvert<T, TResult>(T, Func<T, TResult>, TResult) TypeExtensions.ChangeType<T>(Object) TypeExtensions.ChangeType(Object, Type) TypeExtensions.InvokeMethod<TRet>(Object, Type[], Expression<Func<TRet>>, BindingFlags) TypeExtensions.InvokeMethod(Object, Type[], Expression<Action>, BindingFlags) TypeExtensions.InvokeMethod<TRet>(Object, Expression<Func<TRet>>, BindingFlags) TypeExtensions.InvokeMethod(Object, Expression<Action>, BindingFlags) SqlBlockExtensions.SetExpression<TTag, TResult>(TTag, Expression<Func<IBlockQueryAdapter, TResult>>) QueryDescriptionExtensions.SetExpression<TTag, TResult>(TTag, Expression<Func<IQueryStructureAdapter, TResult>>) See Also DataTableAttribute InnerViewAttribute SubqueryLinkAttribute SubqueryFilterAttribute SubQuery ColumnExpressionAttribute PropertyExpressionAttribute ExpressionFilterAttribute"
  },
  "api/XData.Mapping.SqlExpressionAttribute.html": {
    "href": "api/XData.Mapping.SqlExpressionAttribute.html",
    "title": "Class SqlExpressionAttribute | XData website",
    "keywords": "Class SqlExpressionAttribute Sql expression name Inheritance Object Attribute SqlExpressionAttribute Inherited Members Attribute.Equals(Object) Attribute.GetCustomAttribute(Assembly, Type) Attribute.GetCustomAttribute(Assembly, Type, Boolean) Attribute.GetCustomAttribute(MemberInfo, Type) Attribute.GetCustomAttribute(MemberInfo, Type, Boolean) Attribute.GetCustomAttribute(Module, Type) Attribute.GetCustomAttribute(Module, Type, Boolean) Attribute.GetCustomAttribute(ParameterInfo, Type) Attribute.GetCustomAttribute(ParameterInfo, Type, Boolean) Attribute.GetCustomAttributes(Assembly) Attribute.GetCustomAttributes(Assembly, Boolean) Attribute.GetCustomAttributes(Assembly, Type) Attribute.GetCustomAttributes(Assembly, Type, Boolean) Attribute.GetCustomAttributes(MemberInfo) Attribute.GetCustomAttributes(MemberInfo, Boolean) Attribute.GetCustomAttributes(MemberInfo, Type) Attribute.GetCustomAttributes(MemberInfo, Type, Boolean) Attribute.GetCustomAttributes(Module) Attribute.GetCustomAttributes(Module, Boolean) Attribute.GetCustomAttributes(Module, Type) Attribute.GetCustomAttributes(Module, Type, Boolean) Attribute.GetCustomAttributes(ParameterInfo) Attribute.GetCustomAttributes(ParameterInfo, Boolean) Attribute.GetCustomAttributes(ParameterInfo, Type) Attribute.GetCustomAttributes(ParameterInfo, Type, Boolean) Attribute.GetHashCode() Attribute.IsDefaultAttribute() Attribute.IsDefined(Assembly, Type) Attribute.IsDefined(Assembly, Type, Boolean) Attribute.IsDefined(MemberInfo, Type) Attribute.IsDefined(MemberInfo, Type, Boolean) Attribute.IsDefined(Module, Type) Attribute.IsDefined(Module, Type, Boolean) Attribute.IsDefined(ParameterInfo, Type) Attribute.IsDefined(ParameterInfo, Type, Boolean) Attribute.Match(Object) Attribute.TypeId Object.Equals(Object, Object) Object.GetType() Object.MemberwiseClone() Object.ReferenceEquals(Object, Object) Object.ToString() Namespace : XData.Mapping Assembly : XData.docfx.dll Syntax [AttributeUsage(AttributeTargets.Field)] public sealed class SqlExpressionAttribute : Attribute Remarks Mark static field of type Calculate<T> to use in ExpressionFilterAttribute or PropertyExpressionAttribute as expression text. Hint:This is native way to use expressions Extension Methods SerializationExtensions.ToXml<T>(T) CollectionsExtensions.SetValue<TKey, T>(TKey, T) CollectionsExtensions.AsEnum<T>(T) DataObjectQueryableExtensions.CompareVariable(Object, FilterOperation, String) Processing.Do<T>(T, Action<IProcess<T>>[]) TypeExtensions.TryConvert<T, TResult>(T, Func<T, TResult>) TypeExtensions.TryConvert<T, TResult>(T, Func<T, TResult>, TResult) TypeExtensions.ChangeType<T>(Object) TypeExtensions.ChangeType(Object, Type) TypeExtensions.InvokeMethod<TRet>(Object, Type[], Expression<Func<TRet>>, BindingFlags) TypeExtensions.InvokeMethod(Object, Type[], Expression<Action>, BindingFlags) TypeExtensions.InvokeMethod<TRet>(Object, Expression<Func<TRet>>, BindingFlags) TypeExtensions.InvokeMethod(Object, Expression<Action>, BindingFlags) SqlBlockExtensions.SetExpression<TTag, TResult>(TTag, Expression<Func<IBlockQueryAdapter, TResult>>) QueryDescriptionExtensions.SetExpression<TTag, TResult>(TTag, Expression<Func<IQueryStructureAdapter, TResult>>) See Also ExpressionFilterAttribute PropertyExpressionAttribute"
  },
  "api/XData.DataSource.Structure.IExpressionFilter.html": {
    "href": "api/XData.DataSource.Structure.IExpressionFilter.html",
    "title": "Interface IExpressionFilter | XData website",
    "keywords": "Interface IExpressionFilter Expression filter interface Inherited Members IFilter.FilterType IFilter.SourceAlias IFilter.Field IFilter.Operation ICloneable.Clone() Namespace : XData.DataSource.Structure Assembly : XData.docfx.dll Syntax public interface IExpressionFilter : IFilter, ICloneable Properties | Improve this Doc View Source ExprText Expression text Declaration string ExprText { get; } Property Value Type Description String | Improve this Doc View Source IteratorFilter Iterator filter flag Declaration bool IteratorFilter { get; } Property Value Type Description Boolean Extension Methods SerializationExtensions.ToXml<T>(T) CollectionsExtensions.SetValue<TKey, T>(TKey, T) CollectionsExtensions.AsEnum<T>(T) DataObjectQueryableExtensions.CompareVariable(Object, FilterOperation, String) Processing.Do<T>(T, Action<IProcess<T>>[]) TypeExtensions.TryConvert<T, TResult>(T, Func<T, TResult>) TypeExtensions.TryConvert<T, TResult>(T, Func<T, TResult>, TResult) TypeExtensions.ChangeType<T>(Object) TypeExtensions.ChangeType(Object, Type) TypeExtensions.InvokeMethod<TRet>(Object, Type[], Expression<Func<TRet>>, BindingFlags) TypeExtensions.InvokeMethod(Object, Type[], Expression<Action>, BindingFlags) TypeExtensions.InvokeMethod<TRet>(Object, Expression<Func<TRet>>, BindingFlags) TypeExtensions.InvokeMethod(Object, Expression<Action>, BindingFlags) SqlBlockExtensions.SetExpression<TTag, TResult>(TTag, Expression<Func<IBlockQueryAdapter, TResult>>) QueryDescriptionExtensions.SetExpression<TTag, TResult>(TTag, Expression<Func<IQueryStructureAdapter, TResult>>)"
  },
  "tutorial/mapping/static/filter/subquery.html": {
    "href": "tutorial/mapping/static/filter/subquery.html",
    "title": "Subquery filters | XData website",
    "keywords": "Subquery filters To define filters checks field value is correspond subquery results used SubqueryFilterAttribute with specific (over defined above ) parameter: Subquery - subquery alias (see Subqueries ). Inner view can not be used with subquery filters. [SubqueryFilter(\"D\" /* table alias */, \"doc_state_id\" /* field name */, \"A\" /* subquery alias */, Operation: FilterOperation.In /* filter operation */)] When flag PrimaryFilter is set to true optional part of query is defined by followed rules: when one of linked data sources is skipped then other one will skipped too. When base table of subquery is skipped then subquery is skipped completely."
  },
  "tutorial/mapping/procedure/sample_udt_array.html": {
    "href": "tutorial/mapping/procedure/sample_udt_array.html",
    "title": "| XData website",
    "keywords": "MS SQL Server CREATE TYPE [dbo].[Classifier] AS TABLE( [Id] [int] NULL, [Name] [varchar](20) NULL ) CREATE PROCEDURE [dbo].[TestProcedure7] (@param1 Classifier READONLY) AS SELECT * from @param1 Oracle Not supported Warning Oracle ODP.Net provider does not support UDT PostgreSQL CREATE TYPE public.classifier_rec AS ( Id integer, Name varchar(20) ); CREATE or REPLACE function TestProcedure7(p_tab classifier_rec[]) returns setof classifier_rec as $$ select a.Id, a.Name from unnest(p_tab) a; $$ LANGUAGE sql; MySQL Not supported"
  },
  "tutorial/mapping/procedure/sample_udt.html": {
    "href": "tutorial/mapping/procedure/sample_udt.html",
    "title": "| XData website",
    "keywords": "MS SQL Server Not supported Tip MS SQL Server does not support passing single UDT object as a parameter value, but support array of UDT Oracle Not supported Warning Oracle ODP.Net provider does not support UDT PostgreSQL CREATE TYPE public.classifier_rec AS ( Id integer, Name varchar(20) ); CREATE or REPLACE function TestFunction5(p_obj classifier_rec) returns varchar as $$ begin return p_obj.Id || ' - ' || p_obj.Name; end $$ LANGUAGE plpgsql; MySQL Not supported"
  },
  "tutorial/mapping/procedure/sample_table_func.html": {
    "href": "tutorial/mapping/procedure/sample_table_func.html",
    "title": "| XData website",
    "keywords": "MS SQL Server CREATE FUNCTION [dbo].[TestFunction] ( @param1 int, @param2 varchar(20) ) RETURNS TABLE AS RETURN ( SELECT @param1 as Id, @param2 as Name ) Oracle CREATE OR REPLACE type classifier_rec is object (Id int, Name varchar2(20)); CREATE OR REPLACE type classifier_tab is table of classifier_rec; function TestFunction(p_Id int, p_Name varchar2) return classifier_tab pipelined is begin for curr in (select p_Id as Id, p_Name as Name from dual) loop pipe row (classifier_rec(curr.Id, curr.Name)); end loop; end TestFunction; PostgreSQL CREATE or REPLACE function TestFunction(p_id integer, p_name varchar) returns TABLE ( Id bigint, Name varchar ) as $$ select p_id as Id, p_name as Name; $$ LANGUAGE SQL; ... or with the same mapping syntax... CREATE TYPE public.classifier_rec AS ( Id integer, Name varchar(20) ); CREATE or REPLACE function TestFunction(p_Id integer, p_Name varchar) returns setof classifier_rec as $$ select p_Id as Id, p_Name as Name; $$ LANGUAGE SQL; MySQL Not supported"
  },
  "tutorial/mapping/procedure/sample_scalar_func.html": {
    "href": "tutorial/mapping/procedure/sample_scalar_func.html",
    "title": "| XData website",
    "keywords": "MS SQL Server CREATE FUNCTION [dbo].[TestFunction2] ( @param1 int, @param2 varchar(20) ) RETURNS varchar(20) AS BEGIN DECLARE @res varchar(20) SET @res = convert(varchar(20), @param1) + ' - ' + @param2 RETURN @res END Oracle function TestFunction2(p_Id int, p_Name varchar2) return varchar2 is begin return p_Id || ' - ' || p_Name; end TestFunction2; PostgreSQL CREATE or REPLACE function TestFunction2(p_id integer, p_name varchar) returns varchar as $$ DECLARE ret varchar; begin select p_id || ' - ' || p_name into ret; return ret; end $$ LANGUAGE plpgsql; MySQL create function TestFunction2(p_Id int, p_Name varchar(20)) returns varchar(100) begin declare res varchar(100); select CONCAT(p_Id, ' - ', p_Name) into res; return(res); end"
  },
  "tutorial/mapping/procedure/sample_retval_cursor.html": {
    "href": "tutorial/mapping/procedure/sample_retval_cursor.html",
    "title": "| XData website",
    "keywords": "MS SQL Server MS SQL Server CREATE PROCEDURE [dbo].[TestProcedure6] ( @param1 int, @param2 varchar(20) ) AS SELECT @param1 as Id, @param2 as Name RETURN(@param1) Oracle Not supported PostgreSQL Not supported MySQL Not supported"
  },
  "tutorial/mapping/procedure/sample_retval.html": {
    "href": "tutorial/mapping/procedure/sample_retval.html",
    "title": "| XData website",
    "keywords": "MS SQL Server CREATE PROCEDURE [dbo].[TestProcedure5] ( @param1 int, @param2 varchar(20) ) AS RETURN(@param1) Oracle Not supported PostgreSQL Not supported MySQL Not supported"
  },
  "tutorial/mapping/procedure/sample_out_param.html": {
    "href": "tutorial/mapping/procedure/sample_out_param.html",
    "title": "| XData website",
    "keywords": "MS SQL Server CREATE PROCEDURE [dbo].[TestProcedure3] ( @param1 int, @param2 varchar(20), @param3 varchar(20) OUTPUT ) AS SET @param3 = convert(varchar(20), @param1) + ' - ' + @param2 RETURN Oracle procedure TestProcedure3(p_Id int, p_Name varchar2, p_Out out varchar2) as begin select p_Id || ' - ' || p_Name into p_Out from dual; end TestProcedure3; PostgreSQL CREATE or REPLACE function TestProcedure3(p_id integer, p_name varchar, out p_out varchar) as $$ begin p_Out := p_id || ' - ' || p_name; end $$ LANGUAGE plpgsql; MySQL create procedure TestProcedure3(p_Id int, p_Name varchar(50), out p_Out varchar(100)) begin set p_Out = CONCAT(p_Id, ' - ', p_Name); end"
  },
  "tutorial/mapping/procedure/sample_out_cursor.html": {
    "href": "tutorial/mapping/procedure/sample_out_cursor.html",
    "title": "| XData website",
    "keywords": "MS SQL Server CREATE PROCEDURE [dbo].[TestProcedure4] ( @param1 int, @param2 varchar(20) ) AS SELECT @param1 as Id, @param2 as Name RETURN(@param1) Oracle procedure TestProcedure4(p_Tab in classifier_tab, p_Out out SYS_REFCURSOR) as begin open p_Out for select Id, Name from table(p_Tab); end TestProcedure4; Tip Use refcursor parameters names as ResultSet names! PostgreSQL CREATE OR REPLACE FUNCTION public.TestProcedure4 (p_tab public.classifier_rec [], refcursor) RETURNS refcursor AS $$ begin open $2 for select Id, Name from unnest(p_tab); return $2; end $$ LANGUAGE plpgsql; Tip If refcursor parameters have a names it must be used as ResultSet names! MySQL Not supported"
  },
  "tutorial/mapping/dynamic/procedure/sample_scalar_func.html": {
    "href": "tutorial/mapping/dynamic/procedure/sample_scalar_func.html",
    "title": "SQL scalar function as property data source sample | XData website",
    "keywords": "SQL scalar function as property data source sample MS SQL Server CREATE FUNCTION [dbo].[TestFunction2] ( @param1 int, @param2 varchar(20) ) RETURNS varchar(20) AS BEGIN DECLARE @res varchar(20) SET @res = convert(varchar(20), @param1) + ' - ' + @param2 RETURN @res END Oracle function TestFunction2(p_Id int, p_Name varchar2) return varchar2 is begin return p_Id || ' - ' || p_Name; end TestFunction2; PostgreSQL CREATE or REPLACE function TestFunction2(p_id integer, p_name varchar) returns varchar as $$ DECLARE ret varchar; begin select p_id || ' - ' || p_name into ret; return ret; end $$ LANGUAGE plpgsql; MySQL create function TestFunction2(p_Id int, p_Name varchar(20)) returns varchar(100) begin declare res varchar(100); select CONCAT(p_Id, ' - ', p_Name) into res; return(res); end Mapping var t1 = XDataMapping.GetStructure(\"T\") .DataTable(\"T_DOC_TYPE\", \"T\").Select(x => new { DocTypeId = x.Field<long>(\"T\", \"doc_type_id\", z => z.Key()), Code = x.Field<string>(\"T\", \"code\"), Name = x.Field<string>(\"T\", \"name\"), Test = x.Expr(\"test\", z => z.SqlFn<string>(\"dbo.TestFunction2\", y => y.Field<long>(\"T\", \"doc_type_id\"), y => y.Field<string>(\"T\", \"name\")), DbType.String, z => z.Size(20)) }).AsQuery(DataScope); foreach (var z in t1) Console.WriteLine(\"{0} - \\\"{1}\\\" - \\\"{2}\\\" - \\\"{3}\\\"\", z.DocTypeId, z.Code, z.Name, z.Test);"
  },
  "tutorial/mapping/dynamic/procedure/sample_retval_cursor.html": {
    "href": "tutorial/mapping/dynamic/procedure/sample_retval_cursor.html",
    "title": "SQL procedure with return value and result set sample | XData website",
    "keywords": "SQL procedure with return value and result set sample MS SQL Server MS SQL Server CREATE PROCEDURE [dbo].[TestProcedure6] ( @param1 int, @param2 varchar(20) ) AS SELECT @param1 as Id, @param2 as Name RETURN(@param1) Oracle Not supported PostgreSQL Not supported MySQL Not supported Dynamic query var res6 = XDataMapping.GetStructure(\"T\") .Procedure(\"T\", \"dbo.TestProcedure6\", ProcedureType.Procedure) .Parameter<int>(\"T\", 1, \"param1\", DbType.Int32) .Parameter<string>(\"T\", 2, \"param2\", DbType.String) .Parameter<int>(\"T\", 3, \"result\", DbType.Int32, z => z.Direction(ParameterDirection.ReturnValue)) .Return(\"T\", string.Empty, 1, x => new Classifier { Id = x.Field<int>(z => z.Key()), Name = x.Field<string>() }) .Call<Classifier>(DataScope.Layer, string.Empty, \"param1\".SetVar(param)); foreach (var classifier in res6) Console.WriteLine(\"{0} - \\\"{1}\\\"\", classifier.Id, classifier.Name); Mapping ... .Procedure(\"T\", \"dbo.TestProcedure6\", ProcedureType.Procedure) .Parameter<int>(\"T\", 1, \"param1\", DbType.Int32) .Parameter<string>(\"T\", 2, \"param2\", DbType.String) .Parameter<int>(\"T\", 3, \"result\", DbType.Int32, z => z.Direction(ParameterDirection.ReturnValue)) .Return(\"T\") .Map(x => new TestProcedure6 { Id = x.Field<int>(\"T\", string.Empty, z => z.Key()), Name = x.Field<string>(\"T\", string.Empty) }) .SetBaseTable(\"T\") ... public int ResultParameter { get { return this.GetParameter(x => x.ResultParameter); } }"
  },
  "tutorial/mapping/dynamic/procedure/sample_retval.html": {
    "href": "tutorial/mapping/dynamic/procedure/sample_retval.html",
    "title": "SQL procedure with return value sample | XData website",
    "keywords": "SQL procedure with return value sample MS SQL Server CREATE PROCEDURE [dbo].[TestProcedure5] ( @param1 int, @param2 varchar(20) ) AS RETURN(@param1) Oracle Not supported PostgreSQL Not supported MySQL Not supported Dynamic query var res5 = XDataMapping.GetStructure(\"T\") .Procedure(\"T\", \"dbo.TestProcedure5\", ProcedureType.Procedure) .Parameter<int>(\"T\", 1, \"param1\", DbType.Int32) .Parameter<string>(\"T\", 2, \"param2\", DbType.String) .Parameter<int>(\"T\", 3, \"result\", DbType.Int32, z => z.Direction(ParameterDirection.ReturnValue)) .Call<Classifier>(DataScope.Layer, string.Empty, \"param1\".SetVar(1), \"param2\".SetVar(\"Test\")); Console.WriteLine(res5.GetParameter<int>(\"result\")); Mapping ... .Procedure(\"T\", \"dbo.TestProcedure5\", ProcedureType.Procedure) .Parameter<int>(\"T\", 1, \"param1\", DbType.Int32) .Parameter<string>(\"T\", 2, \"param2\", DbType.String) .Parameter<int>(\"T\", 3, \"result\", DbType.Int32, z => z.Direction(ParameterDirection.ReturnValue)) .Map() .SetBaseTable(\"T\") ... public int ResultParameter { get { return this.GetParameter<int>(\"result\"); } }"
  },
  "tutorial/mapping/dynamic/procedure/sample_out_param.html": {
    "href": "tutorial/mapping/dynamic/procedure/sample_out_param.html",
    "title": "SQL procedure with out parameter sample | XData website",
    "keywords": "SQL procedure with out parameter sample MS SQL Server CREATE PROCEDURE [dbo].[TestProcedure3] ( @param1 int, @param2 varchar(20), @param3 varchar(20) OUTPUT ) AS SET @param3 = convert(varchar(20), @param1) + ' - ' + @param2 RETURN Oracle procedure TestProcedure3(p_Id int, p_Name varchar2, p_Out out varchar2) as begin select p_Id || ' - ' || p_Name into p_Out from dual; end TestProcedure3; PostgreSQL CREATE or REPLACE function TestProcedure3(p_id integer, p_name varchar, out p_out varchar) as $$ begin p_Out := p_id || ' - ' || p_name; end $$ LANGUAGE plpgsql; MySQL create procedure TestProcedure3(p_Id int, p_Name varchar(50), out p_Out varchar(100)) begin set p_Out = CONCAT(p_Id, ' - ', p_Name); end Dynamic query var res3 = XDataMapping.GetStructure(\"T\") .Procedure(\"T\", \"dbo.TestProcedure3\", ProcedureType.Procedure) .Parameter<int>(\"T\", 1, \"param1\", DbType.Int32) .Parameter<string>(\"T\", 2, \"param2\", DbType.String) .Parameter<string>(\"T\", 3, \"param3\", DbType.String, z => z.Size(20), z => z.Direction(ParameterDirection.Output)) .Call(DataScope.Layer, \"param1\".SetVar(1), \"param2\".SetVar(\"Test\")); Console.WriteLine(res3.GetParameter<string>(\"param3\")); Mapping ... .Procedure(\"T\", \"dbo.TestProcedure3\", ProcedureType.Procedure) .Parameter<int>(\"T\", 1, \"param1\", DbType.Int32) .Parameter<string>(\"T\", 2, \"param2\", DbType.String) .Parameter<string>(\"T\", 3, \"param3\", DbType.String, z => z.Size(20), z => z.Direction(ParameterDirection.Output)) .Map() .SetBaseTable(\"T\") ..."
  },
  "tutorial/mapping/procedure/sample_cursor.html": {
    "href": "tutorial/mapping/procedure/sample_cursor.html",
    "title": "| XData website",
    "keywords": "MS SQL Server CREATE PROCEDURE [dbo].[TestProcedure] ( @param1 int, @param2 varchar(20) ) AS SELECT @param1 as Id, @param2 as Name Oracle procedure TestProcedure(p_Id int, p_Name varchar2, p_Out out SYS_REFCURSOR) as begin open p_Out for select p_Id as Id, p_Name as Name from dual; end TestProcedure; PostgreSQL CREATE OR REPLACE FUNCTION public.TestProcedure (p_id integer, p_name varchar, refcursor) RETURNS refcursor AS $$ begin open $3 for select p_id as Id, p_name as Name; return $3; end $$ LANGUAGE plpgsql; MySQL create procedure TestProcedure(p_Id int, p_Name varchar(50)) begin select p_Id as Id, p_Name as Name; end"
  },
  "tutorial/mapping/procedure/sample_array.html": {
    "href": "tutorial/mapping/procedure/sample_array.html",
    "title": "| XData website",
    "keywords": "MS SQL Server Not supported Oracle Not supported PostgreSQL CREATE or REPLACE function TestFunction6(p_arr INTEGER[]) returns integer as $$ begin return sum(s) from unnest(p_arr) s; end $$ LANGUAGE plpgsql; MySQL Not supported"
  },
  "tutorial/mapping/dynamic/property/sql_expr.html": {
    "href": "tutorial/mapping/dynamic/property/sql_expr.html",
    "title": "SQL expression property | XData website",
    "keywords": "SQL expression property Read only property can be mapped to SQL expression. Dynamic mapping of SQL expression is defined by one of IRepositoryStructureAdapter interface Expr method overload: Expr<TValue>(string fieldName, Expression<Func<IQueryStructureAdapter, TValue>> expr, DbType dbType, params Expression<Func<IRepositoryExpressionMappingAdapter, IStructureFlag>>[] attributes) Expr<TValue>(string fieldName, DataExpressionType type, string exprText, DbType dbType, params Expression<Func<IRepositoryExpressionMappingAdapter, IStructureFlag>>[] attributes) - used to define SQL expression DataExpressionType.SubQuery or DataExpressionType.PlainSql When first overload used, SQL expression is defined by expr parameter value as lambda function with IQueryStructureAdapter interface extension methods inside: Case<T, TResult>(this IQueryStructureAdapter adapter, Expression<Func<IQueryStructureAdapter, T>> expression, Expression<Func<IQueryStructureAdapter, TResult>> elseValue, params TaggedExpression<T, TResult>[] switchValues) - case when ... then ... else ... end SQL construction DateDiff<T>(this IQueryStructureAdapter adapter, Expression<Func<IQueryStructureAdapter, DateTime>> finalDate, Expression<Func<IQueryStructureAdapter, DateTime>> startDate, DateDiffKind kind) - date difference Exists(this IQueryStructureAdapter adapter, string subQueryAlias) - exists(select ...) SQL construction HasFlag<T>(this IQueryStructureAdapter adapter, Expression<Func<IQueryStructureAdapter, T>> expression, Expression<Func<IQueryStructureAdapter, T>> flagValue, Expression<Func<IQueryStructureAdapter, T>> trueValue, Expression<Func<IQueryStructureAdapter, T>> falseValue) - bitwise mask checking for value SqlExpr<TResult>(this IQueryStructureAdapter adapter, string format, params Expression<Func<IQueryStructureAdapter, object>>[] expressions) - mixing plain SQL expressions with LINQ style defined expression subparts, parameter format is the string.Format mask SqlFn<TResult>(this IQueryStructureAdapter adapter, string name, params Expression<Func<IQueryStructureAdapter, object>>[] parameters) - SQL function call expression SqlParam<TResult>(this IQueryStructureAdapter adapter, string binding, DbType type, params Expression<Func<IProcedureParameterAdapter, IProcedureParameterFlag>>[] attributes) - SQL function parameter value expression Mapping parameters of SQL expressions is defined by IRepositoryExpressionMappingAdapter interface methods: NativeSqlType(string nativeSqlType) - set native SQL type name of expression result, used when expression result type has specific SQL type Size(int size) - set number or varchar length of SQL expression result type Size(int size, int scale) - set length and scale for floating point SQL data types subquery, ... .ReadOnlyProperty(x => x.DocAmount, x => x.Expr<decimal?>(null, DataExpressionType.SubQuery, \"A\", DbType.Decimal, z => z.Size(17, 5))) ... LINQ expression, ... .ReadOnlyProperty(x => x.AllowedDiscount, x => x.Expr<int>(null, y => y.Case<Product, int>( z => z.Field<bool>(\"is_vip\"), z => 0, 1.SetExpression(z => 10)), DbType.Decimal, z => z.Size(17, 5))) ... plain text SQL expression. ... .ReadOnlyProperty(x => x.AllowedDiscount, x => x.Expr<int>(null, DataExpressionType.PlainSql, \"case P.is_vip when 1 then 10 else 0 end\", DbType.Decimal, z => z.Size(17, 5))) ... Important If possible do not use plain SQL expressions. It possibly use specific SQL dialect features not supported by other DBMS or providers."
  },
  "tutorial/mapping/dynamic/property/reference.html": {
    "href": "tutorial/mapping/dynamic/property/reference.html",
    "title": "Inner view reference | XData website",
    "keywords": "Inner view reference To map property to field from inner view used one of IRepositoryStructureAdapter interface Ref method overload: Ref<TValue>(string sourceAlias, string property, params Expression<Func<IRepositoryPropertyMappingAdapter, IStructureFlag>>[] attributes) - used when referenced property is a hidden property Ref<TValue, TDobj>(string sourceAlias, Expression<Func<TDobj, object>> property, params Expression<Func<IRepositoryPropertyMappingAdapter, IStructureFlag>>[] attributes) .ReadOnlyProperty(x => x.DocLastChange, x => x.Ref<DateTime?>(\"H\", \"HistoryDate\"))"
  },
  "tutorial/mapping/dynamic/property/property.html": {
    "href": "tutorial/mapping/dynamic/property/property.html",
    "title": "Properties | XData website",
    "keywords": "Properties Properties dynamic mapping is performed as method call of IRepositoryStructure<T> interface: Column method call for each of hidden properties mapping ReadOnlyProperty method call for each of read only properties mapping Map method call for declare all of read/write properties mapping ... .Column(\"DocId\", x => x.Field<long?>(\"D\", string.Empty, z => z.Key(), z => z.Default(DefaultType.AutoIncrement))) ... .ReadOnlyProperty(x => x.Changed, x => x.Field<DateTime>(\"D\", string.Empty, z => z.Default(DefaultType.CurrentDateTime, DefaultFeature.UseOnUpdate))) ... Parameter mapper of Map method allows to define mapping rule for multiple read/write properties using lambda expression with IQueryStructureAdapter interface as parameter. ... .Map(x => new Invoice { DocState = x.Link<string, DocState>(\"S\", \"name\", z => z.LinkProperty<DocState>(y => y.Name), z => z.LinkProperty<DocState>(y => y.Code, y => y.DocStateCode), z => z.LinkProperty<DocState>( (Invoice y) => y.GetProperty<long>(\"DocStateId\"))), DocCatalog = x.Link<string, Catalogue>(\"U\", \"name\", z => z.LinkProperty<Catalogue>(y => y.Name), z => z.LinkProperty<Catalogue>( (Invoice y) => y.GetProperty<long>(\"CatalogueId\"))), DocNumb = x.Field<string>(\"N\", \"numb\"), DocDate = x.Field<DateTime?>(\"D\", string.Empty, z => z.Default(DefaultType.CurrentDate)), Scan = x.Lob(\"SC\", z => z.OuterFlag()), Source = x.Xml(\"SR\", z => z.OuterFlag()), CustomerFrom = x.Link<string, Customer>(\"F\", \"name\", z => z.LinkProperty<Customer>(y => y.Name), z => z.LinkProperty<Customer>(y => y.GetProperty<long>(\"CustomerId\"), y => y.GetProperty<long>(\"FromCustomerId\"))), CustomerTo = x.Link<string, Customer>(\"T\", \"name\", z => z.LinkProperty<Customer>(y => y.Name), z => z.LinkProperty<Customer>(y => y.GetProperty<long>(\"CustomerId\"), y => y.GetProperty<long>(\"ToCustomerId\"))), DeliveryType = x.Field<DeliveryTypeEnum>(\"DD\", string.Empty), DeliveryDate = x.Field<DateTime?>(\"DD\", string.Empty, z => z.Default(DefaultType.CurrentDate)) }, x => x.ExternalLink<InvoiceSpec>(\"DocId\")) ... Interfaces IRepositoryStructureAdapter<T> and IQueryStructureAdapter as successor has some overloads of methods to define mapping: Field<TVal> - for mapping property to data source field Expr<TVal> - for mapping property to SQL expression (see detailed description below ) Ref<TVal> - for mapping property to inner view property (see detailed description below ) IRepositoryStructureAdapter<T> also has a special methods to map Lob , Xml and Link<TVal,TSource> Lob - for mapping Lob property Xml - for mapping Xml property Link<TVal,TSource> - for mapping link property (see detailed description below ) These methods of single property mapping has parameter attributes to define additional mapping properties using interface IPropertyMappingAdapter : Key - primary unique key property flag, possible to mark multiple properties or hidden properties as key properties Hidden - flag, the field should not be included in the SELECT expression, but can be used in filters and/or links between data sources (tables, subqueries...) Group - property grouping parameters (see detailed description below ) And using interface IRepositoryPropertyMappingAdapter<T, TValue> : ConcurrencyToken - concurrency token flag for property Default - default value assign rules for property OuterFlag - outer join mandatory flag, values of properties marked this flag is analyzed during making decision of operations over tables in optional references Important Required to set at least one property of mapped class as primary unique key. Subqueries and inner views can has no key properties. Interface IQueryStructureAdapter<T> is used in dynamic queries only. Interfaces IRepositoryStructureAdapter and IRepositoryStructureAdapter<T> is used in dynamic repository mapping only. Interface IPropertyMappingAdapter is used as in dynamic queries as in dynamic repository mapping. Interface IRepositoryPropertyMappingAdapter is inherited from [IPropertyMappingAdapter] and used in dynamic repository mapping only. SQL expression property Read only property can be mapped to SQL expression. Dynamic mapping of SQL expression is defined by one of IRepositoryStructureAdapter interface Expr method overload: Expr<TValue>(string fieldName, Expression<Func<IQueryStructureAdapter, TValue>> expr, DbType dbType, params Expression<Func<IRepositoryExpressionMappingAdapter, IStructureFlag>>[] attributes) Expr<TValue>(string fieldName, DataExpressionType type, string exprText, DbType dbType, params Expression<Func<IRepositoryExpressionMappingAdapter, IStructureFlag>>[] attributes) - used to define SQL expression DataExpressionType.SubQuery or DataExpressionType.PlainSql When first overload used, SQL expression is defined by expr parameter value as lambda function with IQueryStructureAdapter interface extension methods inside: Case<T, TResult>(this IQueryStructureAdapter adapter, Expression<Func<IQueryStructureAdapter, T>> expression, Expression<Func<IQueryStructureAdapter, TResult>> elseValue, params TaggedExpression<T, TResult>[] switchValues) - case when ... then ... else ... end SQL construction DateDiff<T>(this IQueryStructureAdapter adapter, Expression<Func<IQueryStructureAdapter, DateTime>> finalDate, Expression<Func<IQueryStructureAdapter, DateTime>> startDate, DateDiffKind kind) - date difference Exists(this IQueryStructureAdapter adapter, string subQueryAlias) - exists(select ...) SQL construction HasFlag<T>(this IQueryStructureAdapter adapter, Expression<Func<IQueryStructureAdapter, T>> expression, Expression<Func<IQueryStructureAdapter, T>> flagValue, Expression<Func<IQueryStructureAdapter, T>> trueValue, Expression<Func<IQueryStructureAdapter, T>> falseValue) - bitwise mask checking for value SqlExpr<TResult>(this IQueryStructureAdapter adapter, string format, params Expression<Func<IQueryStructureAdapter, object>>[] expressions) - mixing plain SQL expressions with LINQ style defined expression subparts, parameter format is the string.Format mask SqlFn<TResult>(this IQueryStructureAdapter adapter, string name, params Expression<Func<IQueryStructureAdapter, object>>[] parameters) - SQL function call expression SqlParam<TResult>(this IQueryStructureAdapter adapter, string binding, DbType type, params Expression<Func<IProcedureParameterAdapter, IProcedureParameterFlag>>[] attributes) - SQL function parameter value expression Mapping parameters of SQL expressions is defined by IRepositoryExpressionMappingAdapter interface methods: NativeSqlType(string nativeSqlType) - set native SQL type name of expression result, used when expression result type has specific SQL type Size(int size) - set number or varchar length of SQL expression result type Size(int size, int scale) - set length and scale for floating point SQL data types subquery, ... .ReadOnlyProperty(x => x.DocAmount, x => x.Expr<decimal?>(null, DataExpressionType.SubQuery, \"A\", DbType.Decimal, z => z.Size(17, 5))) ... LINQ expression, ... .ReadOnlyProperty(x => x.AllowedDiscount, x => x.Expr<int>(null, y => y.Case<Product, int>( z => z.Field<bool>(\"is_vip\"), z => 0, 1.SetExpression(z => 10)), DbType.Decimal, z => z.Size(17, 5))) ... plain text SQL expression. ... .ReadOnlyProperty(x => x.AllowedDiscount, x => x.Expr<int>(null, DataExpressionType.PlainSql, \"case P.is_vip when 1 then 10 else 0 end\", DbType.Decimal, z => z.Size(17, 5))) ... Important If possible do not use plain SQL expressions. It possibly use specific SQL dialect features not supported by other DBMS or providers. Property default value To set default value of property with dynamic mapping, use one of IRepositoryPropertyMappingAdapter<T, TValue> interface Default method overload: Default(DefaultType source) - use with DefaultType.AutoIncrement , DefaultType.CurrentDate , DefaultType.CurrentDateTime , DefaultType.CurrentDateTimeUtc , DefaultType.NewGuid , DefaultType.UserName where default value assigned data row on insert only Default(DefaultType source, DefaultFeature features) - use with DefaultType.AutoIncrement , DefaultType.CurrentDate , DefaultType.CurrentDateTime , DefaultType.CurrentDateTimeUtc , DefaultType.NewGuid , DefaultType.UserName where default value assigned data row on insert or update Default(DefaultType source, TValue value) - use with DefaultType.Const or DefaultType.Variable where default value assigned data row on insert only Default(DefaultType source, TValue value, DefaultFeature features) - use with DefaultType.Const or DefaultType.Variable where default value assigned data row on insert or update ... .ReadOnlyProperty(x => x.Changed, x => x.Field<DateTime>(\"D\", string.Empty, z => z.Default(DefaultType.CurrentDateTime, DefaultFeature.UseOnUpdate))) ... Property grouping parameters Property grouping parameters used when data object mapped to grouped query to specify property role in GROUP BY expression. Use one of IPropertyMappingAdapter interface Group method overload: Group(int groupOrder) - when property mapped to field query grouped by with N-th order Group(DataGrouping grouping) - when property mapped to aggregation function over field ... HistoryDate = x.Field<DateTime?>(\"H\", string.Empty, z => z.Group(DataGrouping.Max)) ... Hidden properties Hidden properties dynamically defined using Column method call of IRepositoryStructure<T> interface. Hidden property can be mapped to: data source field - Field<TVal> SQL expression (see detailed description above ) - Expr<TVal> inner view property (see detailed description below ) - Ref<TVal> ... .Column(\"DocId\", x => x.Field<long?>(\"D\", string.Empty, z => z.Key(), z => z.Default(DefaultType.AutoIncrement))) ... Inner view reference To map property to field from inner view used one of IRepositoryStructureAdapter interface Ref method overload: Ref<TValue>(string sourceAlias, string property, params Expression<Func<IRepositoryPropertyMappingAdapter, IStructureFlag>>[] attributes) - used when referenced property is a hidden property Ref<TValue, TDobj>(string sourceAlias, Expression<Func<TDobj, object>> property, params Expression<Func<IRepositoryPropertyMappingAdapter, IStructureFlag>>[] attributes) .ReadOnlyProperty(x => x.DocLastChange, x => x.Ref<DateTime?>(\"H\", \"HistoryDate\")) Links To dynamically define link property used one of IRepositoryStructureAdapter<T> interface Link method overload: Link<TValue, TSource> Link<TValue, TSource>(string sourceAlias, params Expression<Func<ILinkPropertyMappingAdapter<T>, IStructureFlag>>[] attributes) - used when source property is correlated with property name with default name mapping rule ( hungarian_notation in DB and CamelCaseNotation property name in code) Link<TValue, TSource> Link<TValue, TSource>(string sourceAlias, string fieldName, params Expression<Func<ILinkPropertyMappingAdapter<T>, IStructureFlag>>[] attributes) Parameter attributes of method Link value used to define link properties pairs with one of ILinkPropertyMappingAdapter<T> interface LinkProperties method overload call: LinkProperty() - used property of source object to associate with link property defined by Link method LinkProperty<TSource>(Expression<Func<TSource, object>> source) - used source as source property and equal named property from target object LinkProperty<TSource>(Expression<Func<TSource, object>> source, Expression<Func<T, object>> property) - specifying both properties ... DocState = x.Link<string, DocState>(\"S\", \"name\", z => z.LinkProperty<DocState>(y => y.Name), z => z.LinkProperty<DocState>(y => y.Code, y => y.DocStateCode) z => z.LinkProperty<DocState>( (Invoice y) => y.GetProperty<long>(\"DocStateId\"))), ..."
  },
  "tutorial/mapping/dynamic/property/link.html": {
    "href": "tutorial/mapping/dynamic/property/link.html",
    "title": "Links | XData website",
    "keywords": "Links To dynamically define link property used one of IRepositoryStructureAdapter<T> interface Link method overload: Link<TValue, TSource> Link<TValue, TSource>(string sourceAlias, params Expression<Func<ILinkPropertyMappingAdapter<T>, IStructureFlag>>[] attributes) - used when source property is correlated with property name with default name mapping rule ( hungarian_notation in DB and CamelCaseNotation property name in code) Link<TValue, TSource> Link<TValue, TSource>(string sourceAlias, string fieldName, params Expression<Func<ILinkPropertyMappingAdapter<T>, IStructureFlag>>[] attributes) Parameter attributes of method Link value used to define link properties pairs with one of ILinkPropertyMappingAdapter<T> interface LinkProperties method overload call: LinkProperty() - used property of source object to associate with link property defined by Link method LinkProperty<TSource>(Expression<Func<TSource, object>> source) - used source as source property and equal named property from target object LinkProperty<TSource>(Expression<Func<TSource, object>> source, Expression<Func<T, object>> property) - specifying both properties ... DocState = x.Link<string, DocState>(\"S\", \"name\", z => z.LinkProperty<DocState>(y => y.Name), z => z.LinkProperty<DocState>(y => y.Code, y => y.DocStateCode) z => z.LinkProperty<DocState>( (Invoice y) => y.GetProperty<long>(\"DocStateId\"))), ..."
  },
  "tutorial/mapping/dynamic/procedure/sample_out_cursor.html": {
    "href": "tutorial/mapping/dynamic/procedure/sample_out_cursor.html",
    "title": "SQL procedure with out parameter and result set sample | XData website",
    "keywords": "SQL procedure with out parameter and result set sample MS SQL Server CREATE PROCEDURE [dbo].[TestProcedure4] ( @param1 int, @param2 varchar(20) ) AS SELECT @param1 as Id, @param2 as Name RETURN(@param1) Oracle procedure TestProcedure4(p_Tab in classifier_tab, p_Out out SYS_REFCURSOR) as begin open p_Out for select Id, Name from table(p_Tab); end TestProcedure4; Tip Use refcursor parameters names as ResultSet names! PostgreSQL CREATE OR REPLACE FUNCTION public.TestProcedure4 (p_tab public.classifier_rec [], refcursor) RETURNS refcursor AS $$ begin open $2 for select Id, Name from unnest(p_tab); return $2; end $$ LANGUAGE plpgsql; Tip If refcursor parameters have a names it must be used as ResultSet names! MySQL Not supported Dynamic query var res4 = XDataMapping.GetStructure(\"T\") .Procedure(\"T\", \"dbo.TestProcedure4\", ProcedureType.Procedure) .Parameter<int>(\"T\", 1, \"param1\", DbType.Int32) .Parameter<string>(\"T\", 2, \"param2\", DbType.String) .Parameter<int>(\"T\", 3, \"result\", DbType.Int32, z => z.Direction(ParameterDirection.ReturnValue)) .Return(\"T\", string.Empty, 1, x => new Classifier { Id = x.Field<int>(z => z.Key()), Name = x.Field<string>() }) .Call<Classifier>(DataScope, string.Empty, \"param1\".SetVar(1), \"param2\".SetVar(\"Test\")); Console.WriteLine(res4.GetParameter<int>(\"result\")); foreach (var classifier in res4) Console.WriteLine(\"{0} - \\\"{1}\\\"\", classifier.Id, classifier.Name); Mapping ... .Procedure(\"T\", \"dbo.TestProcedure4\", ProcedureType.Procedure) .Parameter<int>(\"T\", 1, \"param1\", DbType.Int32) .Parameter<string>(\"T\", 2, \"param2\", DbType.String) .Parameter<int>(\"T\", 3, \"result\", DbType.Int32, z => z.Direction(ParameterDirection.ReturnValue)) .Return(\"T\") .Map(x => new TestProcedure4 { Id = x.Field<int>(\"T\", string.Empty, z => z.Key()), Name = x.Field<string>(\"T\", string.Empty) }) .SetBaseTable(\"T\")"
  },
  "tutorial/mapping/dynamic/procedure/sample_multiple_cursor.html": {
    "href": "tutorial/mapping/dynamic/procedure/sample_multiple_cursor.html",
    "title": "SQL procedure with multiple result sets sample | XData website",
    "keywords": "SQL procedure with multiple result sets sample MS SQL Server CREATE PROCEDURE [dbo].[TestProcedure2] ( @param1 int, @param2 varchar(20), @param3 int, @param4 varchar(20) ) AS BEGIN SELECT @param1 as Id, @param2 as Name SELECT @param3 as Id, @param4 as Name END Oracle procedure TestProcedure2(p_Id int, p_Name varchar2, p_Out out SYS_REFCURSOR, p_Out2 out SYS_REFCURSOR) as begin open p_Out for select p_Id as Id, p_Name as Name from dual; open p_Out2 for select p_Id as Id, p_Name as Name from dual; end TestProcedure2; Tip Use refcursor parameters names as ResultSet names! PostgreSQL CREATE OR REPLACE FUNCTION public.TestProcedure2 (p_id integer, p_name varchar, refcursor, refcursor) RETURNS SETOF refcursor AS $$ begin open $3 for select p_id as Id, p_name as Name; return NEXT $3; open $4 for select p_id as Id, p_name as Name; return NEXT $4; end $$ LANGUAGE plpgsql; Warning Functions witch returns setof refcursor is not supported by NpgSql .Net Standard 2.0 Edition :( XData net4.0 version can call that type functions with the same mapping rules as described here... Tip If refcursor parameters have a names it must be used as ResultSet names! MySQL create procedure TestProcedure2(p_Id int, p_Name varchar(50)) begin select p_Id as Id, p_Name as Name; select p_Id as Id, p_Name as Name; end Dynamic query Expression<Func<IQueryStructureAdapter, PostgreSqlClassifier>> convertor = x => new PostgreSqlClassifier { Id = x.Field<int>(z => z.Key()), Name = x.Field<string>() }; var res2 = XDataMapping.GetStructure(\"T\") .Procedure(\"T\", \"dbo.TestProcedure2\", ProcedureType.Procedure) .Parameter<int>(\"T\", 1, \"param1\", DbType.Int32) .Parameter<string>(\"T\", 2, \"param2\", DbType.String) .Parameter<int>(\"T\", 3, \"param3\", DbType.Int32) .Parameter<string>(\"T\", 4, \"param4\", DbType.String) .Return(\"T\", \"Result1\", 1, convertor) .Return(\"T\", \"Result2\", 2, convertor) .Call<Classifier>(DataScope, \"Result1\", \"param1\".SetVar(1), \"param2\".SetVar(\"Test\"), \"param3\".SetVar(2), \"param4\".SetVar(\"Some\")); foreach (var classifier in res2) Console.WriteLine(\"{0} - \\\"{1}\\\"\", classifier.Id, classifier.Name); foreach (var classifier in res2.GetResultSet<Classifier>(\"Result2\")) Console.WriteLine(\"{0} - \\\"{1}\\\"\", classifier.Id, classifier.Name); Mapping ... .Procedure(\"T\", \"dbo.TestProcedure2\", ProcedureType.Procedure) .Parameter<int>(\"T\", 1, \"param1\", DbType.Int32) .Parameter<string>(\"T\", 2, \"param2\", DbType.String) .Parameter<int>(\"T\", 3, \"param3\", DbType.Int32) .Parameter<string>(\"T\", 4, \"param4\", DbType.String) .Return(\"T\") .Return(\"T\", \"Result2\", 2, x => new PostgreSqlClassifier { Id = x.Field<int>(z => z.Key()), Name = x.Field<string>() }) .Map(x => new TestProcedure2 { Id = x.Field<int>(\"T\", string.Empty, z => z.Key()), Name = x.Field<string>(\"T\", string.Empty) }) .SetBaseTable(\"T\") ..."
  },
  "tutorial/mapping/dynamic/procedure/sample_cursor.html": {
    "href": "tutorial/mapping/dynamic/procedure/sample_cursor.html",
    "title": "SQL procedure result set as query sample | XData website",
    "keywords": "SQL procedure result set as query sample MS SQL Server CREATE PROCEDURE [dbo].[TestProcedure] ( @param1 int, @param2 varchar(20) ) AS SELECT @param1 as Id, @param2 as Name Oracle procedure TestProcedure(p_Id int, p_Name varchar2, p_Out out SYS_REFCURSOR) as begin open p_Out for select p_Id as Id, p_Name as Name from dual; end TestProcedure; PostgreSQL CREATE OR REPLACE FUNCTION public.TestProcedure (p_id integer, p_name varchar, refcursor) RETURNS refcursor AS $$ begin open $3 for select p_id as Id, p_name as Name; return $3; end $$ LANGUAGE plpgsql; MySQL create procedure TestProcedure(p_Id int, p_Name varchar(50)) begin select p_Id as Id, p_Name as Name; end Dynamic query Expression<Func<IQueryStructureAdapter, PostgreSqlClassifier>> convertor = x => new PostgreSqlClassifier { Id = x.Field<int>(z => z.Key()), Name = x.Field<string>() }; var res = XDataMapping.GetStructure(\"T\") .Procedure(\"T\", \"dbo.TestProcedure\", ProcedureType.Procedure) .Parameter<int>(\"T\", 1, \"param1\", DbType.Int32) .Parameter<string>(\"T\", 2, \"param2\", DbType.String) .Return(\"T\", string.Empty, 1, convertor) .Call<Classifier>(DataScope, string.Empty, \"param1\".SetVar(1), \"param2\".SetVar(\"Test\")); foreach (var classifier in res) Console.WriteLine(\"{0} - \\\"{1}\\\"\", classifier.Id, classifier.Name); Mapping ... .Procedure(\"T\", \"dbo.TestProcedure\", ProcedureType.Procedure) .Parameter<int>(\"T\", 1, \"param1\", DbType.Int32) .Parameter<string>(\"T\", 2, \"param2\", DbType.String) .Return(\"T\") .Map(x => new TestProcedure { Id = x.Field<int>(\"T\", string.Empty, z => z.Key()), Name = x.Field<string>(\"T\", string.Empty) }) .SetBaseTable(\"T\") ..."
  },
  "tutorial/mapping/dynamic/procedure/sample_array.html": {
    "href": "tutorial/mapping/dynamic/procedure/sample_array.html",
    "title": "SQL procedure with simple array parameter sample | XData website",
    "keywords": "SQL procedure with simple array parameter sample MS SQL Server Not supported Oracle Not supported PostgreSQL CREATE or REPLACE function TestFunction6(p_arr INTEGER[]) returns integer as $$ begin return sum(s) from unnest(p_arr) s; end $$ LANGUAGE plpgsql; MySQL Not supported Dynamic query var arr = new[] { 1, 2, 3 }; var f6 = XDataMapping.GetStructure(\"T\") .Procedure(\"T\", \"TestFunction6\", ProcedureType.Function) .Parameter<int[]>(\"T\", 1, \"p_arr\", DbType.Int32, z => z.Array()) .Parameter<int>(\"T\", 2, \"result\", DbType.Int32, z => z.Direction(ParameterDirection.ReturnValue)) .Call(DataScope, \"p_arr\".SetVar(arr)); Console.WriteLine(f6.GetParameter<int>(\"result\")); Mapping ... .Procedure(\"T\", \"TestFunction6\", ProcedureType.Function) .Parameter<int[]>(\"T\", 1, \"p_arr\", DbType.Int32, z => z.Array()) .Parameter<int>(\"T\", 2, \"result\", DbType.Int32, z => z.Direction(ParameterDirection.ReturnValue)) ..."
  },
  "tutorial/mapping/dynamic/procedure/result.html": {
    "href": "tutorial/mapping/dynamic/procedure/result.html",
    "title": "SQL procedure result set | XData website",
    "keywords": "SQL procedure result set To describe result set of SQL procedure used Return method call of IRepositoryStructure<T> interface. * - when result set is not mapped to procedure parameter set result set name to string.Empty"
  },
  "tutorial/mapping/dynamic/procedure/procedure.html": {
    "href": "tutorial/mapping/dynamic/procedure/procedure.html",
    "title": "SQL procedures & functions | XData website",
    "keywords": "SQL procedures & functions Common information about mapping to SQL procedures and functions described in common mapping rules description and here we just represent dynamic mapping rules for various procedure types. Warning SQLite not supported SQL procedures & functions Warning PostgreSql functions has restrictions: returning refcursor or set of refcursor requires transaction! parameters use lower case names ONLY! result set names (refcursor names) use lower case names ONLY! SQL procedure as query To define procedure as data source of mapping used Procedure method call of IRepositoryStructure<T> interface. SQL procedure parameter To define SQL procedure parameter used Parameter method call of IRepositoryStructure<T> interface. SQL procedure result set To describe result set of SQL procedure used Return method call of IRepositoryStructure<T> interface. * - when result set is not mapped to procedure parameter set result set name to string.Empty SQL procedure result set as query sample MS SQL Server CREATE PROCEDURE [dbo].[TestProcedure] ( @param1 int, @param2 varchar(20) ) AS SELECT @param1 as Id, @param2 as Name Oracle procedure TestProcedure(p_Id int, p_Name varchar2, p_Out out SYS_REFCURSOR) as begin open p_Out for select p_Id as Id, p_Name as Name from dual; end TestProcedure; PostgreSQL CREATE OR REPLACE FUNCTION public.TestProcedure (p_id integer, p_name varchar, refcursor) RETURNS refcursor AS $$ begin open $3 for select p_id as Id, p_name as Name; return $3; end $$ LANGUAGE plpgsql; MySQL create procedure TestProcedure(p_Id int, p_Name varchar(50)) begin select p_Id as Id, p_Name as Name; end Dynamic query Expression<Func<IQueryStructureAdapter, PostgreSqlClassifier>> convertor = x => new PostgreSqlClassifier { Id = x.Field<int>(z => z.Key()), Name = x.Field<string>() }; var res = XDataMapping.GetStructure(\"T\") .Procedure(\"T\", \"dbo.TestProcedure\", ProcedureType.Procedure) .Parameter<int>(\"T\", 1, \"param1\", DbType.Int32) .Parameter<string>(\"T\", 2, \"param2\", DbType.String) .Return(\"T\", string.Empty, 1, convertor) .Call<Classifier>(DataScope, string.Empty, \"param1\".SetVar(1), \"param2\".SetVar(\"Test\")); foreach (var classifier in res) Console.WriteLine(\"{0} - \\\"{1}\\\"\", classifier.Id, classifier.Name); Mapping ... .Procedure(\"T\", \"dbo.TestProcedure\", ProcedureType.Procedure) .Parameter<int>(\"T\", 1, \"param1\", DbType.Int32) .Parameter<string>(\"T\", 2, \"param2\", DbType.String) .Return(\"T\") .Map(x => new TestProcedure { Id = x.Field<int>(\"T\", string.Empty, z => z.Key()), Name = x.Field<string>(\"T\", string.Empty) }) .SetBaseTable(\"T\") ... SQL procedure with multiple result sets sample MS SQL Server CREATE PROCEDURE [dbo].[TestProcedure2] ( @param1 int, @param2 varchar(20), @param3 int, @param4 varchar(20) ) AS BEGIN SELECT @param1 as Id, @param2 as Name SELECT @param3 as Id, @param4 as Name END Oracle procedure TestProcedure2(p_Id int, p_Name varchar2, p_Out out SYS_REFCURSOR, p_Out2 out SYS_REFCURSOR) as begin open p_Out for select p_Id as Id, p_Name as Name from dual; open p_Out2 for select p_Id as Id, p_Name as Name from dual; end TestProcedure2; Tip Use refcursor parameters names as ResultSet names! PostgreSQL CREATE OR REPLACE FUNCTION public.TestProcedure2 (p_id integer, p_name varchar, refcursor, refcursor) RETURNS SETOF refcursor AS $$ begin open $3 for select p_id as Id, p_name as Name; return NEXT $3; open $4 for select p_id as Id, p_name as Name; return NEXT $4; end $$ LANGUAGE plpgsql; Warning Functions witch returns setof refcursor is not supported by NpgSql .Net Standard 2.0 Edition :( XData net4.0 version can call that type functions with the same mapping rules as described here... Tip If refcursor parameters have a names it must be used as ResultSet names! MySQL create procedure TestProcedure2(p_Id int, p_Name varchar(50)) begin select p_Id as Id, p_Name as Name; select p_Id as Id, p_Name as Name; end Dynamic query Expression<Func<IQueryStructureAdapter, PostgreSqlClassifier>> convertor = x => new PostgreSqlClassifier { Id = x.Field<int>(z => z.Key()), Name = x.Field<string>() }; var res2 = XDataMapping.GetStructure(\"T\") .Procedure(\"T\", \"dbo.TestProcedure2\", ProcedureType.Procedure) .Parameter<int>(\"T\", 1, \"param1\", DbType.Int32) .Parameter<string>(\"T\", 2, \"param2\", DbType.String) .Parameter<int>(\"T\", 3, \"param3\", DbType.Int32) .Parameter<string>(\"T\", 4, \"param4\", DbType.String) .Return(\"T\", \"Result1\", 1, convertor) .Return(\"T\", \"Result2\", 2, convertor) .Call<Classifier>(DataScope, \"Result1\", \"param1\".SetVar(1), \"param2\".SetVar(\"Test\"), \"param3\".SetVar(2), \"param4\".SetVar(\"Some\")); foreach (var classifier in res2) Console.WriteLine(\"{0} - \\\"{1}\\\"\", classifier.Id, classifier.Name); foreach (var classifier in res2.GetResultSet<Classifier>(\"Result2\")) Console.WriteLine(\"{0} - \\\"{1}\\\"\", classifier.Id, classifier.Name); Mapping ... .Procedure(\"T\", \"dbo.TestProcedure2\", ProcedureType.Procedure) .Parameter<int>(\"T\", 1, \"param1\", DbType.Int32) .Parameter<string>(\"T\", 2, \"param2\", DbType.String) .Parameter<int>(\"T\", 3, \"param3\", DbType.Int32) .Parameter<string>(\"T\", 4, \"param4\", DbType.String) .Return(\"T\") .Return(\"T\", \"Result2\", 2, x => new PostgreSqlClassifier { Id = x.Field<int>(z => z.Key()), Name = x.Field<string>() }) .Map(x => new TestProcedure2 { Id = x.Field<int>(\"T\", string.Empty, z => z.Key()), Name = x.Field<string>(\"T\", string.Empty) }) .SetBaseTable(\"T\") ... SQL procedure with out parameter sample MS SQL Server CREATE PROCEDURE [dbo].[TestProcedure3] ( @param1 int, @param2 varchar(20), @param3 varchar(20) OUTPUT ) AS SET @param3 = convert(varchar(20), @param1) + ' - ' + @param2 RETURN Oracle procedure TestProcedure3(p_Id int, p_Name varchar2, p_Out out varchar2) as begin select p_Id || ' - ' || p_Name into p_Out from dual; end TestProcedure3; PostgreSQL CREATE or REPLACE function TestProcedure3(p_id integer, p_name varchar, out p_out varchar) as $$ begin p_Out := p_id || ' - ' || p_name; end $$ LANGUAGE plpgsql; MySQL create procedure TestProcedure3(p_Id int, p_Name varchar(50), out p_Out varchar(100)) begin set p_Out = CONCAT(p_Id, ' - ', p_Name); end Dynamic query var res3 = XDataMapping.GetStructure(\"T\") .Procedure(\"T\", \"dbo.TestProcedure3\", ProcedureType.Procedure) .Parameter<int>(\"T\", 1, \"param1\", DbType.Int32) .Parameter<string>(\"T\", 2, \"param2\", DbType.String) .Parameter<string>(\"T\", 3, \"param3\", DbType.String, z => z.Size(20), z => z.Direction(ParameterDirection.Output)) .Call(DataScope.Layer, \"param1\".SetVar(1), \"param2\".SetVar(\"Test\")); Console.WriteLine(res3.GetParameter<string>(\"param3\")); Mapping ... .Procedure(\"T\", \"dbo.TestProcedure3\", ProcedureType.Procedure) .Parameter<int>(\"T\", 1, \"param1\", DbType.Int32) .Parameter<string>(\"T\", 2, \"param2\", DbType.String) .Parameter<string>(\"T\", 3, \"param3\", DbType.String, z => z.Size(20), z => z.Direction(ParameterDirection.Output)) .Map() .SetBaseTable(\"T\") ... SQL procedure with out parameter and result set sample MS SQL Server CREATE PROCEDURE [dbo].[TestProcedure4] ( @param1 int, @param2 varchar(20) ) AS SELECT @param1 as Id, @param2 as Name RETURN(@param1) Oracle procedure TestProcedure4(p_Tab in classifier_tab, p_Out out SYS_REFCURSOR) as begin open p_Out for select Id, Name from table(p_Tab); end TestProcedure4; Tip Use refcursor parameters names as ResultSet names! PostgreSQL CREATE OR REPLACE FUNCTION public.TestProcedure4 (p_tab public.classifier_rec [], refcursor) RETURNS refcursor AS $$ begin open $2 for select Id, Name from unnest(p_tab); return $2; end $$ LANGUAGE plpgsql; Tip If refcursor parameters have a names it must be used as ResultSet names! MySQL Not supported Dynamic query var res4 = XDataMapping.GetStructure(\"T\") .Procedure(\"T\", \"dbo.TestProcedure4\", ProcedureType.Procedure) .Parameter<int>(\"T\", 1, \"param1\", DbType.Int32) .Parameter<string>(\"T\", 2, \"param2\", DbType.String) .Parameter<int>(\"T\", 3, \"result\", DbType.Int32, z => z.Direction(ParameterDirection.ReturnValue)) .Return(\"T\", string.Empty, 1, x => new Classifier { Id = x.Field<int>(z => z.Key()), Name = x.Field<string>() }) .Call<Classifier>(DataScope, string.Empty, \"param1\".SetVar(1), \"param2\".SetVar(\"Test\")); Console.WriteLine(res4.GetParameter<int>(\"result\")); foreach (var classifier in res4) Console.WriteLine(\"{0} - \\\"{1}\\\"\", classifier.Id, classifier.Name); Mapping ... .Procedure(\"T\", \"dbo.TestProcedure4\", ProcedureType.Procedure) .Parameter<int>(\"T\", 1, \"param1\", DbType.Int32) .Parameter<string>(\"T\", 2, \"param2\", DbType.String) .Parameter<int>(\"T\", 3, \"result\", DbType.Int32, z => z.Direction(ParameterDirection.ReturnValue)) .Return(\"T\") .Map(x => new TestProcedure4 { Id = x.Field<int>(\"T\", string.Empty, z => z.Key()), Name = x.Field<string>(\"T\", string.Empty) }) .SetBaseTable(\"T\") SQL procedure with return value sample MS SQL Server CREATE PROCEDURE [dbo].[TestProcedure5] ( @param1 int, @param2 varchar(20) ) AS RETURN(@param1) Oracle Not supported PostgreSQL Not supported MySQL Not supported Dynamic query var res5 = XDataMapping.GetStructure(\"T\") .Procedure(\"T\", \"dbo.TestProcedure5\", ProcedureType.Procedure) .Parameter<int>(\"T\", 1, \"param1\", DbType.Int32) .Parameter<string>(\"T\", 2, \"param2\", DbType.String) .Parameter<int>(\"T\", 3, \"result\", DbType.Int32, z => z.Direction(ParameterDirection.ReturnValue)) .Call<Classifier>(DataScope.Layer, string.Empty, \"param1\".SetVar(1), \"param2\".SetVar(\"Test\")); Console.WriteLine(res5.GetParameter<int>(\"result\")); Mapping ... .Procedure(\"T\", \"dbo.TestProcedure5\", ProcedureType.Procedure) .Parameter<int>(\"T\", 1, \"param1\", DbType.Int32) .Parameter<string>(\"T\", 2, \"param2\", DbType.String) .Parameter<int>(\"T\", 3, \"result\", DbType.Int32, z => z.Direction(ParameterDirection.ReturnValue)) .Map() .SetBaseTable(\"T\") ... public int ResultParameter { get { return this.GetParameter<int>(\"result\"); } } SQL procedure with return value and result set sample MS SQL Server MS SQL Server CREATE PROCEDURE [dbo].[TestProcedure6] ( @param1 int, @param2 varchar(20) ) AS SELECT @param1 as Id, @param2 as Name RETURN(@param1) Oracle Not supported PostgreSQL Not supported MySQL Not supported Dynamic query var res6 = XDataMapping.GetStructure(\"T\") .Procedure(\"T\", \"dbo.TestProcedure6\", ProcedureType.Procedure) .Parameter<int>(\"T\", 1, \"param1\", DbType.Int32) .Parameter<string>(\"T\", 2, \"param2\", DbType.String) .Parameter<int>(\"T\", 3, \"result\", DbType.Int32, z => z.Direction(ParameterDirection.ReturnValue)) .Return(\"T\", string.Empty, 1, x => new Classifier { Id = x.Field<int>(z => z.Key()), Name = x.Field<string>() }) .Call<Classifier>(DataScope.Layer, string.Empty, \"param1\".SetVar(param)); foreach (var classifier in res6) Console.WriteLine(\"{0} - \\\"{1}\\\"\", classifier.Id, classifier.Name); Mapping ... .Procedure(\"T\", \"dbo.TestProcedure6\", ProcedureType.Procedure) .Parameter<int>(\"T\", 1, \"param1\", DbType.Int32) .Parameter<string>(\"T\", 2, \"param2\", DbType.String) .Parameter<int>(\"T\", 3, \"result\", DbType.Int32, z => z.Direction(ParameterDirection.ReturnValue)) .Return(\"T\") .Map(x => new TestProcedure6 { Id = x.Field<int>(\"T\", string.Empty, z => z.Key()), Name = x.Field<string>(\"T\", string.Empty) }) .SetBaseTable(\"T\") ... public int ResultParameter { get { return this.GetParameter(x => x.ResultParameter); } } SQL procedure with simple array parameter sample MS SQL Server Not supported Oracle Not supported PostgreSQL CREATE or REPLACE function TestFunction6(p_arr INTEGER[]) returns integer as $$ begin return sum(s) from unnest(p_arr) s; end $$ LANGUAGE plpgsql; MySQL Not supported Dynamic query var arr = new[] { 1, 2, 3 }; var f6 = XDataMapping.GetStructure(\"T\") .Procedure(\"T\", \"TestFunction6\", ProcedureType.Function) .Parameter<int[]>(\"T\", 1, \"p_arr\", DbType.Int32, z => z.Array()) .Parameter<int>(\"T\", 2, \"result\", DbType.Int32, z => z.Direction(ParameterDirection.ReturnValue)) .Call(DataScope, \"p_arr\".SetVar(arr)); Console.WriteLine(f6.GetParameter<int>(\"result\")); Mapping ... .Procedure(\"T\", \"TestFunction6\", ProcedureType.Function) .Parameter<int[]>(\"T\", 1, \"p_arr\", DbType.Int32, z => z.Array()) .Parameter<int>(\"T\", 2, \"result\", DbType.Int32, z => z.Direction(ParameterDirection.ReturnValue)) ... SQL procedure with UDT parameter sample MS SQL Server Not supported Tip MS SQL Server does not support passing single UDT object as a parameter value, but support array of UDT Oracle Not supported Warning Oracle ODP.Net provider does not support UDT PostgreSQL CREATE TYPE public.classifier_rec AS ( Id integer, Name varchar(20) ); CREATE or REPLACE function TestFunction5(p_obj classifier_rec) returns varchar as $$ begin return p_obj.Id || ' - ' || p_obj.Name; end $$ LANGUAGE plpgsql; MySQL Not supported Dynamic query /* Type mapped to UDT required to be Xml serializable */ [Serializable] public class Classifier { [XmlAttribute] public int Id { get; set; } [XmlAttribute] public string Name { get; set; } } ... var f5 = XDataMapping.GetStructure(\"T\") .Procedure(\"T\", \"TestFunction5\", ProcedureType.Function) .Parameter<Classifier>(\"T\", 1, \"p_obj\", DbType.Object, z => z.UdtDataType(\"classifier_rec\")) .Parameter<string>(\"T\", 3, \"result\", DbType.String, z => z.Size(20), z => z.Direction(ParameterDirection.ReturnValue)) .Call(DataScope, \"p_obj\".SetVar( new Classifier { Id = 1, Name = \"Test\" })); Console.WriteLine(f5.GetParameter<string>(\"result\")); Mapping /* Type mapped to UDT required to be Xml serializable */ [Serializable] public class Classifier { [XmlAttribute] public int Id { get; set; } [XmlAttribute] public string Name { get; set; } } ... .Procedure(\"T\", \"TestFunction5\", ProcedureType.Function) .Parameter<Classifier>(\"T\", 1, \"p_obj\", DbType.Object, z => z.UdtDataType(\"classifier_rec\")) .Parameter<string>(\"T\", 3, \"result\", DbType.String, z => z.Size(20), z => z.Direction(ParameterDirection.ReturnValue)) .Map() .SetBaseTable(\"T\") ... public class TestFunction5 : IDataObject { public string Result => this.GetParameter(x => x.Result); } SQL procedure with UDT array parameter sample MS SQL Server CREATE TYPE [dbo].[Classifier] AS TABLE( [Id] [int] NULL, [Name] [varchar](20) NULL ) CREATE PROCEDURE [dbo].[TestProcedure7] (@param1 Classifier READONLY) AS SELECT * from @param1 Oracle Not supported Warning Oracle ODP.Net provider does not support UDT PostgreSQL CREATE TYPE public.classifier_rec AS ( Id integer, Name varchar(20) ); CREATE or REPLACE function TestProcedure7(p_tab classifier_rec[]) returns setof classifier_rec as $$ select a.Id, a.Name from unnest(p_tab) a; $$ LANGUAGE sql; MySQL Not supported Dynamic query /* Type mapped to UDT required to be Xml serializable */ [Serializable] public class Classifier { [XmlAttribute] public int Id { get; set; } [XmlAttribute] public string Name { get; set; } } ... var param = new[] { new Classifier { Id = 1, Name = \"Test\" }, new Classifier { Id = 2, Name = \"Some\" } }; var f4 = XDataMapping.GetStructure(\"T\") .Procedure(\"T\", \"dbo.TestProcedure7\", ProcedureType.Procedure) .Parameter<Classifier[]>(\"T\", 1, \"param1\", DbType.Object, z => z.UdtDataType(null, \"dbo.Classifier\")) .Return(\"T\") .Call(DataScope, string.Empty, \"param1\".SetVar(param)); foreach (var classifier in res) Console.WriteLine(\"{0} - \\\"{1}\\\"\", classifier.Id, classifier.Name); Mapping /* Type mapped to UDT required to be Xml serializable */ [Serializable] public class Classifier { [XmlAttribute] public int Id { get; set; } [XmlAttribute] public string Name { get; set; } } ... .Procedure(\"T\", \"dbo.TestProcedure7\", ProcedureType.Procedure) .Parameter<Classifier[]>(\"T\", 1, \"param1\", DbType.Object, z => z.UdtDataType(null, \"dbo.Classifier\")) .Return(\"T\") .Map(x => new TestProcedure { Id = x.Field<int>(\"T\", string.Empty, z => z.Key()), Name = x.Field<string>(\"T\", string.Empty) }) .SetBaseTable(\"T\") SQL table valued function as query sample MS SQL Server CREATE FUNCTION [dbo].[TestFunction] ( @param1 int, @param2 varchar(20) ) RETURNS TABLE AS RETURN ( SELECT @param1 as Id, @param2 as Name ) Oracle CREATE OR REPLACE type classifier_rec is object (Id int, Name varchar2(20)); CREATE OR REPLACE type classifier_tab is table of classifier_rec; function TestFunction(p_Id int, p_Name varchar2) return classifier_tab pipelined is begin for curr in (select p_Id as Id, p_Name as Name from dual) loop pipe row (classifier_rec(curr.Id, curr.Name)); end loop; end TestFunction; PostgreSQL CREATE or REPLACE function TestFunction(p_id integer, p_name varchar) returns TABLE ( Id bigint, Name varchar ) as $$ select p_id as Id, p_name as Name; $$ LANGUAGE SQL; ... or with the same mapping syntax... CREATE TYPE public.classifier_rec AS ( Id integer, Name varchar(20) ); CREATE or REPLACE function TestFunction(p_Id integer, p_Name varchar) returns setof classifier_rec as $$ select p_Id as Id, p_Name as Name; $$ LANGUAGE SQL; MySQL Not supported Dynamic query var f3 = XDataMapping.GetStructure() .Procedure(\"T\", \"dbo.TestFunction\", ProcedureType.Function) .Parameter<int>(\"T\", 1, \"param1\", DbType.Int32) .Parameter<string>(\"T\", 2, \"param2\", DbType.String) .Return(\"T\") .Select(x => new Classifier { Id = x.Field<int>(\"T\", \"Id\", z => z.Key()), Name = x.Field<string>(\"T\", \"Name\") }) .AsQuery(DataScope, \"param1\".SetVar(param)); foreach (var classifier in f3) Console.WriteLine(\"{0} - \\\"{1}\\\"\", classifier.Id, classifier.Name); Dynamic query table function with joined table var f1Join = XDataMapping.GetStructure() .DataTable(\"T_DOC_TYPE\", \"D\") .Procedure(\"T\", \"dbo.TestFunction\", ProcedureType.Function, z => z.Link(\"D\", \"doc_type_id\", \"Id\")) .Parameter<int>(\"T\", 1, \"param1\", DbType.Int32) .Parameter<string>(\"T\", 2, \"param2\", DbType.String) .Return(\"T\") .Select(x => new { Id = x.Field<int>(\"T\", \"Id\", z => z.Key()), Name = x.Field<string>(\"T\", \"Name\"), Code = x.Field<string>(\"D\", string.Empty) }) .AsQuery(DataScope, \"param1\".SetVar(1), \"param2\".SetVar(\"Test\")); foreach (var res in f1Join) Console.WriteLine(\"{0} - \\\"{1}\\\" - \\\"{2}\\\"\", res.Id, res.Name, res.Code); Mapping ... .Procedure(\"T\", \"dbo.TestFunction\", ProcedureType.Function) .Parameter<int>(\"T\", 1, \"param1\", DbType.Int32) .Parameter<string>(\"T\", 2, \"param2\", DbType.String) .Return(\"T\") .Map(x => new TestFunction { Id = x.Field<int>(\"T\", \"Id\", z => z.Key()), Name = x.Field<string>(\"T\", \"Name\") }) .SetBaseTable(\"T\") Mapping table function with joined table .DataTable(\"T_DOC_TYPE\", \"D\") .Procedure(\"T\", \"dbo.TestFunction\", ProcedureType.Function, z => z.Link(\"D\", \"doc_type_id\", \"Id\")) .Parameter<int>(\"T\", 1, \"param1\", DbType.Int32) .Parameter<string>(\"T\", 2, \"param2\", DbType.String) .Return(\"T\") .Map(x => new TestFunctionJoin { Id = x.Field<int>(\"T\", \"Id\", z => z.Key()), Name = x.Field<string>(\"T\", \"Name\"), Code = x.Field<string>(\"D\", string.Empty) }) .SetBaseTable(\"D\") SQL scalar function as property data source sample MS SQL Server CREATE FUNCTION [dbo].[TestFunction2] ( @param1 int, @param2 varchar(20) ) RETURNS varchar(20) AS BEGIN DECLARE @res varchar(20) SET @res = convert(varchar(20), @param1) + ' - ' + @param2 RETURN @res END Oracle function TestFunction2(p_Id int, p_Name varchar2) return varchar2 is begin return p_Id || ' - ' || p_Name; end TestFunction2; PostgreSQL CREATE or REPLACE function TestFunction2(p_id integer, p_name varchar) returns varchar as $$ DECLARE ret varchar; begin select p_id || ' - ' || p_name into ret; return ret; end $$ LANGUAGE plpgsql; MySQL create function TestFunction2(p_Id int, p_Name varchar(20)) returns varchar(100) begin declare res varchar(100); select CONCAT(p_Id, ' - ', p_Name) into res; return(res); end Mapping var t1 = XDataMapping.GetStructure(\"T\") .DataTable(\"T_DOC_TYPE\", \"T\").Select(x => new { DocTypeId = x.Field<long>(\"T\", \"doc_type_id\", z => z.Key()), Code = x.Field<string>(\"T\", \"code\"), Name = x.Field<string>(\"T\", \"name\"), Test = x.Expr(\"test\", z => z.SqlFn<string>(\"dbo.TestFunction2\", y => y.Field<long>(\"T\", \"doc_type_id\"), y => y.Field<string>(\"T\", \"name\")), DbType.String, z => z.Size(20)) }).AsQuery(DataScope); foreach (var z in t1) Console.WriteLine(\"{0} - \\\"{1}\\\" - \\\"{2}\\\" - \\\"{3}\\\"\", z.DocTypeId, z.Code, z.Name, z.Test);"
  },
  "tutorial/mapping/master_detail.html": {
    "href": "tutorial/mapping/master_detail.html",
    "title": "Master detail relations | XData website",
    "keywords": "Master detail relations External references is the base element of master-detail references definition in XData. It describes link rules between related detail entities from master entities. XData support multi master and multi detail relation (many-to-many). And it's possible to define multiple relations between every two data objects. External references is the declarations of possible master-detail relations between data objects . Each of external reference is describe master property (or column ) to detail filter relation, used to filter detail collections data when master current object is set. Tip External references applied to manually attached detail data sources only. External references definition is differs for static and dynamic methods of mapping. Reference rules is defined at mapping level, and when detail object will be attached using GetChild method, that rules will be applied. To fill child repository data in some unmapped array property (when the reference has type \"one-to-many\") can be used special overload of GetChild method. And when reference has type \"one-to-one\" can be used GetChild overload. That properties will be filled by child data automatically during data acquire when child repositories has been connected using that overloads of method. var rep = dataScope.GetRepository<Invoice>(); var child = rep.GetChild(z => z.InvoiceSpec); Warning Data hierarchy can be acquired by that way has not limited deep level, but important keep in mind the price of that is performance. Use child repository data loading into unmapped properties when needed only! To break master-detail reference call DetachChild method. When data scope or one of referenced repositories will be disposed - reference is beaked automatically. Detail object reference filter value is set when SetCurrent extension method is called for master object. if (newInvoice.Submit()) { newInvoice.SetCurrent(); return true; } Master-detail linked repositories can be used for cascade delete operation over multiple related data objects: newInvoice.SetDeleted(true); newInvoice.Submit(); or cascade delete applied for filtered subset of repository objects and their detail objects: invoices.Clear(x => x.DocStateCode == \"REJECTED\");"
  },
  "tutorial/mapping/mapping.html": {
    "href": "tutorial/mapping/mapping.html",
    "title": "Mapping common rules | XData website",
    "keywords": "XData tutorial Mapping common rules All data objects must to be signed with marker interface (empty interface) IDataObject . All objects describes subqueries must to be signed with marker interface ISqlObject . Tip Ability of defining mapping to marker interface is key feature of XData allowed to get flexible and natural objects deriving hierarchy with full featured and handy methods to work with it (using extension methods). Mapping rules can be declared statically with attributes of class and its properties (see static mapping ), and dynamically using LINQ style expression (see dynamic mapping ). Mapping inheritance Complex projects can contain many reusable parts. Including query parts (tables, subqueries, stored procedure calls). Sometimes these reused parts correspond to the inheritance hierarchy, sometimes they dont. XData supports the inheritance of parts of the mapping of data objects both within the hierarchy of inheritance of objects reflected to the database and the construction of its hierarchy for the reuse of parts of mapping. Only mapping description is depends on static or dynamic method of declaration. Common types properties Common types properties (string, bool, int...) including nullable (int?, bool?...), and enum properties is declared as common class properties. Data access to this properties is usual. Only mapping description is depends on static or dynamic method of declaration. Binary properties To work with large binary object (BLOB) using lazy coupling XData represent property type Lob . This type has followed... properties: byte[] Value - binary object value (read-only) bool Assigned - check object has value (including empty value) or NULL methods: GetSize () - returns size of binary object (extension) Modify(Action<byte[]> action) - helper method to simplify changing of binary object value operation: += - \"syntax sugar\", _data.SomeBlob += _someVariable identical with _data.SomeBlob.Value = _someVariable. Examples: newInvoice.Scan += _image; ... if(newInvoice.Scan.Assigned) _size = newInvoice.Scan.GetSize(); ... invoice.Scan.Modify(x => x = new byte[0]); Xml properties To work with Xml using lazy coupling XData represent property type Xml . This type has followed... properties: XDocument Document - get or set Xml value (read-only) bool Assigned - check Xml field for NULL value methods: Extract (string path, params KeyValuePair<string, string>[] namespaces) - returning result of XPath expression path using namespaces (pair: namespace - URL) (extension) Modify (Action action) - helper method to change Xml value operations: += - \"syntax sugar\", _data.SomeXml += _someVariable identical with _data.SomeXml.Document = _someVariable. Example: newInvoice.Source += new XDocument(new XElement(\"invoice\", new XAttribute(\"number\", number), new XAttribute(\"state\", newInvoice.DocStateCode))); ... dataScope.GetRepository<Invoice>(Owner, context: Context) .First(x => x.Source.Extract(\"(/invoice/@state)[1]\") == \"ACTIVE\").DocNumb ... invoice.Source.Modify(x => x = new XDocument()); Link properties To work with external links to data objects outside current object without operating surogate keys, XData represent special property type - Link<TVal,TSrc> , where TVal - type of property for preview, TSrc - type of external object. For type Link is defined... properties: TVal Value - this property to get preview of linked object TSrc Source - this property can be used to set linked object (read-only) bool Assigned - check link value for NULL value operations: += - \"syntax sugar\", _data.SomeLink += _someDictionaryObject identical with _data.SomeLink.Source = _someDictionaryObject. newInvoice.DocState += dataScope.GetDictionaryValue<DocState>(x => x.Code == \"CREATED\"); To make link properties work correct, at mapping level need to be defined pairs of properties source and current objects, that values will be copied from source object to current when link is applied. Link description is deferent for static and dynamic methods of mapping. Read only properties Read only properties XData require to perform as in example below: public string DocStateCode { get { return this.GetProperty(x => x.DocStateCode); } } Data access is provided through extension method GetProperty , but property is read only. Child repositories references Detail related repositories XData require to perform as: public IRepository<InvoiceSpec> Spec { get { return this.GetRepository().GetChild<InvoiceSpec>(); } } No additional mapping description are needed. Only external reference is required. Tip To use hierarchical objects and XData Unit of Work realization ( WorkSet ), child repositories references are required. Hidden properties Some columns in database is needed to full description of mapping, but not required to business logic. This columns is declared as part of mapping named Column is selected from database, but not mapped on data object properties. For example - XData can operate primary (PK) and foreign (FK) keys of business objects and work with master-detail references between them, but mapping to property of external references is not required to operate with key. Second case - optimistic concurrency resolving (see concurrency resolving ) required concurrency token field, but this field is not required to business logic. Third example - when data is grouped, needed to declare some field to link with external reference , but in this case possibly we can`t include this field in SELECT expression because of GROUP BY syntax. This case is resolved by Hidden property of column declaration. When Hidden is true - column will be not included into SELECT expression of resulted SQL query. Hidden properties description is various to static and dynamic mapping declaration methods. Master detail relations External references is the base element of master-detail references definition in XData. It describes link rules between related detail entities from master entities. XData support multi master and multi detail relation (many-to-many). And it's possible to define multiple relations between every two data objects. External references is the declarations of possible master-detail relations between data objects . Each of external reference is describe master property (or column ) to detail filter relation, used to filter detail collections data when master current object is set. Tip External references applied to manually attached detail data sources only. External references definition is differs for static and dynamic methods of mapping. Reference rules is defined at mapping level, and when detail object will be attached using GetChild method, that rules will be applied. To fill child repository data in some unmapped array property (when the reference has type \"one-to-many\") can be used special overload of GetChild method. And when reference has type \"one-to-one\" can be used GetChild overload. That properties will be filled by child data automatically during data acquire when child repositories has been connected using that overloads of method. var rep = dataScope.GetRepository<Invoice>(); var child = rep.GetChild(z => z.InvoiceSpec); Warning Data hierarchy can be acquired by that way has not limited deep level, but important keep in mind the price of that is performance. Use child repository data loading into unmapped properties when needed only! To break master-detail reference call DetachChild method. When data scope or one of referenced repositories will be disposed - reference is beaked automatically. Detail object reference filter value is set when SetCurrent extension method is called for master object. if (newInvoice.Submit()) { newInvoice.SetCurrent(); return true; } Master-detail linked repositories can be used for cascade delete operation over multiple related data objects: newInvoice.SetDeleted(true); newInvoice.Submit(); or cascade delete applied for filtered subset of repository objects and their detail objects: invoices.Clear(x => x.DocStateCode == \"REJECTED\"); Tree XData can use CTE (common table expression) as part of repository data source definition. Supported as plain (WITH), as recursive (WITH RECURSIVE) expressions. CTE is defined in mapping differently for static and dynamic mapping paradigm, but it can be used with similar way: defined one or more tables with unique aliases and name equals CTE name. Recursive CTE can be used as independent data source too. In this case CTE name must to be declared as base table of repository. SQL functions & procedures Stored procedures and functions can be used as data source of mapping (if used DBMS and ADO .Net provider is support this). Important At this moment we has various limitations of using SQL procedures as on DBMS SQL dialect level, as on ADO .Net provider realization level. Please, choose DBMS and ADO .Net provider with keep in mind limitations they have. XData support many procedure mapping styles and call conventions, but can not garant all of them is supported by DBMS and ADO .Net provider You choose. XData has support followed SQL procedure mapping styles and call conventions and it combinations: Using procedure result set as data source Using procedure with multiple result sets Using out parameters Using return value of stored procedure Using simple type array as parameter Using cursor as parameter Using UTD (user defined type) as parameter Using table valued function as data source Using scalar function as single property source Warning Class mapped to UDT must support native XML serialization! All this mapping features described as for static as for dynamic mapping paradigm."
  },
  "tutorial/mapping/link.html": {
    "href": "tutorial/mapping/link.html",
    "title": "Link properties | XData website",
    "keywords": "Link properties To work with external links to data objects outside current object without operating surogate keys, XData represent special property type - Link<TVal,TSrc> , where TVal - type of property for preview, TSrc - type of external object. For type Link is defined... properties: TVal Value - this property to get preview of linked object TSrc Source - this property can be used to set linked object (read-only) bool Assigned - check link value for NULL value operations: += - \"syntax sugar\", _data.SomeLink += _someDictionaryObject identical with _data.SomeLink.Source = _someDictionaryObject. newInvoice.DocState += dataScope.GetDictionaryValue<DocState>(x => x.Code == \"CREATED\"); To make link properties work correct, at mapping level need to be defined pairs of properties source and current objects, that values will be copied from source object to current when link is applied. Link description is deferent for static and dynamic methods of mapping."
  },
  "tutorial/mapping/inheritance.html": {
    "href": "tutorial/mapping/inheritance.html",
    "title": "Mapping inheritance | XData website",
    "keywords": "Mapping inheritance Complex projects can contain many reusable parts. Including query parts (tables, subqueries, stored procedure calls). Sometimes these reused parts correspond to the inheritance hierarchy, sometimes they dont. XData supports the inheritance of parts of the mapping of data objects both within the hierarchy of inheritance of objects reflected to the database and the construction of its hierarchy for the reuse of parts of mapping. Only mapping description is depends on static or dynamic method of declaration."
  },
  "tutorial/mapping/db_diagram.html": {
    "href": "tutorial/mapping/db_diagram.html",
    "title": "Sample database structure | XData website",
    "keywords": "<!--MD5=[9fbc3a7cfb9f92e84de8970988e48bb2] class t_catalogue--> t_catalogue catalogue_id code name parent_id <!--MD5=[ea6ea2e31c0cbff1b909b1f0bd59093e] class t_customer--> t_customer customer_id code name <!--MD5=[a6ce46e431db16f1c4014df928aac3e8] class t_doc_cust_type--> t_doc_cust_type doc_cust_type_id code name <!--MD5=[bccea5d0c54fc84e4bad16ab69fd73e7] class t_doc_type--> t_doc_type doc_type_id code name <!--MD5=[5ea577eca533bfca935d04f775d3f167] class t_doc--> t_doc doc_id doc_type_id doc_date generation changed author <!--MD5=[d4ba8adfb5df751cf422e2fad2a28e94] class t_catalogue_doc--> t_catalogue_doc catalogue_id doc_id <!--MD5=[8cca3b0685271c670c4226b30b01cbcf] class t_doc_cust--> t_doc_cust doc_cust_id doc_id customer_id doc_cust_type_id <!--MD5=[fd8c5e68644f1f4fc0b14eca97226ae4] class t_doc_delivery--> t_doc_delivery doc_id delivery_type delivery_date <!--MD5=[dd40a5851c55ff9d7da9b59b2cdb5061] class t_doc_number--> t_doc_number doc_id numb <!--MD5=[710d3dc0240fd500b1d510e138be1447] class t_doc_scan--> t_doc_scan doc_id scan <!--MD5=[5937349b424f6b33ad58af94594dfd63] class t_doc_source--> t_doc_source doc_id source <!--MD5=[4efa0cfa5e1d38a4afda4e219b98680a] class t_doc_state--> t_doc_state doc_state_id code name <!--MD5=[5c02744e5b0455229387a946a811ce2e] class t_doc_doc_state--> t_doc_doc_state doc_id doc_state_id <!--MD5=[0d4a222ed2d2d268b8328f05b8f9e363] class t_doc_history--> t_doc_history doc_history_id doc_id doc_state_id history_date <!--MD5=[d4b45c8a441f4cb1774906928f147529] link t_catalogue to t_catalogue--> parent_id <!--MD5=[b3294211ce75436a8f4d3c51fb151377] link t_doc_type to t_doc--> doc_type_id <!--MD5=[840062eaffe844779ca4f4f301a47d9a] reverse link t_catalogue to t_catalogue_doc--> catalogue_id <!--MD5=[b3a8eac680fbb6e047950cbceafbeb2c] link t_catalogue_doc to t_doc--> doc_id <!--MD5=[7eefc4f6dff794e64e78dcbbfb9c491a] link t_doc to t_doc_cust--> doc_id <!--MD5=[0005336a9822bd19ef61e4ce8910c4c5] reverse link t_doc_cust to t_customer--> customer_id <!--MD5=[131b4a0e76521106752daee341bf156a] reverse link t_doc_cust to t_doc_cust_type--> doc_cust_type_id <!--MD5=[94de7abaa940d64e718a7c3244926e87] reverse link t_doc_delivery to t_doc--> doc_id <!--MD5=[2d23622d96560790c79c16e9140044a4] reverse link t_doc_number to t_doc--> doc_id <!--MD5=[7c459e52799c0d4d655e72449bb91e72] reverse link t_doc_scan to t_doc--> doc_id <!--MD5=[4aa29f824d631e9db9c0b4ff518403cc] reverse link t_doc_source to t_doc--> doc_id <!--MD5=[fdc70aa94f88d88b378c08a646310f88] reverse link t_doc_doc_state to t_doc--> doc_id <!--MD5=[63d405c0f3a8aa08b15fc74dd2b85047] link t_doc_state to t_doc_doc_state--> doc_state_id <!--MD5=[9c004340c543d5fd28395a65d65b76dd] link t_doc to t_doc_history--> doc_id <!--MD5=[ac06e947c28172a1581fe83d17c1f569] reverse link t_doc_history to t_doc_state--> doc_state_id <!--MD5=[a24f9b6c28c3f11eb813d302e9c42a66] @startuml hide circle skinparam ClassHeaderBackgroundColor lightgray skinparam ClassBorderColor black skinparam ClassBorderThickness 1 skinparam ClassBackgroundColor transparrent skinparam ArrowFontSize 8 skinparam ArrowColor black entity t_catalogue { <&key> catalogue_id - - <&code> code name <&arrow-circle-right> //parent_id// } t_catalogue - -{ t_catalogue : parent_id entity t_customer { <&key> customer_id - - <&code> code name } entity t_doc_cust_type { <&key> doc_cust_type_id - - <&code> code name } entity t_doc_type { <&key> doc_type_id - - <&code> code name } entity t_doc { <&key> doc_id - - <&arrow-circle-right> doc_type_id doc_date - - <&tag> generation <&clock> changed <&person> author } t_doc_type -right-{ t_doc : doc_type_id entity t_catalogue_doc { <&key> <&arrow-circle-right> catalogue_id <&key> <&arrow-circle-right> doc_id } t_catalogue_doc -up-{ t_catalogue : catalogue_id t_catalogue_doc - -{ t_doc : doc_id entity t_doc_cust { <&key> doc_cust_id - - <&arrow-circle-right> doc_id <&arrow-circle-right> customer_id <&arrow-circle-right> doc_cust_type_id } t_doc_cust }-up- t_doc : doc_id t_doc_cust }- - t_customer : customer_id t_doc_cust }- - t_doc_cust_type : doc_cust_type_id entity t_doc_delivery { <&key> <&arrow-circle-right> doc_id - - delivery_type delivery_date } t_doc_delivery }o- - t_doc : doc_id entity t_doc_number { <&key> <&arrow-circle-right> doc_id - - numb } t_doc_number }o- - t_doc : doc_id entity t_doc_scan { <&key> <&arrow-circle-right> doc_id - - <&map> scan } t_doc_scan }o- - t_doc : doc_id entity t_doc_source { <&key> <&arrow-circle-right> doc_id - - <&document> source } t_doc_source }o- - t_doc : doc_id entity t_doc_state { <&key> doc_state_id - - <&code> code name } entity t_doc_doc_state { <&key> <&arrow-circle-right> doc_id - - <&arrow-circle-right> doc_state_id } t_doc_doc_state }o-right- t_doc : doc_id t_doc_doc_state }-left- t_doc_state : doc_state_id entity t_doc_history { <&key> doc_history_id - - <&arrow-circle-right> doc_id <&arrow-circle-right> doc_state_id <&clock> history_date } t_doc_history }-up- t_doc : doc_id t_doc_history }- - t_doc_state : doc_state_id @enduml PlantUML version 1.2020.12(Sat Jun 06 10:54:15 UTC 2020) (GPL source distribution) Java Runtime: Java(TM) SE Runtime Environment JVM: Java HotSpot(TM) 64-Bit Server VM Default Encoding: UTF-8 Language: en Country: US --> <!--MD5=[5ea577eca533bfca935d04f775d3f167] class t_doc--> t_doc doc_id doc_type_id doc_date generation changed author <!--MD5=[e871482fb55f9150fc3be5a0e93d8569] class t_doc_spec_type--> t_doc_spec_type doc_spec_type_id code name <!--MD5=[4ed4cd12cd2eeb59e644791b1ec40217] class t_doc_spec--> t_doc_spec doc_spec_id doc_id doc_spec_type_id <!--MD5=[025ac326a6ab31b45989aa42f37da176] class t_doc_spec_amount--> t_doc_spec_amount doc_spec_id amount <!--MD5=[cef6fc7600387b202b7e697154b0ecaf] link t_doc to t_doc_spec--> doc_id <!--MD5=[175fa9f72450b3173fe29432cd7fb745] reverse link t_doc_spec to t_doc_spec_type--> doc_spec_type_id <!--MD5=[542647722f52d6ccd9b263e63b85e2d8] link t_doc_spec to t_doc_spec_amount--> doc_spec_id <!--MD5=[5cb7b5aa399201d5b29efcb8adfe8a65] @startuml hide circle skinparam ClassHeaderBackgroundColor lightgray skinparam ClassBorderColor black skinparam ClassBorderThickness 1 skinparam ClassBackgroundColor transparrent skinparam ArrowFontSize 8 skinparam ArrowColor black entity t_doc { <&key> doc_id - - <&arrow-circle-right> doc_type_id doc_date - - <&tag> generation <&clock> changed <&person> author } entity t_doc_spec_type { <&key> doc_spec_type_id - - <&code> code name } entity t_doc_spec { <&key> doc_spec_id - - <&arrow-circle-right> doc_id <&arrow-circle-right> doc_spec_type_id } t_doc_spec }-left- t_doc : doc_id t_doc_spec }- - t_doc_spec_type : doc_spec_type_id entity t_doc_spec_amount { <&key> <&arrow-circle-right> doc_spec_id - - <&dollar> amount } t_doc_spec_amount }o-left- t_doc_spec : doc_spec_id @enduml PlantUML version 1.2020.12(Sat Jun 06 10:54:15 UTC 2020) (GPL source distribution) Java Runtime: Java(TM) SE Runtime Environment JVM: Java HotSpot(TM) 64-Bit Server VM Default Encoding: UTF-8 Language: en Country: US -->"
  },
  "tutorial/mapping/static/property/sql_expr.html": {
    "href": "tutorial/mapping/static/property/sql_expr.html",
    "title": "SQL expression property | XData website",
    "keywords": "SQL expression property Read only property can be mapped to SQL expression. Static mapping of SQL expression is defined by PropertyExpressionAttribute with parameters: ExprText - depends of ExprType value (see below) it can be: subquery alias / SQL expression / private static field name define SQL expression in LINQ style, ExprType - optional, SQL expression type , default is DataExpressionType . PlainSql , DbType - ADO ,Net provider data type (optional, default is DbType . String ), ExprSize - optional, expression field size (if applicable), ExprScale - optional, expression field precision (if applicable). Possible to use SQL expressions of three types: subquery, [PropertyExpression(\"A\", DataExpressionType.SubQuery, DbType.Decimal, ExprSize = 17, ExprScale = 5)] LINQ expression, [PropertyExpression(\"AllowedDiscount\", DataExpressionType.LinqExpression, DbType.Decimal, ExprSize = 17, ExprScale = 5)] ... //Private static field of mapped class marked with SqlExpression attribute [SqlExpression] private static Calculate<int> AllowedDiscount = x => x.Case<Product, int>( z => z.Field<bool>(\"is_vip\"), z => 0, 1.SetExpression(z => 10)); plain text SQL expression. [PropertyExpression(\"case P.is_vip when 1 then 10 else 0 end\", DataExpressionType.PlainSql, DbType.Decimal, ExprSize = 17, ExprScale = 5)] Tip Attribute PropertyExpressionAttribute is not replaced PropertyAttribute but extend it. Important If possible do not use plain SQL expressions. It possibly use specific SQL dialect features not supported by other DBMS or providers. Tip It's recommended to use virtual table as SQL expression source omitting data source alias in PropertyAttribute ."
  },
  "tutorial/mapping/static/property/reference.html": {
    "href": "tutorial/mapping/static/property/reference.html",
    "title": "Inner view reference | XData website",
    "keywords": "Inner view reference To map property to field from inner view a ReferenceAttribute is used with parameters: Source - inner view alias, PropertyName - optional, DB field name (may be omitted when property name is equals with inner view mapped class property), Flags - optional, mask of property flags , NativeSqlType - optional, SQL type name in DB. Parameter NativeSqlType is used when type default mapping is conflicted with real SQL type name. [Reference(\"H\" /* inner view alias */, \"HistoryDate\" /* property name inside inner view */)]"
  },
  "tutorial/mapping/static/property/property.html": {
    "href": "tutorial/mapping/static/property/property.html",
    "title": "Properties | XData website",
    "keywords": "Properties Static mapping is performed as each property with specific attributes mark. Main attribute to statically map property is PropertyAttribute with parameters: Source - data source alias (may be omitted for virtual table ), FieldName - DB field name mapped to property (may be omitted when field and property correspond naming rule, for example DB field named as some_field_name and mapped to SomeFieldName property), Flags - optional, mask of property flags , NativeSqlType - optional, SQL type name in DB. Parameter NativeSqlType is used when type default mapping is conflicted with real SQL type name. [Property(\"S\" /* table alias */, \"code\" /* field name */)] SQL expression property Read only property can be mapped to SQL expression. Static mapping of SQL expression is defined by PropertyExpressionAttribute with parameters: ExprText - depends of ExprType value (see below) it can be: subquery alias / SQL expression / private static field name define SQL expression in LINQ style, ExprType - optional, SQL expression type , default is DataExpressionType . PlainSql , DbType - ADO ,Net provider data type (optional, default is DbType . String ), ExprSize - optional, expression field size (if applicable), ExprScale - optional, expression field precision (if applicable). Possible to use SQL expressions of three types: subquery, [PropertyExpression(\"A\", DataExpressionType.SubQuery, DbType.Decimal, ExprSize = 17, ExprScale = 5)] LINQ expression, [PropertyExpression(\"AllowedDiscount\", DataExpressionType.LinqExpression, DbType.Decimal, ExprSize = 17, ExprScale = 5)] ... //Private static field of mapped class marked with SqlExpression attribute [SqlExpression] private static Calculate<int> AllowedDiscount = x => x.Case<Product, int>( z => z.Field<bool>(\"is_vip\"), z => 0, 1.SetExpression(z => 10)); plain text SQL expression. [PropertyExpression(\"case P.is_vip when 1 then 10 else 0 end\", DataExpressionType.PlainSql, DbType.Decimal, ExprSize = 17, ExprScale = 5)] Tip Attribute PropertyExpressionAttribute is not replaced PropertyAttribute but extend it. Important If possible do not use plain SQL expressions. It possibly use specific SQL dialect features not supported by other DBMS or providers. Tip It's recommended to use virtual table as SQL expression source omitting data source alias in PropertyAttribute . Property default value To set default value of property with static mapping, use PropertyDefaultAttribute with parameters: DefaultSource - default value type , DefaultValue optional, depends on DefaultSource , DefaultFeature - optional, default is DefaultFeature.UseOnInsert , default value assignment will be applied with some extended features . [PropertyDefault(DefaultType.UserName, AlwaysUseDefault = true)] Property grouping parameters Property grouping parameters used when data object mapped to grouped query to specify property role in GROUP BY expression. PropertyGroupingAttribute has properties: Grouping - optional, property aggregation type , default is None , GroupOrder - optional, property grouping order when Grouping = DataGrouping . None . [PropertyGrouping(DataGrouping.Sum)] Hidden properties Hidden properties statically defined using couple of specific attributes: ColumnAttribute , ColumnExpressionAttribute and ColumnDefaultAttribute as analog with similar attributes of properties . ColumnAttribute has parameters: PropertyName - name of hidden property, PropertyType - type of hidden property, Source - data source alias, FieldName - optional, DB field name (can be omitted when correspond default mapping rule (example: some_field_name is mapped to SomeFieldName )), Flags - optional, bit mask of property flags , Grouping - optional, defined aggregation type , default is None , GroupOrder - optional, group order when Grouping = DataGrouping . None , Hidden - optional, mapped field omitted in SELECT expression of result query (when grouping limitations demand this), default is false , NativeSqlType - optional, native SQL type name. NativeSqlType is used when default data type mapping is conflicted with result set data type. ColumnExpressionAttribute has parameters: PropertyName - name of hidden property (same as defined by ColumnAttribute ), ExprText - depends on ExprType (see below): subquery alias / SQL expression text / field name with LINQ style expression definition, ExprType - optional, SQL expression type default is DataExpressionType . PlainSql , DbType - data type on ADO .Net provider level (optional, default is DbType . String ), ExprSize - optional, expression field size (if applicable), ExprScale - optional, expression field precision (if applicable). ColumnDefaultAttribute has parameters: PropertyName - hidden property name (same as defined by ColumnAttribute ), DefaultSource - default value type , DefaultValue optional, depends on DefaultSource , DefaultFeature - optional, default is DefaultFeature.UseOnInsert , default value assignment will be applied with some extended features . [Column(\"DocId\", typeof(long?), \"D\", Flags = DataPropertyFlag.Id), ColumnDefault(\"DocId\", DefaultType.AutoIncrement)] Inner view reference To map property to field from inner view a ReferenceAttribute is used with parameters: Source - inner view alias, PropertyName - optional, DB field name (may be omitted when property name is equals with inner view mapped class property), Flags - optional, mask of property flags , NativeSqlType - optional, SQL type name in DB. Parameter NativeSqlType is used when type default mapping is conflicted with real SQL type name. [Reference(\"H\" /* inner view alias */, \"HistoryDate\" /* property name inside inner view */)] Links To statically define link property pairs used LinkPropertyAttribute with parameters: DictSource - optional, source object property name, Property - optional, property name. When one or both of parameters is omitted, followed rules are used: When omit both properties - used property name of link property as target and equal named property from source object When DictSource is omitted - used Property as target property name and equal named property from source object When Property is omitted - used property name of link property as target and property with name equals DictSource from source object [Property(\"S\", \"name\"), LinkProperty(\"Name\") /* DocState.Name -> this.DocState */, LinkProperty(Property = \"DocStateId\") /* column DocState.DocStateId -> column this.DocStateId */, LinkProperty(\"Code\", \"DocStateCode\") /* DocState.Code -> this.DocStateCode */] public Link<string, DocState> DocState { get; set; }"
  },
  "tutorial/mapping/dynamic/procedure/sample_table_func.html": {
    "href": "tutorial/mapping/dynamic/procedure/sample_table_func.html",
    "title": "SQL table valued function as query sample | XData website",
    "keywords": "SQL table valued function as query sample MS SQL Server CREATE FUNCTION [dbo].[TestFunction] ( @param1 int, @param2 varchar(20) ) RETURNS TABLE AS RETURN ( SELECT @param1 as Id, @param2 as Name ) Oracle CREATE OR REPLACE type classifier_rec is object (Id int, Name varchar2(20)); CREATE OR REPLACE type classifier_tab is table of classifier_rec; function TestFunction(p_Id int, p_Name varchar2) return classifier_tab pipelined is begin for curr in (select p_Id as Id, p_Name as Name from dual) loop pipe row (classifier_rec(curr.Id, curr.Name)); end loop; end TestFunction; PostgreSQL CREATE or REPLACE function TestFunction(p_id integer, p_name varchar) returns TABLE ( Id bigint, Name varchar ) as $$ select p_id as Id, p_name as Name; $$ LANGUAGE SQL; ... or with the same mapping syntax... CREATE TYPE public.classifier_rec AS ( Id integer, Name varchar(20) ); CREATE or REPLACE function TestFunction(p_Id integer, p_Name varchar) returns setof classifier_rec as $$ select p_Id as Id, p_Name as Name; $$ LANGUAGE SQL; MySQL Not supported Dynamic query var f3 = XDataMapping.GetStructure() .Procedure(\"T\", \"dbo.TestFunction\", ProcedureType.Function) .Parameter<int>(\"T\", 1, \"param1\", DbType.Int32) .Parameter<string>(\"T\", 2, \"param2\", DbType.String) .Return(\"T\") .Select(x => new Classifier { Id = x.Field<int>(\"T\", \"Id\", z => z.Key()), Name = x.Field<string>(\"T\", \"Name\") }) .AsQuery(DataScope, \"param1\".SetVar(param)); foreach (var classifier in f3) Console.WriteLine(\"{0} - \\\"{1}\\\"\", classifier.Id, classifier.Name); Dynamic query table function with joined table var f1Join = XDataMapping.GetStructure() .DataTable(\"T_DOC_TYPE\", \"D\") .Procedure(\"T\", \"dbo.TestFunction\", ProcedureType.Function, z => z.Link(\"D\", \"doc_type_id\", \"Id\")) .Parameter<int>(\"T\", 1, \"param1\", DbType.Int32) .Parameter<string>(\"T\", 2, \"param2\", DbType.String) .Return(\"T\") .Select(x => new { Id = x.Field<int>(\"T\", \"Id\", z => z.Key()), Name = x.Field<string>(\"T\", \"Name\"), Code = x.Field<string>(\"D\", string.Empty) }) .AsQuery(DataScope, \"param1\".SetVar(1), \"param2\".SetVar(\"Test\")); foreach (var res in f1Join) Console.WriteLine(\"{0} - \\\"{1}\\\" - \\\"{2}\\\"\", res.Id, res.Name, res.Code); Mapping ... .Procedure(\"T\", \"dbo.TestFunction\", ProcedureType.Function) .Parameter<int>(\"T\", 1, \"param1\", DbType.Int32) .Parameter<string>(\"T\", 2, \"param2\", DbType.String) .Return(\"T\") .Map(x => new TestFunction { Id = x.Field<int>(\"T\", \"Id\", z => z.Key()), Name = x.Field<string>(\"T\", \"Name\") }) .SetBaseTable(\"T\") Mapping table function with joined table .DataTable(\"T_DOC_TYPE\", \"D\") .Procedure(\"T\", \"dbo.TestFunction\", ProcedureType.Function, z => z.Link(\"D\", \"doc_type_id\", \"Id\")) .Parameter<int>(\"T\", 1, \"param1\", DbType.Int32) .Parameter<string>(\"T\", 2, \"param2\", DbType.String) .Return(\"T\") .Map(x => new TestFunctionJoin { Id = x.Field<int>(\"T\", \"Id\", z => z.Key()), Name = x.Field<string>(\"T\", \"Name\"), Code = x.Field<string>(\"D\", string.Empty) }) .SetBaseTable(\"D\")"
  },
  "tutorial/mapping/dynamic/filter/subquery_links.html": {
    "href": "tutorial/mapping/dynamic/filter/subquery_links.html",
    "title": "Subquery links | XData website",
    "keywords": "Subquery links Links with subqueries is used to link not table fields but properties of base class and subquery mapped class including hidden properties . To link with subquery or inner view used one of SubqueryLink method overload of ISubqueryLinkAdapter , ISubqueryLinkAdapter<TDObj> or ISubqueryLinkAdapter<T,TDObj> depending by outer method signature and subquery declaration specific. ... .InnerView<DocBySpecType>(\"ST\", x => x.SubqueryLink(\"DocId\")) ... Tip Subquery links can be used to define optional filters . To specify role in optional filter chain need to call extension method AsPrimary as continuation of Link method call."
  },
  "tutorial/mapping/dynamic/filter/subquery.html": {
    "href": "tutorial/mapping/dynamic/filter/subquery.html",
    "title": "Subquery filters | XData website",
    "keywords": "Subquery filters To define filters checks field value is correspond subquery results used SubqueryFilter method of IInnerFilterAdapter . ... .DataTable(\"T_DOC_CATALOGUE\", \"DC\", \"D\", x => x.Link(\"D\", \"doc_id\"), x => x.SubqueryFilter(\"catalogue_id\", \"UT\") .SetOperation(FilterOperation.In)) .Subquery<CatalogueTree>(\"UT\", x => x.CatalogueId, DataGrouping.None) ... Tip Subquery filters can be used to define optional filters . To specify role in optional filter chain need to call extension method AsPrimary as continuation of Link method call."
  },
  "tutorial/mapping/dynamic/filter/sql_expr.html": {
    "href": "tutorial/mapping/dynamic/filter/sql_expr.html",
    "title": "SQL expression filters | XData website",
    "keywords": "SQL expression filters To define filter over SQL expression used one of ExprFilter method overloads of IInnerFilterAdapter interface. There are two overloads of ExprFilter method: IFilterDescription ExprFilter(string field, string exprText) - to use with plain SQL expressions or subquery alias IFilterDescription ExprFilter<T>(string field, Expression<Func<IQueryStructureAdapter, T>> expression) - to use with SQL expressions as LINQ style expressions Depending style of SQL expression description that overloads can be used with: subquery alias, , ExprFilter(\"discount\" /* field name */, \"D\" /* ExpressionText: subquery alias */) .SetOperation(FilterOperation.In) dynamic definition of SQL expression, , ExprFilter(\"discount\" /* field name */, /* expression: SQL expression LINQ style definition */ x => x.Case<Product, int>( z => z.Field<bool>(\"is_vip\"), z => 0, 1.SetExpression(z => 10)), Operation: FilterOperation.NotEqual /* filter operation */)] plain SQL expression text. , ExprFilter(\"discount\" /* field name */, /* ExpressionText: plain SQL expression */ \"case P.is_vip when 1 then 10 else 0 end\") .SetOperation(FilterOperation.NotEqual) Important If possible do not use plain SQL expressions. It possibly use specific SQL dialect features not supported by other DBMS or providers."
  },
  "tutorial/mapping/dynamic/filter/range.html": {
    "href": "tutorial/mapping/dynamic/filter/range.html",
    "title": "Range filters | XData website",
    "keywords": "Range filters To define filter checks field value over array of values used RangeFilter methods of IInnerFilterAdapter interface. ... , RangeFilter(\"discount\", 1, 5, 10) .SetOperation(FilterOperation.In) ..."
  },
  "tutorial/mapping/dynamic/filter/inner_links.html": {
    "href": "tutorial/mapping/dynamic/filter/inner_links.html",
    "title": "Inner links | XData website",
    "keywords": "Inner links To define links between data sources inside query used Link overloads of IInnerFilterAdapter interface. ... , x => x.Link(\"DS\", \"doc_state_id\") ... Tip Inner links can be used to define optional filters . To specify role in optional filter chain need to call extension method AsPrimary as continuation of Link method call."
  },
  "tutorial/mapping/dynamic/filter/group.html": {
    "href": "tutorial/mapping/dynamic/filter/group.html",
    "title": "Filter group | XData website",
    "keywords": "Filter group Filter group of filter can be assigned to it declaration by SetCombination extension of IFilterDescription interface. ... , x => x.ConstFilter(\"FilterByCathalogue\", \"catalogue_id\", FilterConstantType.Const, null, FilterNullable.NullsNotAllowed) .SetCombination(\"root\") ..."
  },
  "tutorial/mapping/dynamic/filter/filter.html": {
    "href": "tutorial/mapping/dynamic/filter/filter.html",
    "title": "Filters | XData website",
    "keywords": "Filters Filters can be defined as: Constant filters SQL expression filters Dictionary filters Range filters Subquery filters Inner links Each of them described by corresponding LINQ expression define their parameters depending on the context of their use and the type of the filter itself (see below). Filter descriptions are provided to filters parameter value of DataTable , Subquery , InnerView and Procedure methods of IRepositoryStructure<T> interface, or WithRecursive method of IQueryWithAdapter<TRoot> . Each of expression has described one filter. Type of filter is declared by one of fabric method of interface inside lambda expression with one of followed filter adapter: IInnerFilterAdapter - filter adapter to define filters and links inside plain query (see DataTable , Procedure ), ISubqueryLinkAdapter , ISubqueryLinkAdapter<TDObj> and ISubqueryLinkAdapter<T,TDObj> - used in various overloads of subquery definition (see Subquery , InnerView and WithRecursive ) to declare links with subqueries. Specific parameters for each type of filter is described in filter fabric methods described below in specific topics. And some optional modificators can be defined using continue LINQ calls with extension methods: SetOperation - to set filter operation AsPrimary - to set optional filter flag SetCombination - to set filter combination Each of filter type is defined by own special method of corresponding filter adapter. Filter operation is defined by enum FilterOperation : Equal - equal NotEqual - not equal LessThan - less then GreaterThan - greater then LessThanOrEqual - less or equal GreaterThanOrEqual - greater or equal In - field value in range or subquery NotIn - field value is not in range or subquery Exists - subquery returns one or more rows NotExists - subquery returns no rows Like - field value correlated with find expression NotLike - field value not correlated with find expression OuterJoin - left outer join link between query sources (tables or inner views) Contains - field value correlated with full-text search NotContains - field value not correlated with full-text search Filter group Filter group of filter can be assigned to it declaration by SetCombination extension of IFilterDescription interface. ... , x => x.ConstFilter(\"FilterByCathalogue\", \"catalogue_id\", FilterConstantType.Const, null, FilterNullable.NullsNotAllowed) .SetCombination(\"root\") ... Constant filters Constant filters allows to restrict selection of data by some constant value. This filter defined by one of ConstFilter method overloads of IInnerFilterAdapter interface. Constant type list restricted by enum FilterConstantType : Const - constant with value set by ConstantValue . Variable - value of variable with name set by ConstantValue . CurrentDate - current date. CurrentDateTime - current date and time. CurrentDateTimeUTC - current date and time (UTC). ... , x => x.ConstFilter(\"FilterByCathalogue\", \"catalogue_id\", FilterConstantType.Const, null, FilterNullable.NullsNotAllowed) .SetCombination(\"root\") ... SQL expression filters To define filter over SQL expression used one of ExprFilter method overloads of IInnerFilterAdapter interface. There are two overloads of ExprFilter method: IFilterDescription ExprFilter(string field, string exprText) - to use with plain SQL expressions or subquery alias IFilterDescription ExprFilter<T>(string field, Expression<Func<IQueryStructureAdapter, T>> expression) - to use with SQL expressions as LINQ style expressions Depending style of SQL expression description that overloads can be used with: subquery alias, , ExprFilter(\"discount\" /* field name */, \"D\" /* ExpressionText: subquery alias */) .SetOperation(FilterOperation.In) dynamic definition of SQL expression, , ExprFilter(\"discount\" /* field name */, /* expression: SQL expression LINQ style definition */ x => x.Case<Product, int>( z => z.Field<bool>(\"is_vip\"), z => 0, 1.SetExpression(z => 10)), Operation: FilterOperation.NotEqual /* filter operation */)] plain SQL expression text. , ExprFilter(\"discount\" /* field name */, /* ExpressionText: plain SQL expression */ \"case P.is_vip when 1 then 10 else 0 end\") .SetOperation(FilterOperation.NotEqual) Important If possible do not use plain SQL expressions. It possibly use specific SQL dialect features not supported by other DBMS or providers. Range filters To define filter checks field value over array of values used RangeFilter methods of IInnerFilterAdapter interface. ... , RangeFilter(\"discount\", 1, 5, 10) .SetOperation(FilterOperation.In) ... Dictionary filters Dictionaries surrogate keys may varied over one instance to another, and names can be changed by users. Sometimes business logic need to operate with the concrete value of dictionary. Because of this it's recommended to add into dictionary DB structure a special unique text field - mnemonic code. XData supports using mnemonic code when define filters on dictionary value - dictionary filters. They defined by one of DictFilter overloads of IInnerFilterAdapter interface. Important This filter can be used when dictionary has simple (one field only) identity field and mnemonic code field. But it's a very common case. ... , x => x.DictFilter(\"T_DOC_CUST_TYPE\", \"doc_cust_type_id\", \"code\", \"TO\") ... Inner links To define links between data sources inside query used Link overloads of IInnerFilterAdapter interface. ... , x => x.Link(\"DS\", \"doc_state_id\") ... Tip Inner links can be used to define optional filters . To specify role in optional filter chain need to call extension method AsPrimary as continuation of Link method call. Subquery filters To define filters checks field value is correspond subquery results used SubqueryFilter method of IInnerFilterAdapter . ... .DataTable(\"T_DOC_CATALOGUE\", \"DC\", \"D\", x => x.Link(\"D\", \"doc_id\"), x => x.SubqueryFilter(\"catalogue_id\", \"UT\") .SetOperation(FilterOperation.In)) .Subquery<CatalogueTree>(\"UT\", x => x.CatalogueId, DataGrouping.None) ... Tip Subquery filters can be used to define optional filters . To specify role in optional filter chain need to call extension method AsPrimary as continuation of Link method call. Subquery links Links with subqueries is used to link not table fields but properties of base class and subquery mapped class including hidden properties . To link with subquery or inner view used one of SubqueryLink method overload of ISubqueryLinkAdapter , ISubqueryLinkAdapter<TDObj> or ISubqueryLinkAdapter<T,TDObj> depending by outer method signature and subquery declaration specific. ... .InnerView<DocBySpecType>(\"ST\", x => x.SubqueryLink(\"DocId\")) ... Tip Subquery links can be used to define optional filters . To specify role in optional filter chain need to call extension method AsPrimary as continuation of Link method call."
  },
  "tutorial/mapping/dynamic/filter/dictionary.html": {
    "href": "tutorial/mapping/dynamic/filter/dictionary.html",
    "title": "Dictionary filters | XData website",
    "keywords": "Dictionary filters Dictionaries surrogate keys may varied over one instance to another, and names can be changed by users. Sometimes business logic need to operate with the concrete value of dictionary. Because of this it's recommended to add into dictionary DB structure a special unique text field - mnemonic code. XData supports using mnemonic code when define filters on dictionary value - dictionary filters. They defined by one of DictFilter overloads of IInnerFilterAdapter interface. Important This filter can be used when dictionary has simple (one field only) identity field and mnemonic code field. But it's a very common case. ... , x => x.DictFilter(\"T_DOC_CUST_TYPE\", \"doc_cust_type_id\", \"code\", \"TO\") ..."
  },
  "tutorial/mapping/dynamic/dynamic.html": {
    "href": "tutorial/mapping/dynamic/dynamic.html",
    "title": "Dynamic mapping | XData website",
    "keywords": "XData tutorial Mapping common rules Dynamic mapping Tip Before read this topic be sure to already readied Glossary and Common mapping rules contains base information to better understanding this. Dynamic mapping is defined using specific LINQ style expression as private static field of mapped class and it properties. Dynamic mapping sample <!--MD5=[9fbc3a7cfb9f92e84de8970988e48bb2] class t_catalogue--> t_catalogue catalogue_id code name parent_id <!--MD5=[ea6ea2e31c0cbff1b909b1f0bd59093e] class t_customer--> t_customer customer_id code name <!--MD5=[a6ce46e431db16f1c4014df928aac3e8] class t_doc_cust_type--> t_doc_cust_type doc_cust_type_id code name <!--MD5=[bccea5d0c54fc84e4bad16ab69fd73e7] class t_doc_type--> t_doc_type doc_type_id code name <!--MD5=[5ea577eca533bfca935d04f775d3f167] class t_doc--> t_doc doc_id doc_type_id doc_date generation changed author <!--MD5=[d4ba8adfb5df751cf422e2fad2a28e94] class t_catalogue_doc--> t_catalogue_doc catalogue_id doc_id <!--MD5=[8cca3b0685271c670c4226b30b01cbcf] class t_doc_cust--> t_doc_cust doc_cust_id doc_id customer_id doc_cust_type_id <!--MD5=[fd8c5e68644f1f4fc0b14eca97226ae4] class t_doc_delivery--> t_doc_delivery doc_id delivery_type delivery_date <!--MD5=[dd40a5851c55ff9d7da9b59b2cdb5061] class t_doc_number--> t_doc_number doc_id numb <!--MD5=[710d3dc0240fd500b1d510e138be1447] class t_doc_scan--> t_doc_scan doc_id scan <!--MD5=[5937349b424f6b33ad58af94594dfd63] class t_doc_source--> t_doc_source doc_id source <!--MD5=[4efa0cfa5e1d38a4afda4e219b98680a] class t_doc_state--> t_doc_state doc_state_id code name <!--MD5=[5c02744e5b0455229387a946a811ce2e] class t_doc_doc_state--> t_doc_doc_state doc_id doc_state_id <!--MD5=[0d4a222ed2d2d268b8328f05b8f9e363] class t_doc_history--> t_doc_history doc_history_id doc_id doc_state_id history_date <!--MD5=[d4b45c8a441f4cb1774906928f147529] link t_catalogue to t_catalogue--> parent_id <!--MD5=[b3294211ce75436a8f4d3c51fb151377] link t_doc_type to t_doc--> doc_type_id <!--MD5=[840062eaffe844779ca4f4f301a47d9a] reverse link t_catalogue to t_catalogue_doc--> catalogue_id <!--MD5=[b3a8eac680fbb6e047950cbceafbeb2c] link t_catalogue_doc to t_doc--> doc_id <!--MD5=[7eefc4f6dff794e64e78dcbbfb9c491a] link t_doc to t_doc_cust--> doc_id <!--MD5=[0005336a9822bd19ef61e4ce8910c4c5] reverse link t_doc_cust to t_customer--> customer_id <!--MD5=[131b4a0e76521106752daee341bf156a] reverse link t_doc_cust to t_doc_cust_type--> doc_cust_type_id <!--MD5=[94de7abaa940d64e718a7c3244926e87] reverse link t_doc_delivery to t_doc--> doc_id <!--MD5=[2d23622d96560790c79c16e9140044a4] reverse link t_doc_number to t_doc--> doc_id <!--MD5=[7c459e52799c0d4d655e72449bb91e72] reverse link t_doc_scan to t_doc--> doc_id <!--MD5=[4aa29f824d631e9db9c0b4ff518403cc] reverse link t_doc_source to t_doc--> doc_id <!--MD5=[fdc70aa94f88d88b378c08a646310f88] reverse link t_doc_doc_state to t_doc--> doc_id <!--MD5=[63d405c0f3a8aa08b15fc74dd2b85047] link t_doc_state to t_doc_doc_state--> doc_state_id <!--MD5=[9c004340c543d5fd28395a65d65b76dd] link t_doc to t_doc_history--> doc_id <!--MD5=[ac06e947c28172a1581fe83d17c1f569] reverse link t_doc_history to t_doc_state--> doc_state_id <!--MD5=[a24f9b6c28c3f11eb813d302e9c42a66] @startuml hide circle skinparam ClassHeaderBackgroundColor lightgray skinparam ClassBorderColor black skinparam ClassBorderThickness 1 skinparam ClassBackgroundColor transparrent skinparam ArrowFontSize 8 skinparam ArrowColor black entity t_catalogue { <&key> catalogue_id - - <&code> code name <&arrow-circle-right> //parent_id// } t_catalogue - -{ t_catalogue : parent_id entity t_customer { <&key> customer_id - - <&code> code name } entity t_doc_cust_type { <&key> doc_cust_type_id - - <&code> code name } entity t_doc_type { <&key> doc_type_id - - <&code> code name } entity t_doc { <&key> doc_id - - <&arrow-circle-right> doc_type_id doc_date - - <&tag> generation <&clock> changed <&person> author } t_doc_type -right-{ t_doc : doc_type_id entity t_catalogue_doc { <&key> <&arrow-circle-right> catalogue_id <&key> <&arrow-circle-right> doc_id } t_catalogue_doc -up-{ t_catalogue : catalogue_id t_catalogue_doc - -{ t_doc : doc_id entity t_doc_cust { <&key> doc_cust_id - - <&arrow-circle-right> doc_id <&arrow-circle-right> customer_id <&arrow-circle-right> doc_cust_type_id } t_doc_cust }-up- t_doc : doc_id t_doc_cust }- - t_customer : customer_id t_doc_cust }- - t_doc_cust_type : doc_cust_type_id entity t_doc_delivery { <&key> <&arrow-circle-right> doc_id - - delivery_type delivery_date } t_doc_delivery }o- - t_doc : doc_id entity t_doc_number { <&key> <&arrow-circle-right> doc_id - - numb } t_doc_number }o- - t_doc : doc_id entity t_doc_scan { <&key> <&arrow-circle-right> doc_id - - <&map> scan } t_doc_scan }o- - t_doc : doc_id entity t_doc_source { <&key> <&arrow-circle-right> doc_id - - <&document> source } t_doc_source }o- - t_doc : doc_id entity t_doc_state { <&key> doc_state_id - - <&code> code name } entity t_doc_doc_state { <&key> <&arrow-circle-right> doc_id - - <&arrow-circle-right> doc_state_id } t_doc_doc_state }o-right- t_doc : doc_id t_doc_doc_state }-left- t_doc_state : doc_state_id entity t_doc_history { <&key> doc_history_id - - <&arrow-circle-right> doc_id <&arrow-circle-right> doc_state_id <&clock> history_date } t_doc_history }-up- t_doc : doc_id t_doc_history }- - t_doc_state : doc_state_id @enduml PlantUML version 1.2020.12(Sat Jun 06 10:54:15 UTC 2020) (GPL source distribution) Java Runtime: Java(TM) SE Runtime Environment JVM: Java HotSpot(TM) 64-Bit Server VM Default Encoding: UTF-8 Language: en Country: US --> <!--MD5=[5ea577eca533bfca935d04f775d3f167] class t_doc--> t_doc doc_id doc_type_id doc_date generation changed author <!--MD5=[e871482fb55f9150fc3be5a0e93d8569] class t_doc_spec_type--> t_doc_spec_type doc_spec_type_id code name <!--MD5=[4ed4cd12cd2eeb59e644791b1ec40217] class t_doc_spec--> t_doc_spec doc_spec_id doc_id doc_spec_type_id <!--MD5=[025ac326a6ab31b45989aa42f37da176] class t_doc_spec_amount--> t_doc_spec_amount doc_spec_id amount <!--MD5=[cef6fc7600387b202b7e697154b0ecaf] link t_doc to t_doc_spec--> doc_id <!--MD5=[175fa9f72450b3173fe29432cd7fb745] reverse link t_doc_spec to t_doc_spec_type--> doc_spec_type_id <!--MD5=[542647722f52d6ccd9b263e63b85e2d8] link t_doc_spec to t_doc_spec_amount--> doc_spec_id <!--MD5=[5cb7b5aa399201d5b29efcb8adfe8a65] @startuml hide circle skinparam ClassHeaderBackgroundColor lightgray skinparam ClassBorderColor black skinparam ClassBorderThickness 1 skinparam ClassBackgroundColor transparrent skinparam ArrowFontSize 8 skinparam ArrowColor black entity t_doc { <&key> doc_id - - <&arrow-circle-right> doc_type_id doc_date - - <&tag> generation <&clock> changed <&person> author } entity t_doc_spec_type { <&key> doc_spec_type_id - - <&code> code name } entity t_doc_spec { <&key> doc_spec_id - - <&arrow-circle-right> doc_id <&arrow-circle-right> doc_spec_type_id } t_doc_spec }-left- t_doc : doc_id t_doc_spec }- - t_doc_spec_type : doc_spec_type_id entity t_doc_spec_amount { <&key> <&arrow-circle-right> doc_spec_id - - <&dollar> amount } t_doc_spec_amount }o-left- t_doc_spec : doc_spec_id @enduml PlantUML version 1.2020.12(Sat Jun 06 10:54:15 UTC 2020) (GPL source distribution) Java Runtime: Java(TM) SE Runtime Environment JVM: Java HotSpot(TM) 64-Bit Server VM Default Encoding: UTF-8 Language: en Country: US --> Dynamic mapping example for same data object as represented in static mapping description: SQL representation of following sample: with recursive T (catalogue_id, code, name, parent_id) as ((SELECT R.catalogue_id AS R_catalogue_id, R.code AS R_code, R.name AS R_name, R.parent_id AS R_parent_id FROM T_CATALOGUE R WHERE ((@FilterByRoot is not null and R.catalogue_id = @FilterByRoot) OR (@FilterByRoot is null and R.parent_id is null))) UNION (SELECT S.catalogue_id AS S_catalogue_id, S.code AS S_code, S.name AS S_name, S.parent_id AS S_parent_id FROM T_CATALOGUE S, T T WHERE S.parent_id = (T.catalogue_id))) SELECT CF.CUSTOMER_ID AS CF_CUSTOMER_ID, CF.DOC_CUST_ID AS CF_DOC_CUST_ID, CF.DOC_CUST_TYPE_ID AS CF_DOC_CUST_TYPE_ID, CF.DOC_ID AS CF_DOC_ID, CT.CUSTOMER_ID AS CT_CUSTOMER_ID, CT.DOC_CUST_ID AS CT_DOC_CUST_ID, CT.DOC_CUST_TYPE_ID AS CT_DOC_CUST_TYPE_ID, CT.DOC_ID AS CT_DOC_ID, CAST((SELECT Sum(A.amount) AS A_amount FROM T_DOC_SPEC S JOIN T_DOC_SPEC_AMOUNT A ON A.DOC_SPEC_ID = S.DOC_SPEC_ID WHERE S.doc_id = S.doc_id) AS NUMERIC(17, 5)) AS doc_amount /* DocAmount */, D.doc_date AS D_doc_date /* DocDate */, D.doc_id AS D_doc_id /* DocId */, D.DOC_TYPE_ID AS D_DOC_TYPE_ID, D.generation AS D_generation /* Generation */, D.changed AS D_changed /* Changed */, D.author AS D_author /* Author */, DD.delivery_date AS DD_delivery_date /* DeliveryDate */, DD.delivery_type AS DD_delivery_type /* DeliveryType */, DD.DOC_ID AS DD_DOC_ID, DS.DOC_DOC_STATE_ID AS DS_DOC_DOC_STATE_ID, DS.DOC_ID AS DS_DOC_ID, DS.DOC_STATE_ID AS DS_DOC_STATE_ID, F.CODE AS F_CODE, F.CUSTOMER_ID AS F_CUSTOMER_ID, F.name AS F_name /* CustomerFrom */, H.H_doc_id AS H_H_doc_id, H.H_history_date AS H_H_history_date /* DocLastChange */, N.DOC_ID AS N_DOC_ID, N.numb AS N_numb /* DocNumb */, S.code AS S_code /* DocStateCode */, S.DOC_STATE_ID AS S_DOC_STATE_ID, S.name AS S_name /* DocState */, SC.DOC_ID AS SC_DOC_ID, SC.scan AS SC_scan /* Scan */, SR.DOC_ID AS SR_DOC_ID, SR.source AS SR_source /* Source */, ST.S_doc_id AS ST_S_doc_id, T.CODE AS T_CODE, T.CUSTOMER_ID AS T_CUSTOMER_ID, T.name AS T_name /* CustomerTo */ FROM T_DOC D JOIN T_DOC_DOC_STATE DS ON DS.doc_id = D.doc_id JOIN T_DOC_STATE S ON S.DOC_STATE_ID = DS.DOC_STATE_ID JOIN T_DOC_NUMBER N ON N.doc_id = D.doc_id JOIN T_DOC_CUST CF ON CF.doc_id = D.doc_id JOIN T_DOC_CATALOGUE DC ON DC.doc_id = D.doc_id JOIN T_CATALOGUE U ON DC.catalogue_id = U.catalogue_id JOIN T_CUSTOMER F ON F.CUSTOMER_ID = CF.CUSTOMER_ID JOIN T_DOC_CUST CT ON CT.doc_id = D.doc_id JOIN T_CUSTOMER T ON T.CUSTOMER_ID = CF.CUSTOMER_ID LEFT OUTER JOIN T_DOC_SCAN SC ON SC.doc_id = D.doc_id LEFT OUTER JOIN T_DOC_SOURCE SR ON SR.doc_id = D.doc_id LEFT OUTER JOIN T_DOC_DELIVERY DD ON DD.doc_id = D.doc_id LEFT OUTER JOIN (SELECT H.doc_id AS H_doc_id, H.history_date AS H_history_date FROM T_DOC_HISTORY H) H ON D.doc_id = H.H_doc_id JOIN (SELECT S.doc_id AS S_doc_id FROM T_DOC_SPEC_TYPE ST JOIN T_DOC_SPEC S ON S.DOC_SPEC_TYPE_ID = ST.DOC_SPEC_TYPE_ID WHERE ST.code = @FilterBySpecTypeCode) ST ON D.doc_id = ST.S_doc_id WHERE D.DOC_TYPE_ID = (select doc_type_id from T_DOC_TYPE where code='INVOICE') AND CF.DOC_CUST_TYPE_ID = (select doc_cust_type_id from T_DOC_CUST_TYPE where code='FROM') AND CF.DOC_CUST_TYPE_ID = (select doc_cust_type_id from T_DOC_CUST_TYPE where code='TO') AND D.doc_id = @FilterByDocId AND DC.catalogue_id in (SELECT T.catalogue_id AS T_catalogue_id FROM T T) Mapping sample: public partial class Invoice: IDataObject { public static CustomLogic<Invoice> TestCustomLogic; private static Expression<CustomMapping<Invoice>> _mapping = ( () => XDataMapping.CustomMapping<Invoice>() .DataTable(\"T_DOC\", \"D\", x => x.DictFilter(\"T_DOC_TYPE\", \"doc_type_id\", \"code\", \"INVOICE\")) .DataTable(\"T_DOC_DOC_STATE\", \"DS\", \"D\", x => x.Link(\"D\", \"doc_id\")) .DataTable(\"T_DOC_STATE\", \"S\", x => x.Link(\"DS\", \"doc_state_id\")) .DataTable(\"T_DOC_CATALOGUE\", \"DC\", \"D\", x => x.Link(\"D\", \"doc_id\"), x => x.SubqueryFilter(\"catalogue_id\", \"UT\").SetOperation(FilterOperation.In)) .DataTable(\"T_CATALOGUE\", \"U\", x => x.Link(\"DC\", \"catalogue_id\")) .DataTable(\"T_DOC_NUMBER\", \"N\", \"D\", x => x.Link(\"D\", \"doc_id\")) .DataTable(\"T_DOC_CUST\", \"CF\", \"D\", x => x.Link(\"D\", \"doc_id\"), x => x.DictFilter(\"T_DOC_CUST_TYPE\", \"doc_cust_type_id\", \"code\", \"FROM\")) .DataTable(\"T_CUSTOMER\", \"F\", x => x.Link(\"CF\", \"customer_id\")) .DataTable(\"T_DOC_CUST\", \"CT\", \"D\", x => x.Link(\"D\", \"doc_id\"), x => x.DictFilter(\"T_DOC_CUST_TYPE\", \"doc_cust_type_id\", \"code\", \"TO\")) .DataTable(\"T_CUSTOMER\", \"T\", x => x.Link(\"CT\", \"customer_id\")) .DataTable(\"T_DOC_SCAN\", \"SC\", \"D\", x => x.Link(\"D\", \"doc_id\").SetOperation(FilterOperation.OuterJoin)) .DataTable(\"T_DOC_SOURCE\", \"SR\", \"D\", x => x.Link(\"D\", \"doc_id\").SetOperation(FilterOperation.OuterJoin)) .DataTable(\"T_DOC_DELIVERY\", \"DD\", \"D\", x => x.Link(\"D\", \"doc_id\").SetOperation(FilterOperation.OuterJoin)) .Subquery(\"A\", typeof(DocSpecAmounts), \"Amount\", DataGrouping.Sum, x => x.SubqueryLink(\"DocId\")) .Subquery<CatalogueTree>(\"UT\", x => x.CatalogueId, DataGrouping.None) .InnerView(\"H\", XDataMapping.GetStructure(\"H\", DataStructureFlag.Grouping) .DataTable(\"T_DOC_HISTORY\", \"H\") .Select(x => new { DocId = x.Field<long?>(\"H\", string.Empty, z => z.Group(DataGrouping.None)), HistoryDate = x.Field<DateTime?>(\"H\", string.Empty, z => z.Group(DataGrouping.Max)) }), x => x.SubqueryLink(\"DocId\").SetOperation(FilterOperation.OuterJoin)) .InnerView<DocBySpecType>(\"ST\", x => x.SubqueryLink(\"DocId\")) .Column(\"DocId\", x => x.Field<long?>(\"D\", string.Empty, z => z.Key(), z => z.Default(DefaultType.AutoIncrement))) .Column(\"DocStateId\", x => x.Field<long>(\"S\", string.Empty)) .Column(\"FromCustomerId\", x => x.Field<long>(\"F\", \"customer_id\")) .Column(\"ToCustomerId\", x => x.Field<long>(\"T\", \"customer_id\")) .Column(\"CatalogueId\", x => x.Field<long?>(\"U\", string.Empty)) .ReadOnlyProperty(x => x.DocStateCode, x => x.Field<string>(\"S\", \"code\")) .ReadOnlyProperty(x => x.Generation, x => x.Field<long>(\"D\", string.Empty, z => z.ConcurrencyToken(), z => z.Default(DefaultType.AutoIncrement))) .ReadOnlyProperty(x => x.Changed, x => x.Field<DateTime>(\"D\", string.Empty, z => z.Default(DefaultType.CurrentDateTime, DefaultFeature.UseOnUpdate))) .ReadOnlyProperty(x => x.Author, x => x.Field<string>(\"D\", string.Empty, z => z.Default(DefaultType.UserName, DefaultFeature.UseOnUpdate))) .ReadOnlyProperty(x => x.DocAmount, x => x.Expr<decimal?>(null, DataExpressionType.SubQuery, \"A\", DbType.Decimal, z => z.Size(17, 5))) .ReadOnlyProperty(x => x.DocLastChange, x => x.Ref<DateTime?>(\"H\", \"HistoryDate\")) .Map(x => new Invoice { DocState = x.Link<string, DocState>(\"S\", \"name\", z => z.LinkProperty<DocState>(y => y.Name), z => z.LinkProperty<DocState>(y => y.Code, y => y.DocStateCode), z => z.LinkProperty<DocState>((Invoice y) => y.GetProperty<long>(\"DocStateId\"))), DocCatalog = x.Link<string, Catalogue>(\"U\", \"name\", z => z.LinkProperty<Catalogue>(y => y.Name), z => z.LinkProperty<Catalogue>((Invoice y) => y.GetProperty<long>(\"CatalogueId\"))), DocNumb = x.Field<string>(\"N\", \"numb\"), DocDate = x.Field<DateTime?>(\"D\", string.Empty, z => z.Default(DefaultType.CurrentDate)), Scan = x.Lob(\"SC\", z => z.OuterFlag()), Source = x.Xml(\"SR\", z => z.OuterFlag()), CustomerFrom = x.Link<string, Customer>(\"F\", \"name\", z => z.LinkProperty<Customer>(y => y.Name), z => z.LinkProperty<Customer>(y => y.GetProperty<long>(\"CustomerId\"), y => y.GetProperty<long>(\"FromCustomerId\"))), CustomerTo = x.Link<string, Customer>(\"T\", \"name\", z => z.LinkProperty<Customer>(y => y.Name), z => z.LinkProperty<Customer>(y => y.GetProperty<long>(\"CustomerId\"), y => y.GetProperty<long>(\"ToCustomerId\"))), DeliveryType = x.Field<DeliveryTypeEnum>(\"DD\", string.Empty), DeliveryDate = x.Field<DateTime?>(\"DD\", string.Empty, z => z.Default(DefaultType.CurrentDate)) }, x => x.ExternalLink<InvoiceSpec>(\"DocId\")) .SetBaseTable(\"D\").SetLogicAssembly(\"XDataObjectTest\") ); } ... public partial class Invoice { public string DocStateCode { get { return this.GetProperty(x => x.DocStateCode); } } public Link<string, DocState> DocState { get; set; } public Link<string, Catalogue> DocCatalog { get; set; } public string DocNumb { get; set; } public DateTime? DocDate { get; set; } public long Generation { get { return this.GetProperty(x => x.Generation); } } public DateTime Changed { get { return this.GetProperty(x => x.Changed); } } public string Author { get { return this.GetProperty(x => x.Author); } } public decimal? DocAmount { get { return this.GetProperty(x => x.DocAmount); } } public DateTime? DocLastChange { get { return this.GetProperty(x => x.DocLastChange); } } public Lob Scan { get; set; } public Xml Source { get; set; } public Link<string, Customer> CustomerFrom { get; set; } public Link<string, Customer> CustomerTo { get; set; } public DeliveryTypeEnum DeliveryType { get; set; } public DateTime? DeliveryDate { get; set; } public IRepository<InvoiceSpec> Spec { get { return this.GetRepository().GetChild<InvoiceSpec>(); } } } Dynamic mapping provide more representable mechanics to define mapping because of no attribute parameters limitation. Subqueries and inner views can be described in place using dynamic query mechanics. SQL expressions can be described in LINQ style in place. This abilities enreach representability of dynamic mapping. Dynamic mapping allows split data object to partial class definitions with basic class definition and mapping. Dynamic mapping initialization Dynamic mapping is described as private static field of type Expression<CustomMapping<T>> where T - data object type. The value of this property is assigned by call of XDataMapping.CustomMapping<T> method returning IRepositoryStructure<T> . Interface IRepositoryStructure<T> has a number of methods to describe all of mapping entities analog to static mapping attributes. The XDataMapping.UseMapping<T> method can be used to inherit the mapping description of the data object. The depth of the inheritance hierarchy of the mapping description is not limited. There are several overloads of this method: UseMapping<T, TParent>() - points to type TParent as the base mapping description class. The TParent class must implement the ISqlObject interface but does not have to be associated with the T class. UseMapping<T>() - the same as the previous method, only the base class in the usual class inheritance hierarchy acts as the base class in the mapping description hierarchy. UseMapping<T, TParent>(params Expression<Func<IExternalLinkDefinitionAdapter<T>, IExternalLinkDefinition>>[] externalLinks) - allows you to fully inherit the description of mapping and supplement the description with external links. This method of inheriting the mapping description imposes a limitation - the base class must be the ancestor of the T class. UseMapping<T>(params Expression<Func<IExternalLinkDefinitionAdapter<T>, IExternalLinkDefinition>>[] externalLinks) - the same as the previous method, only the base class in the usual class inheritance hierarchy acts as the base class in the mapping description hierarchy. Warning When inheriting mapping descriptions, a mixture of the static and dynamic description methods within the a single mapping inheritance hierarchy is not allowed! Mapping parameters To set parameters of dynamically mapped classes used IRepositoryDescription<T> interface methods: SetBaseTable - to set base table , (optional, by default used virtual table with the empty alias) SetContext - database context (optional, by default context will by assigned in runtime) SetFlags - data source flags (optional, by default None ) SetLogicAssemblies - to set data processing logic classes assemblies FullName for this repository (see Using three tier architecture and IDataLogic<T> ) To get reference to IRepositoryDescription<T> interface is required to define mapping of repository read/write properties using IRepositoryStructure<T> interface method Map Example: ... .Map(x => new Invoice { DocState = x.Link<string, DocState>(\"S\", \"name\", z => z.LinkProperty<DocState>(y => y.Name), z => z.LinkProperty<DocState>(y => y.Code, y => y.DocStateCode), z => z.LinkProperty<DocState>( (Invoice y) => y.GetProperty<long>(\"DocStateId\"))), DocCatalog = x.Link<string, Catalogue>(\"U\", \"name\", z => z.LinkProperty(y => y.Name), z => z.LinkProperty<Catalogue>( (Invoice y) => y.GetProperty<long>(\"CatalogueId\"))), DocNumb = x.Field<string>(\"N\", \"numb\"), DocDate = x.Field<DateTime?>(\"D\", string.Empty, z => z.Default(DefaultType.CurrentDate)), Scan = x.Lob(\"SC\", z => z.OuterFlag()), Source = x.Xml(\"SR\", z => z.OuterFlag()), CustomerFrom = x.Link<string, Customer>(\"F\", \"name\", z => z.LinkProperty(y => y.Name), z => z.LinkProperty<Customer>(y => y.GetProperty<long>(\"CustomerId\"), y => y.GetProperty<long>(\"FromCustomerId\"))), CustomerTo = x.Link<string, Customer>(\"T\", \"name\", z => z.LinkProperty(y => y.Name), z => z.LinkProperty<Customer>(y => y.GetProperty<long>(\"CustomerId\"), y => y.GetProperty<long>(\"ToCustomerId\"))), DeliveryType = x.Field(\"DD\", string.Empty), DeliveryDate = x.Field<DateTime?>(\"DD\", string.Empty, z => z.Default(DefaultType.CurrentDate)) }, x => x.ExternalLink(\"DocId\")) .SetBaseTable(\"D\").SetLogicAssembly(\"XDataObjectTest\") ... More detailed repository properties map description see below . Tables All tables of data object mapping described by IRepositoryStructure<T>. DataTable method. Tables included into updatable tables hierarchy excluding base table must be defined using special overload allows to set parent table alias. ... .DataTable(\"T_DOC\", \"D\", x => x.DictFilter(\"T_DOC_TYPE\", \"doc_type_id\", \"code\", \"INVOICE\")) .DataTable(\"T_DOC_DOC_STATE\", \"DS\", \"D\", x => x.Link(\"D\", \"doc_id\")) ... Same way is possible to define mapping to view , but all properties must to mapped as read only properties or hidden fields . Important Filters and links between tables is defined using filters parameter of IRepositoryStructure<T>. DataTable method or it's overload . Detailed filter definition described below . Subqueries Subqueries can be used for a: filtration using [not] exists() , [not] in (select) ( see below ) inner view subquery expression as single property source ( see below ) Subquery deep level is not limited. In dynamic mapping of data object subqueries can be defined using one of Subquery or InnerView methods overload of IRepositoryStructure<T> interface to define subqueries or inner views respectively. While using generic overloads of Subquery or InnerView , parameter IQueryDescription<TDobj> sub can be used with in place dynamic query notation. Non generic overloads of Subquery or InnerView must provide ISqlType or IDataObject marked class type as parameter Type dobjType to reuse of existing mapping. This class can be mapped using static or dynamic style, no matter. ... .Subquery(\"A\", typeof(DocSpecAmounts), \"Amount\", DataGrouping.Sum, x => x.SubqueryLink(\"DocId\")) .Subquery<CatalogueTree>(\"UT\", x => x.CatalogueId, DataGrouping.None) .InnerView(\"H\", XDataMapping.GetStructure(\"H\", DataStructureFlag.Grouping) .DataTable(\"T_DOC_HISTORY\", \"H\") .Select(x => new { DocId = x.Field<long?>(\"H\", string.Empty, z => z.Group(DataGrouping.None)), HistoryDate = x.Field<DateTime?>(\"H\", string.Empty, z => z.Group(DataGrouping.Max)) }), x => x.SubqueryLink(\"DocId\").SetOperation(FilterOperation.OuterJoin)) .InnerView<DocBySpecType>(\"ST\", x => x.SubqueryLink(\"DocId\")) ... Filters Filters can be defined as: Constant filters SQL expression filters Dictionary filters Range filters Subquery filters Inner links Each of them described by corresponding LINQ expression define their parameters depending on the context of their use and the type of the filter itself (see below). Filter descriptions are provided to filters parameter value of DataTable , Subquery , InnerView and Procedure methods of IRepositoryStructure<T> interface, or WithRecursive method of IQueryWithAdapter<TRoot> . Each of expression has described one filter. Type of filter is declared by one of fabric method of interface inside lambda expression with one of followed filter adapter: IInnerFilterAdapter - filter adapter to define filters and links inside plain query (see DataTable , Procedure ), ISubqueryLinkAdapter , ISubqueryLinkAdapter<TDObj> and ISubqueryLinkAdapter<T,TDObj> - used in various overloads of subquery definition (see Subquery , InnerView and WithRecursive ) to declare links with subqueries. Specific parameters for each type of filter is described in filter fabric methods described below in specific topics. And some optional modificators can be defined using continue LINQ calls with extension methods: SetOperation - to set filter operation AsPrimary - to set optional filter flag SetCombination - to set filter combination Each of filter type is defined by own special method of corresponding filter adapter. Filter operation is defined by enum FilterOperation : Equal - equal NotEqual - not equal LessThan - less then GreaterThan - greater then LessThanOrEqual - less or equal GreaterThanOrEqual - greater or equal In - field value in range or subquery NotIn - field value is not in range or subquery Exists - subquery returns one or more rows NotExists - subquery returns no rows Like - field value correlated with find expression NotLike - field value not correlated with find expression OuterJoin - left outer join link between query sources (tables or inner views) Contains - field value correlated with full-text search NotContains - field value not correlated with full-text search Filter group Filter group of filter can be assigned to it declaration by SetCombination extension of IFilterDescription interface. ... , x => x.ConstFilter(\"FilterByCathalogue\", \"catalogue_id\", FilterConstantType.Const, null, FilterNullable.NullsNotAllowed) .SetCombination(\"root\") ... Constant filters Constant filters allows to restrict selection of data by some constant value. This filter defined by one of ConstFilter method overloads of IInnerFilterAdapter interface. Constant type list restricted by enum FilterConstantType : Const - constant with value set by ConstantValue . Variable - value of variable with name set by ConstantValue . CurrentDate - current date. CurrentDateTime - current date and time. CurrentDateTimeUTC - current date and time (UTC). ... , x => x.ConstFilter(\"FilterByCathalogue\", \"catalogue_id\", FilterConstantType.Const, null, FilterNullable.NullsNotAllowed) .SetCombination(\"root\") ... SQL expression filters To define filter over SQL expression used one of ExprFilter method overloads of IInnerFilterAdapter interface. There are two overloads of ExprFilter method: IFilterDescription ExprFilter(string field, string exprText) - to use with plain SQL expressions or subquery alias IFilterDescription ExprFilter<T>(string field, Expression<Func<IQueryStructureAdapter, T>> expression) - to use with SQL expressions as LINQ style expressions Depending style of SQL expression description that overloads can be used with: subquery alias, , ExprFilter(\"discount\" /* field name */, \"D\" /* ExpressionText: subquery alias */) .SetOperation(FilterOperation.In) dynamic definition of SQL expression, , ExprFilter(\"discount\" /* field name */, /* expression: SQL expression LINQ style definition */ x => x.Case<Product, int>( z => z.Field<bool>(\"is_vip\"), z => 0, 1.SetExpression(z => 10)), Operation: FilterOperation.NotEqual /* filter operation */)] plain SQL expression text. , ExprFilter(\"discount\" /* field name */, /* ExpressionText: plain SQL expression */ \"case P.is_vip when 1 then 10 else 0 end\") .SetOperation(FilterOperation.NotEqual) Important If possible do not use plain SQL expressions. It possibly use specific SQL dialect features not supported by other DBMS or providers. Range filters To define filter checks field value over array of values used RangeFilter methods of IInnerFilterAdapter interface. ... , RangeFilter(\"discount\", 1, 5, 10) .SetOperation(FilterOperation.In) ... Dictionary filters Dictionaries surrogate keys may varied over one instance to another, and names can be changed by users. Sometimes business logic need to operate with the concrete value of dictionary. Because of this it's recommended to add into dictionary DB structure a special unique text field - mnemonic code. XData supports using mnemonic code when define filters on dictionary value - dictionary filters. They defined by one of DictFilter overloads of IInnerFilterAdapter interface. Important This filter can be used when dictionary has simple (one field only) identity field and mnemonic code field. But it's a very common case. ... , x => x.DictFilter(\"T_DOC_CUST_TYPE\", \"doc_cust_type_id\", \"code\", \"TO\") ... Inner links To define links between data sources inside query used Link overloads of IInnerFilterAdapter interface. ... , x => x.Link(\"DS\", \"doc_state_id\") ... Tip Inner links can be used to define optional filters . To specify role in optional filter chain need to call extension method AsPrimary as continuation of Link method call. Subquery filters To define filters checks field value is correspond subquery results used SubqueryFilter method of IInnerFilterAdapter . ... .DataTable(\"T_DOC_CATALOGUE\", \"DC\", \"D\", x => x.Link(\"D\", \"doc_id\"), x => x.SubqueryFilter(\"catalogue_id\", \"UT\") .SetOperation(FilterOperation.In)) .Subquery<CatalogueTree>(\"UT\", x => x.CatalogueId, DataGrouping.None) ... Tip Subquery filters can be used to define optional filters . To specify role in optional filter chain need to call extension method AsPrimary as continuation of Link method call. Subquery links Links with subqueries is used to link not table fields but properties of base class and subquery mapped class including hidden properties . To link with subquery or inner view used one of SubqueryLink method overload of ISubqueryLinkAdapter , ISubqueryLinkAdapter<TDObj> or ISubqueryLinkAdapter<T,TDObj> depending by outer method signature and subquery declaration specific. ... .InnerView<DocBySpecType>(\"ST\", x => x.SubqueryLink(\"DocId\")) ... Tip Subquery links can be used to define optional filters . To specify role in optional filter chain need to call extension method AsPrimary as continuation of Link method call. Properties Properties dynamic mapping is performed as method call of IRepositoryStructure<T> interface: Column method call for each of hidden properties mapping ReadOnlyProperty method call for each of read only properties mapping Map method call for declare all of read/write properties mapping ... .Column(\"DocId\", x => x.Field<long?>(\"D\", string.Empty, z => z.Key(), z => z.Default(DefaultType.AutoIncrement))) ... .ReadOnlyProperty(x => x.Changed, x => x.Field<DateTime>(\"D\", string.Empty, z => z.Default(DefaultType.CurrentDateTime, DefaultFeature.UseOnUpdate))) ... Parameter mapper of Map method allows to define mapping rule for multiple read/write properties using lambda expression with IQueryStructureAdapter interface as parameter. ... .Map(x => new Invoice { DocState = x.Link<string, DocState>(\"S\", \"name\", z => z.LinkProperty<DocState>(y => y.Name), z => z.LinkProperty<DocState>(y => y.Code, y => y.DocStateCode), z => z.LinkProperty<DocState>( (Invoice y) => y.GetProperty<long>(\"DocStateId\"))), DocCatalog = x.Link<string, Catalogue>(\"U\", \"name\", z => z.LinkProperty<Catalogue>(y => y.Name), z => z.LinkProperty<Catalogue>( (Invoice y) => y.GetProperty<long>(\"CatalogueId\"))), DocNumb = x.Field<string>(\"N\", \"numb\"), DocDate = x.Field<DateTime?>(\"D\", string.Empty, z => z.Default(DefaultType.CurrentDate)), Scan = x.Lob(\"SC\", z => z.OuterFlag()), Source = x.Xml(\"SR\", z => z.OuterFlag()), CustomerFrom = x.Link<string, Customer>(\"F\", \"name\", z => z.LinkProperty<Customer>(y => y.Name), z => z.LinkProperty<Customer>(y => y.GetProperty<long>(\"CustomerId\"), y => y.GetProperty<long>(\"FromCustomerId\"))), CustomerTo = x.Link<string, Customer>(\"T\", \"name\", z => z.LinkProperty<Customer>(y => y.Name), z => z.LinkProperty<Customer>(y => y.GetProperty<long>(\"CustomerId\"), y => y.GetProperty<long>(\"ToCustomerId\"))), DeliveryType = x.Field<DeliveryTypeEnum>(\"DD\", string.Empty), DeliveryDate = x.Field<DateTime?>(\"DD\", string.Empty, z => z.Default(DefaultType.CurrentDate)) }, x => x.ExternalLink<InvoiceSpec>(\"DocId\")) ... Interfaces IRepositoryStructureAdapter<T> and IQueryStructureAdapter as successor has some overloads of methods to define mapping: Field<TVal> - for mapping property to data source field Expr<TVal> - for mapping property to SQL expression (see detailed description below ) Ref<TVal> - for mapping property to inner view property (see detailed description below ) IRepositoryStructureAdapter<T> also has a special methods to map Lob , Xml and Link<TVal,TSource> Lob - for mapping Lob property Xml - for mapping Xml property Link<TVal,TSource> - for mapping link property (see detailed description below ) These methods of single property mapping has parameter attributes to define additional mapping properties using interface IPropertyMappingAdapter : Key - primary unique key property flag, possible to mark multiple properties or hidden properties as key properties Hidden - flag, the field should not be included in the SELECT expression, but can be used in filters and/or links between data sources (tables, subqueries...) Group - property grouping parameters (see detailed description below ) And using interface IRepositoryPropertyMappingAdapter<T, TValue> : ConcurrencyToken - concurrency token flag for property Default - default value assign rules for property OuterFlag - outer join mandatory flag, values of properties marked this flag is analyzed during making decision of operations over tables in optional references Important Required to set at least one property of mapped class as primary unique key. Subqueries and inner views can has no key properties. Interface IQueryStructureAdapter<T> is used in dynamic queries only. Interfaces IRepositoryStructureAdapter and IRepositoryStructureAdapter<T> is used in dynamic repository mapping only. Interface IPropertyMappingAdapter is used as in dynamic queries as in dynamic repository mapping. Interface IRepositoryPropertyMappingAdapter is inherited from [IPropertyMappingAdapter] and used in dynamic repository mapping only. SQL expression property Read only property can be mapped to SQL expression. Dynamic mapping of SQL expression is defined by one of IRepositoryStructureAdapter interface Expr method overload: Expr<TValue>(string fieldName, Expression<Func<IQueryStructureAdapter, TValue>> expr, DbType dbType, params Expression<Func<IRepositoryExpressionMappingAdapter, IStructureFlag>>[] attributes) Expr<TValue>(string fieldName, DataExpressionType type, string exprText, DbType dbType, params Expression<Func<IRepositoryExpressionMappingAdapter, IStructureFlag>>[] attributes) - used to define SQL expression DataExpressionType.SubQuery or DataExpressionType.PlainSql When first overload used, SQL expression is defined by expr parameter value as lambda function with IQueryStructureAdapter interface extension methods inside: Case<T, TResult>(this IQueryStructureAdapter adapter, Expression<Func<IQueryStructureAdapter, T>> expression, Expression<Func<IQueryStructureAdapter, TResult>> elseValue, params TaggedExpression<T, TResult>[] switchValues) - case when ... then ... else ... end SQL construction DateDiff<T>(this IQueryStructureAdapter adapter, Expression<Func<IQueryStructureAdapter, DateTime>> finalDate, Expression<Func<IQueryStructureAdapter, DateTime>> startDate, DateDiffKind kind) - date difference Exists(this IQueryStructureAdapter adapter, string subQueryAlias) - exists(select ...) SQL construction HasFlag<T>(this IQueryStructureAdapter adapter, Expression<Func<IQueryStructureAdapter, T>> expression, Expression<Func<IQueryStructureAdapter, T>> flagValue, Expression<Func<IQueryStructureAdapter, T>> trueValue, Expression<Func<IQueryStructureAdapter, T>> falseValue) - bitwise mask checking for value SqlExpr<TResult>(this IQueryStructureAdapter adapter, string format, params Expression<Func<IQueryStructureAdapter, object>>[] expressions) - mixing plain SQL expressions with LINQ style defined expression subparts, parameter format is the string.Format mask SqlFn<TResult>(this IQueryStructureAdapter adapter, string name, params Expression<Func<IQueryStructureAdapter, object>>[] parameters) - SQL function call expression SqlParam<TResult>(this IQueryStructureAdapter adapter, string binding, DbType type, params Expression<Func<IProcedureParameterAdapter, IProcedureParameterFlag>>[] attributes) - SQL function parameter value expression Mapping parameters of SQL expressions is defined by IRepositoryExpressionMappingAdapter interface methods: NativeSqlType(string nativeSqlType) - set native SQL type name of expression result, used when expression result type has specific SQL type Size(int size) - set number or varchar length of SQL expression result type Size(int size, int scale) - set length and scale for floating point SQL data types subquery, ... .ReadOnlyProperty(x => x.DocAmount, x => x.Expr<decimal?>(null, DataExpressionType.SubQuery, \"A\", DbType.Decimal, z => z.Size(17, 5))) ... LINQ expression, ... .ReadOnlyProperty(x => x.AllowedDiscount, x => x.Expr<int>(null, y => y.Case<Product, int>( z => z.Field<bool>(\"is_vip\"), z => 0, 1.SetExpression(z => 10)), DbType.Decimal, z => z.Size(17, 5))) ... plain text SQL expression. ... .ReadOnlyProperty(x => x.AllowedDiscount, x => x.Expr<int>(null, DataExpressionType.PlainSql, \"case P.is_vip when 1 then 10 else 0 end\", DbType.Decimal, z => z.Size(17, 5))) ... Important If possible do not use plain SQL expressions. It possibly use specific SQL dialect features not supported by other DBMS or providers. Property default value To set default value of property with dynamic mapping, use one of IRepositoryPropertyMappingAdapter<T, TValue> interface Default method overload: Default(DefaultType source) - use with DefaultType.AutoIncrement , DefaultType.CurrentDate , DefaultType.CurrentDateTime , DefaultType.CurrentDateTimeUtc , DefaultType.NewGuid , DefaultType.UserName where default value assigned data row on insert only Default(DefaultType source, DefaultFeature features) - use with DefaultType.AutoIncrement , DefaultType.CurrentDate , DefaultType.CurrentDateTime , DefaultType.CurrentDateTimeUtc , DefaultType.NewGuid , DefaultType.UserName where default value assigned data row on insert or update Default(DefaultType source, TValue value) - use with DefaultType.Const or DefaultType.Variable where default value assigned data row on insert only Default(DefaultType source, TValue value, DefaultFeature features) - use with DefaultType.Const or DefaultType.Variable where default value assigned data row on insert or update ... .ReadOnlyProperty(x => x.Changed, x => x.Field<DateTime>(\"D\", string.Empty, z => z.Default(DefaultType.CurrentDateTime, DefaultFeature.UseOnUpdate))) ... Property grouping parameters Property grouping parameters used when data object mapped to grouped query to specify property role in GROUP BY expression. Use one of IPropertyMappingAdapter interface Group method overload: Group(int groupOrder) - when property mapped to field query grouped by with N-th order Group(DataGrouping grouping) - when property mapped to aggregation function over field ... HistoryDate = x.Field<DateTime?>(\"H\", string.Empty, z => z.Group(DataGrouping.Max)) ... Hidden properties Hidden properties dynamically defined using Column method call of IRepositoryStructure<T> interface. Hidden property can be mapped to: data source field - Field<TVal> SQL expression (see detailed description above ) - Expr<TVal> inner view property (see detailed description below ) - Ref<TVal> ... .Column(\"DocId\", x => x.Field<long?>(\"D\", string.Empty, z => z.Key(), z => z.Default(DefaultType.AutoIncrement))) ... Inner view reference To map property to field from inner view used one of IRepositoryStructureAdapter interface Ref method overload: Ref<TValue>(string sourceAlias, string property, params Expression<Func<IRepositoryPropertyMappingAdapter, IStructureFlag>>[] attributes) - used when referenced property is a hidden property Ref<TValue, TDobj>(string sourceAlias, Expression<Func<TDobj, object>> property, params Expression<Func<IRepositoryPropertyMappingAdapter, IStructureFlag>>[] attributes) .ReadOnlyProperty(x => x.DocLastChange, x => x.Ref<DateTime?>(\"H\", \"HistoryDate\")) Links To dynamically define link property used one of IRepositoryStructureAdapter<T> interface Link method overload: Link<TValue, TSource> Link<TValue, TSource>(string sourceAlias, params Expression<Func<ILinkPropertyMappingAdapter<T>, IStructureFlag>>[] attributes) - used when source property is correlated with property name with default name mapping rule ( hungarian_notation in DB and CamelCaseNotation property name in code) Link<TValue, TSource> Link<TValue, TSource>(string sourceAlias, string fieldName, params Expression<Func<ILinkPropertyMappingAdapter<T>, IStructureFlag>>[] attributes) Parameter attributes of method Link value used to define link properties pairs with one of ILinkPropertyMappingAdapter<T> interface LinkProperties method overload call: LinkProperty() - used property of source object to associate with link property defined by Link method LinkProperty<TSource>(Expression<Func<TSource, object>> source) - used source as source property and equal named property from target object LinkProperty<TSource>(Expression<Func<TSource, object>> source, Expression<Func<T, object>> property) - specifying both properties ... DocState = x.Link<string, DocState>(\"S\", \"name\", z => z.LinkProperty<DocState>(y => y.Name), z => z.LinkProperty<DocState>(y => y.Code, y => y.DocStateCode) z => z.LinkProperty<DocState>( (Invoice y) => y.GetProperty<long>(\"DocStateId\"))), ... Tree To dynamically map tree organized data structure used special method With of RepositoryStructure<T> interface to describe tree root query and tree childs. Both of them use subquery mappings (see example below) to set subquery structure for tree query construction. Important Data source flags of tree organized data sources must contain DataStructureFlag.ReadOnly and DataStructureFlag.Tree! private static Expression<CustomMapping<CatalogueTree>> _unused = ( () => XDataMapping.CustomMapping<CatalogueTree>() .With(\"CAT\", XDataMapping.GetStructure(\"R\") .DataTable(\"T_CATALOGUE\", \"R\", x => x.Combination(\"root\", Combination.Or), x => x.ConstFilter(\"FilterByCathalogue\", \"catalogue_id\", FilterConstantType.Const, null, FilterNullable.NullsNotAllowed).SetCombination(\"root\"), x => x.ConstFilter(\"FilterByRoot\", \"parent_id\", FilterConstantType.Const, null, FilterNullable.NullsCompared) .SetCombination(\"root\")) .Select(x => new { CatalogueId = x.Field<long>(\"R\", string.Empty, z => z.Key()), Code = x.Field<string>(\"R\", string.Empty), Name = x.Field<string>(\"R\", string.Empty), ParentId = x.Field<long?>(\"R\", string.Empty), }), x => x.Properties(z => z.CatalogueId, z => z.Code, z => z.Name, z => z.ParentId), x => x.WithRecursive(\"S\", XDataMapping .GetStructure(\"S\") .DataTable(\"T_CATALOGUE\", \"S\") .Select(y => new { CatalogueId = y.Field<long>(\"S\", string.Empty, z => z.Key()), Code = y.Field<string>(\"S\", string.Empty), Name = y.Field<string>(\"S\", string.Empty), ParentId = y.Field<long?>(\"S\", string.Empty) }), z => z.SubqueryLink(y => y.ParentId, y => y.CatalogueId))) .ReadOnlyProperty(x => x.CatalogueId, x => x.Field<long>(\"CAT\", string.Empty, z => z.Key())) .ReadOnlyProperty(x => x.Code, x => x.Field<string>(\"CAT\", string.Empty)) .ReadOnlyProperty(x => x.Name, x => x.Field<string>(\"CAT\", string.Empty)) .ReadOnlyProperty(x => x.ParentId, x => x.Field<long?>(\"CAT\", string.Empty)) .Map() .SetFlags(DataStructureFlag.ReadOnly | DataStructureFlag.Tree) ); External link External link can be dynamically defined using expression of type Expression as part of call Map method of IRepositoryStructure interface. Expression<IExternalLinkDefinition> can be obtained using multiple overloads of ExternalLink method of ExternalLinkDefinitionAdapter<T> : IExternalLinkDefinition ExternalLink<TChild>(params Expression<Func<IExternalLinkAdapter<T, TChild>, IExternalLinkFlag>>[] linkFlags) IExternalLinkDefinition ExternalLink<TChild>(Expression<Func<T, object>> property, params Expression<Func<IExternalLinkAdapter<T, TChild>, IExternalLinkFlag>>[] linkFlags) IExternalLinkDefinition ExternalLink<TChild>(string property, params Expression<Func<IExternalLinkAdapter<T, TChild>, IExternalLinkFlag>>[] linkFlags) IExternalLinkAdapter<T, TChild> used to specify properties of external link: Filter - used to specify external link runtime filter, FilterCombination - used to set filter group of filter, DirectLink - used to set direct link flag, see tree master-detail specifics for details, MasterRefresh - used to set refresh master repository current row data on submit details changes flag (useful when master has calculated properties over detail repository data), Nullable - filter null processing behavior , Operation - link filter operation (see Filters ), PrimaryFilter - used to specify external link is optional filter, Property - link property in master repository (used when property is hidden property ), Property<TChildLink> - link property in master repository (used when property is actual property), TreeFilter - used to set external link filter's tree filter flag // when external link used hidden property ..., x => x.ExternalLink<InvoiceSpec>(\"DocId\")) // when external link used read-only or regular property ..., x => x.ExternalLink<InvoiceSpec>(z => z.DocId)) Variables The use of variables is described here . To describe the variables, special overloads of Subquery and InnerView methods are used. Variables are described in the variables parameter. .Subquery<DocPropertyValue>(\"PH\", x => x.GetProperty(\"ParamValue\"), DataGrouping.None, new[]{\"ParamCode\".SetVar(\"AUTHOR_PHONE\")}, /* variables */ x => x.SubqueryLink(\"DocId\")) SQL procedures & functions Common information about mapping to SQL procedures and functions described in common mapping rules description and here we just represent dynamic mapping rules for various procedure types. Warning SQLite not supported SQL procedures & functions Warning PostgreSql functions has restrictions: returning refcursor or set of refcursor requires transaction! parameters use lower case names ONLY! result set names (refcursor names) use lower case names ONLY! SQL procedure as query To define procedure as data source of mapping used Procedure method call of IRepositoryStructure<T> interface. SQL procedure parameter To define SQL procedure parameter used Parameter method call of IRepositoryStructure<T> interface. SQL procedure result set To describe result set of SQL procedure used Return method call of IRepositoryStructure<T> interface. * - when result set is not mapped to procedure parameter set result set name to string.Empty SQL procedure result set as query sample MS SQL Server CREATE PROCEDURE [dbo].[TestProcedure] ( @param1 int, @param2 varchar(20) ) AS SELECT @param1 as Id, @param2 as Name Oracle procedure TestProcedure(p_Id int, p_Name varchar2, p_Out out SYS_REFCURSOR) as begin open p_Out for select p_Id as Id, p_Name as Name from dual; end TestProcedure; PostgreSQL CREATE OR REPLACE FUNCTION public.TestProcedure (p_id integer, p_name varchar, refcursor) RETURNS refcursor AS $$ begin open $3 for select p_id as Id, p_name as Name; return $3; end $$ LANGUAGE plpgsql; MySQL create procedure TestProcedure(p_Id int, p_Name varchar(50)) begin select p_Id as Id, p_Name as Name; end Dynamic query Expression<Func<IQueryStructureAdapter, PostgreSqlClassifier>> convertor = x => new PostgreSqlClassifier { Id = x.Field<int>(z => z.Key()), Name = x.Field<string>() }; var res = XDataMapping.GetStructure(\"T\") .Procedure(\"T\", \"dbo.TestProcedure\", ProcedureType.Procedure) .Parameter<int>(\"T\", 1, \"param1\", DbType.Int32) .Parameter<string>(\"T\", 2, \"param2\", DbType.String) .Return(\"T\", string.Empty, 1, convertor) .Call<Classifier>(DataScope, string.Empty, \"param1\".SetVar(1), \"param2\".SetVar(\"Test\")); foreach (var classifier in res) Console.WriteLine(\"{0} - \\\"{1}\\\"\", classifier.Id, classifier.Name); Mapping ... .Procedure(\"T\", \"dbo.TestProcedure\", ProcedureType.Procedure) .Parameter<int>(\"T\", 1, \"param1\", DbType.Int32) .Parameter<string>(\"T\", 2, \"param2\", DbType.String) .Return(\"T\") .Map(x => new TestProcedure { Id = x.Field<int>(\"T\", string.Empty, z => z.Key()), Name = x.Field<string>(\"T\", string.Empty) }) .SetBaseTable(\"T\") ... SQL procedure with multiple result sets sample MS SQL Server CREATE PROCEDURE [dbo].[TestProcedure2] ( @param1 int, @param2 varchar(20), @param3 int, @param4 varchar(20) ) AS BEGIN SELECT @param1 as Id, @param2 as Name SELECT @param3 as Id, @param4 as Name END Oracle procedure TestProcedure2(p_Id int, p_Name varchar2, p_Out out SYS_REFCURSOR, p_Out2 out SYS_REFCURSOR) as begin open p_Out for select p_Id as Id, p_Name as Name from dual; open p_Out2 for select p_Id as Id, p_Name as Name from dual; end TestProcedure2; Tip Use refcursor parameters names as ResultSet names! PostgreSQL CREATE OR REPLACE FUNCTION public.TestProcedure2 (p_id integer, p_name varchar, refcursor, refcursor) RETURNS SETOF refcursor AS $$ begin open $3 for select p_id as Id, p_name as Name; return NEXT $3; open $4 for select p_id as Id, p_name as Name; return NEXT $4; end $$ LANGUAGE plpgsql; Warning Functions witch returns setof refcursor is not supported by NpgSql .Net Standard 2.0 Edition :( XData net4.0 version can call that type functions with the same mapping rules as described here... Tip If refcursor parameters have a names it must be used as ResultSet names! MySQL create procedure TestProcedure2(p_Id int, p_Name varchar(50)) begin select p_Id as Id, p_Name as Name; select p_Id as Id, p_Name as Name; end Dynamic query Expression<Func<IQueryStructureAdapter, PostgreSqlClassifier>> convertor = x => new PostgreSqlClassifier { Id = x.Field<int>(z => z.Key()), Name = x.Field<string>() }; var res2 = XDataMapping.GetStructure(\"T\") .Procedure(\"T\", \"dbo.TestProcedure2\", ProcedureType.Procedure) .Parameter<int>(\"T\", 1, \"param1\", DbType.Int32) .Parameter<string>(\"T\", 2, \"param2\", DbType.String) .Parameter<int>(\"T\", 3, \"param3\", DbType.Int32) .Parameter<string>(\"T\", 4, \"param4\", DbType.String) .Return(\"T\", \"Result1\", 1, convertor) .Return(\"T\", \"Result2\", 2, convertor) .Call<Classifier>(DataScope, \"Result1\", \"param1\".SetVar(1), \"param2\".SetVar(\"Test\"), \"param3\".SetVar(2), \"param4\".SetVar(\"Some\")); foreach (var classifier in res2) Console.WriteLine(\"{0} - \\\"{1}\\\"\", classifier.Id, classifier.Name); foreach (var classifier in res2.GetResultSet<Classifier>(\"Result2\")) Console.WriteLine(\"{0} - \\\"{1}\\\"\", classifier.Id, classifier.Name); Mapping ... .Procedure(\"T\", \"dbo.TestProcedure2\", ProcedureType.Procedure) .Parameter<int>(\"T\", 1, \"param1\", DbType.Int32) .Parameter<string>(\"T\", 2, \"param2\", DbType.String) .Parameter<int>(\"T\", 3, \"param3\", DbType.Int32) .Parameter<string>(\"T\", 4, \"param4\", DbType.String) .Return(\"T\") .Return(\"T\", \"Result2\", 2, x => new PostgreSqlClassifier { Id = x.Field<int>(z => z.Key()), Name = x.Field<string>() }) .Map(x => new TestProcedure2 { Id = x.Field<int>(\"T\", string.Empty, z => z.Key()), Name = x.Field<string>(\"T\", string.Empty) }) .SetBaseTable(\"T\") ... SQL procedure with out parameter sample MS SQL Server CREATE PROCEDURE [dbo].[TestProcedure3] ( @param1 int, @param2 varchar(20), @param3 varchar(20) OUTPUT ) AS SET @param3 = convert(varchar(20), @param1) + ' - ' + @param2 RETURN Oracle procedure TestProcedure3(p_Id int, p_Name varchar2, p_Out out varchar2) as begin select p_Id || ' - ' || p_Name into p_Out from dual; end TestProcedure3; PostgreSQL CREATE or REPLACE function TestProcedure3(p_id integer, p_name varchar, out p_out varchar) as $$ begin p_Out := p_id || ' - ' || p_name; end $$ LANGUAGE plpgsql; MySQL create procedure TestProcedure3(p_Id int, p_Name varchar(50), out p_Out varchar(100)) begin set p_Out = CONCAT(p_Id, ' - ', p_Name); end Dynamic query var res3 = XDataMapping.GetStructure(\"T\") .Procedure(\"T\", \"dbo.TestProcedure3\", ProcedureType.Procedure) .Parameter<int>(\"T\", 1, \"param1\", DbType.Int32) .Parameter<string>(\"T\", 2, \"param2\", DbType.String) .Parameter<string>(\"T\", 3, \"param3\", DbType.String, z => z.Size(20), z => z.Direction(ParameterDirection.Output)) .Call(DataScope.Layer, \"param1\".SetVar(1), \"param2\".SetVar(\"Test\")); Console.WriteLine(res3.GetParameter<string>(\"param3\")); Mapping ... .Procedure(\"T\", \"dbo.TestProcedure3\", ProcedureType.Procedure) .Parameter<int>(\"T\", 1, \"param1\", DbType.Int32) .Parameter<string>(\"T\", 2, \"param2\", DbType.String) .Parameter<string>(\"T\", 3, \"param3\", DbType.String, z => z.Size(20), z => z.Direction(ParameterDirection.Output)) .Map() .SetBaseTable(\"T\") ... SQL procedure with out parameter and result set sample MS SQL Server CREATE PROCEDURE [dbo].[TestProcedure4] ( @param1 int, @param2 varchar(20) ) AS SELECT @param1 as Id, @param2 as Name RETURN(@param1) Oracle procedure TestProcedure4(p_Tab in classifier_tab, p_Out out SYS_REFCURSOR) as begin open p_Out for select Id, Name from table(p_Tab); end TestProcedure4; Tip Use refcursor parameters names as ResultSet names! PostgreSQL CREATE OR REPLACE FUNCTION public.TestProcedure4 (p_tab public.classifier_rec [], refcursor) RETURNS refcursor AS $$ begin open $2 for select Id, Name from unnest(p_tab); return $2; end $$ LANGUAGE plpgsql; Tip If refcursor parameters have a names it must be used as ResultSet names! MySQL Not supported Dynamic query var res4 = XDataMapping.GetStructure(\"T\") .Procedure(\"T\", \"dbo.TestProcedure4\", ProcedureType.Procedure) .Parameter<int>(\"T\", 1, \"param1\", DbType.Int32) .Parameter<string>(\"T\", 2, \"param2\", DbType.String) .Parameter<int>(\"T\", 3, \"result\", DbType.Int32, z => z.Direction(ParameterDirection.ReturnValue)) .Return(\"T\", string.Empty, 1, x => new Classifier { Id = x.Field<int>(z => z.Key()), Name = x.Field<string>() }) .Call<Classifier>(DataScope, string.Empty, \"param1\".SetVar(1), \"param2\".SetVar(\"Test\")); Console.WriteLine(res4.GetParameter<int>(\"result\")); foreach (var classifier in res4) Console.WriteLine(\"{0} - \\\"{1}\\\"\", classifier.Id, classifier.Name); Mapping ... .Procedure(\"T\", \"dbo.TestProcedure4\", ProcedureType.Procedure) .Parameter<int>(\"T\", 1, \"param1\", DbType.Int32) .Parameter<string>(\"T\", 2, \"param2\", DbType.String) .Parameter<int>(\"T\", 3, \"result\", DbType.Int32, z => z.Direction(ParameterDirection.ReturnValue)) .Return(\"T\") .Map(x => new TestProcedure4 { Id = x.Field<int>(\"T\", string.Empty, z => z.Key()), Name = x.Field<string>(\"T\", string.Empty) }) .SetBaseTable(\"T\") SQL procedure with return value sample MS SQL Server CREATE PROCEDURE [dbo].[TestProcedure5] ( @param1 int, @param2 varchar(20) ) AS RETURN(@param1) Oracle Not supported PostgreSQL Not supported MySQL Not supported Dynamic query var res5 = XDataMapping.GetStructure(\"T\") .Procedure(\"T\", \"dbo.TestProcedure5\", ProcedureType.Procedure) .Parameter<int>(\"T\", 1, \"param1\", DbType.Int32) .Parameter<string>(\"T\", 2, \"param2\", DbType.String) .Parameter<int>(\"T\", 3, \"result\", DbType.Int32, z => z.Direction(ParameterDirection.ReturnValue)) .Call<Classifier>(DataScope.Layer, string.Empty, \"param1\".SetVar(1), \"param2\".SetVar(\"Test\")); Console.WriteLine(res5.GetParameter<int>(\"result\")); Mapping ... .Procedure(\"T\", \"dbo.TestProcedure5\", ProcedureType.Procedure) .Parameter<int>(\"T\", 1, \"param1\", DbType.Int32) .Parameter<string>(\"T\", 2, \"param2\", DbType.String) .Parameter<int>(\"T\", 3, \"result\", DbType.Int32, z => z.Direction(ParameterDirection.ReturnValue)) .Map() .SetBaseTable(\"T\") ... public int ResultParameter { get { return this.GetParameter<int>(\"result\"); } } SQL procedure with return value and result set sample MS SQL Server MS SQL Server CREATE PROCEDURE [dbo].[TestProcedure6] ( @param1 int, @param2 varchar(20) ) AS SELECT @param1 as Id, @param2 as Name RETURN(@param1) Oracle Not supported PostgreSQL Not supported MySQL Not supported Dynamic query var res6 = XDataMapping.GetStructure(\"T\") .Procedure(\"T\", \"dbo.TestProcedure6\", ProcedureType.Procedure) .Parameter<int>(\"T\", 1, \"param1\", DbType.Int32) .Parameter<string>(\"T\", 2, \"param2\", DbType.String) .Parameter<int>(\"T\", 3, \"result\", DbType.Int32, z => z.Direction(ParameterDirection.ReturnValue)) .Return(\"T\", string.Empty, 1, x => new Classifier { Id = x.Field<int>(z => z.Key()), Name = x.Field<string>() }) .Call<Classifier>(DataScope.Layer, string.Empty, \"param1\".SetVar(param)); foreach (var classifier in res6) Console.WriteLine(\"{0} - \\\"{1}\\\"\", classifier.Id, classifier.Name); Mapping ... .Procedure(\"T\", \"dbo.TestProcedure6\", ProcedureType.Procedure) .Parameter<int>(\"T\", 1, \"param1\", DbType.Int32) .Parameter<string>(\"T\", 2, \"param2\", DbType.String) .Parameter<int>(\"T\", 3, \"result\", DbType.Int32, z => z.Direction(ParameterDirection.ReturnValue)) .Return(\"T\") .Map(x => new TestProcedure6 { Id = x.Field<int>(\"T\", string.Empty, z => z.Key()), Name = x.Field<string>(\"T\", string.Empty) }) .SetBaseTable(\"T\") ... public int ResultParameter { get { return this.GetParameter(x => x.ResultParameter); } } SQL procedure with simple array parameter sample MS SQL Server Not supported Oracle Not supported PostgreSQL CREATE or REPLACE function TestFunction6(p_arr INTEGER[]) returns integer as $$ begin return sum(s) from unnest(p_arr) s; end $$ LANGUAGE plpgsql; MySQL Not supported Dynamic query var arr = new[] { 1, 2, 3 }; var f6 = XDataMapping.GetStructure(\"T\") .Procedure(\"T\", \"TestFunction6\", ProcedureType.Function) .Parameter<int[]>(\"T\", 1, \"p_arr\", DbType.Int32, z => z.Array()) .Parameter<int>(\"T\", 2, \"result\", DbType.Int32, z => z.Direction(ParameterDirection.ReturnValue)) .Call(DataScope, \"p_arr\".SetVar(arr)); Console.WriteLine(f6.GetParameter<int>(\"result\")); Mapping ... .Procedure(\"T\", \"TestFunction6\", ProcedureType.Function) .Parameter<int[]>(\"T\", 1, \"p_arr\", DbType.Int32, z => z.Array()) .Parameter<int>(\"T\", 2, \"result\", DbType.Int32, z => z.Direction(ParameterDirection.ReturnValue)) ... SQL procedure with UDT parameter sample MS SQL Server Not supported Tip MS SQL Server does not support passing single UDT object as a parameter value, but support array of UDT Oracle Not supported Warning Oracle ODP.Net provider does not support UDT PostgreSQL CREATE TYPE public.classifier_rec AS ( Id integer, Name varchar(20) ); CREATE or REPLACE function TestFunction5(p_obj classifier_rec) returns varchar as $$ begin return p_obj.Id || ' - ' || p_obj.Name; end $$ LANGUAGE plpgsql; MySQL Not supported Dynamic query /* Type mapped to UDT required to be Xml serializable */ [Serializable] public class Classifier { [XmlAttribute] public int Id { get; set; } [XmlAttribute] public string Name { get; set; } } ... var f5 = XDataMapping.GetStructure(\"T\") .Procedure(\"T\", \"TestFunction5\", ProcedureType.Function) .Parameter<Classifier>(\"T\", 1, \"p_obj\", DbType.Object, z => z.UdtDataType(\"classifier_rec\")) .Parameter<string>(\"T\", 3, \"result\", DbType.String, z => z.Size(20), z => z.Direction(ParameterDirection.ReturnValue)) .Call(DataScope, \"p_obj\".SetVar( new Classifier { Id = 1, Name = \"Test\" })); Console.WriteLine(f5.GetParameter<string>(\"result\")); Mapping /* Type mapped to UDT required to be Xml serializable */ [Serializable] public class Classifier { [XmlAttribute] public int Id { get; set; } [XmlAttribute] public string Name { get; set; } } ... .Procedure(\"T\", \"TestFunction5\", ProcedureType.Function) .Parameter<Classifier>(\"T\", 1, \"p_obj\", DbType.Object, z => z.UdtDataType(\"classifier_rec\")) .Parameter<string>(\"T\", 3, \"result\", DbType.String, z => z.Size(20), z => z.Direction(ParameterDirection.ReturnValue)) .Map() .SetBaseTable(\"T\") ... public class TestFunction5 : IDataObject { public string Result => this.GetParameter(x => x.Result); } SQL procedure with UDT array parameter sample MS SQL Server CREATE TYPE [dbo].[Classifier] AS TABLE( [Id] [int] NULL, [Name] [varchar](20) NULL ) CREATE PROCEDURE [dbo].[TestProcedure7] (@param1 Classifier READONLY) AS SELECT * from @param1 Oracle Not supported Warning Oracle ODP.Net provider does not support UDT PostgreSQL CREATE TYPE public.classifier_rec AS ( Id integer, Name varchar(20) ); CREATE or REPLACE function TestProcedure7(p_tab classifier_rec[]) returns setof classifier_rec as $$ select a.Id, a.Name from unnest(p_tab) a; $$ LANGUAGE sql; MySQL Not supported Dynamic query /* Type mapped to UDT required to be Xml serializable */ [Serializable] public class Classifier { [XmlAttribute] public int Id { get; set; } [XmlAttribute] public string Name { get; set; } } ... var param = new[] { new Classifier { Id = 1, Name = \"Test\" }, new Classifier { Id = 2, Name = \"Some\" } }; var f4 = XDataMapping.GetStructure(\"T\") .Procedure(\"T\", \"dbo.TestProcedure7\", ProcedureType.Procedure) .Parameter<Classifier[]>(\"T\", 1, \"param1\", DbType.Object, z => z.UdtDataType(null, \"dbo.Classifier\")) .Return(\"T\") .Call(DataScope, string.Empty, \"param1\".SetVar(param)); foreach (var classifier in res) Console.WriteLine(\"{0} - \\\"{1}\\\"\", classifier.Id, classifier.Name); Mapping /* Type mapped to UDT required to be Xml serializable */ [Serializable] public class Classifier { [XmlAttribute] public int Id { get; set; } [XmlAttribute] public string Name { get; set; } } ... .Procedure(\"T\", \"dbo.TestProcedure7\", ProcedureType.Procedure) .Parameter<Classifier[]>(\"T\", 1, \"param1\", DbType.Object, z => z.UdtDataType(null, \"dbo.Classifier\")) .Return(\"T\") .Map(x => new TestProcedure { Id = x.Field<int>(\"T\", string.Empty, z => z.Key()), Name = x.Field<string>(\"T\", string.Empty) }) .SetBaseTable(\"T\") SQL table valued function as query sample MS SQL Server CREATE FUNCTION [dbo].[TestFunction] ( @param1 int, @param2 varchar(20) ) RETURNS TABLE AS RETURN ( SELECT @param1 as Id, @param2 as Name ) Oracle CREATE OR REPLACE type classifier_rec is object (Id int, Name varchar2(20)); CREATE OR REPLACE type classifier_tab is table of classifier_rec; function TestFunction(p_Id int, p_Name varchar2) return classifier_tab pipelined is begin for curr in (select p_Id as Id, p_Name as Name from dual) loop pipe row (classifier_rec(curr.Id, curr.Name)); end loop; end TestFunction; PostgreSQL CREATE or REPLACE function TestFunction(p_id integer, p_name varchar) returns TABLE ( Id bigint, Name varchar ) as $$ select p_id as Id, p_name as Name; $$ LANGUAGE SQL; ... or with the same mapping syntax... CREATE TYPE public.classifier_rec AS ( Id integer, Name varchar(20) ); CREATE or REPLACE function TestFunction(p_Id integer, p_Name varchar) returns setof classifier_rec as $$ select p_Id as Id, p_Name as Name; $$ LANGUAGE SQL; MySQL Not supported Dynamic query var f3 = XDataMapping.GetStructure() .Procedure(\"T\", \"dbo.TestFunction\", ProcedureType.Function) .Parameter<int>(\"T\", 1, \"param1\", DbType.Int32) .Parameter<string>(\"T\", 2, \"param2\", DbType.String) .Return(\"T\") .Select(x => new Classifier { Id = x.Field<int>(\"T\", \"Id\", z => z.Key()), Name = x.Field<string>(\"T\", \"Name\") }) .AsQuery(DataScope, \"param1\".SetVar(param)); foreach (var classifier in f3) Console.WriteLine(\"{0} - \\\"{1}\\\"\", classifier.Id, classifier.Name); Dynamic query table function with joined table var f1Join = XDataMapping.GetStructure() .DataTable(\"T_DOC_TYPE\", \"D\") .Procedure(\"T\", \"dbo.TestFunction\", ProcedureType.Function, z => z.Link(\"D\", \"doc_type_id\", \"Id\")) .Parameter<int>(\"T\", 1, \"param1\", DbType.Int32) .Parameter<string>(\"T\", 2, \"param2\", DbType.String) .Return(\"T\") .Select(x => new { Id = x.Field<int>(\"T\", \"Id\", z => z.Key()), Name = x.Field<string>(\"T\", \"Name\"), Code = x.Field<string>(\"D\", string.Empty) }) .AsQuery(DataScope, \"param1\".SetVar(1), \"param2\".SetVar(\"Test\")); foreach (var res in f1Join) Console.WriteLine(\"{0} - \\\"{1}\\\" - \\\"{2}\\\"\", res.Id, res.Name, res.Code); Mapping ... .Procedure(\"T\", \"dbo.TestFunction\", ProcedureType.Function) .Parameter<int>(\"T\", 1, \"param1\", DbType.Int32) .Parameter<string>(\"T\", 2, \"param2\", DbType.String) .Return(\"T\") .Map(x => new TestFunction { Id = x.Field<int>(\"T\", \"Id\", z => z.Key()), Name = x.Field<string>(\"T\", \"Name\") }) .SetBaseTable(\"T\") Mapping table function with joined table .DataTable(\"T_DOC_TYPE\", \"D\") .Procedure(\"T\", \"dbo.TestFunction\", ProcedureType.Function, z => z.Link(\"D\", \"doc_type_id\", \"Id\")) .Parameter<int>(\"T\", 1, \"param1\", DbType.Int32) .Parameter<string>(\"T\", 2, \"param2\", DbType.String) .Return(\"T\") .Map(x => new TestFunctionJoin { Id = x.Field<int>(\"T\", \"Id\", z => z.Key()), Name = x.Field<string>(\"T\", \"Name\"), Code = x.Field<string>(\"D\", string.Empty) }) .SetBaseTable(\"D\") SQL scalar function as property data source sample MS SQL Server CREATE FUNCTION [dbo].[TestFunction2] ( @param1 int, @param2 varchar(20) ) RETURNS varchar(20) AS BEGIN DECLARE @res varchar(20) SET @res = convert(varchar(20), @param1) + ' - ' + @param2 RETURN @res END Oracle function TestFunction2(p_Id int, p_Name varchar2) return varchar2 is begin return p_Id || ' - ' || p_Name; end TestFunction2; PostgreSQL CREATE or REPLACE function TestFunction2(p_id integer, p_name varchar) returns varchar as $$ DECLARE ret varchar; begin select p_id || ' - ' || p_name into ret; return ret; end $$ LANGUAGE plpgsql; MySQL create function TestFunction2(p_Id int, p_Name varchar(20)) returns varchar(100) begin declare res varchar(100); select CONCAT(p_Id, ' - ', p_Name) into res; return(res); end Mapping var t1 = XDataMapping.GetStructure(\"T\") .DataTable(\"T_DOC_TYPE\", \"T\").Select(x => new { DocTypeId = x.Field<long>(\"T\", \"doc_type_id\", z => z.Key()), Code = x.Field<string>(\"T\", \"code\"), Name = x.Field<string>(\"T\", \"name\"), Test = x.Expr(\"test\", z => z.SqlFn<string>(\"dbo.TestFunction2\", y => y.Field<long>(\"T\", \"doc_type_id\"), y => y.Field<string>(\"T\", \"name\")), DbType.String, z => z.Size(20)) }).AsQuery(DataScope); foreach (var z in t1) Console.WriteLine(\"{0} - \\\"{1}\\\" - \\\"{2}\\\" - \\\"{3}\\\"\", z.DocTypeId, z.Code, z.Name, z.Test);"
  },
  "tutorial/mapping/dynamic/datatable.html": {
    "href": "tutorial/mapping/dynamic/datatable.html",
    "title": "Tables | XData website",
    "keywords": "Tables All tables of data object mapping described by IRepositoryStructure<T>. DataTable method. Tables included into updatable tables hierarchy excluding base table must be defined using special overload allows to set parent table alias. ... .DataTable(\"T_DOC\", \"D\", x => x.DictFilter(\"T_DOC_TYPE\", \"doc_type_id\", \"code\", \"INVOICE\")) .DataTable(\"T_DOC_DOC_STATE\", \"DS\", \"D\", x => x.Link(\"D\", \"doc_id\")) ... Same way is possible to define mapping to view , but all properties must to mapped as read only properties or hidden fields . Important Filters and links between tables is defined using filters parameter of IRepositoryStructure<T>. DataTable method or it's overload . Detailed filter definition described below ."
  },
  "tutorial/mapping/xml_type.html": {
    "href": "tutorial/mapping/xml_type.html",
    "title": "Xml properties | XData website",
    "keywords": "Xml properties To work with Xml using lazy coupling XData represent property type Xml . This type has followed... properties: XDocument Document - get or set Xml value (read-only) bool Assigned - check Xml field for NULL value methods: Extract (string path, params KeyValuePair<string, string>[] namespaces) - returning result of XPath expression path using namespaces (pair: namespace - URL) (extension) Modify (Action action) - helper method to change Xml value operations: += - \"syntax sugar\", _data.SomeXml += _someVariable identical with _data.SomeXml.Document = _someVariable. Example: newInvoice.Source += new XDocument(new XElement(\"invoice\", new XAttribute(\"number\", number), new XAttribute(\"state\", newInvoice.DocStateCode))); ... dataScope.GetRepository<Invoice>(Owner, context: Context) .First(x => x.Source.Extract(\"(/invoice/@state)[1]\") == \"ACTIVE\").DocNumb ... invoice.Source.Modify(x => x = new XDocument());"
  },
  "quick_start/asp_net_core/first_mapping.html": {
    "href": "quick_start/asp_net_core/first_mapping.html",
    "title": "First mapping | XData website",
    "keywords": "First mapping 1) Add table T_DOC_STATE to database... <!--MD5=[4efa0cfa5e1d38a4afda4e219b98680a] class t_doc_state--> t_doc_state doc_state_id code name <!--MD5=[177ee83b98d3d3cbeb24134116cfa8c5] @startuml hide circle skinparam ClassHeaderBackgroundColor lightgray skinparam ClassBorderColor black skinparam ClassBorderThickness 1 skinparam ClassBackgroundColor transparrent skinparam ArrowFontSize 8 skinparam ArrowColor black entity t_doc_state { <&key> doc_state_id - - <&code> code name } @enduml PlantUML version 1.2020.12(Sat Jun 06 10:54:15 UTC 2020) (GPL source distribution) Java Runtime: Java(TM) SE Runtime Environment JVM: Java HotSpot(TM) 64-Bit Server VM Default Encoding: UTF-8 Language: en Country: US --> 2) Add Model class DocState.cs in a Models folder... using XData; namespace <..Your namespace..>.Models { public partial class DocState { public long DocStateId => this.GetProperty(x => x.DocStateId); public string Code { get; set; } public string Name { get; set; } } } Tip The class is marked as partial because mapping will be added to another part of its description. It's comfortable. Tip Notice that the id field is marked as read-only. Note also that when using the XData, this DTO mapping is not required (absolutely!!! See documentation topic for more details). This allows you to more correctly use the model classes and more closely match the ideology of DDD . Note Errors and warnings may occur before adding mapping. Ignore them. While we will not describe the GetProperty method, we will return to it later 3) Add class DocState.xdata.cs in a Models folder and define mapping... using System.Linq.Expressions; using XData; using XData.Mapping.Dynamic; namespace <..Your namespace..>.Models { public partial class DocState : IDataObject { private static Expression<CustomMapping<DocState>> _ = () => XDataMapping.CustomMapping<DocState>() .DataTable(\"T_DOC_STATE\", \"S\") .ReadOnlyProperty(x => x.DocStateId, x => x.Field<long>(\"S\", string.Empty, z => z.Key(), z => z.Default(DefaultType.AutoIncrement))) .Map(x => new DocState { Code = x.Field<string>(\"S\", string.Empty), Name = x.Field<string>(\"S\", string.Empty) }).SetBaseTable(\"S\"); } } 4) Now errors have been gone... Let's look at the mapping structure... 5) The table is described by the DataTable method. The table name and the alias of the data source are passed as parameters. The alias of the data source will also be used as the alias of the table in the final SQL. See documentation topic for more details 6) Description of the read-only property is done using the ReadOnlyProperty method. The description of the DocStateId property and its mapping described by the Field method are transmitted to it. See documentation topic for more details Field method parameters: The data source alias string.Empty is passed as the field name because the field name corresponds to the default conversion of the property name a set of mapping modifiers: attribute of the key field of the data object Key default value generation method Default (the auto-increment database value is used here DefaultType.AutoIncrement ) 7) Mapping the usual properties available for both reading and writing is described by the Map method. Mapping of each field is described using the familiar Field method. See documentation topic for more details 8) The mapping is completed by the SetBaseTable method, which determines the base table of the data object by the alias of the data source. See documentation topic for more details 9) We return to the description of the structure of the object itself and to the GetProperty method with which we get the DocStateId read-only property value. See documentation topic for more details"
  },
  "api/XData.InitObject-1.html": {
    "href": "api/XData.InitObject-1.html",
    "title": "Delegate InitObject<T> | XData website",
    "keywords": "Delegate InitObject<T> Object instance initialization delegate type Namespace : XData Assembly : XData.docfx.dll Syntax public delegate void InitObject<T>(ref T obj) where T : class, IDataObject; Parameters Type Name Description T obj Object instance Type Parameters Name Description T Object type Extension Methods SerializationExtensions.ToXml<T>(T) CollectionsExtensions.SetValue<TKey, T>(TKey, T) CollectionsExtensions.AsEnum<T>(T) DataObjectQueryableExtensions.CompareVariable(Object, FilterOperation, String) Processing.Do<T>(T, Action<IProcess<T>>[]) TypeExtensions.TryConvert<T, TResult>(T, Func<T, TResult>) TypeExtensions.TryConvert<T, TResult>(T, Func<T, TResult>, TResult) TypeExtensions.ChangeType<T>(Object) TypeExtensions.ChangeType(Object, Type) TypeExtensions.InvokeMethod<TRet>(Object, Type[], Expression<Func<TRet>>, BindingFlags) TypeExtensions.InvokeMethod(Object, Type[], Expression<Action>, BindingFlags) TypeExtensions.InvokeMethod<TRet>(Object, Expression<Func<TRet>>, BindingFlags) TypeExtensions.InvokeMethod(Object, Expression<Action>, BindingFlags) SqlBlockExtensions.SetExpression<TTag, TResult>(TTag, Expression<Func<IBlockQueryAdapter, TResult>>) QueryDescriptionExtensions.SetExpression<TTag, TResult>(TTag, Expression<Func<IQueryStructureAdapter, TResult>>) See Also InitObject OnInitObject"
  },
  "api/XData.Combination.html": {
    "href": "api/XData.Combination.html",
    "title": "Enum Combination | XData website",
    "keywords": "Enum Combination Filter combination logical composition Namespace : XData Assembly : XData.docfx.dll Syntax [DataContract] public enum Combination Fields Name Description And AND Or OR See Also Combination And Or Extension Methods SerializationExtensions.ToXml<Combination>() CollectionsExtensions.SetValue<Combination, T>(T) CollectionsExtensions.AsEnum<Combination>() DataObjectQueryableExtensions.CompareVariable(FilterOperation, String) Processing.Do<Combination>(Action<IProcess<Combination>>[]) TypeExtensions.ChangeType<T>() TypeExtensions.ChangeType(Type) TypeExtensions.InvokeMethod<TRet>(Type[], Expression<Func<TRet>>, BindingFlags) TypeExtensions.InvokeMethod(Type[], Expression<Action>, BindingFlags) TypeExtensions.InvokeMethod<TRet>(Expression<Func<TRet>>, BindingFlags) TypeExtensions.InvokeMethod(Expression<Action>, BindingFlags) TypeExtensions.ConvertTo<T>() TypeExtensions.EqualValue(Enum) SqlBlockExtensions.SetExpression<Combination, TResult>(Expression<Func<IBlockQueryAdapter, TResult>>) QueryDescriptionExtensions.SetExpression<Combination, TResult>(Expression<Func<IQueryStructureAdapter, TResult>>)"
  },
  "api/XData.IDataQuery.html": {
    "href": "api/XData.IDataQuery.html",
    "title": "Interface IDataQuery | XData website",
    "keywords": "Interface IDataQuery Read only data source basic interface Inherited Members IQueryable.ElementType IQueryable.Expression IQueryable.Provider IEnumerable.GetEnumerator() IDisposable.Dispose() Namespace : XData Assembly : XData.docfx.dll Syntax public interface IDataQuery : IOrderedQueryable, IQueryable, IEnumerable, IDisposable Properties | Improve this Doc View Source Alias Data repository alias Declaration string Alias { get; } Property Value Type Description String Remarks Default value is data object type name | Improve this Doc View Source Context Data context Declaration string Context { get; } Property Value Type Description String | Improve this Doc View Source Keys Data query/repository key properties Declaration string[] Keys { get; } Property Value Type Description String [] | Improve this Doc View Source Layer Data repository layer Declaration Guid Layer { get; } Property Value Type Description Guid Remarks Sharing same layer the data object repositories can interact automatically as parent/child (see ExternalLinkAttribute ) Repositories on different layers but same data object are independent for each other Repositories on same layer based on same data object is the same repository | Improve this Doc View Source Token Cancellation token Declaration CancellationToken Token { get; } Property Value Type Description CancellationToken | Improve this Doc View Source Variables Data query/repository/call result variables Declaration VariableIndexer Variables { get; } Property Value Type Description VariableIndexer Remarks Variable values can be used to set the filter values (query/repository) Variable values can be used in custom logic (repository) Variables is stored in query/repository/call result instance Examples var rep = dataScope.GetRepository<Customer>(variables: new []{\"OurCode\", \"SELF\"}); var newInvoice = dataScope.GetRepository<Invoice>().New(); newInvoice.CustomerFrom += rep.First(x => x.Code.CompareVariable(FilterOperation.Equal, \"SELF\")); See Also Variable GetRepository<T>(String, ISecuritySession, Variable[]) XData.DataObjectExtensions.CompareVariable(XData.IDataQueryInternal,System.Object,XData.FilterOperation,System.String) Extension Methods DataObjectExtensions.GetParameter<T>(IDataQuery, String) DataObjectExtensions.GetResultSet<TRes>(IDataQuery, String) DataObjectExtensions.GetResultSet<TRes>(IDataQuery, Expression<Func<IEnumerable<TRes>>>) SerializationExtensions.ToXml<T>(T) AsyncExtensions.GetParameterAsync<T>(IDataQuery, String) AsyncExtensions.GetResultSetAsync<TRes>(IDataQuery, String) AsyncExtensions.GetResultSetAsync<TRes>(IDataQuery, Expression<Func<IEnumerable<TRes>>>) CollectionsExtensions.SetValue<TKey, T>(TKey, T) CollectionsExtensions.AsEnum<T>(T) DataObjectQueryableExtensions.CompareVariable(Object, FilterOperation, String) Processing.Do<T>(T, Action<IProcess<T>>[]) TypeExtensions.TryConvert<T, TResult>(T, Func<T, TResult>) TypeExtensions.TryConvert<T, TResult>(T, Func<T, TResult>, TResult) TypeExtensions.ChangeType<T>(Object) TypeExtensions.ChangeType(Object, Type) TypeExtensions.InvokeMethod<TRet>(Object, Type[], Expression<Func<TRet>>, BindingFlags) TypeExtensions.InvokeMethod(Object, Type[], Expression<Action>, BindingFlags) TypeExtensions.InvokeMethod<TRet>(Object, Expression<Func<TRet>>, BindingFlags) TypeExtensions.InvokeMethod(Object, Expression<Action>, BindingFlags) SqlBlockExtensions.SetExpression<TTag, TResult>(TTag, Expression<Func<IBlockQueryAdapter, TResult>>) QueryDescriptionExtensions.SetExpression<TTag, TResult>(TTag, Expression<Func<IQueryStructureAdapter, TResult>>)"
  },
  "api/XData.Extensions.TypeExtensions.DummyType.html": {
    "href": "api/XData.Extensions.TypeExtensions.DummyType.html",
    "title": "Class TypeExtensions.DummyType | XData website",
    "keywords": "Class TypeExtensions.DummyType Inheritance Object TypeExtensions.DummyType Implements IDataObject ISqlObject Inherited Members Object.Equals(Object) Object.Equals(Object, Object) Object.GetHashCode() Object.GetType() Object.MemberwiseClone() Object.ReferenceEquals(Object, Object) Object.ToString() Namespace : XData.Extensions Assembly : XData.docfx.dll Syntax public sealed class DummyType : IDataObject, ISqlObject Implements IDataObject ISqlObject Extension Methods DataObjectExtensions.Modify<T>(T, Action<T>[]) DataObjectExtensions.GetProperties<T>(T, IEnumerable<String>, DataVersion) DataObjectExtensions.GetProperties<T>(T, String[]) DataObjectExtensions.Refresh<T>(T) DataObjectExtensions.Execute<T>(T, String, IDictionary<String, Action<Byte[]>>, IDictionary<String, Func<Byte[], Byte[]>>) DataObjectExtensions.Execute<T>(T, Expression<Func<CustomLogic<T>>>, IDictionary<String, Action<Byte[]>>, IDictionary<String, Func<Byte[], Byte[]>>) DataObjectExtensions.PostData<T>(T, String, Func<Byte[]>) DataObjectExtensions.Callback<T>(T, String, ref Byte[]) DataObjectExtensions.GetProperties<T>(T, DataVersion, String[]) DataObjectExtensions.IsCleared<T>(T, String) DataObjectExtensions.IsChanged<T>(T, String) DataObjectExtensions.IsChanged<T>(T, Expression<Func<T, Object>>[]) DataObjectExtensions.IsEmpty<T>(T, String) DataObjectExtensions.IsEmpty<T>(T, Expression<Func<T, Object>>) DataObjectExtensions.Submit<T>(T, out T, DataSubmitFlag) DataObjectExtensions.Submit<T>(T, Func<JsonSettings<T>, JsonSettings<T>>, out T, DataSubmitFlag) DataObjectExtensions.Submit<T>(T, DataSubmitFlag) DataObjectExtensions.Lock<T>(T) DataObjectExtensions.SetCurrent<T>(T) DataObjectExtensions.GetProperty<TRet>(IDataObject, String) DataObjectExtensions.GetContext(IDataObject) DataObjectExtensions.GetLayer(IDataObject) DataObjectExtensions.GetRepositoryAlias(IDataObject) DataObjectExtensions.GetProperty<T, TRet>(T, Expression<Func<T, TRet>>) DataObjectExtensions.GetProperty<T, TRet>(T, Expression<Func<T, TRet>>, DataVersion) DataObjectExtensions.AssignProperty<T, TValue>(T, String, TValue) DataObjectExtensions.Copy<T>(T, T, String[]) DataObjectExtensions.Copy<T>(T, T, ApplyFlag, String[]) DataObjectExtensions.LoadLob<T>(T, Expression<Func<T, Object>>[]) DataObjectExtensions.LoadLob<T>(T) DataObjectExtensions.LoadLob<T>(T, String[]) DataObjectExtensions.WithJsonSettings<T>(T, Func<JsonSettings<T>, JsonSettings<T>>) DataObjectExtensions.GetParameter<T, TRet>(T, String) DataObjectExtensions.GetParameter<T, TRet>(T, Expression<Func<T, TRet>>) DataObjectExtensions.GetResultSet<T, TRes>(T, Expression<Func<T, IEnumerable<TRes>>>) DataObjectExtensions.GetRepository<T>(T) DataObjectExtensions.SetAttachedHandlers<T>(T, AttachedHandler<T>[]) DataObjectExtensions.IsAttached(IDataObject, Type) DataObjectExtensions.GetState<T>(T) DataObjectExtensions.CheckState<T>(T, DataObjectState) DataObjectExtensions.SetDeleted<T>(T, Boolean) SerializationExtensions.ToXml<T>(T) SerializationExtensions.Serialize<T>(T) SerializationExtensions.Restore<T>(T, SerializedData) AsyncExtensions.ExecuteAsync<T>(T, Expression<Func<CustomLogic<T>>>, IDictionary<String, Action<Byte[]>>, IDictionary<String, Func<Byte[], Byte[]>>) AsyncExtensions.ExecuteAsync<T>(T, Expression<Func<CustomLogic<T>>>, IDictionary<String, Action<Byte[]>>) AsyncExtensions.ExecuteAsync<T>(T, Expression<Func<CustomLogic<T>>>, IDictionary<String, Func<Byte[], Byte[]>>) AsyncExtensions.ExecuteAsync<T>(T, String, IDictionary<String, Action<Byte[]>>, IDictionary<String, Func<Byte[], Byte[]>>) AsyncExtensions.ExecuteAsync<T>(T, String, IDictionary<String, Action<Byte[]>>) AsyncExtensions.ExecuteAsync<T>(T, String, IDictionary<String, Func<Byte[], Byte[]>>) AsyncExtensions.GetParameterAsync<T, TRet>(T, Expression<Func<T, TRet>>) AsyncExtensions.GetParameterAsync<T, TRet>(T, String) AsyncExtensions.GetResultSetAsync<T, TRes>(T, Expression<Func<T, IEnumerable<TRes>>>) AsyncExtensions.SubmitAsync<T>(T, DataSubmitFlag) AsyncExtensions.SubmitAndReturnAsync<T>(T, DataSubmitFlag) AsyncExtensions.SubmitAndReturnAsync<T>(T, Func<JsonSettings<T>, JsonSettings<T>>, DataSubmitFlag) AsyncExtensions.LoadLobAsync<T>(T) AsyncExtensions.LoadLobAsync<T>(T, String[]) AsyncExtensions.LoadLobAsync<T>(T, Expression<Func<T, Object>>[]) CollectionsExtensions.SetValue<TKey, T>(TKey, T) CollectionsExtensions.AsEnum<T>(T) DataObjectQueryableExtensions.CompareVariable(Object, FilterOperation, String) Processing.Do<T>(T, Action<IProcess<T>>[]) TypeExtensions.TryConvert<T, TResult>(T, Func<T, TResult>) TypeExtensions.TryConvert<T, TResult>(T, Func<T, TResult>, TResult) TypeExtensions.ChangeType<T>(Object) TypeExtensions.ChangeType(Object, Type) TypeExtensions.InvokeMethod<TRet>(Object, Type[], Expression<Func<TRet>>, BindingFlags) TypeExtensions.InvokeMethod(Object, Type[], Expression<Action>, BindingFlags) TypeExtensions.InvokeMethod<TRet>(Object, Expression<Func<TRet>>, BindingFlags) TypeExtensions.InvokeMethod(Object, Expression<Action>, BindingFlags) SqlBlockExtensions.SetExpression<TTag, TResult>(TTag, Expression<Func<IBlockQueryAdapter, TResult>>) QueryDescriptionExtensions.SetExpression<TTag, TResult>(TTag, Expression<Func<IQueryStructureAdapter, TResult>>) QueryDescriptionExtensions.GetProperty(ISqlObject, String)"
  },
  "api/XData.Extensions.TypeComparer.html": {
    "href": "api/XData.Extensions.TypeComparer.html",
    "title": "Class TypeComparer | XData website",
    "keywords": "Class TypeComparer Type equality comparer Inheritance Object TypeComparer Implements IEqualityComparer < Type > Inherited Members Object.Equals(Object) Object.Equals(Object, Object) Object.GetHashCode() Object.GetType() Object.MemberwiseClone() Object.ReferenceEquals(Object, Object) Object.ToString() Namespace : XData.Extensions Assembly : XData.docfx.dll Syntax public class TypeComparer : IEqualityComparer<Type> Properties | Improve this Doc View Source Instance Type equality comparer instance Declaration public static TypeComparer Instance { get; } Property Value Type Description TypeComparer Methods | Improve this Doc View Source Equals(Type, Type) Determines whether the specified types are equal. Declaration public bool Equals(Type x, Type y) Parameters Type Name Description Type x The first type to compare. Type y The second type to compare. Returns Type Description Boolean true if the specified types are equal; otherwise, false. | Improve this Doc View Source GetHashCode(Type) Returns a hash code for the specified type. Declaration public int GetHashCode(Type obj) Parameters Type Name Description Type obj The type for which a hash code is to be returned. Returns Type Description Int32 A hash code for the specified type. Implements System.Collections.Generic.IEqualityComparer<T> Extension Methods SerializationExtensions.ToXml<T>(T) CollectionsExtensions.SetValue<TKey, T>(TKey, T) CollectionsExtensions.AsEnum<T>(T) DataObjectQueryableExtensions.CompareVariable(Object, FilterOperation, String) Processing.Do<T>(T, Action<IProcess<T>>[]) TypeExtensions.TryConvert<T, TResult>(T, Func<T, TResult>) TypeExtensions.TryConvert<T, TResult>(T, Func<T, TResult>, TResult) TypeExtensions.ChangeType<T>(Object) TypeExtensions.ChangeType(Object, Type) TypeExtensions.InvokeMethod<TRet>(Object, Type[], Expression<Func<TRet>>, BindingFlags) TypeExtensions.InvokeMethod(Object, Type[], Expression<Action>, BindingFlags) TypeExtensions.InvokeMethod<TRet>(Object, Expression<Func<TRet>>, BindingFlags) TypeExtensions.InvokeMethod(Object, Expression<Action>, BindingFlags) SqlBlockExtensions.SetExpression<TTag, TResult>(TTag, Expression<Func<IBlockQueryAdapter, TResult>>) QueryDescriptionExtensions.SetExpression<TTag, TResult>(TTag, Expression<Func<IQueryStructureAdapter, TResult>>)"
  },
  "api/XData.Exceptions.XDataSecurityException.html": {
    "href": "api/XData.Exceptions.XDataSecurityException.html",
    "title": "Class XDataSecurityException | XData website",
    "keywords": "Class XDataSecurityException XData security related exception Inheritance Object Exception ApplicationException XDataException XDataSecurityException Implements ISerializable Inherited Members Exception.GetBaseException() Exception.GetObjectData(SerializationInfo, StreamingContext) Exception.GetType() Exception.ToString() Exception.Data Exception.HelpLink Exception.HResult Exception.InnerException Exception.Message Exception.Source Exception.StackTrace Exception.TargetSite Exception.SerializeObjectState Object.Equals(Object) Object.Equals(Object, Object) Object.GetHashCode() Object.MemberwiseClone() Object.ReferenceEquals(Object, Object) Namespace : XData.Exceptions Assembly : XData.docfx.dll Syntax [Serializable] public sealed class XDataSecurityException : XDataException, ISerializable Constructors | Improve this Doc View Source XDataSecurityException(String) XData security exception Declaration public XDataSecurityException(string details) Parameters Type Name Description String details Exception details info | Improve this Doc View Source XDataSecurityException(String, Exception) XData security exception Declaration public XDataSecurityException(string details, Exception exception) Parameters Type Name Description String details Exception details info Exception exception Inner exception | Improve this Doc View Source XDataSecurityException(String, Exception, Type) XData security exception Declaration public XDataSecurityException(string details, Exception exception, Type dataObjectType) Parameters Type Name Description String details Exception details info Exception exception Inner exception Type dataObjectType Data object type | Improve this Doc View Source XDataSecurityException(String, Exception, Type, AdditionalInfo[]) XData security exception Declaration public XDataSecurityException(string details, Exception exception, Type dataObjectType, params AdditionalInfo[] addInfo) Parameters Type Name Description String details Exception details info Exception exception Inner exception Type dataObjectType Data object type AdditionalInfo [] addInfo Additional information | Improve this Doc View Source XDataSecurityException(String, Type) XData security exception Declaration public XDataSecurityException(string details, Type dataObjectType) Parameters Type Name Description String details Exception details info Type dataObjectType Data object type | Improve this Doc View Source XDataSecurityException(String, Type, AdditionalInfo[]) XData security exception Declaration public XDataSecurityException(string details, Type dataObjectType, params AdditionalInfo[] addInfo) Parameters Type Name Description String details Exception details info Type dataObjectType Data object type AdditionalInfo [] addInfo Additional info Properties | Improve this Doc View Source DataObjectType Data object type Declaration public Type DataObjectType { get; } Property Value Type Description Type | Improve this Doc View Source DetailsInfo Exception details info Declaration public string DetailsInfo { get; } Property Value Type Description String Implements System.Runtime.Serialization.ISerializable Extension Methods SerializationExtensions.ToXml<T>(T) CollectionsExtensions.SetValue<TKey, T>(TKey, T) CollectionsExtensions.AsEnum<T>(T) DataObjectQueryableExtensions.CompareVariable(Object, FilterOperation, String) Processing.Do<T>(T, Action<IProcess<T>>[]) TypeExtensions.TryConvert<T, TResult>(T, Func<T, TResult>) TypeExtensions.TryConvert<T, TResult>(T, Func<T, TResult>, TResult) TypeExtensions.ChangeType<T>(Object) TypeExtensions.ChangeType(Object, Type) TypeExtensions.InvokeMethod<TRet>(Object, Type[], Expression<Func<TRet>>, BindingFlags) TypeExtensions.InvokeMethod(Object, Type[], Expression<Action>, BindingFlags) TypeExtensions.InvokeMethod<TRet>(Object, Expression<Func<TRet>>, BindingFlags) TypeExtensions.InvokeMethod(Object, Expression<Action>, BindingFlags) SqlBlockExtensions.SetExpression<TTag, TResult>(TTag, Expression<Func<IBlockQueryAdapter, TResult>>) QueryDescriptionExtensions.SetExpression<TTag, TResult>(TTag, Expression<Func<IQueryStructureAdapter, TResult>>)"
  },
  "api/XData.Mapping.Dynamic.IRepositoryExpressionMappingAdapter.html": {
    "href": "api/XData.Mapping.Dynamic.IRepositoryExpressionMappingAdapter.html",
    "title": "Interface IRepositoryExpressionMappingAdapter | XData website",
    "keywords": "Interface IRepositoryExpressionMappingAdapter Repository SQL expression property mapping adapter Inherited Members IExpressionPropertyAdapter.Size(Int32) IExpressionPropertyAdapter.Size(Int32, Int32) IExpressionPropertyAdapter.NativeSqlType(String) IExpressionPropertyAdapter.Exists() IExpressionPropertyAdapter.Exists(ExistsOperation) IPropertyMappingAdapter.Key() IPropertyMappingAdapter.Group(DataGrouping) IPropertyMappingAdapter.Group(Int32) IPropertyMappingAdapter.Hidden() IPropertyMappingAdapter.OrderBy(Int32, Boolean) IPropertyMappingAdapter.OrderBy(Int32) Namespace : XData.Mapping.Dynamic Assembly : XData.docfx.dll Syntax public interface IRepositoryExpressionMappingAdapter : IExpressionPropertyAdapter, IPropertyMappingAdapter Extension Methods SerializationExtensions.ToXml<T>(T) CollectionsExtensions.SetValue<TKey, T>(TKey, T) CollectionsExtensions.AsEnum<T>(T) DataObjectQueryableExtensions.CompareVariable(Object, FilterOperation, String) Processing.Do<T>(T, Action<IProcess<T>>[]) TypeExtensions.TryConvert<T, TResult>(T, Func<T, TResult>) TypeExtensions.TryConvert<T, TResult>(T, Func<T, TResult>, TResult) TypeExtensions.ChangeType<T>(Object) TypeExtensions.ChangeType(Object, Type) TypeExtensions.InvokeMethod<TRet>(Object, Type[], Expression<Func<TRet>>, BindingFlags) TypeExtensions.InvokeMethod(Object, Type[], Expression<Action>, BindingFlags) TypeExtensions.InvokeMethod<TRet>(Object, Expression<Func<TRet>>, BindingFlags) TypeExtensions.InvokeMethod(Object, Expression<Action>, BindingFlags) SqlBlockExtensions.SetExpression<TTag, TResult>(TTag, Expression<Func<IBlockQueryAdapter, TResult>>) QueryDescriptionExtensions.SetExpression<TTag, TResult>(TTag, Expression<Func<IQueryStructureAdapter, TResult>>)"
  },
  "api/XData.Mapping.Dynamic.IRepositoryDescription-1.html": {
    "href": "api/XData.Mapping.Dynamic.IRepositoryDescription-1.html",
    "title": "Interface IRepositoryDescription<T> | XData website",
    "keywords": "Interface IRepositoryDescription<T> Dynamic repository structure description interface Inherited Members IQueryDescription.Type Namespace : XData.Mapping.Dynamic Assembly : XData.docfx.dll Syntax public interface IRepositoryDescription<out T> : IQueryDescription where T : class, ISqlObject, new() Type Parameters Name Description T Methods | Improve this Doc View Source SetBaseTable(String) Set base table alias to repository dynamic mapping Declaration IRepositoryDescription<T> SetBaseTable(string baseTableAlias) Parameters Type Name Description String baseTableAlias Base table alias Returns Type Description IRepositoryDescription <T> Dynamic repository description | Improve this Doc View Source SetContext(String) Set context to repository dynamic mapping Declaration IRepositoryDescription<T> SetContext(string context) Parameters Type Name Description String context Database context name Returns Type Description IRepositoryDescription <T> Dynamic repository description | Improve this Doc View Source SetFlags(DataStructureFlag) Set flags to repository dynamic mapping Declaration IRepositoryDescription<T> SetFlags(DataStructureFlag flags) Parameters Type Name Description DataStructureFlag flags Data repository flags Returns Type Description IRepositoryDescription <T> Dynamic repository description | Improve this Doc View Source SetLogicAssemblies(String[]) Set server data logic assembly name to repository dynamic mapping Declaration IRepositoryDescription<T> SetLogicAssemblies(params string[] logicAssemblyNames) Parameters Type Name Description String [] logicAssemblyNames Server data logic assembly names Returns Type Description IRepositoryDescription <T> Dynamic repository description Remarks NOTE: Used when no IoC Container available. Otherwise register logic modules through container Extension Methods SerializationExtensions.ToXml<T>(T) CollectionsExtensions.SetValue<TKey, T>(TKey, T) CollectionsExtensions.AsEnum<T>(T) DataObjectQueryableExtensions.CompareVariable(Object, FilterOperation, String) Processing.Do<T>(T, Action<IProcess<T>>[]) TypeExtensions.TryConvert<T, TResult>(T, Func<T, TResult>) TypeExtensions.TryConvert<T, TResult>(T, Func<T, TResult>, TResult) TypeExtensions.ChangeType<T>(Object) TypeExtensions.ChangeType(Object, Type) TypeExtensions.InvokeMethod<TRet>(Object, Type[], Expression<Func<TRet>>, BindingFlags) TypeExtensions.InvokeMethod(Object, Type[], Expression<Action>, BindingFlags) TypeExtensions.InvokeMethod<TRet>(Object, Expression<Func<TRet>>, BindingFlags) TypeExtensions.InvokeMethod(Object, Expression<Action>, BindingFlags) SqlBlockExtensions.SetExpression<TTag, TResult>(TTag, Expression<Func<IBlockQueryAdapter, TResult>>) QueryDescriptionExtensions.SetExpression<TTag, TResult>(TTag, Expression<Func<IQueryStructureAdapter, TResult>>)"
  },
  "api/XData.Mapping.Dynamic.IQueryWithFlag.html": {
    "href": "api/XData.Mapping.Dynamic.IQueryWithFlag.html",
    "title": "Interface IQueryWithFlag | XData website",
    "keywords": "Interface IQueryWithFlag Common-Table-Expression (WITH) flag Namespace : XData.Mapping.Dynamic Assembly : XData.docfx.dll Syntax public interface IQueryWithFlag Extension Methods SerializationExtensions.ToXml<T>(T) CollectionsExtensions.SetValue<TKey, T>(TKey, T) CollectionsExtensions.AsEnum<T>(T) DataObjectQueryableExtensions.CompareVariable(Object, FilterOperation, String) Processing.Do<T>(T, Action<IProcess<T>>[]) TypeExtensions.TryConvert<T, TResult>(T, Func<T, TResult>) TypeExtensions.TryConvert<T, TResult>(T, Func<T, TResult>, TResult) TypeExtensions.ChangeType<T>(Object) TypeExtensions.ChangeType(Object, Type) TypeExtensions.InvokeMethod<TRet>(Object, Type[], Expression<Func<TRet>>, BindingFlags) TypeExtensions.InvokeMethod(Object, Type[], Expression<Action>, BindingFlags) TypeExtensions.InvokeMethod<TRet>(Object, Expression<Func<TRet>>, BindingFlags) TypeExtensions.InvokeMethod(Object, Expression<Action>, BindingFlags) SqlBlockExtensions.SetExpression<TTag, TResult>(TTag, Expression<Func<IBlockQueryAdapter, TResult>>) QueryDescriptionExtensions.SetExpression<TTag, TResult>(TTag, Expression<Func<IQueryStructureAdapter, TResult>>)"
  },
  "api/XData.Mapping.Dynamic.IQueryWithAdapter-1.html": {
    "href": "api/XData.Mapping.Dynamic.IQueryWithAdapter-1.html",
    "title": "Interface IQueryWithAdapter<TRoot> | XData website",
    "keywords": "Interface IQueryWithAdapter<TRoot> Common-Table-Expression (WITH) mapping attributes Namespace : XData.Mapping.Dynamic Assembly : XData.docfx.dll Syntax public interface IQueryWithAdapter<TRoot> where TRoot : class Type Parameters Name Description TRoot Common-Table-Expression (WITH) initial subquery mapped type Methods | Improve this Doc View Source Properties(Expression<Func<TRoot, Object>>[]) Common-Table-Expression (WITH) properties order Declaration IQueryWithFlag Properties(params Expression<Func<TRoot, object>>[] properties) Parameters Type Name Description Expression < Func <TRoot, Object >>[] properties Common-Table-Expression (WITH) properties expressions Returns Type Description IQueryWithFlag Common-Table-Expression (WITH) flag | Improve this Doc View Source RecursiveType(WithRecursiveType) Common-Table-Expression (WITH) recursive link type attribute Declaration IQueryWithFlag RecursiveType(WithRecursiveType withType) Parameters Type Name Description WithRecursiveType withType Common-Table-Expression (WITH) recursive link type Returns Type Description IQueryWithFlag Common-Table-Expression (WITH) flag | Improve this Doc View Source WithRecursive<TSubquery>(String, IQueryDescription<TSubquery>, Expression<Func<ISubqueryLinkAdapter<TRoot, TSubquery>, IFilterDescription>>[]) Common-Table-Expression (WITH) recursive subqueries Declaration IQueryWithFlag WithRecursive<TSubquery>(string alias, IQueryDescription<TSubquery> query, params Expression<Func<ISubqueryLinkAdapter<TRoot, TSubquery>, IFilterDescription>>[] filters) where TSubquery : class Parameters Type Name Description String alias Common-Table-Expression (WITH) recursive subquery alias IQueryDescription <TSubquery> query Common-Table-Expression (WITH) recursive subquery description Expression < Func < ISubqueryLinkAdapter <TRoot, TSubquery>, IFilterDescription >>[] filters Common-Table-Expression (WITH) recursive subquery links Returns Type Description IQueryWithFlag Common-Table-Expression (WITH) flag Type Parameters Name Description TSubquery Common-Table-Expression (WITH) recursive subquery type Extension Methods SerializationExtensions.ToXml<T>(T) CollectionsExtensions.SetValue<TKey, T>(TKey, T) CollectionsExtensions.AsEnum<T>(T) DataObjectQueryableExtensions.CompareVariable(Object, FilterOperation, String) Processing.Do<T>(T, Action<IProcess<T>>[]) TypeExtensions.TryConvert<T, TResult>(T, Func<T, TResult>) TypeExtensions.TryConvert<T, TResult>(T, Func<T, TResult>, TResult) TypeExtensions.ChangeType<T>(Object) TypeExtensions.ChangeType(Object, Type) TypeExtensions.InvokeMethod<TRet>(Object, Type[], Expression<Func<TRet>>, BindingFlags) TypeExtensions.InvokeMethod(Object, Type[], Expression<Action>, BindingFlags) TypeExtensions.InvokeMethod<TRet>(Object, Expression<Func<TRet>>, BindingFlags) TypeExtensions.InvokeMethod(Object, Expression<Action>, BindingFlags) SqlBlockExtensions.SetExpression<TTag, TResult>(TTag, Expression<Func<IBlockQueryAdapter, TResult>>) QueryDescriptionExtensions.SetExpression<TTag, TResult>(TTag, Expression<Func<IQueryStructureAdapter, TResult>>)"
  },
  "api/XData.SubmitAttachedHandler-1.html": {
    "href": "api/XData.SubmitAttachedHandler-1.html",
    "title": "Delegate SubmitAttachedHandler<T> | XData website",
    "keywords": "Delegate SubmitAttachedHandler<T> Submit attached handler delegate Namespace : XData Assembly : XData.docfx.dll Syntax public delegate bool SubmitAttachedHandler<in T>(IEnumerable<T> objects, DataSubmitFlag flag = DataSubmitFlag.None) where T : class, IDataObject; Parameters Type Name Description IEnumerable <T> objects Object sequence DataSubmitFlag flag Submit flag Returns Type Description Boolean Type Parameters Name Description T Object type Extension Methods SerializationExtensions.ToXml<T>(T) CollectionsExtensions.SetValue<TKey, T>(TKey, T) CollectionsExtensions.AsEnum<T>(T) DataObjectQueryableExtensions.CompareVariable(Object, FilterOperation, String) Processing.Do<T>(T, Action<IProcess<T>>[]) TypeExtensions.TryConvert<T, TResult>(T, Func<T, TResult>) TypeExtensions.TryConvert<T, TResult>(T, Func<T, TResult>, TResult) TypeExtensions.ChangeType<T>(Object) TypeExtensions.ChangeType(Object, Type) TypeExtensions.InvokeMethod<TRet>(Object, Type[], Expression<Func<TRet>>, BindingFlags) TypeExtensions.InvokeMethod(Object, Type[], Expression<Action>, BindingFlags) TypeExtensions.InvokeMethod<TRet>(Object, Expression<Func<TRet>>, BindingFlags) TypeExtensions.InvokeMethod(Object, Expression<Action>, BindingFlags) SqlBlockExtensions.SetExpression<TTag, TResult>(TTag, Expression<Func<IBlockQueryAdapter, TResult>>) QueryDescriptionExtensions.SetExpression<TTag, TResult>(TTag, Expression<Func<IQueryStructureAdapter, TResult>>)"
  },
  "api/XData.SetXmlAttachedHandler.html": {
    "href": "api/XData.SetXmlAttachedHandler.html",
    "title": "Delegate SetXmlAttachedHandler | XData website",
    "keywords": "Delegate SetXmlAttachedHandler Set Xml attached handler delegate Namespace : XData Assembly : XData.docfx.dll Syntax public delegate bool SetXmlAttachedHandler(string property, IDataObject obj, string xml); Parameters Type Name Description String property Lob property name IDataObject obj Data object String xml Xml string Returns Type Description Boolean Extension Methods SerializationExtensions.ToXml<T>(T) CollectionsExtensions.SetValue<TKey, T>(TKey, T) CollectionsExtensions.AsEnum<T>(T) DataObjectQueryableExtensions.CompareVariable(Object, FilterOperation, String) Processing.Do<T>(T, Action<IProcess<T>>[]) TypeExtensions.TryConvert<T, TResult>(T, Func<T, TResult>) TypeExtensions.TryConvert<T, TResult>(T, Func<T, TResult>, TResult) TypeExtensions.ChangeType<T>(Object) TypeExtensions.ChangeType(Object, Type) TypeExtensions.InvokeMethod<TRet>(Object, Type[], Expression<Func<TRet>>, BindingFlags) TypeExtensions.InvokeMethod(Object, Type[], Expression<Action>, BindingFlags) TypeExtensions.InvokeMethod<TRet>(Object, Expression<Func<TRet>>, BindingFlags) TypeExtensions.InvokeMethod(Object, Expression<Action>, BindingFlags) SqlBlockExtensions.SetExpression<TTag, TResult>(TTag, Expression<Func<IBlockQueryAdapter, TResult>>) QueryDescriptionExtensions.SetExpression<TTag, TResult>(TTag, Expression<Func<IQueryStructureAdapter, TResult>>)"
  },
  "api/XData.SetLobAttachedHandler.html": {
    "href": "api/XData.SetLobAttachedHandler.html",
    "title": "Delegate SetLobAttachedHandler | XData website",
    "keywords": "Delegate SetLobAttachedHandler Set Lob attached handler delegate Namespace : XData Assembly : XData.docfx.dll Syntax public delegate void SetLobAttachedHandler(string property, IDataObject obj, byte[] body); Parameters Type Name Description String property Lob property name IDataObject obj Data object Byte [] body Lob body Extension Methods SerializationExtensions.ToXml<T>(T) CollectionsExtensions.SetValue<TKey, T>(TKey, T) CollectionsExtensions.AsEnum<T>(T) DataObjectQueryableExtensions.CompareVariable(Object, FilterOperation, String) Processing.Do<T>(T, Action<IProcess<T>>[]) TypeExtensions.TryConvert<T, TResult>(T, Func<T, TResult>) TypeExtensions.TryConvert<T, TResult>(T, Func<T, TResult>, TResult) TypeExtensions.ChangeType<T>(Object) TypeExtensions.ChangeType(Object, Type) TypeExtensions.InvokeMethod<TRet>(Object, Type[], Expression<Func<TRet>>, BindingFlags) TypeExtensions.InvokeMethod(Object, Type[], Expression<Action>, BindingFlags) TypeExtensions.InvokeMethod<TRet>(Object, Expression<Func<TRet>>, BindingFlags) TypeExtensions.InvokeMethod(Object, Expression<Action>, BindingFlags) SqlBlockExtensions.SetExpression<TTag, TResult>(TTag, Expression<Func<IBlockQueryAdapter, TResult>>) QueryDescriptionExtensions.SetExpression<TTag, TResult>(TTag, Expression<Func<IQueryStructureAdapter, TResult>>)"
  },
  "api/XData.SerializedValue.html": {
    "href": "api/XData.SerializedValue.html",
    "title": "Class SerializedValue | XData website",
    "keywords": "Class SerializedValue Serialized data value Inheritance Object SerializedValue Inherited Members Object.Equals(Object) Object.Equals(Object, Object) Object.GetHashCode() Object.GetType() Object.MemberwiseClone() Object.ReferenceEquals(Object, Object) Object.ToString() Namespace : XData Assembly : XData.docfx.dll Syntax [Serializable] [DataContract] public class SerializedValue Constructors | Improve this Doc View Source SerializedValue(String, String, Object, Object) Serialized value constructor Declaration public SerializedValue(string propertyName, string fieldName, object original, object value) Parameters Type Name Description String propertyName Property name String fieldName Field name Object original Original value Object value Value Properties | Improve this Doc View Source FieldName Field name Declaration [DataMember] public string FieldName { get; set; } Property Value Type Description String | Improve this Doc View Source IsNotChanged Not changed flag Declaration [DataMember] public bool IsNotChanged { get; set; } Property Value Type Description Boolean | Improve this Doc View Source IsNull Null value flag Declaration [DataMember] public bool IsNull { get; set; } Property Value Type Description Boolean | Improve this Doc View Source Original Original value Declaration [DataMember] public string Original { get; set; } Property Value Type Description String | Improve this Doc View Source PropertyName Property name Declaration [DataMember] public string PropertyName { get; set; } Property Value Type Description String | Improve this Doc View Source TypeName Value type name Declaration [DataMember] public string TypeName { get; set; } Property Value Type Description String | Improve this Doc View Source Value Original value Declaration [DataMember] public string Value { get; set; } Property Value Type Description String Methods | Improve this Doc View Source Deserialize(Type, String) Deserialize value Declaration public static object Deserialize(Type type, string value) Parameters Type Name Description Type type Data type String value String value representation Returns Type Description Object Value | Improve this Doc View Source GetValue(Type) Returns serialized value Declaration public object GetValue(Type type) Parameters Type Name Description Type type Returns Type Description Object | Improve this Doc View Source Serialize(Object) Serialize value Declaration public static string Serialize(object value) Parameters Type Name Description Object value Value Returns Type Description String String value representation Extension Methods SerializationExtensions.ToXml<T>(T) CollectionsExtensions.SetValue<TKey, T>(TKey, T) CollectionsExtensions.AsEnum<T>(T) DataObjectQueryableExtensions.CompareVariable(Object, FilterOperation, String) Processing.Do<T>(T, Action<IProcess<T>>[]) TypeExtensions.TryConvert<T, TResult>(T, Func<T, TResult>) TypeExtensions.TryConvert<T, TResult>(T, Func<T, TResult>, TResult) TypeExtensions.ChangeType<T>(Object) TypeExtensions.ChangeType(Object, Type) TypeExtensions.InvokeMethod<TRet>(Object, Type[], Expression<Func<TRet>>, BindingFlags) TypeExtensions.InvokeMethod(Object, Type[], Expression<Action>, BindingFlags) TypeExtensions.InvokeMethod<TRet>(Object, Expression<Func<TRet>>, BindingFlags) TypeExtensions.InvokeMethod(Object, Expression<Action>, BindingFlags) SqlBlockExtensions.SetExpression<TTag, TResult>(TTag, Expression<Func<IBlockQueryAdapter, TResult>>) QueryDescriptionExtensions.SetExpression<TTag, TResult>(TTag, Expression<Func<IQueryStructureAdapter, TResult>>)"
  },
  "api/XData.Mapping.ActionAttribute.html": {
    "href": "api/XData.Mapping.ActionAttribute.html",
    "title": "Class ActionAttribute | XData website",
    "keywords": "Class ActionAttribute Data action attribute Inheritance Object Attribute ActionAttribute Inherited Members Attribute.Equals(Object) Attribute.GetCustomAttribute(Assembly, Type) Attribute.GetCustomAttribute(Assembly, Type, Boolean) Attribute.GetCustomAttribute(MemberInfo, Type) Attribute.GetCustomAttribute(MemberInfo, Type, Boolean) Attribute.GetCustomAttribute(Module, Type) Attribute.GetCustomAttribute(Module, Type, Boolean) Attribute.GetCustomAttribute(ParameterInfo, Type) Attribute.GetCustomAttribute(ParameterInfo, Type, Boolean) Attribute.GetCustomAttributes(Assembly) Attribute.GetCustomAttributes(Assembly, Boolean) Attribute.GetCustomAttributes(Assembly, Type) Attribute.GetCustomAttributes(Assembly, Type, Boolean) Attribute.GetCustomAttributes(MemberInfo) Attribute.GetCustomAttributes(MemberInfo, Boolean) Attribute.GetCustomAttributes(MemberInfo, Type) Attribute.GetCustomAttributes(MemberInfo, Type, Boolean) Attribute.GetCustomAttributes(Module) Attribute.GetCustomAttributes(Module, Boolean) Attribute.GetCustomAttributes(Module, Type) Attribute.GetCustomAttributes(Module, Type, Boolean) Attribute.GetCustomAttributes(ParameterInfo) Attribute.GetCustomAttributes(ParameterInfo, Boolean) Attribute.GetCustomAttributes(ParameterInfo, Type) Attribute.GetCustomAttributes(ParameterInfo, Type, Boolean) Attribute.GetHashCode() Attribute.IsDefaultAttribute() Attribute.IsDefined(Assembly, Type) Attribute.IsDefined(Assembly, Type, Boolean) Attribute.IsDefined(MemberInfo, Type) Attribute.IsDefined(MemberInfo, Type, Boolean) Attribute.IsDefined(Module, Type) Attribute.IsDefined(Module, Type, Boolean) Attribute.IsDefined(ParameterInfo, Type) Attribute.IsDefined(ParameterInfo, Type, Boolean) Attribute.Match(Object) Object.Equals(Object, Object) Object.GetType() Object.MemberwiseClone() Object.ReferenceEquals(Object, Object) Object.ToString() Namespace : XData.Mapping Assembly : XData.docfx.dll Syntax [AttributeUsage(AttributeTargets.Property, AllowMultiple = true)] public sealed class ActionAttribute : Attribute Remarks Used to assign one or more DataActionType to IDataLogic<T> action handler Hint: Use ActionOrder to apply execution order of multiple handlers marked ActionAttribute for same DataActionType Hint: Action handlers will executed on server side when using XData Application server Constructors | Improve this Doc View Source ActionAttribute(DataActionType, Int32) Data action attribute Declaration public ActionAttribute(DataActionType type, int order = 0) Parameters Type Name Description DataActionType type Type of action (see DataActionType) Int32 order Action execution order Properties | Improve this Doc View Source ActionOrder Action execution order Declaration public int ActionOrder { get; } Property Value Type Description Int32 | Improve this Doc View Source ActionType Type of action (see DataActionType) Declaration public DataActionType ActionType { get; } Property Value Type Description DataActionType See Also DataActionType | Improve this Doc View Source TypeId When implemented in a derived class, gets a unique identifier for this Attribute . Declaration public override object TypeId { get; } Property Value Type Description Object An Object that is a unique identifier for the attribute. Overrides Attribute.TypeId Extension Methods SerializationExtensions.ToXml<T>(T) CollectionsExtensions.SetValue<TKey, T>(TKey, T) CollectionsExtensions.AsEnum<T>(T) DataObjectQueryableExtensions.CompareVariable(Object, FilterOperation, String) Processing.Do<T>(T, Action<IProcess<T>>[]) TypeExtensions.TryConvert<T, TResult>(T, Func<T, TResult>) TypeExtensions.TryConvert<T, TResult>(T, Func<T, TResult>, TResult) TypeExtensions.ChangeType<T>(Object) TypeExtensions.ChangeType(Object, Type) TypeExtensions.InvokeMethod<TRet>(Object, Type[], Expression<Func<TRet>>, BindingFlags) TypeExtensions.InvokeMethod(Object, Type[], Expression<Action>, BindingFlags) TypeExtensions.InvokeMethod<TRet>(Object, Expression<Func<TRet>>, BindingFlags) TypeExtensions.InvokeMethod(Object, Expression<Action>, BindingFlags) SqlBlockExtensions.SetExpression<TTag, TResult>(TTag, Expression<Func<IBlockQueryAdapter, TResult>>) QueryDescriptionExtensions.SetExpression<TTag, TResult>(TTag, Expression<Func<IQueryStructureAdapter, TResult>>)"
  },
  "api/XData.Interfaces.ISecuritySession.html": {
    "href": "api/XData.Interfaces.ISecuritySession.html",
    "title": "Interface ISecuritySession | XData website",
    "keywords": "Interface ISecuritySession Security session interface Namespace : XData.Interfaces Assembly : XData.docfx.dll Syntax public interface ISecuritySession Properties | Improve this Doc View Source IsSupervisor Current user is supervisor flag Declaration bool IsSupervisor { get; } Property Value Type Description Boolean | Improve this Doc View Source Roles Current user roles list Declaration string[] Roles { get; } Property Value Type Description String [] | Improve this Doc View Source UserName Current user name Declaration string UserName { get; } Property Value Type Description String Methods | Improve this Doc View Source FilterGrantedObjects<T>(String, Expression) Converts initial IQueryable expression filtering granted objects only Declaration Expression FilterGrantedObjects<T>(string context, Expression allDataExpr) where T : class, IDataObject, new() Parameters Type Name Description String context Context name Expression allDataExpr Initial IQueryable expression Returns Type Description Expression Modified IQueryable expression Type Parameters Name Description T Data object type | Improve this Doc View Source GetGrantedActions<T>(String) Returns list of granted actions for current user Declaration string[] GetGrantedActions<T>(string context = null) where T : class, IDataObject, new() Parameters Type Name Description String context Context name Returns Type Description String [] Actions list Type Parameters Name Description T Data object type | Improve this Doc View Source GetRestrictedProperties<T>(String) Returns list of restricted properties for current user Declaration string[] GetRestrictedProperties<T>(string context = null) where T : class, IDataObject, new() Parameters Type Name Description String context Context name Returns Type Description String [] Properties name list Type Parameters Name Description T Data object type Extension Methods SerializationExtensions.ToXml<T>(T) CollectionsExtensions.SetValue<TKey, T>(TKey, T) CollectionsExtensions.AsEnum<T>(T) DataObjectQueryableExtensions.CompareVariable(Object, FilterOperation, String) Processing.Do<T>(T, Action<IProcess<T>>[]) TypeExtensions.TryConvert<T, TResult>(T, Func<T, TResult>) TypeExtensions.TryConvert<T, TResult>(T, Func<T, TResult>, TResult) TypeExtensions.ChangeType<T>(Object) TypeExtensions.ChangeType(Object, Type) TypeExtensions.InvokeMethod<TRet>(Object, Type[], Expression<Func<TRet>>, BindingFlags) TypeExtensions.InvokeMethod(Object, Type[], Expression<Action>, BindingFlags) TypeExtensions.InvokeMethod<TRet>(Object, Expression<Func<TRet>>, BindingFlags) TypeExtensions.InvokeMethod(Object, Expression<Action>, BindingFlags) SqlBlockExtensions.SetExpression<TTag, TResult>(TTag, Expression<Func<IBlockQueryAdapter, TResult>>) QueryDescriptionExtensions.SetExpression<TTag, TResult>(TTag, Expression<Func<IQueryStructureAdapter, TResult>>)"
  },
  "api/XData.Exceptions.XDataConfigurationExceptionType.html": {
    "href": "api/XData.Exceptions.XDataConfigurationExceptionType.html",
    "title": "Enum XDataConfigurationExceptionType | XData website",
    "keywords": "Enum XDataConfigurationExceptionType XData configuration exception types Namespace : XData.Exceptions Assembly : XData.docfx.dll Syntax public enum XDataConfigurationExceptionType Fields Name Description AdapterAssemblyNotFoundError Adapter assembly not found AdapterNotConfiguredError Data adapter not configured ConfigurationFileLoadError Configuration file load error ConfigurationFileSaveError Configuration file save error ConfigurationXmlReadError Configuration xml read error ConnectionStringHasWrongFormatError Connection string has wrong format ContextNotConfiguredError Data context not configured DefaultContextNotFoundError Default data context is not found ProxyNotConfiguredError Proxy not configured Extension Methods SerializationExtensions.ToXml<XDataConfigurationExceptionType>() CollectionsExtensions.SetValue<XDataConfigurationExceptionType, T>(T) CollectionsExtensions.AsEnum<XDataConfigurationExceptionType>() DataObjectQueryableExtensions.CompareVariable(FilterOperation, String) Processing.Do<XDataConfigurationExceptionType>(Action<IProcess<XDataConfigurationExceptionType>>[]) TypeExtensions.ChangeType<T>() TypeExtensions.ChangeType(Type) TypeExtensions.InvokeMethod<TRet>(Type[], Expression<Func<TRet>>, BindingFlags) TypeExtensions.InvokeMethod(Type[], Expression<Action>, BindingFlags) TypeExtensions.InvokeMethod<TRet>(Expression<Func<TRet>>, BindingFlags) TypeExtensions.InvokeMethod(Expression<Action>, BindingFlags) TypeExtensions.ConvertTo<T>() TypeExtensions.EqualValue(Enum) SqlBlockExtensions.SetExpression<XDataConfigurationExceptionType, TResult>(Expression<Func<IBlockQueryAdapter, TResult>>) QueryDescriptionExtensions.SetExpression<XDataConfigurationExceptionType, TResult>(Expression<Func<IQueryStructureAdapter, TResult>>)"
  },
  "api/XData.SubmitQueryAttachedHandler-1.html": {
    "href": "api/XData.SubmitQueryAttachedHandler-1.html",
    "title": "Delegate SubmitQueryAttachedHandler<T> | XData website",
    "keywords": "Delegate SubmitQueryAttachedHandler<T> Lock object attached handler delegate Namespace : XData Assembly : XData.docfx.dll Syntax public delegate QueryResult SubmitQueryAttachedHandler<in T>(T obj, Query query) where T : class, IDataObject; Parameters Type Name Description T obj Object instance Query query Query Returns Type Description QueryResult Type Parameters Name Description T Object type Extension Methods SerializationExtensions.ToXml<T>(T) CollectionsExtensions.SetValue<TKey, T>(TKey, T) CollectionsExtensions.AsEnum<T>(T) DataObjectQueryableExtensions.CompareVariable(Object, FilterOperation, String) Processing.Do<T>(T, Action<IProcess<T>>[]) TypeExtensions.TryConvert<T, TResult>(T, Func<T, TResult>) TypeExtensions.TryConvert<T, TResult>(T, Func<T, TResult>, TResult) TypeExtensions.ChangeType<T>(Object) TypeExtensions.ChangeType(Object, Type) TypeExtensions.InvokeMethod<TRet>(Object, Type[], Expression<Func<TRet>>, BindingFlags) TypeExtensions.InvokeMethod(Object, Type[], Expression<Action>, BindingFlags) TypeExtensions.InvokeMethod<TRet>(Object, Expression<Func<TRet>>, BindingFlags) TypeExtensions.InvokeMethod(Object, Expression<Action>, BindingFlags) SqlBlockExtensions.SetExpression<TTag, TResult>(TTag, Expression<Func<IBlockQueryAdapter, TResult>>) QueryDescriptionExtensions.SetExpression<TTag, TResult>(TTag, Expression<Func<IQueryStructureAdapter, TResult>>)"
  },
  "api/XData.ParameterIndexer.html": {
    "href": "api/XData.ParameterIndexer.html",
    "title": "Class ParameterIndexer | XData website",
    "keywords": "Class ParameterIndexer SQL procedure call out parameters indexer Inheritance Object ParameterIndexer Inherited Members Object.Equals(Object) Object.Equals(Object, Object) Object.GetHashCode() Object.GetType() Object.MemberwiseClone() Object.ReferenceEquals(Object, Object) Object.ToString() Namespace : XData Assembly : XData.docfx.dll Syntax public sealed class ParameterIndexer Constructors | Improve this Doc View Source ParameterIndexer(IEnumerable<IParameterDescription>) Parameter indexer constructor Declaration public ParameterIndexer(IEnumerable<IParameterDescription> parameters) Parameters Type Name Description IEnumerable < IParameterDescription > parameters Parameter sequence Properties | Improve this Doc View Source Count Variables count Declaration public int Count { get; } Property Value Type Description Int32 | Improve this Doc View Source Item[String] Parameter indexer Declaration public IParameterDescription this[string name] { get; } Parameters Type Name Description String name Parameter name Property Value Type Description IParameterDescription Variable Methods | Improve this Doc View Source Add(IParameterDescription) Add parameter Declaration public void Add(IParameterDescription parameter) Parameters Type Name Description IParameterDescription parameter Variable | Improve this Doc View Source Add(ParameterIndexer) Add variables to collection Declaration public void Add(ParameterIndexer variables) Parameters Type Name Description ParameterIndexer variables Variable indexer | Improve this Doc View Source Contains(String) Variables contains name Declaration public bool Contains(string name) Parameters Type Name Description String name Variable name Returns Type Description Boolean Contains flag | Improve this Doc View Source GetValue(String) Returns parameter value Declaration public object GetValue(string name) Parameters Type Name Description String name Parameter name Returns Type Description Object Parameter value | Improve this Doc View Source GetValue<T>(String) Returns parameter value Declaration public T GetValue<T>(string name) Parameters Type Name Description String name Parameter name Returns Type Description T Parameter value Type Parameters Name Description T Parameter type Extension Methods SerializationExtensions.ToXml<T>(T) CollectionsExtensions.SetValue<TKey, T>(TKey, T) CollectionsExtensions.AsEnum<T>(T) DataObjectQueryableExtensions.CompareVariable(Object, FilterOperation, String) Processing.Do<T>(T, Action<IProcess<T>>[]) TypeExtensions.TryConvert<T, TResult>(T, Func<T, TResult>) TypeExtensions.TryConvert<T, TResult>(T, Func<T, TResult>, TResult) TypeExtensions.ChangeType<T>(Object) TypeExtensions.ChangeType(Object, Type) TypeExtensions.InvokeMethod<TRet>(Object, Type[], Expression<Func<TRet>>, BindingFlags) TypeExtensions.InvokeMethod(Object, Type[], Expression<Action>, BindingFlags) TypeExtensions.InvokeMethod<TRet>(Object, Expression<Func<TRet>>, BindingFlags) TypeExtensions.InvokeMethod(Object, Expression<Action>, BindingFlags) SqlBlockExtensions.SetExpression<TTag, TResult>(TTag, Expression<Func<IBlockQueryAdapter, TResult>>) QueryDescriptionExtensions.SetExpression<TTag, TResult>(TTag, Expression<Func<IQueryStructureAdapter, TResult>>)"
  },
  "api/XData.Mapping.HintInfo.html": {
    "href": "api/XData.Mapping.HintInfo.html",
    "title": "Class HintInfo | XData website",
    "keywords": "Class HintInfo Hint description Inheritance Object HintInfo Inherited Members Object.Equals(Object) Object.Equals(Object, Object) Object.GetHashCode() Object.GetType() Object.MemberwiseClone() Object.ReferenceEquals(Object, Object) Object.ToString() Namespace : XData.Mapping Assembly : XData.docfx.dll Syntax public class HintInfo Properties | Improve this Doc View Source Hint Hint text Declaration public string Hint { get; set; } Property Value Type Description String | Improve this Doc View Source HintType Hint type Declaration public HintType HintType { get; set; } Property Value Type Description HintType Extension Methods SerializationExtensions.ToXml<T>(T) CollectionsExtensions.SetValue<TKey, T>(TKey, T) CollectionsExtensions.AsEnum<T>(T) DataObjectQueryableExtensions.CompareVariable(Object, FilterOperation, String) Processing.Do<T>(T, Action<IProcess<T>>[]) TypeExtensions.TryConvert<T, TResult>(T, Func<T, TResult>) TypeExtensions.TryConvert<T, TResult>(T, Func<T, TResult>, TResult) TypeExtensions.ChangeType<T>(Object) TypeExtensions.ChangeType(Object, Type) TypeExtensions.InvokeMethod<TRet>(Object, Type[], Expression<Func<TRet>>, BindingFlags) TypeExtensions.InvokeMethod(Object, Type[], Expression<Action>, BindingFlags) TypeExtensions.InvokeMethod<TRet>(Object, Expression<Func<TRet>>, BindingFlags) TypeExtensions.InvokeMethod(Object, Expression<Action>, BindingFlags) SqlBlockExtensions.SetExpression<TTag, TResult>(TTag, Expression<Func<IBlockQueryAdapter, TResult>>) QueryDescriptionExtensions.SetExpression<TTag, TResult>(TTag, Expression<Func<IQueryStructureAdapter, TResult>>)"
  },
  "api/XData.Mapping.HintAttribute.html": {
    "href": "api/XData.Mapping.HintAttribute.html",
    "title": "Class HintAttribute | XData website",
    "keywords": "Class HintAttribute Inheritance Object Attribute HintAttribute Inherited Members Attribute.Equals(Object) Attribute.GetCustomAttribute(Assembly, Type) Attribute.GetCustomAttribute(Assembly, Type, Boolean) Attribute.GetCustomAttribute(MemberInfo, Type) Attribute.GetCustomAttribute(MemberInfo, Type, Boolean) Attribute.GetCustomAttribute(Module, Type) Attribute.GetCustomAttribute(Module, Type, Boolean) Attribute.GetCustomAttribute(ParameterInfo, Type) Attribute.GetCustomAttribute(ParameterInfo, Type, Boolean) Attribute.GetCustomAttributes(Assembly) Attribute.GetCustomAttributes(Assembly, Boolean) Attribute.GetCustomAttributes(Assembly, Type) Attribute.GetCustomAttributes(Assembly, Type, Boolean) Attribute.GetCustomAttributes(MemberInfo) Attribute.GetCustomAttributes(MemberInfo, Boolean) Attribute.GetCustomAttributes(MemberInfo, Type) Attribute.GetCustomAttributes(MemberInfo, Type, Boolean) Attribute.GetCustomAttributes(Module) Attribute.GetCustomAttributes(Module, Boolean) Attribute.GetCustomAttributes(Module, Type) Attribute.GetCustomAttributes(Module, Type, Boolean) Attribute.GetCustomAttributes(ParameterInfo) Attribute.GetCustomAttributes(ParameterInfo, Boolean) Attribute.GetCustomAttributes(ParameterInfo, Type) Attribute.GetCustomAttributes(ParameterInfo, Type, Boolean) Attribute.GetHashCode() Attribute.IsDefaultAttribute() Attribute.IsDefined(Assembly, Type) Attribute.IsDefined(Assembly, Type, Boolean) Attribute.IsDefined(MemberInfo, Type) Attribute.IsDefined(MemberInfo, Type, Boolean) Attribute.IsDefined(Module, Type) Attribute.IsDefined(Module, Type, Boolean) Attribute.IsDefined(ParameterInfo, Type) Attribute.IsDefined(ParameterInfo, Type, Boolean) Attribute.Match(Object) Object.Equals(Object, Object) Object.GetType() Object.MemberwiseClone() Object.ReferenceEquals(Object, Object) Object.ToString() Namespace : XData.Mapping Assembly : XData.docfx.dll Syntax [AttributeUsage(AttributeTargets.Class, AllowMultiple = true)] public sealed class HintAttribute : Attribute Constructors | Improve this Doc View Source HintAttribute(String, String, HintType) Hint attribute constructor Declaration public HintAttribute(string alias, string hint, HintType hintType = HintType.Select) Parameters Type Name Description String alias Data source alias String hint Hint text HintType hintType Hint type Properties | Improve this Doc View Source Alias Data source alias to apply hint Declaration public string Alias { get; } Property Value Type Description String | Improve this Doc View Source Hint Hint Declaration public HintInfo Hint { get; } Property Value Type Description HintInfo | Improve this Doc View Source TypeId When implemented in a derived class, gets a unique identifier for this Attribute . Declaration public override object TypeId { get; } Property Value Type Description Object An Object that is a unique identifier for the attribute. Overrides Attribute.TypeId Extension Methods SerializationExtensions.ToXml<T>(T) CollectionsExtensions.SetValue<TKey, T>(TKey, T) CollectionsExtensions.AsEnum<T>(T) DataObjectQueryableExtensions.CompareVariable(Object, FilterOperation, String) Processing.Do<T>(T, Action<IProcess<T>>[]) TypeExtensions.TryConvert<T, TResult>(T, Func<T, TResult>) TypeExtensions.TryConvert<T, TResult>(T, Func<T, TResult>, TResult) TypeExtensions.ChangeType<T>(Object) TypeExtensions.ChangeType(Object, Type) TypeExtensions.InvokeMethod<TRet>(Object, Type[], Expression<Func<TRet>>, BindingFlags) TypeExtensions.InvokeMethod(Object, Type[], Expression<Action>, BindingFlags) TypeExtensions.InvokeMethod<TRet>(Object, Expression<Func<TRet>>, BindingFlags) TypeExtensions.InvokeMethod(Object, Expression<Action>, BindingFlags) SqlBlockExtensions.SetExpression<TTag, TResult>(TTag, Expression<Func<IBlockQueryAdapter, TResult>>) QueryDescriptionExtensions.SetExpression<TTag, TResult>(TTag, Expression<Func<IQueryStructureAdapter, TResult>>)"
  },
  "api/XData.Mapping.HierarchyAttribute.html": {
    "href": "api/XData.Mapping.HierarchyAttribute.html",
    "title": "Class HierarchyAttribute | XData website",
    "keywords": "Class HierarchyAttribute Hierarchy attribute Inheritance Object Attribute HierarchyAttribute Inherited Members Attribute.Equals(Object) Attribute.GetCustomAttribute(Assembly, Type) Attribute.GetCustomAttribute(Assembly, Type, Boolean) Attribute.GetCustomAttribute(MemberInfo, Type) Attribute.GetCustomAttribute(MemberInfo, Type, Boolean) Attribute.GetCustomAttribute(Module, Type) Attribute.GetCustomAttribute(Module, Type, Boolean) Attribute.GetCustomAttribute(ParameterInfo, Type) Attribute.GetCustomAttribute(ParameterInfo, Type, Boolean) Attribute.GetCustomAttributes(Assembly) Attribute.GetCustomAttributes(Assembly, Boolean) Attribute.GetCustomAttributes(Assembly, Type) Attribute.GetCustomAttributes(Assembly, Type, Boolean) Attribute.GetCustomAttributes(MemberInfo) Attribute.GetCustomAttributes(MemberInfo, Boolean) Attribute.GetCustomAttributes(MemberInfo, Type) Attribute.GetCustomAttributes(MemberInfo, Type, Boolean) Attribute.GetCustomAttributes(Module) Attribute.GetCustomAttributes(Module, Boolean) Attribute.GetCustomAttributes(Module, Type) Attribute.GetCustomAttributes(Module, Type, Boolean) Attribute.GetCustomAttributes(ParameterInfo) Attribute.GetCustomAttributes(ParameterInfo, Boolean) Attribute.GetCustomAttributes(ParameterInfo, Type) Attribute.GetCustomAttributes(ParameterInfo, Type, Boolean) Attribute.GetHashCode() Attribute.IsDefaultAttribute() Attribute.IsDefined(Assembly, Type) Attribute.IsDefined(Assembly, Type, Boolean) Attribute.IsDefined(MemberInfo, Type) Attribute.IsDefined(MemberInfo, Type, Boolean) Attribute.IsDefined(Module, Type) Attribute.IsDefined(Module, Type, Boolean) Attribute.IsDefined(ParameterInfo, Type) Attribute.IsDefined(ParameterInfo, Type, Boolean) Attribute.Match(Object) Object.Equals(Object, Object) Object.GetType() Object.MemberwiseClone() Object.ReferenceEquals(Object, Object) Object.ToString() Namespace : XData.Mapping Assembly : XData.docfx.dll Syntax [AttributeUsage(AttributeTargets.Class, AllowMultiple = true)] public sealed class HierarchyAttribute : Attribute Remarks Tables can be hierarchically liked to themselves. On every hierarchical link is possible to build hierarchy table, to simplify tree structure queries. It's alternative of ORACLE CONNECT BY PRIOR...START WITH construction for other database engines // Table T_TEST has parent_id field tree linked to test_id (T_TEST's pk) // Table L_TEST has two fields parent_id and child_id all linked to T_TEST.test_id // Table L_TEST contains all subtree relations inside T_TEST // For example: for T_TEST (test_id, parent_id): (1, null) : (2, 1) : (3, 2) // L_TEST will contain (parent_id, child_id): (1, 1) : (1, 2) : (1, 3) : (2, 2) : (2, 3) : (3, 3) [DataObject(\"T\"), DataTable(\"T_TEST\", \"T\"), Hierarchy(\"T\", \"L_TEST\", \"parent_id\", \"parent_id\", \"child_id\"), Column(\"TestId\", \"test_id\", typeof(long?), \"T\", Flags = DataPropertyFlag.Id)] WARNING! Hierarchy base table (T_TEST in example above) mast contain non complex primary key! Hint: Possible to describe multiple hierarchies across one table using different tree links Constructors | Improve this Doc View Source HierarchyAttribute(String, String, String, String, String) Hierarchy attribute Declaration public HierarchyAttribute(string source, string treeTableName, string parent, string linkParent, string linkChild) Parameters Type Name Description String source Source table alias String treeTableName Link table name String parent Source table parent column name String linkParent Link table parent column name String linkChild Link table child column name Exceptions Type Condition XDataRuntimeException Source table alias cannot be null or empty string XDataRuntimeException Link table name cannot be null or empty string XDataRuntimeException Source table parent column name cannot be null or empty string XDataRuntimeException Link table parent column name cannot be null or empty string XDataRuntimeException Link table child column name cannot be null or empty string Properties | Improve this Doc View Source LinkChild Link table child column name Declaration public string LinkChild { get; } Property Value Type Description String | Improve this Doc View Source LinkParent Link table parent column name Declaration public string LinkParent { get; } Property Value Type Description String | Improve this Doc View Source Parent Source table parent column name Declaration public string Parent { get; } Property Value Type Description String | Improve this Doc View Source Source Source table alias Declaration public string Source { get; } Property Value Type Description String See Also Alias | Improve this Doc View Source TreeTableName Link table name Declaration public string TreeTableName { get; } Property Value Type Description String Remarks Tree table contains links from tree node to all subtree nodes. | Improve this Doc View Source TypeId When implemented in a derived class, gets a unique identifier for this Attribute . Declaration public override object TypeId { get; } Property Value Type Description Object An Object that is a unique identifier for the attribute. Overrides Attribute.TypeId Extension Methods SerializationExtensions.ToXml<T>(T) CollectionsExtensions.SetValue<TKey, T>(TKey, T) CollectionsExtensions.AsEnum<T>(T) DataObjectQueryableExtensions.CompareVariable(Object, FilterOperation, String) Processing.Do<T>(T, Action<IProcess<T>>[]) TypeExtensions.TryConvert<T, TResult>(T, Func<T, TResult>) TypeExtensions.TryConvert<T, TResult>(T, Func<T, TResult>, TResult) TypeExtensions.ChangeType<T>(Object) TypeExtensions.ChangeType(Object, Type) TypeExtensions.InvokeMethod<TRet>(Object, Type[], Expression<Func<TRet>>, BindingFlags) TypeExtensions.InvokeMethod(Object, Type[], Expression<Action>, BindingFlags) TypeExtensions.InvokeMethod<TRet>(Object, Expression<Func<TRet>>, BindingFlags) TypeExtensions.InvokeMethod(Object, Expression<Action>, BindingFlags) SqlBlockExtensions.SetExpression<TTag, TResult>(TTag, Expression<Func<IBlockQueryAdapter, TResult>>) QueryDescriptionExtensions.SetExpression<TTag, TResult>(TTag, Expression<Func<IQueryStructureAdapter, TResult>>)"
  },
  "api/XData.Mapping.FilterCombinationAttribute.html": {
    "href": "api/XData.Mapping.FilterCombinationAttribute.html",
    "title": "Class FilterCombinationAttribute | XData website",
    "keywords": "Class FilterCombinationAttribute Data object filter combination (filter group) attribute Inheritance Object Attribute FilterCombinationAttribute Inherited Members Attribute.Equals(Object) Attribute.GetCustomAttribute(Assembly, Type) Attribute.GetCustomAttribute(Assembly, Type, Boolean) Attribute.GetCustomAttribute(MemberInfo, Type) Attribute.GetCustomAttribute(MemberInfo, Type, Boolean) Attribute.GetCustomAttribute(Module, Type) Attribute.GetCustomAttribute(Module, Type, Boolean) Attribute.GetCustomAttribute(ParameterInfo, Type) Attribute.GetCustomAttribute(ParameterInfo, Type, Boolean) Attribute.GetCustomAttributes(Assembly) Attribute.GetCustomAttributes(Assembly, Boolean) Attribute.GetCustomAttributes(Assembly, Type) Attribute.GetCustomAttributes(Assembly, Type, Boolean) Attribute.GetCustomAttributes(MemberInfo) Attribute.GetCustomAttributes(MemberInfo, Boolean) Attribute.GetCustomAttributes(MemberInfo, Type) Attribute.GetCustomAttributes(MemberInfo, Type, Boolean) Attribute.GetCustomAttributes(Module) Attribute.GetCustomAttributes(Module, Boolean) Attribute.GetCustomAttributes(Module, Type) Attribute.GetCustomAttributes(Module, Type, Boolean) Attribute.GetCustomAttributes(ParameterInfo) Attribute.GetCustomAttributes(ParameterInfo, Boolean) Attribute.GetCustomAttributes(ParameterInfo, Type) Attribute.GetCustomAttributes(ParameterInfo, Type, Boolean) Attribute.GetHashCode() Attribute.IsDefaultAttribute() Attribute.IsDefined(Assembly, Type) Attribute.IsDefined(Assembly, Type, Boolean) Attribute.IsDefined(MemberInfo, Type) Attribute.IsDefined(MemberInfo, Type, Boolean) Attribute.IsDefined(Module, Type) Attribute.IsDefined(Module, Type, Boolean) Attribute.IsDefined(ParameterInfo, Type) Attribute.IsDefined(ParameterInfo, Type, Boolean) Attribute.Match(Object) Object.Equals(Object, Object) Object.GetType() Object.MemberwiseClone() Object.ReferenceEquals(Object, Object) Object.ToString() Namespace : XData.Mapping Assembly : XData.docfx.dll Syntax [AttributeUsage(AttributeTargets.Class, AllowMultiple = true)] public sealed class FilterCombinationAttribute : Attribute Remarks Filter combinations combine filters into named logical groups united by same logical operation (see Combination ) Default filter combination always exists. It have And combination and named as Empty Filter combination tree based on Parent property Constructors | Improve this Doc View Source FilterCombinationAttribute(String) Data object filter combination (filter group) attribute constructor Declaration public FilterCombinationAttribute(string name) Parameters Type Name Description String name Name of filter combination (filter group) Exceptions Type Condition XDataRuntimeException Name of filter combination (filter group) cannot be null or empty string Properties | Improve this Doc View Source Combination Filter combination (filter group) logical operation (And or Or) Declaration public Combination Combination { get; set; } Property Value Type Description Combination | Improve this Doc View Source Name Name of filter combination (filter group) Declaration public string Name { get; } Property Value Type Description String | Improve this Doc View Source Parent Parent filter combination (filter group) name Declaration public string Parent { get; set; } Property Value Type Description String | Improve this Doc View Source TypeId When implemented in a derived class, gets a unique identifier for this Attribute . Declaration public override object TypeId { get; } Property Value Type Description Object An Object that is a unique identifier for the attribute. Overrides Attribute.TypeId Extension Methods SerializationExtensions.ToXml<T>(T) CollectionsExtensions.SetValue<TKey, T>(TKey, T) CollectionsExtensions.AsEnum<T>(T) DataObjectQueryableExtensions.CompareVariable(Object, FilterOperation, String) Processing.Do<T>(T, Action<IProcess<T>>[]) TypeExtensions.TryConvert<T, TResult>(T, Func<T, TResult>) TypeExtensions.TryConvert<T, TResult>(T, Func<T, TResult>, TResult) TypeExtensions.ChangeType<T>(Object) TypeExtensions.ChangeType(Object, Type) TypeExtensions.InvokeMethod<TRet>(Object, Type[], Expression<Func<TRet>>, BindingFlags) TypeExtensions.InvokeMethod(Object, Type[], Expression<Action>, BindingFlags) TypeExtensions.InvokeMethod<TRet>(Object, Expression<Func<TRet>>, BindingFlags) TypeExtensions.InvokeMethod(Object, Expression<Action>, BindingFlags) SqlBlockExtensions.SetExpression<TTag, TResult>(TTag, Expression<Func<IBlockQueryAdapter, TResult>>) QueryDescriptionExtensions.SetExpression<TTag, TResult>(TTag, Expression<Func<IQueryStructureAdapter, TResult>>)"
  },
  "api/XData.Mapping.Dynamic.IProcedureParameterAdapter.html": {
    "href": "api/XData.Mapping.Dynamic.IProcedureParameterAdapter.html",
    "title": "Interface IProcedureParameterAdapter | XData website",
    "keywords": "Interface IProcedureParameterAdapter Procedure parameter mapping adapter Namespace : XData.Mapping.Dynamic Assembly : XData.docfx.dll Syntax public interface IProcedureParameterAdapter Methods | Improve this Doc View Source Array() Parameter is simple type array flag Declaration IProcedureParameterFlag Array() Returns Type Description IProcedureParameterFlag Procedure parameter mapping flag | Improve this Doc View Source Default(Object) Parameter default value Declaration IProcedureParameterFlag Default(object defaultValue) Parameters Type Name Description Object defaultValue Parameter default value Returns Type Description IProcedureParameterFlag Procedure parameter mapping flag | Improve this Doc View Source Default(DefaultType) Parameter default value Declaration IProcedureParameterFlag Default(DefaultType type) Parameters Type Name Description DefaultType type Parameter default value type Returns Type Description IProcedureParameterFlag Procedure parameter mapping flag | Improve this Doc View Source Default(DefaultType, Object) Parameter default value Declaration IProcedureParameterFlag Default(DefaultType type, object defaultValue) Parameters Type Name Description DefaultType type Parameter default value type Object defaultValue Parameter default value Returns Type Description IProcedureParameterFlag Procedure parameter mapping flag | Improve this Doc View Source Direction(ParameterDirection) Parameter direction Declaration IProcedureParameterFlag Direction(ParameterDirection direction) Parameters Type Name Description ParameterDirection direction Parameter direction Returns Type Description IProcedureParameterFlag Procedure parameter mapping flag | Improve this Doc View Source NativeSqlType(String) Native SQL type name Declaration IProcedureParameterFlag NativeSqlType(string nativeSqlType) Parameters Type Name Description String nativeSqlType Native SQL type name Returns Type Description IProcedureParameterFlag Procedure parameter mapping flag | Improve this Doc View Source ParameterName(String) Parameter mapping name Declaration IProcedureParameterFlag ParameterName(string parameterName) Parameters Type Name Description String parameterName Parameter mapping name Returns Type Description IProcedureParameterFlag Procedure parameter mapping flag | Improve this Doc View Source Size(Int32) Size of SQL expression result value Declaration IProcedureParameterFlag Size(int size) Parameters Type Name Description Int32 size Size Returns Type Description IProcedureParameterFlag SQL expression mapping flag | Improve this Doc View Source Size(Int32, Int32) Size of SQL expression result value Declaration IProcedureParameterFlag Size(int size, int scale) Parameters Type Name Description Int32 size Size Int32 scale Scale Returns Type Description IProcedureParameterFlag SQL expression mapping flag | Improve this Doc View Source UdtDataType(String) User defined type mapping Declaration IProcedureParameterFlag UdtDataType(string sqlTypeName) Parameters Type Name Description String sqlTypeName UDT SQL type name Returns Type Description IProcedureParameterFlag Procedure parameter mapping flag | Improve this Doc View Source UdtDataType(String, String) User defined type mapping Declaration IProcedureParameterFlag UdtDataType(string sqlTypeName, string elementSqlTypeName) Parameters Type Name Description String sqlTypeName UDT SQL type name String elementSqlTypeName UDT type element type name Returns Type Description IProcedureParameterFlag Procedure parameter mapping flag Extension Methods SerializationExtensions.ToXml<T>(T) CollectionsExtensions.SetValue<TKey, T>(TKey, T) CollectionsExtensions.AsEnum<T>(T) DataObjectQueryableExtensions.CompareVariable(Object, FilterOperation, String) Processing.Do<T>(T, Action<IProcess<T>>[]) TypeExtensions.TryConvert<T, TResult>(T, Func<T, TResult>) TypeExtensions.TryConvert<T, TResult>(T, Func<T, TResult>, TResult) TypeExtensions.ChangeType<T>(Object) TypeExtensions.ChangeType(Object, Type) TypeExtensions.InvokeMethod<TRet>(Object, Type[], Expression<Func<TRet>>, BindingFlags) TypeExtensions.InvokeMethod(Object, Type[], Expression<Action>, BindingFlags) TypeExtensions.InvokeMethod<TRet>(Object, Expression<Func<TRet>>, BindingFlags) TypeExtensions.InvokeMethod(Object, Expression<Action>, BindingFlags) SqlBlockExtensions.SetExpression<TTag, TResult>(TTag, Expression<Func<IBlockQueryAdapter, TResult>>) QueryDescriptionExtensions.SetExpression<TTag, TResult>(TTag, Expression<Func<IQueryStructureAdapter, TResult>>)"
  },
  "api/XData.Mapping.Dynamic.IParameterDescription.html": {
    "href": "api/XData.Mapping.Dynamic.IParameterDescription.html",
    "title": "Interface IParameterDescription | XData website",
    "keywords": "Interface IParameterDescription Dynamic stored procedure parameter description Namespace : XData.Mapping.Dynamic Assembly : XData.docfx.dll Syntax public interface IParameterDescription Properties | Improve this Doc View Source Alias Procedure source alias Declaration string Alias { get; } Property Value Type Description String | Improve this Doc View Source Binding Parameter value binding Declaration string Binding { get; } Property Value Type Description String | Improve this Doc View Source DbType Parameter database type Declaration DbType DbType { get; } Property Value Type Description DbType | Improve this Doc View Source DefaultValue Default parameter value Declaration object DefaultValue { get; } Property Value Type Description Object | Improve this Doc View Source DefaultValueType Default parameter value type Declaration DefaultType DefaultValueType { get; } Property Value Type Description DefaultType | Improve this Doc View Source Direction Parameter direction Declaration ParameterDirection Direction { get; } Property Value Type Description ParameterDirection | Improve this Doc View Source Name Parameter name Declaration string Name { get; } Property Value Type Description String | Improve this Doc View Source NativeSqlType Native SQL type name Declaration string NativeSqlType { get; } Property Value Type Description String Remarks Used to specify native SQL column type when conflicted with default type mapping WARNING! May be not supported by database adapter! | Improve this Doc View Source Order Parameter order Declaration int Order { get; } Property Value Type Description Int32 | Improve this Doc View Source Scale Parameter scale Declaration int Scale { get; } Property Value Type Description Int32 | Improve this Doc View Source Size Parameter size Declaration int Size { get; } Property Value Type Description Int32 | Improve this Doc View Source Type Parameter mapped type Declaration Type Type { get; } Property Value Type Description Type | Improve this Doc View Source TypeIsArray Parameter mapped type is array Declaration bool TypeIsArray { get; } Property Value Type Description Boolean | Improve this Doc View Source UdtSqlType Parameter SQL user defined type (UDT) description Declaration UdtSqlType UdtSqlType { get; } Property Value Type Description UdtSqlType | Improve this Doc View Source Value Parameter value Declaration object Value { get; } Property Value Type Description Object Methods | Improve this Doc View Source Clone() Clone parameter description Declaration IParameterDescription Clone() Returns Type Description IParameterDescription Cloned parameter | Improve this Doc View Source GetValue<T>() Returns parameter value Declaration T GetValue<T>() Returns Type Description T Parameter value Type Parameters Name Description T Parameter mapped type Extension Methods SerializationExtensions.ToXml<T>(T) CollectionsExtensions.SetValue<TKey, T>(TKey, T) CollectionsExtensions.AsEnum<T>(T) DataObjectQueryableExtensions.CompareVariable(Object, FilterOperation, String) Processing.Do<T>(T, Action<IProcess<T>>[]) TypeExtensions.TryConvert<T, TResult>(T, Func<T, TResult>) TypeExtensions.TryConvert<T, TResult>(T, Func<T, TResult>, TResult) TypeExtensions.ChangeType<T>(Object) TypeExtensions.ChangeType(Object, Type) TypeExtensions.InvokeMethod<TRet>(Object, Type[], Expression<Func<TRet>>, BindingFlags) TypeExtensions.InvokeMethod(Object, Type[], Expression<Action>, BindingFlags) TypeExtensions.InvokeMethod<TRet>(Object, Expression<Func<TRet>>, BindingFlags) TypeExtensions.InvokeMethod(Object, Expression<Action>, BindingFlags) SqlBlockExtensions.SetExpression<TTag, TResult>(TTag, Expression<Func<IBlockQueryAdapter, TResult>>) QueryDescriptionExtensions.SetExpression<TTag, TResult>(TTag, Expression<Func<IQueryStructureAdapter, TResult>>)"
  },
  "api/XData.Mapping.Dynamic.ILinkPropertyMappingAdapter-1.html": {
    "href": "api/XData.Mapping.Dynamic.ILinkPropertyMappingAdapter-1.html",
    "title": "Interface ILinkPropertyMappingAdapter<T> | XData website",
    "keywords": "Interface ILinkPropertyMappingAdapter<T> Link property mapping adapter Inherited Members IRepositoryReadOnlyPropertyMappingAdapter.ConcurrencyToken() IRepositoryReadOnlyPropertyMappingAdapter.OuterFlag() IPropertyMappingAdapter.Key() IPropertyMappingAdapter.Group(DataGrouping) IPropertyMappingAdapter.Group(Int32) IPropertyMappingAdapter.Hidden() IPropertyMappingAdapter.OrderBy(Int32, Boolean) IPropertyMappingAdapter.OrderBy(Int32) Namespace : XData.Mapping.Dynamic Assembly : XData.docfx.dll Syntax public interface ILinkPropertyMappingAdapter<T> : IRepositoryReadOnlyPropertyMappingAdapter, IPropertyMappingAdapter where T : class, ISqlObject, new() Type Parameters Name Description T Data object type Methods | Improve this Doc View Source LinkProperty() Link property data association property Declaration IStructureFlag LinkProperty() Returns Type Description IStructureFlag Property link description | Improve this Doc View Source LinkProperty<TSource>(Expression<Func<TSource, Object>>) Link property data association property Declaration IStructureFlag LinkProperty<TSource>(Expression<Func<TSource, object>> source) where TSource : class, IDataObject, new() Parameters Type Name Description Expression < Func <TSource, Object >> source Source dictionary property Returns Type Description IStructureFlag Property link description Type Parameters Name Description TSource Source dictionary type | Improve this Doc View Source LinkProperty<TSource>(Expression<Func<TSource, Object>>, Expression<Func<T, Object>>) Link property data association property Declaration IStructureFlag LinkProperty<TSource>(Expression<Func<TSource, object>> source, Expression<Func<T, object>> property) where TSource : class, IDataObject, new() Parameters Type Name Description Expression < Func <TSource, Object >> source Source dictionary property Expression < Func <T, Object >> property Property Returns Type Description IStructureFlag Property link description Type Parameters Name Description TSource Source dictionary type | Improve this Doc View Source LinkProperty<TSource>(Expression<Func<T, Object>>) Link property data association property Declaration IStructureFlag LinkProperty<TSource>(Expression<Func<T, object>> property) where TSource : class, IDataObject, new() Parameters Type Name Description Expression < Func <T, Object >> property Property Returns Type Description IStructureFlag Property link description Type Parameters Name Description TSource Source dictionary type Extension Methods SerializationExtensions.ToXml<T>(T) CollectionsExtensions.SetValue<TKey, T>(TKey, T) CollectionsExtensions.AsEnum<T>(T) DataObjectQueryableExtensions.CompareVariable(Object, FilterOperation, String) Processing.Do<T>(T, Action<IProcess<T>>[]) TypeExtensions.TryConvert<T, TResult>(T, Func<T, TResult>) TypeExtensions.TryConvert<T, TResult>(T, Func<T, TResult>, TResult) TypeExtensions.ChangeType<T>(Object) TypeExtensions.ChangeType(Object, Type) TypeExtensions.InvokeMethod<TRet>(Object, Type[], Expression<Func<TRet>>, BindingFlags) TypeExtensions.InvokeMethod(Object, Type[], Expression<Action>, BindingFlags) TypeExtensions.InvokeMethod<TRet>(Object, Expression<Func<TRet>>, BindingFlags) TypeExtensions.InvokeMethod(Object, Expression<Action>, BindingFlags) SqlBlockExtensions.SetExpression<TTag, TResult>(TTag, Expression<Func<IBlockQueryAdapter, TResult>>) QueryDescriptionExtensions.SetExpression<TTag, TResult>(TTag, Expression<Func<IQueryStructureAdapter, TResult>>)"
  },
  "api/XData.DataSource.Structure.DataQueryState.html": {
    "href": "api/XData.DataSource.Structure.DataQueryState.html",
    "title": "Class DataQueryState | XData website",
    "keywords": "Class DataQueryState Data query state Inheritance Object DataQueryState RepositoryState Inherited Members Object.Equals(Object) Object.Equals(Object, Object) Object.GetHashCode() Object.GetType() Object.MemberwiseClone() Object.ReferenceEquals(Object, Object) Namespace : XData.DataSource.Structure Assembly : XData.docfx.dll Syntax [Serializable] [DataContract] public class DataQueryState Properties | Improve this Doc View Source AssemblyName Element type assembly name Declaration [DataMember] public string AssemblyName { get; set; } Property Value Type Description String | Improve this Doc View Source Context Context Declaration [DataMember] public string Context { get; set; } Property Value Type Description String | Improve this Doc View Source ElementType Element type name Declaration [DataMember] public string ElementType { get; set; } Property Value Type Description String | Improve this Doc View Source Structure DataStructure Declaration [DataMember] public DataStructureState Structure { get; set; } Property Value Type Description DataStructureState Methods | Improve this Doc View Source ToString() Returns a String that represents the current Object . Declaration public override string ToString() Returns Type Description String A String that represents the current Object . Overrides Object.ToString() Extension Methods SerializationExtensions.ToXml<T>(T) CollectionsExtensions.SetValue<TKey, T>(TKey, T) CollectionsExtensions.AsEnum<T>(T) DataObjectQueryableExtensions.CompareVariable(Object, FilterOperation, String) Processing.Do<T>(T, Action<IProcess<T>>[]) TypeExtensions.TryConvert<T, TResult>(T, Func<T, TResult>) TypeExtensions.TryConvert<T, TResult>(T, Func<T, TResult>, TResult) TypeExtensions.ChangeType<T>(Object) TypeExtensions.ChangeType(Object, Type) TypeExtensions.InvokeMethod<TRet>(Object, Type[], Expression<Func<TRet>>, BindingFlags) TypeExtensions.InvokeMethod(Object, Type[], Expression<Action>, BindingFlags) TypeExtensions.InvokeMethod<TRet>(Object, Expression<Func<TRet>>, BindingFlags) TypeExtensions.InvokeMethod(Object, Expression<Action>, BindingFlags) SqlBlockExtensions.SetExpression<TTag, TResult>(TTag, Expression<Func<IBlockQueryAdapter, TResult>>) QueryDescriptionExtensions.SetExpression<TTag, TResult>(TTag, Expression<Func<IQueryStructureAdapter, TResult>>)"
  },
  "api/XData.DataObjectState.html": {
    "href": "api/XData.DataObjectState.html",
    "title": "Enum DataObjectState | XData website",
    "keywords": "Enum DataObjectState Data object instance state Namespace : XData Assembly : XData.docfx.dll Syntax [Flags] [DataContract] public enum DataObjectState Fields Name Description Changed Original data values are changed Deleted Instance is marked for delete Ghost Instance is deleted New New instance flag Original Original data values has no changes See Also GetState<T> (T) CheckState<T> (T, DataObjectState ) SetDeleted<T> (T, Boolean ) Original New Changed Deleted Ghost Extension Methods SerializationExtensions.ToXml<DataObjectState>() CollectionsExtensions.SetValue<DataObjectState, T>(T) CollectionsExtensions.AsEnum<DataObjectState>() DataObjectQueryableExtensions.CompareVariable(FilterOperation, String) Processing.Do<DataObjectState>(Action<IProcess<DataObjectState>>[]) TypeExtensions.ChangeType<T>() TypeExtensions.ChangeType(Type) TypeExtensions.InvokeMethod<TRet>(Type[], Expression<Func<TRet>>, BindingFlags) TypeExtensions.InvokeMethod(Type[], Expression<Action>, BindingFlags) TypeExtensions.InvokeMethod<TRet>(Expression<Func<TRet>>, BindingFlags) TypeExtensions.InvokeMethod(Expression<Action>, BindingFlags) TypeExtensions.ConvertTo<T>() TypeExtensions.EqualValue(Enum) SqlBlockExtensions.SetExpression<DataObjectState, TResult>(Expression<Func<IBlockQueryAdapter, TResult>>) QueryDescriptionExtensions.SetExpression<DataObjectState, TResult>(Expression<Func<IQueryStructureAdapter, TResult>>)"
  },
  "api/XData.Database.SqlBlock.SqlBlockDefinition-1.html": {
    "href": "api/XData.Database.SqlBlock.SqlBlockDefinition-1.html",
    "title": "Delegate SqlBlockDefinition<T> | XData website",
    "keywords": "Delegate SqlBlockDefinition<T> SQL block definition expression type Namespace : XData.Database.SqlBlock Assembly : XData.docfx.dll Syntax public delegate ISqlBlock SqlBlockDefinition<T>(ISqlBlockAdapter<T> adapter) where T : class, new(); Parameters Type Name Description ISqlBlockAdapter <T> adapter SQL block adapter typed interface Returns Type Description ISqlBlock SQL block definition Type Parameters Name Description T SQL block result mapped type Extension Methods SerializationExtensions.ToXml<T>(T) CollectionsExtensions.SetValue<TKey, T>(TKey, T) CollectionsExtensions.AsEnum<T>(T) DataObjectQueryableExtensions.CompareVariable(Object, FilterOperation, String) Processing.Do<T>(T, Action<IProcess<T>>[]) TypeExtensions.TryConvert<T, TResult>(T, Func<T, TResult>) TypeExtensions.TryConvert<T, TResult>(T, Func<T, TResult>, TResult) TypeExtensions.ChangeType<T>(Object) TypeExtensions.ChangeType(Object, Type) TypeExtensions.InvokeMethod<TRet>(Object, Type[], Expression<Func<TRet>>, BindingFlags) TypeExtensions.InvokeMethod(Object, Type[], Expression<Action>, BindingFlags) TypeExtensions.InvokeMethod<TRet>(Object, Expression<Func<TRet>>, BindingFlags) TypeExtensions.InvokeMethod(Object, Expression<Action>, BindingFlags) SqlBlockExtensions.SetExpression<TTag, TResult>(TTag, Expression<Func<IBlockQueryAdapter, TResult>>) QueryDescriptionExtensions.SetExpression<TTag, TResult>(TTag, Expression<Func<IQueryStructureAdapter, TResult>>)"
  },
  "api/XData.Database.SqlBlock.ISqlParamAdapter.html": {
    "href": "api/XData.Database.SqlBlock.ISqlParamAdapter.html",
    "title": "Interface ISqlParamAdapter | XData website",
    "keywords": "Interface ISqlParamAdapter Adapter to describe SQL block parameters Namespace : XData.Database.SqlBlock Assembly : XData.docfx.dll Syntax public interface ISqlParamAdapter Methods | Improve this Doc View Source Param<T>(String, DbType) SQL block parameter Declaration ISqlParam Param<T>(string name, DbType dbType) Parameters Type Name Description String name Parameter name DbType dbType Parameter database type Returns Type Description ISqlParam SQL block parameter description Type Parameters Name Description T Parameter mapped type | Improve this Doc View Source Param<T>(String, DbType, Int32) SQL block parameter Declaration ISqlParam Param<T>(string name, DbType dbType, int length) Parameters Type Name Description String name Parameter name DbType dbType Parameter database type Int32 length Parameter length Returns Type Description ISqlParam SQL block parameter description Type Parameters Name Description T Parameter mapped typ | Improve this Doc View Source Param<T>(String, DbType, String) SQL block parameter Declaration ISqlParam Param<T>(string name, DbType dbType, string nativeSqlType) Parameters Type Name Description String name Parameter name DbType dbType Parameter database type String nativeSqlType Parameter native SQL type Returns Type Description ISqlParam SQL block parameter description Type Parameters Name Description T Parameter mapped typ | Improve this Doc View Source Param<T>(String, DbType, String, Int32) SQL block parameter Declaration ISqlParam Param<T>(string name, DbType dbType, string nativeSqlType, int length) Parameters Type Name Description String name Parameter name DbType dbType Parameter database type String nativeSqlType Parameter native SQL type Int32 length Parameter length Returns Type Description ISqlParam SQL block parameter description Type Parameters Name Description T Parameter mapped typ | Improve this Doc View Source Param<T>(String, SqlType) SQL block parameter Declaration ISqlParam Param<T>(string name, SqlType type) Parameters Type Name Description String name Parameter name SqlType type Parameter type Returns Type Description ISqlParam SQL block parameter description Type Parameters Name Description T Parameter mapped type Extension Methods SerializationExtensions.ToXml<T>(T) CollectionsExtensions.SetValue<TKey, T>(TKey, T) CollectionsExtensions.AsEnum<T>(T) DataObjectQueryableExtensions.CompareVariable(Object, FilterOperation, String) Processing.Do<T>(T, Action<IProcess<T>>[]) TypeExtensions.TryConvert<T, TResult>(T, Func<T, TResult>) TypeExtensions.TryConvert<T, TResult>(T, Func<T, TResult>, TResult) TypeExtensions.ChangeType<T>(Object) TypeExtensions.ChangeType(Object, Type) TypeExtensions.InvokeMethod<TRet>(Object, Type[], Expression<Func<TRet>>, BindingFlags) TypeExtensions.InvokeMethod(Object, Type[], Expression<Action>, BindingFlags) TypeExtensions.InvokeMethod<TRet>(Object, Expression<Func<TRet>>, BindingFlags) TypeExtensions.InvokeMethod(Object, Expression<Action>, BindingFlags) SqlBlockExtensions.SetExpression<TTag, TResult>(TTag, Expression<Func<IBlockQueryAdapter, TResult>>) QueryDescriptionExtensions.SetExpression<TTag, TResult>(TTag, Expression<Func<IQueryStructureAdapter, TResult>>)"
  },
  "api/XData.Exceptions.XDataRuntimeExceptionType.html": {
    "href": "api/XData.Exceptions.XDataRuntimeExceptionType.html",
    "title": "Enum XDataRuntimeExceptionType | XData website",
    "keywords": "Enum XDataRuntimeExceptionType XData runtime exception type Namespace : XData.Exceptions Assembly : XData.docfx.dll Syntax public enum XDataRuntimeExceptionType Fields Name Description ArgumentError Argument error AssemblyNotFoundError Assembly not found by path AttachedHandlersNotFoundError Attached handlers collection not found CustomActionAttributeNotFoundError CustomActionAttribute not found CustomLogicError Custom logic error DataConversionError Data conversion error DataMappingAttributeNotFoundError Data mapping attribute not found DataMappingError Data mapping error FunctionLockedError Function is locked GetIndexedAttributeError IndexedAttribute not found GetOriginalDataError Original data not found GetPropertyValueError Property not found GetRepositoryError Object not attached to repository GetSerializedDataFieldError SerializedData field not found GetStateError Object state not found PropertyIsReadOnlyError Property is read only RepositoryIsReadOnlyError Repository marked as read only ServerCallError XData Application Server call error SessionCreationFailedError Application server session creation failed SessionNotFoundError Application server session not found TypeLoadingError Type loading error TypeNotFoundError Type not found in assembly WorkSetError Work set data access error Extension Methods SerializationExtensions.ToXml<XDataRuntimeExceptionType>() CollectionsExtensions.SetValue<XDataRuntimeExceptionType, T>(T) CollectionsExtensions.AsEnum<XDataRuntimeExceptionType>() DataObjectQueryableExtensions.CompareVariable(FilterOperation, String) Processing.Do<XDataRuntimeExceptionType>(Action<IProcess<XDataRuntimeExceptionType>>[]) TypeExtensions.ChangeType<T>() TypeExtensions.ChangeType(Type) TypeExtensions.InvokeMethod<TRet>(Type[], Expression<Func<TRet>>, BindingFlags) TypeExtensions.InvokeMethod(Type[], Expression<Action>, BindingFlags) TypeExtensions.InvokeMethod<TRet>(Expression<Func<TRet>>, BindingFlags) TypeExtensions.InvokeMethod(Expression<Action>, BindingFlags) TypeExtensions.ConvertTo<T>() TypeExtensions.EqualValue(Enum) SqlBlockExtensions.SetExpression<XDataRuntimeExceptionType, TResult>(Expression<Func<IBlockQueryAdapter, TResult>>) QueryDescriptionExtensions.SetExpression<XDataRuntimeExceptionType, TResult>(Expression<Func<IQueryStructureAdapter, TResult>>)"
  },
  "api/XData.Exceptions.AdditionalInfo.html": {
    "href": "api/XData.Exceptions.AdditionalInfo.html",
    "title": "Class AdditionalInfo | XData website",
    "keywords": "Class AdditionalInfo Exception and log additional info Inheritance Object AdditionalInfo Inherited Members Object.Equals(Object) Object.Equals(Object, Object) Object.GetHashCode() Object.GetType() Object.MemberwiseClone() Object.ReferenceEquals(Object, Object) Object.ToString() Namespace : XData.Exceptions Assembly : XData.docfx.dll Syntax [Serializable] public sealed class AdditionalInfo Properties | Improve this Doc View Source Name Additional info name Declaration public string Name { get; set; } Property Value Type Description String | Improve this Doc View Source Value Additional info value Declaration public object Value { get; set; } Property Value Type Description Object Operators | Improve this Doc View Source Implicit(KeyValuePair<String, Object> to AdditionalInfo) Exception additional info Declaration public static implicit operator AdditionalInfo(KeyValuePair<string, object> source) Parameters Type Name Description KeyValuePair < String , Object > source Source key value pair Returns Type Description AdditionalInfo Exception additional info | Improve this Doc View Source Implicit(KeyValuePair<String, String> to AdditionalInfo) Exception additional info Declaration public static implicit operator AdditionalInfo(KeyValuePair<string, string> source) Parameters Type Name Description KeyValuePair < String , String > source Source key value pair Returns Type Description AdditionalInfo Exception additional info Extension Methods SerializationExtensions.ToXml<T>(T) CollectionsExtensions.SetValue<TKey, T>(TKey, T) CollectionsExtensions.AsEnum<T>(T) DataObjectQueryableExtensions.CompareVariable(Object, FilterOperation, String) Processing.Do<T>(T, Action<IProcess<T>>[]) TypeExtensions.TryConvert<T, TResult>(T, Func<T, TResult>) TypeExtensions.TryConvert<T, TResult>(T, Func<T, TResult>, TResult) TypeExtensions.ChangeType<T>(Object) TypeExtensions.ChangeType(Object, Type) TypeExtensions.InvokeMethod<TRet>(Object, Type[], Expression<Func<TRet>>, BindingFlags) TypeExtensions.InvokeMethod(Object, Type[], Expression<Action>, BindingFlags) TypeExtensions.InvokeMethod<TRet>(Object, Expression<Func<TRet>>, BindingFlags) TypeExtensions.InvokeMethod(Object, Expression<Action>, BindingFlags) SqlBlockExtensions.SetExpression<TTag, TResult>(TTag, Expression<Func<IBlockQueryAdapter, TResult>>) QueryDescriptionExtensions.SetExpression<TTag, TResult>(TTag, Expression<Func<IQueryStructureAdapter, TResult>>)"
  },
  "api/XData.DialectOptions.html": {
    "href": "api/XData.DialectOptions.html",
    "title": "Enum DialectOptions | XData website",
    "keywords": "Enum DialectOptions SQL dialect options Namespace : XData Assembly : XData.docfx.dll Syntax [Flags] public enum DialectOptions : ulong Fields Name Description CheckConcurrencySupport Concurrency check supported ClearByRowIdArrays Clear statement used row id arrays InternalErrorCatch Concurrency SQL errors are handled and jammed in provider MultipleRecordsetProceduresSupported Multiple record set stored procedures are supported None No specific SQL dialect options declared ObjectParametersSupported User defined objects (UDT) are supported as procedure/function parameter types RegisterRecordsetRequired Output record set registering is required ReturningInResult Insert returned identity value as query result RowIteratorSupported Row iterator is supported SafeTypeConvert Safe type conversion required ScalarFunctionsOutParametersAllowed Scalar-valued SQL functions OUT parameters are supported ScalarFunctionsSupported Scalar-valued SQL functions are supported SequenceRequired Sequence is required to auto increment fields SequenceSupported Sequences are supported SqlBlockOuterTableVariables Sql block can operate with table variables out of block only StoredProcedureResultAsExecuteScalar SQL function result value returned as Execute scalar result StoredProcedureResultFetch Stored procedure results fetched by multiple reader execute StoredProceduresSupported SQL stored procedures are supported TableFunctionsSupported Table-valued SQL functions are supported TableOutParametersAllowed Table types are supported as procedure/function OUT parameter types TableParametersSupported Table types are supported as procedure/function parameter types TempTableNotSupported Temp Table is not supported UdtAsReturnValueSupported SQL function can return UDT or Arrays UpdateSubqueryFields Update can use subquery fields as update source values and target fields UpdateTableNotInFrom Update table is part of update (or delete) statement and not listed in from statement UpdateTableNotUseAlias Update and delete statements only for one table and not use table alias UpdateUseTableNames Update not use table aliases but lower case table names WithInsideSubqueryNotSupported Common-Table-Expression (WITH) queries not supported inside subqueries WithSupported Common-Table-Expression (WITH) queries are supported WithUnionNotSupported Common-Table-Expression (WITH) recursive queries combination with UNION operation not supported XmlSourceSupported XML data source is supported Extension Methods SerializationExtensions.ToXml<DialectOptions>() CollectionsExtensions.SetValue<DialectOptions, T>(T) CollectionsExtensions.AsEnum<DialectOptions>() DataObjectQueryableExtensions.CompareVariable(FilterOperation, String) Processing.Do<DialectOptions>(Action<IProcess<DialectOptions>>[]) TypeExtensions.ChangeType<T>() TypeExtensions.ChangeType(Type) TypeExtensions.InvokeMethod<TRet>(Type[], Expression<Func<TRet>>, BindingFlags) TypeExtensions.InvokeMethod(Type[], Expression<Action>, BindingFlags) TypeExtensions.InvokeMethod<TRet>(Expression<Func<TRet>>, BindingFlags) TypeExtensions.InvokeMethod(Expression<Action>, BindingFlags) TypeExtensions.ConvertTo<T>() TypeExtensions.EqualValue(Enum) SqlBlockExtensions.SetExpression<DialectOptions, TResult>(Expression<Func<IBlockQueryAdapter, TResult>>) QueryDescriptionExtensions.SetExpression<DialectOptions, TResult>(Expression<Func<IQueryStructureAdapter, TResult>>)"
  },
  "api/XData.Mapping.Dynamic.ISubqueryLinkAdapter.html": {
    "href": "api/XData.Mapping.Dynamic.ISubqueryLinkAdapter.html",
    "title": "Interface ISubqueryLinkAdapter | XData website",
    "keywords": "Interface ISubqueryLinkAdapter Subquery link filter description adapter Inherited Members IFilterAdapter.Combination(String, Combination, String) IFilterAdapter.Combination(String, Combination) Namespace : XData.Mapping.Dynamic Assembly : XData.docfx.dll Syntax public interface ISubqueryLinkAdapter : IFilterAdapter Methods | Improve this Doc View Source SubqueryLink(String) Subquery link filter description Declaration IFilterDescription SubqueryLink(string subqueryProperty) Parameters Type Name Description String subqueryProperty Subquery property name to link with Returns Type Description IFilterDescription Filter description | Improve this Doc View Source SubqueryLink(String, String) Subquery link filter description Declaration IFilterDescription SubqueryLink(string subqueryProperty, string property) Parameters Type Name Description String subqueryProperty Subquery property name to link with String property Base query property name to link with Returns Type Description IFilterDescription Filter description Extension Methods SerializationExtensions.ToXml<T>(T) CollectionsExtensions.SetValue<TKey, T>(TKey, T) CollectionsExtensions.AsEnum<T>(T) DataObjectQueryableExtensions.CompareVariable(Object, FilterOperation, String) Processing.Do<T>(T, Action<IProcess<T>>[]) TypeExtensions.TryConvert<T, TResult>(T, Func<T, TResult>) TypeExtensions.TryConvert<T, TResult>(T, Func<T, TResult>, TResult) TypeExtensions.ChangeType<T>(Object) TypeExtensions.ChangeType(Object, Type) TypeExtensions.InvokeMethod<TRet>(Object, Type[], Expression<Func<TRet>>, BindingFlags) TypeExtensions.InvokeMethod(Object, Type[], Expression<Action>, BindingFlags) TypeExtensions.InvokeMethod<TRet>(Object, Expression<Func<TRet>>, BindingFlags) TypeExtensions.InvokeMethod(Object, Expression<Action>, BindingFlags) SqlBlockExtensions.SetExpression<TTag, TResult>(TTag, Expression<Func<IBlockQueryAdapter, TResult>>) QueryDescriptionExtensions.SetExpression<TTag, TResult>(TTag, Expression<Func<IQueryStructureAdapter, TResult>>)"
  },
  "api/XData.DataSource.Structure.IRuntimeFilter.html": {
    "href": "api/XData.DataSource.Structure.IRuntimeFilter.html",
    "title": "Interface IRuntimeFilter | XData website",
    "keywords": "Interface IRuntimeFilter Runtime filter interface Inherited Members INamedFilter.Name IOptionalFilter.Primary IFilter.FilterType IFilter.SourceAlias IFilter.Field IFilter.Operation ICloneable.Clone() Namespace : XData.DataSource.Structure Assembly : XData.docfx.dll Syntax public interface IRuntimeFilter : INamedFilter, IOptionalFilter, IFilter, ICloneable Properties | Improve this Doc View Source Nullable Null value handling Declaration FilterNullable Nullable { get; } Property Value Type Description FilterNullable Methods | Improve this Doc View Source GetCaption() Filter caption Declaration string GetCaption() Returns Type Description String Extension Methods SerializationExtensions.ToXml<T>(T) CollectionsExtensions.SetValue<TKey, T>(TKey, T) CollectionsExtensions.AsEnum<T>(T) DataObjectQueryableExtensions.CompareVariable(Object, FilterOperation, String) Processing.Do<T>(T, Action<IProcess<T>>[]) TypeExtensions.TryConvert<T, TResult>(T, Func<T, TResult>) TypeExtensions.TryConvert<T, TResult>(T, Func<T, TResult>, TResult) TypeExtensions.ChangeType<T>(Object) TypeExtensions.ChangeType(Object, Type) TypeExtensions.InvokeMethod<TRet>(Object, Type[], Expression<Func<TRet>>, BindingFlags) TypeExtensions.InvokeMethod(Object, Type[], Expression<Action>, BindingFlags) TypeExtensions.InvokeMethod<TRet>(Object, Expression<Func<TRet>>, BindingFlags) TypeExtensions.InvokeMethod(Object, Expression<Action>, BindingFlags) SqlBlockExtensions.SetExpression<TTag, TResult>(TTag, Expression<Func<IBlockQueryAdapter, TResult>>) QueryDescriptionExtensions.SetExpression<TTag, TResult>(TTag, Expression<Func<IQueryStructureAdapter, TResult>>)"
  },
  "api/XData.DataSource.Structure.IDataSource.html": {
    "href": "api/XData.DataSource.Structure.IDataSource.html",
    "title": "Interface IDataSource | XData website",
    "keywords": "Interface IDataSource Data object source Inherited Members ICloneable.Clone() Namespace : XData.DataSource.Structure Assembly : XData.docfx.dll Syntax public interface IDataSource : ICloneable Properties | Improve this Doc View Source Alias Source alias Declaration string Alias { get; } Property Value Type Description String | Improve this Doc View Source IsBase Base table flag Declaration bool IsBase { get; } Property Value Type Description Boolean | Improve this Doc View Source SourceType Source type Declaration DataSourceType SourceType { get; } Property Value Type Description DataSourceType Methods | Improve this Doc View Source GetField(String, String, out String, out String) Returns property field Declaration IField GetField(string sourceAlias, string fieldName, out string alias, out string fullName) Parameters Type Name Description String sourceAlias Source alias String fieldName Field name String alias Relative source alias String fullName Relative field full name Returns Type Description IField Field object | Improve this Doc View Source GetField(String, out String, out String) Returns property field Declaration IField GetField(string propertyName, out string alias, out string fieldName) Parameters Type Name Description String propertyName Property name String alias Relative source alias String fieldName Relative field full name Returns Type Description IField Field object | Improve this Doc View Source GetFields() Returns selected fields Declaration IEnumerable<SelectedField> GetFields() Returns Type Description IEnumerable < SelectedField > Selected fields list | Improve this Doc View Source GetFields(Type) Returns selected fields of subquery with type Declaration IEnumerable<SelectedField> GetFields(Type type) Parameters Type Name Description Type type Returns Type Description IEnumerable < SelectedField > Selected fields list Extension Methods SerializationExtensions.ToXml<T>(T) CollectionsExtensions.SetValue<TKey, T>(TKey, T) CollectionsExtensions.AsEnum<T>(T) DataObjectQueryableExtensions.CompareVariable(Object, FilterOperation, String) Processing.Do<T>(T, Action<IProcess<T>>[]) TypeExtensions.TryConvert<T, TResult>(T, Func<T, TResult>) TypeExtensions.TryConvert<T, TResult>(T, Func<T, TResult>, TResult) TypeExtensions.ChangeType<T>(Object) TypeExtensions.ChangeType(Object, Type) TypeExtensions.InvokeMethod<TRet>(Object, Type[], Expression<Func<TRet>>, BindingFlags) TypeExtensions.InvokeMethod(Object, Type[], Expression<Action>, BindingFlags) TypeExtensions.InvokeMethod<TRet>(Object, Expression<Func<TRet>>, BindingFlags) TypeExtensions.InvokeMethod(Object, Expression<Action>, BindingFlags) SqlBlockExtensions.SetExpression<TTag, TResult>(TTag, Expression<Func<IBlockQueryAdapter, TResult>>) QueryDescriptionExtensions.SetExpression<TTag, TResult>(TTag, Expression<Func<IQueryStructureAdapter, TResult>>)"
  },
  "api/XData.Mapping.Lob.html": {
    "href": "api/XData.Mapping.Lob.html",
    "title": "Class Lob | XData website",
    "keywords": "Class Lob Blob field wrapper Inheritance Object Lob Inherited Members Object.Equals(Object) Object.Equals(Object, Object) Object.GetHashCode() Object.GetType() Object.MemberwiseClone() Object.ReferenceEquals(Object, Object) Object.ToString() Namespace : XData.Mapping Assembly : XData.docfx.dll Syntax public abstract class Lob Examples // declaration [Property(\"scan\", \"SC\", Flags = DataPropertyFlag.OuterFlag)] public Lob Scan { get; set; } // using byte[] scan = GetScanFileBody(); newInvoice.Scan += scan; // is the same as newInvoice.Scan.Value = scan; Properties | Improve this Doc View Source Assigned Blob is value is changed from null value Declaration public abstract bool Assigned { get; } Property Value Type Description Boolean | Improve this Doc View Source Cleared Blob is value is cleared Declaration public abstract bool Cleared { get; } Property Value Type Description Boolean | Improve this Doc View Source EmptyKeys Blob table keys are empty Declaration public abstract bool EmptyKeys { get; } Property Value Type Description Boolean | Improve this Doc View Source Value Blob value Declaration public abstract byte[] Value { get; set; } Property Value Type Description Byte [] Methods | Improve this Doc View Source GetSize() Returns Lob size Declaration public abstract long GetSize() Returns Type Description Int64 Operators | Improve this Doc View Source Addition(Lob, Byte[]) Set Lob value Declaration public static Lob operator +(Lob lob, byte[] body) Parameters Type Name Description Lob lob Lob Byte [] body Lob body Returns Type Description Lob Updated lob | Improve this Doc View Source Implicit(Lob to Byte[]) Implicit Lob body extraction Declaration public static implicit operator byte[](Lob lob) Parameters Type Name Description Lob lob Lob property Returns Type Description Byte [] Lob body Extension Methods DataObjectExtensions.Modify(Lob, Action<Byte[]>) SerializationExtensions.ToXml<T>(T) CollectionsExtensions.SetValue<TKey, T>(TKey, T) CollectionsExtensions.AsEnum<T>(T) DataObjectQueryableExtensions.CompareVariable(Object, FilterOperation, String) Processing.Do<T>(T, Action<IProcess<T>>[]) TypeExtensions.TryConvert<T, TResult>(T, Func<T, TResult>) TypeExtensions.TryConvert<T, TResult>(T, Func<T, TResult>, TResult) TypeExtensions.ChangeType<T>(Object) TypeExtensions.ChangeType(Object, Type) TypeExtensions.InvokeMethod<TRet>(Object, Type[], Expression<Func<TRet>>, BindingFlags) TypeExtensions.InvokeMethod(Object, Type[], Expression<Action>, BindingFlags) TypeExtensions.InvokeMethod<TRet>(Object, Expression<Func<TRet>>, BindingFlags) TypeExtensions.InvokeMethod(Object, Expression<Action>, BindingFlags) SqlBlockExtensions.SetExpression<TTag, TResult>(TTag, Expression<Func<IBlockQueryAdapter, TResult>>) QueryDescriptionExtensions.SetExpression<TTag, TResult>(TTag, Expression<Func<IQueryStructureAdapter, TResult>>) See Also Value Addition(Lob, Byte[]) Implicit(Lob to Byte[]) Modify ( Lob , Action < Byte []>) Assigned Cleared EmptyKeys"
  },
  "api/XData.Mapping.LinkPropertyAttribute.html": {
    "href": "api/XData.Mapping.LinkPropertyAttribute.html",
    "title": "Class LinkPropertyAttribute | XData website",
    "keywords": "Class LinkPropertyAttribute Data object link property attribute Inheritance Object Attribute LinkPropertyAttribute Inherited Members Attribute.Equals(Object) Attribute.GetCustomAttribute(Assembly, Type) Attribute.GetCustomAttribute(Assembly, Type, Boolean) Attribute.GetCustomAttribute(MemberInfo, Type) Attribute.GetCustomAttribute(MemberInfo, Type, Boolean) Attribute.GetCustomAttribute(Module, Type) Attribute.GetCustomAttribute(Module, Type, Boolean) Attribute.GetCustomAttribute(ParameterInfo, Type) Attribute.GetCustomAttribute(ParameterInfo, Type, Boolean) Attribute.GetCustomAttributes(Assembly) Attribute.GetCustomAttributes(Assembly, Boolean) Attribute.GetCustomAttributes(Assembly, Type) Attribute.GetCustomAttributes(Assembly, Type, Boolean) Attribute.GetCustomAttributes(MemberInfo) Attribute.GetCustomAttributes(MemberInfo, Boolean) Attribute.GetCustomAttributes(MemberInfo, Type) Attribute.GetCustomAttributes(MemberInfo, Type, Boolean) Attribute.GetCustomAttributes(Module) Attribute.GetCustomAttributes(Module, Boolean) Attribute.GetCustomAttributes(Module, Type) Attribute.GetCustomAttributes(Module, Type, Boolean) Attribute.GetCustomAttributes(ParameterInfo) Attribute.GetCustomAttributes(ParameterInfo, Boolean) Attribute.GetCustomAttributes(ParameterInfo, Type) Attribute.GetCustomAttributes(ParameterInfo, Type, Boolean) Attribute.GetHashCode() Attribute.IsDefaultAttribute() Attribute.IsDefined(Assembly, Type) Attribute.IsDefined(Assembly, Type, Boolean) Attribute.IsDefined(MemberInfo, Type) Attribute.IsDefined(MemberInfo, Type, Boolean) Attribute.IsDefined(Module, Type) Attribute.IsDefined(Module, Type, Boolean) Attribute.IsDefined(ParameterInfo, Type) Attribute.IsDefined(ParameterInfo, Type, Boolean) Attribute.Match(Object) Object.Equals(Object, Object) Object.GetType() Object.MemberwiseClone() Object.ReferenceEquals(Object, Object) Object.ToString() Namespace : XData.Mapping Assembly : XData.docfx.dll Syntax [AttributeUsage(AttributeTargets.Property, AllowMultiple = true)] public sealed class LinkPropertyAttribute : Attribute Remarks Used to declare source and destination properties to copy values when assigned Source Every link from DictSource to Property mast be declared as separated LinkPropertyAttribute WARNING! Applicable to Link<TVal, TSrc> typed properties only! Constructors | Improve this Doc View Source LinkPropertyAttribute(String, String) Data object link property attribute Declaration public LinkPropertyAttribute(string dictSource = null, string property = null) Parameters Type Name Description String dictSource Dictionary source object property String property Property to fill Properties | Improve this Doc View Source DictSource Dictionary source object property Declaration public string DictSource { get; } Property Value Type Description String | Improve this Doc View Source Property Property to fill Declaration public string Property { get; set; } Property Value Type Description String | Improve this Doc View Source TypeId When implemented in a derived class, gets a unique identifier for this Attribute . Declaration public override object TypeId { get; } Property Value Type Description Object An Object that is a unique identifier for the attribute. Overrides Attribute.TypeId Extension Methods SerializationExtensions.ToXml<T>(T) CollectionsExtensions.SetValue<TKey, T>(TKey, T) CollectionsExtensions.AsEnum<T>(T) DataObjectQueryableExtensions.CompareVariable(Object, FilterOperation, String) Processing.Do<T>(T, Action<IProcess<T>>[]) TypeExtensions.TryConvert<T, TResult>(T, Func<T, TResult>) TypeExtensions.TryConvert<T, TResult>(T, Func<T, TResult>, TResult) TypeExtensions.ChangeType<T>(Object) TypeExtensions.ChangeType(Object, Type) TypeExtensions.InvokeMethod<TRet>(Object, Type[], Expression<Func<TRet>>, BindingFlags) TypeExtensions.InvokeMethod(Object, Type[], Expression<Action>, BindingFlags) TypeExtensions.InvokeMethod<TRet>(Object, Expression<Func<TRet>>, BindingFlags) TypeExtensions.InvokeMethod(Object, Expression<Action>, BindingFlags) SqlBlockExtensions.SetExpression<TTag, TResult>(TTag, Expression<Func<IBlockQueryAdapter, TResult>>) QueryDescriptionExtensions.SetExpression<TTag, TResult>(TTag, Expression<Func<IQueryStructureAdapter, TResult>>)"
  },
  "api/XData.DataSource.Structure.Grouping.html": {
    "href": "api/XData.DataSource.Structure.Grouping.html",
    "title": "Class Grouping | XData website",
    "keywords": "Class Grouping Grouping element Inheritance Object Grouping Implements IEquatable < Grouping > Inherited Members Object.Equals(Object) Object.Equals(Object, Object) Object.GetHashCode() Object.GetType() Object.MemberwiseClone() Object.ReferenceEquals(Object, Object) Object.ToString() Namespace : XData.DataSource.Structure Assembly : XData.docfx.dll Syntax [Serializable] [DataContract] public sealed class Grouping : IEquatable<Grouping> Properties | Improve this Doc View Source FieldName Field name Declaration [DataMember] public string FieldName { get; set; } Property Value Type Description String | Improve this Doc View Source GroupFunction Group function Declaration [DataMember] public DataGrouping GroupFunction { get; set; } Property Value Type Description DataGrouping | Improve this Doc View Source GroupOrder Group function Declaration [DataMember] public int GroupOrder { get; set; } Property Value Type Description Int32 | Improve this Doc View Source PropertyName Property name Declaration [DataMember] public string PropertyName { get; set; } Property Value Type Description String | Improve this Doc View Source PropertyOwnerType Property owner type name Declaration [DataMember] public string PropertyOwnerType { get; set; } Property Value Type Description String | Improve this Doc View Source SourceAlias Source alias Declaration [DataMember] public string SourceAlias { get; set; } Property Value Type Description String Methods | Improve this Doc View Source Equals(Grouping) Grouping equality check Declaration public bool Equals(Grouping other) Parameters Type Name Description Grouping other Grouping instance to compare Returns Type Description Boolean Instances are contains the same data Implements System.IEquatable<T> Extension Methods SerializationExtensions.ToXml<T>(T) CollectionsExtensions.SetValue<TKey, T>(TKey, T) CollectionsExtensions.AsEnum<T>(T) DataObjectQueryableExtensions.CompareVariable(Object, FilterOperation, String) Processing.Do<T>(T, Action<IProcess<T>>[]) TypeExtensions.TryConvert<T, TResult>(T, Func<T, TResult>) TypeExtensions.TryConvert<T, TResult>(T, Func<T, TResult>, TResult) TypeExtensions.ChangeType<T>(Object) TypeExtensions.ChangeType(Object, Type) TypeExtensions.InvokeMethod<TRet>(Object, Type[], Expression<Func<TRet>>, BindingFlags) TypeExtensions.InvokeMethod(Object, Type[], Expression<Action>, BindingFlags) TypeExtensions.InvokeMethod<TRet>(Object, Expression<Func<TRet>>, BindingFlags) TypeExtensions.InvokeMethod(Object, Expression<Action>, BindingFlags) SqlBlockExtensions.SetExpression<TTag, TResult>(TTag, Expression<Func<IBlockQueryAdapter, TResult>>) QueryDescriptionExtensions.SetExpression<TTag, TResult>(TTag, Expression<Func<IQueryStructureAdapter, TResult>>)"
  },
  "api/XData.Database.XDataContext.html": {
    "href": "api/XData.Database.XDataContext.html",
    "title": "Class XDataContext | XData website",
    "keywords": "Class XDataContext Data context Provides database adapter and SQL builder access Inheritance Object XDataContext Implements IDisposable Inherited Members Object.Equals(Object) Object.Equals(Object, Object) Object.GetHashCode() Object.GetType() Object.MemberwiseClone() Object.ReferenceEquals(Object, Object) Object.ToString() Namespace : XData.Database Assembly : XData.docfx.dll Syntax public sealed class XDataContext : IDisposable Properties | Improve this Doc View Source ConcurrencyErrorId Concurrency error id Declaration public string ConcurrencyErrorId { get; } Property Value Type Description String | Improve this Doc View Source ConnectionInfo Context connection information Declaration public XConnectionInfo ConnectionInfo { get; } Property Value Type Description XConnectionInfo | Improve this Doc View Source DatabaseAdapter Database adapter Declaration public IDatabaseAdapter DatabaseAdapter { get; } Property Value Type Description IDatabaseAdapter | Improve this Doc View Source DatabaseDialect SQL builder Declaration public ISqlBuilder DatabaseDialect { get; } Property Value Type Description ISqlBuilder | Improve this Doc View Source DialectName SQL dialect name Declaration public string DialectName { get; } Property Value Type Description String | Improve this Doc View Source DialectOptions Dialect options supported by context Declaration public DialectOptions DialectOptions { get; } Property Value Type Description DialectOptions | Improve this Doc View Source Name Context name Declaration public string Name { get; } Property Value Type Description String | Improve this Doc View Source Proxy Remote proxy Declaration public IProxy Proxy { get; } Property Value Type Description IProxy Methods | Improve this Doc View Source Dispose() Declaration public void Dispose() | Improve this Doc View Source Dispose(Boolean) Declaration public void Dispose(bool disposing) Parameters Type Name Description Boolean disposing Implements System.IDisposable Extension Methods SerializationExtensions.ToXml<T>(T) CollectionsExtensions.SetValue<TKey, T>(TKey, T) CollectionsExtensions.AsEnum<T>(T) DataObjectQueryableExtensions.CompareVariable(Object, FilterOperation, String) Processing.Do<T>(T, Action<IProcess<T>>[]) TypeExtensions.TryConvert<T, TResult>(T, Func<T, TResult>) TypeExtensions.TryConvert<T, TResult>(T, Func<T, TResult>, TResult) TypeExtensions.ChangeType<T>(Object) TypeExtensions.ChangeType(Object, Type) TypeExtensions.InvokeMethod<TRet>(Object, Type[], Expression<Func<TRet>>, BindingFlags) TypeExtensions.InvokeMethod(Object, Type[], Expression<Action>, BindingFlags) TypeExtensions.InvokeMethod<TRet>(Object, Expression<Func<TRet>>, BindingFlags) TypeExtensions.InvokeMethod(Object, Expression<Action>, BindingFlags) SqlBlockExtensions.SetExpression<TTag, TResult>(TTag, Expression<Func<IBlockQueryAdapter, TResult>>) QueryDescriptionExtensions.SetExpression<TTag, TResult>(TTag, Expression<Func<IQueryStructureAdapter, TResult>>)"
  },
  "api/XData.Mapping.PropertyDefaultAttribute.html": {
    "href": "api/XData.Mapping.PropertyDefaultAttribute.html",
    "title": "Class PropertyDefaultAttribute | XData website",
    "keywords": "Class PropertyDefaultAttribute Data object property default value attribute Inheritance Object Attribute PropertyDefaultAttribute Inherited Members Attribute.Equals(Object) Attribute.GetCustomAttribute(Assembly, Type) Attribute.GetCustomAttribute(Assembly, Type, Boolean) Attribute.GetCustomAttribute(MemberInfo, Type) Attribute.GetCustomAttribute(MemberInfo, Type, Boolean) Attribute.GetCustomAttribute(Module, Type) Attribute.GetCustomAttribute(Module, Type, Boolean) Attribute.GetCustomAttribute(ParameterInfo, Type) Attribute.GetCustomAttribute(ParameterInfo, Type, Boolean) Attribute.GetCustomAttributes(Assembly) Attribute.GetCustomAttributes(Assembly, Boolean) Attribute.GetCustomAttributes(Assembly, Type) Attribute.GetCustomAttributes(Assembly, Type, Boolean) Attribute.GetCustomAttributes(MemberInfo) Attribute.GetCustomAttributes(MemberInfo, Boolean) Attribute.GetCustomAttributes(MemberInfo, Type) Attribute.GetCustomAttributes(MemberInfo, Type, Boolean) Attribute.GetCustomAttributes(Module) Attribute.GetCustomAttributes(Module, Boolean) Attribute.GetCustomAttributes(Module, Type) Attribute.GetCustomAttributes(Module, Type, Boolean) Attribute.GetCustomAttributes(ParameterInfo) Attribute.GetCustomAttributes(ParameterInfo, Boolean) Attribute.GetCustomAttributes(ParameterInfo, Type) Attribute.GetCustomAttributes(ParameterInfo, Type, Boolean) Attribute.GetHashCode() Attribute.IsDefaultAttribute() Attribute.IsDefined(Assembly, Type) Attribute.IsDefined(Assembly, Type, Boolean) Attribute.IsDefined(MemberInfo, Type) Attribute.IsDefined(MemberInfo, Type, Boolean) Attribute.IsDefined(Module, Type) Attribute.IsDefined(Module, Type, Boolean) Attribute.IsDefined(ParameterInfo, Type) Attribute.IsDefined(ParameterInfo, Type, Boolean) Attribute.Match(Object) Attribute.TypeId Object.Equals(Object, Object) Object.GetType() Object.MemberwiseClone() Object.ReferenceEquals(Object, Object) Object.ToString() Namespace : XData.Mapping Assembly : XData.docfx.dll Syntax [AttributeUsage(AttributeTargets.Property)] public sealed class PropertyDefaultAttribute : Attribute Remarks Used to declare default value rule for property Constructors | Improve this Doc View Source PropertyDefaultAttribute(DefaultType, Object) Data object property default value attribute Declaration public PropertyDefaultAttribute(DefaultType source, object val = null) Parameters Type Name Description DefaultType source Default value source Object val Default value Properties | Improve this Doc View Source DefaultFeature Default extended features Declaration public DefaultFeature DefaultFeature { get; set; } Property Value Type Description DefaultFeature | Improve this Doc View Source DefaultSource Default value source Declaration public DefaultType DefaultSource { get; } Property Value Type Description DefaultType See Also DefaultType | Improve this Doc View Source DefaultValue Default value Declaration public object DefaultValue { get; } Property Value Type Description Object Extension Methods SerializationExtensions.ToXml<T>(T) CollectionsExtensions.SetValue<TKey, T>(TKey, T) CollectionsExtensions.AsEnum<T>(T) DataObjectQueryableExtensions.CompareVariable(Object, FilterOperation, String) Processing.Do<T>(T, Action<IProcess<T>>[]) TypeExtensions.TryConvert<T, TResult>(T, Func<T, TResult>) TypeExtensions.TryConvert<T, TResult>(T, Func<T, TResult>, TResult) TypeExtensions.ChangeType<T>(Object) TypeExtensions.ChangeType(Object, Type) TypeExtensions.InvokeMethod<TRet>(Object, Type[], Expression<Func<TRet>>, BindingFlags) TypeExtensions.InvokeMethod(Object, Type[], Expression<Action>, BindingFlags) TypeExtensions.InvokeMethod<TRet>(Object, Expression<Func<TRet>>, BindingFlags) TypeExtensions.InvokeMethod(Object, Expression<Action>, BindingFlags) SqlBlockExtensions.SetExpression<TTag, TResult>(TTag, Expression<Func<IBlockQueryAdapter, TResult>>) QueryDescriptionExtensions.SetExpression<TTag, TResult>(TTag, Expression<Func<IQueryStructureAdapter, TResult>>) See Also DefaultType"
  },
  "api/XData.Mapping.ColumnDefaultAttribute.html": {
    "href": "api/XData.Mapping.ColumnDefaultAttribute.html",
    "title": "Class ColumnDefaultAttribute | XData website",
    "keywords": "Class ColumnDefaultAttribute Column default value attribute Inheritance Object Attribute ColumnDefaultAttribute Inherited Members Attribute.Equals(Object) Attribute.GetCustomAttribute(Assembly, Type) Attribute.GetCustomAttribute(Assembly, Type, Boolean) Attribute.GetCustomAttribute(MemberInfo, Type) Attribute.GetCustomAttribute(MemberInfo, Type, Boolean) Attribute.GetCustomAttribute(Module, Type) Attribute.GetCustomAttribute(Module, Type, Boolean) Attribute.GetCustomAttribute(ParameterInfo, Type) Attribute.GetCustomAttribute(ParameterInfo, Type, Boolean) Attribute.GetCustomAttributes(Assembly) Attribute.GetCustomAttributes(Assembly, Boolean) Attribute.GetCustomAttributes(Assembly, Type) Attribute.GetCustomAttributes(Assembly, Type, Boolean) Attribute.GetCustomAttributes(MemberInfo) Attribute.GetCustomAttributes(MemberInfo, Boolean) Attribute.GetCustomAttributes(MemberInfo, Type) Attribute.GetCustomAttributes(MemberInfo, Type, Boolean) Attribute.GetCustomAttributes(Module) Attribute.GetCustomAttributes(Module, Boolean) Attribute.GetCustomAttributes(Module, Type) Attribute.GetCustomAttributes(Module, Type, Boolean) Attribute.GetCustomAttributes(ParameterInfo) Attribute.GetCustomAttributes(ParameterInfo, Boolean) Attribute.GetCustomAttributes(ParameterInfo, Type) Attribute.GetCustomAttributes(ParameterInfo, Type, Boolean) Attribute.GetHashCode() Attribute.IsDefaultAttribute() Attribute.IsDefined(Assembly, Type) Attribute.IsDefined(Assembly, Type, Boolean) Attribute.IsDefined(MemberInfo, Type) Attribute.IsDefined(MemberInfo, Type, Boolean) Attribute.IsDefined(Module, Type) Attribute.IsDefined(Module, Type, Boolean) Attribute.IsDefined(ParameterInfo, Type) Attribute.IsDefined(ParameterInfo, Type, Boolean) Attribute.Match(Object) Object.Equals(Object, Object) Object.GetType() Object.MemberwiseClone() Object.ReferenceEquals(Object, Object) Object.ToString() Namespace : XData.Mapping Assembly : XData.docfx.dll Syntax [AttributeUsage(AttributeTargets.Class, AllowMultiple = true)] public sealed class ColumnDefaultAttribute : Attribute Remarks Used to declare default value rule for column Constructors | Improve this Doc View Source ColumnDefaultAttribute(String, DefaultType, Object) Column default value attribute Declaration public ColumnDefaultAttribute(string propertyName, DefaultType source, object val = null) Parameters Type Name Description String propertyName Property name DefaultType source Default value source Object val Default value Exceptions Type Condition XDataRuntimeException Property name cannot be null or empty string Properties | Improve this Doc View Source DefaultFeature Default extended features Declaration public DefaultFeature DefaultFeature { get; set; } Property Value Type Description DefaultFeature | Improve this Doc View Source DefaultSource Default value source Declaration public DefaultType DefaultSource { get; } Property Value Type Description DefaultType | Improve this Doc View Source DefaultValue Default value Declaration public object DefaultValue { get; } Property Value Type Description Object | Improve this Doc View Source PropertyName Property name Declaration public string PropertyName { get; } Property Value Type Description String See Also ColumnAttribute | Improve this Doc View Source TypeId When implemented in a derived class, gets a unique identifier for this Attribute . Declaration public override object TypeId { get; } Property Value Type Description Object An Object that is a unique identifier for the attribute. Overrides Attribute.TypeId Extension Methods SerializationExtensions.ToXml<T>(T) CollectionsExtensions.SetValue<TKey, T>(TKey, T) CollectionsExtensions.AsEnum<T>(T) DataObjectQueryableExtensions.CompareVariable(Object, FilterOperation, String) Processing.Do<T>(T, Action<IProcess<T>>[]) TypeExtensions.TryConvert<T, TResult>(T, Func<T, TResult>) TypeExtensions.TryConvert<T, TResult>(T, Func<T, TResult>, TResult) TypeExtensions.ChangeType<T>(Object) TypeExtensions.ChangeType(Object, Type) TypeExtensions.InvokeMethod<TRet>(Object, Type[], Expression<Func<TRet>>, BindingFlags) TypeExtensions.InvokeMethod(Object, Type[], Expression<Action>, BindingFlags) TypeExtensions.InvokeMethod<TRet>(Object, Expression<Func<TRet>>, BindingFlags) TypeExtensions.InvokeMethod(Object, Expression<Action>, BindingFlags) SqlBlockExtensions.SetExpression<TTag, TResult>(TTag, Expression<Func<IBlockQueryAdapter, TResult>>) QueryDescriptionExtensions.SetExpression<TTag, TResult>(TTag, Expression<Func<IQueryStructureAdapter, TResult>>) See Also DefaultType"
  },
  "api/XData.GetXmlAttachedHandler.html": {
    "href": "api/XData.GetXmlAttachedHandler.html",
    "title": "Delegate GetXmlAttachedHandler | XData website",
    "keywords": "Delegate GetXmlAttachedHandler Get Xml attached handler delegate Namespace : XData Assembly : XData.docfx.dll Syntax public delegate bool GetXmlAttachedHandler(string property, IDataObject obj, out string xml); Parameters Type Name Description String property Xml property name IDataObject obj Data object String xml Xml string Returns Type Description Boolean Extension Methods SerializationExtensions.ToXml<T>(T) CollectionsExtensions.SetValue<TKey, T>(TKey, T) CollectionsExtensions.AsEnum<T>(T) DataObjectQueryableExtensions.CompareVariable(Object, FilterOperation, String) Processing.Do<T>(T, Action<IProcess<T>>[]) TypeExtensions.TryConvert<T, TResult>(T, Func<T, TResult>) TypeExtensions.TryConvert<T, TResult>(T, Func<T, TResult>, TResult) TypeExtensions.ChangeType<T>(Object) TypeExtensions.ChangeType(Object, Type) TypeExtensions.InvokeMethod<TRet>(Object, Type[], Expression<Func<TRet>>, BindingFlags) TypeExtensions.InvokeMethod(Object, Type[], Expression<Action>, BindingFlags) TypeExtensions.InvokeMethod<TRet>(Object, Expression<Func<TRet>>, BindingFlags) TypeExtensions.InvokeMethod(Object, Expression<Action>, BindingFlags) SqlBlockExtensions.SetExpression<TTag, TResult>(TTag, Expression<Func<IBlockQueryAdapter, TResult>>) QueryDescriptionExtensions.SetExpression<TTag, TResult>(TTag, Expression<Func<IQueryStructureAdapter, TResult>>)"
  },
  "api/XData.WorkState.html": {
    "href": "api/XData.WorkState.html",
    "title": "Enum WorkState | XData website",
    "keywords": "Enum WorkState Work set state Namespace : XData Assembly : XData.WorkSet.docfx.dll Syntax public enum WorkState Fields Name Description Active Active (not deleted) objects Changed Changed objects Deleted Deleted objects New New objects Original Original objects Extension Methods SerializationExtensions.ToXml<WorkState>() CollectionsExtensions.SetValue<WorkState, T>(T) CollectionsExtensions.AsEnum<WorkState>() DataObjectQueryableExtensions.CompareVariable(FilterOperation, String) Processing.Do<WorkState>(Action<IProcess<WorkState>>[]) TypeExtensions.ChangeType<T>() TypeExtensions.ChangeType(Type) TypeExtensions.InvokeMethod<TRet>(Type[], Expression<Func<TRet>>, BindingFlags) TypeExtensions.InvokeMethod(Type[], Expression<Action>, BindingFlags) TypeExtensions.InvokeMethod<TRet>(Expression<Func<TRet>>, BindingFlags) TypeExtensions.InvokeMethod(Expression<Action>, BindingFlags) TypeExtensions.ConvertTo<T>() TypeExtensions.EqualValue(Enum) SqlBlockExtensions.SetExpression<WorkState, TResult>(Expression<Func<IBlockQueryAdapter, TResult>>) QueryDescriptionExtensions.SetExpression<WorkState, TResult>(Expression<Func<IQueryStructureAdapter, TResult>>)"
  },
  "api/XData.Work.html": {
    "href": "api/XData.Work.html",
    "title": "Class Work | XData website",
    "keywords": "Class Work Work set helper class Inheritance Object Work Inherited Members Object.Equals(Object) Object.Equals(Object, Object) Object.GetHashCode() Object.GetType() Object.MemberwiseClone() Object.ReferenceEquals(Object, Object) Object.ToString() Namespace : XData Assembly : XData.WorkSet.docfx.dll Syntax public static class Work Methods | Improve this Doc View Source Add<T>(T, Expression<Func<T, IWorkSet>>[]) Create work set based on single object Declaration public static IWorkSet<T> Add<T>(T data, params Expression<Func<T, IWorkSet>>[] workSets) where T : class, IDataObject, new() Parameters Type Name Description T data Data object Expression < Func <T, IWorkSet >>[] workSets Depended objects/collections initializers Returns Type Description IWorkSet <T> Work set Type Parameters Name Description T Data object type See Also Empty<T, TRet>(String, ISecuritySession, Expression<Func<TRet, IWorkSet>>[]) Fill<T, TRet>(String, ISecuritySession, Expression<Func<TRet, IWorkSet>>[]) | Improve this Doc View Source Add<T>(ICollection<T>, Expression<Func<T, IWorkSet>>[]) Create work set based on collection Declaration public static IWorkSet<T> Add<T>(ICollection<T> data, params Expression<Func<T, IWorkSet>>[] workSets) where T : class, IDataObject, new() Parameters Type Name Description ICollection <T> data Data object collection Expression < Func <T, IWorkSet >>[] workSets Depended objects/collections initializers Returns Type Description IWorkSet <T> Work set Type Parameters Name Description T Data object type See Also Empty<T, TRet>(String, ISecuritySession, Expression<Func<TRet, IWorkSet>>[]) Fill<T, TRet>(String, ISecuritySession, Expression<Func<TRet, IWorkSet>>[]) | Improve this Doc View Source Apply<TRoot>(TRoot, Expression<Func<IWorkScope<TRoot>>>) Apply single data object (optionally with some childs) to work set Declaration public static void Apply<TRoot>(TRoot obj, Expression<Func<IWorkScope<TRoot>>> structure) where TRoot : class, IDataObject, new() Parameters Type Name Description TRoot obj Detached data object to apply Expression < Func < IWorkScope <TRoot>>> structure Childs data description Type Parameters Name Description TRoot Root object type | Improve this Doc View Source Empty<T, TRet>(String, ISecuritySession, Expression<Func<TRet, IWorkSet>>[]) Empty single depended object initializer Declaration public static Expression<Func<T, IWorkSet>> Empty<T, TRet>(string alias = null, ISecuritySession security = null, params Expression<Func<TRet, IWorkSet>>[] workSets) where T : class, IDataObject, new() where TRet : class, IDataObject, new() Parameters Type Name Description String alias (optional) Child repository alias ISecuritySession security (optional) Security session Expression < Func <TRet, IWorkSet >>[] workSets Depended objects/collections initializers Returns Type Description Expression < Func <T, IWorkSet >> Work set Type Parameters Name Description T Parent data object type TRet Depended data object type See Also Fill<T, TRet>(String, ISecuritySession, Expression<Func<TRet, IWorkSet>>[]) | Improve this Doc View Source Export<TRoot>(Guid, Guid, Expression<Func<IWorkScope<TRoot>>>) Export single data object (optionally with some childs) by key Declaration public static TRoot Export<TRoot>(Guid layer, Guid key, Expression<Func<IWorkScope<TRoot>>> structure) where TRoot : class, IDataObject, new() Parameters Type Name Description Guid layer Data set layer Guid key Work set key Expression < Func < IWorkScope <TRoot>>> structure Structure description Returns Type Description TRoot Data object Type Parameters Name Description TRoot Root object type | Improve this Doc View Source Fill<T, TRet>(String, ISecuritySession, Expression<Func<TRet, IWorkSet>>[]) Existed depended collection initializer Declaration public static Expression<Func<T, IWorkSet>> Fill<T, TRet>(string alias = null, ISecuritySession security = null, params Expression<Func<TRet, IWorkSet>>[] workSets) where T : class, IDataObject, new() where TRet : class, IDataObject, new() Parameters Type Name Description String alias (optional) Child repository alias ISecuritySession security (optional) Security session Expression < Func <TRet, IWorkSet >>[] workSets Depended objects/collections initializers Returns Type Description Expression < Func <T, IWorkSet >> Work set Type Parameters Name Description T Parent data object type TRet Depended data object type See Also Empty<T, TRet>(String, ISecuritySession, Expression<Func<TRet, IWorkSet>>[]) | Improve this Doc View Source GetWorkSet<T>(Guid) Returns a cached work set Declaration public static IWorkSet<T> GetWorkSet<T>(Guid layer) where T : class, IDataObject, new() Parameters Type Name Description Guid layer Data scope layer Returns Type Description IWorkSet <T> Work set Type Parameters Name Description T Data object type | Improve this Doc View Source Root<T>(Expression<Func<T, Guid>>, Expression<Func<T, Guid>>) Root structure describer for work set export/apply Declaration public static IWorkScope<T> Root<T>(Expression<Func<T, Guid>> layerProperty, Expression<Func<T, Guid>> keyProperty) Parameters Type Name Description Expression < Func <T, Guid >> layerProperty Data scope layer property Expression < Func <T, Guid >> keyProperty Work set key property Returns Type Description IWorkScope <T> Structure describer Type Parameters Name Description T Root type See Also Empty<T, TRet>(String, ISecuritySession, Expression<Func<TRet, IWorkSet>>[]) Fill<T, TRet>(String, ISecuritySession, Expression<Func<TRet, IWorkSet>>[])"
  },
  "api/XData.WithRecursiveType.html": {
    "href": "api/XData.WithRecursiveType.html",
    "title": "Enum WithRecursiveType | XData website",
    "keywords": "Enum WithRecursiveType Common-Table-Expression (WITH) Subquery type Namespace : XData Assembly : XData.docfx.dll Syntax [DataContract] public enum WithRecursiveType Fields Name Description RecursiveUnion Recursive select with UNION combination RecursiveUnionAll Recursive select with ALL combination Extension Methods SerializationExtensions.ToXml<WithRecursiveType>() CollectionsExtensions.SetValue<WithRecursiveType, T>(T) CollectionsExtensions.AsEnum<WithRecursiveType>() DataObjectQueryableExtensions.CompareVariable(FilterOperation, String) Processing.Do<WithRecursiveType>(Action<IProcess<WithRecursiveType>>[]) TypeExtensions.ChangeType<T>() TypeExtensions.ChangeType(Type) TypeExtensions.InvokeMethod<TRet>(Type[], Expression<Func<TRet>>, BindingFlags) TypeExtensions.InvokeMethod(Type[], Expression<Action>, BindingFlags) TypeExtensions.InvokeMethod<TRet>(Expression<Func<TRet>>, BindingFlags) TypeExtensions.InvokeMethod(Expression<Action>, BindingFlags) TypeExtensions.ConvertTo<T>() TypeExtensions.EqualValue(Enum) SqlBlockExtensions.SetExpression<WithRecursiveType, TResult>(Expression<Func<IBlockQueryAdapter, TResult>>) QueryDescriptionExtensions.SetExpression<WithRecursiveType, TResult>(Expression<Func<IQueryStructureAdapter, TResult>>)"
  },
  "api/XData.Mapping.ExpressionFilterAttribute.html": {
    "href": "api/XData.Mapping.ExpressionFilterAttribute.html",
    "title": "Class ExpressionFilterAttribute | XData website",
    "keywords": "Class ExpressionFilterAttribute Data object plain SQL expression filter attribute Inheritance Object Attribute FilterBaseAttribute FilterAttribute ExpressionFilterAttribute Inherited Members FilterAttribute.Source FilterAttribute.FieldName FilterAttribute.Operation FilterAttribute.Combination Attribute.Equals(Object) Attribute.GetCustomAttribute(Assembly, Type) Attribute.GetCustomAttribute(Assembly, Type, Boolean) Attribute.GetCustomAttribute(MemberInfo, Type) Attribute.GetCustomAttribute(MemberInfo, Type, Boolean) Attribute.GetCustomAttribute(Module, Type) Attribute.GetCustomAttribute(Module, Type, Boolean) Attribute.GetCustomAttribute(ParameterInfo, Type) Attribute.GetCustomAttribute(ParameterInfo, Type, Boolean) Attribute.GetCustomAttributes(Assembly) Attribute.GetCustomAttributes(Assembly, Boolean) Attribute.GetCustomAttributes(Assembly, Type) Attribute.GetCustomAttributes(Assembly, Type, Boolean) Attribute.GetCustomAttributes(MemberInfo) Attribute.GetCustomAttributes(MemberInfo, Boolean) Attribute.GetCustomAttributes(MemberInfo, Type) Attribute.GetCustomAttributes(MemberInfo, Type, Boolean) Attribute.GetCustomAttributes(Module) Attribute.GetCustomAttributes(Module, Boolean) Attribute.GetCustomAttributes(Module, Type) Attribute.GetCustomAttributes(Module, Type, Boolean) Attribute.GetCustomAttributes(ParameterInfo) Attribute.GetCustomAttributes(ParameterInfo, Boolean) Attribute.GetCustomAttributes(ParameterInfo, Type) Attribute.GetCustomAttributes(ParameterInfo, Type, Boolean) Attribute.GetHashCode() Attribute.IsDefaultAttribute() Attribute.IsDefined(Assembly, Type) Attribute.IsDefined(Assembly, Type, Boolean) Attribute.IsDefined(MemberInfo, Type) Attribute.IsDefined(MemberInfo, Type, Boolean) Attribute.IsDefined(Module, Type) Attribute.IsDefined(Module, Type, Boolean) Attribute.IsDefined(ParameterInfo, Type) Attribute.IsDefined(ParameterInfo, Type, Boolean) Attribute.Match(Object) Object.Equals(Object, Object) Object.GetType() Object.MemberwiseClone() Object.ReferenceEquals(Object, Object) Object.ToString() Namespace : XData.Mapping Assembly : XData.docfx.dll Syntax [AttributeUsage(AttributeTargets.Class, AllowMultiple = true)] public sealed class ExpressionFilterAttribute : FilterAttribute Remarks Used to filter data by field comparison to plain SQL expression (for example: some_field = substr(other_field, 1, 2) ) Hint: Filter field can be represented as expression two by ColumnExpressionAttribute or PropertyExpressionAttribute WARNING! Sql expressions can use specific Sql dialect features! Data mapping may be not compatible with other database engines! Constructors | Improve this Doc View Source ExpressionFilterAttribute(String, String, String) Expression filter attribute Declaration public ExpressionFilterAttribute(string source, string fieldName, string exprText) Parameters Type Name Description String source Primary source alias String fieldName Primary field name String exprText SQL expression text Exceptions Type Condition XDataRuntimeException SQL expression cannot be null or empty string Properties | Improve this Doc View Source ExprText SQL expression Declaration public string ExprText { get; } Property Value Type Description String Remarks WARNING! SQL expressions can use specific SQL dialect features! Data mapping may be not compatible with other database engines! | Improve this Doc View Source FilterType Filter type Declaration public override FilterType FilterType { get; } Property Value Type Description FilterType Expression Overrides FilterBaseAttribute.FilterType | Improve this Doc View Source TypeId When implemented in a derived class, gets a unique identifier for this Attribute . Declaration public override object TypeId { get; } Property Value Type Description Object An Object that is a unique identifier for the attribute. Overrides Attribute.TypeId Extension Methods SerializationExtensions.ToXml<T>(T) CollectionsExtensions.SetValue<TKey, T>(TKey, T) CollectionsExtensions.AsEnum<T>(T) DataObjectQueryableExtensions.CompareVariable(Object, FilterOperation, String) Processing.Do<T>(T, Action<IProcess<T>>[]) TypeExtensions.TryConvert<T, TResult>(T, Func<T, TResult>) TypeExtensions.TryConvert<T, TResult>(T, Func<T, TResult>, TResult) TypeExtensions.ChangeType<T>(Object) TypeExtensions.ChangeType(Object, Type) TypeExtensions.InvokeMethod<TRet>(Object, Type[], Expression<Func<TRet>>, BindingFlags) TypeExtensions.InvokeMethod(Object, Type[], Expression<Action>, BindingFlags) TypeExtensions.InvokeMethod<TRet>(Object, Expression<Func<TRet>>, BindingFlags) TypeExtensions.InvokeMethod(Object, Expression<Action>, BindingFlags) SqlBlockExtensions.SetExpression<TTag, TResult>(TTag, Expression<Func<IBlockQueryAdapter, TResult>>) QueryDescriptionExtensions.SetExpression<TTag, TResult>(TTag, Expression<Func<IQueryStructureAdapter, TResult>>)"
  },
  "api/XData.Mapping.Dynamic.IInheritedStructure-1.html": {
    "href": "api/XData.Mapping.Dynamic.IInheritedStructure-1.html",
    "title": "Interface IInheritedStructure<T> | XData website",
    "keywords": "Interface IInheritedStructure<T> Inherited repository structure descriptor Namespace : XData.Mapping.Dynamic Assembly : XData.docfx.dll Syntax public interface IInheritedStructure<T> where T : class, ISqlObject, new() Type Parameters Name Description T Data object type Methods | Improve this Doc View Source AddInnerFilters(String, Expression<Func<IInnerFilterAdapter, IFilterDescription>>[]) Add inner filters Declaration IInheritedStructure<T> AddInnerFilters(string alias, params Expression<Func<IInnerFilterAdapter, IFilterDescription>>[] filters) Parameters Type Name Description String alias Data source alias Expression < Func < IInnerFilterAdapter , IFilterDescription >>[] filters Filters to add Returns Type Description IInheritedStructure <T> Inherited repository structure | Improve this Doc View Source AddSubqueryLinks(String, Expression<Func<ISubqueryLinkAdapter<T>, IFilterDescription>>[]) Add subquery links Declaration IInheritedStructure<T> AddSubqueryLinks(string alias, params Expression<Func<ISubqueryLinkAdapter<T>, IFilterDescription>>[] filters) Parameters Type Name Description String alias Subquery alias Expression < Func < ISubqueryLinkAdapter <T>, IFilterDescription >>[] filters Links to add Returns Type Description IInheritedStructure <T> Inherited repository structure | Improve this Doc View Source AddSubqueryLinks<TSubquery>(String, Expression<Func<ISubqueryLinkAdapter<T, TSubquery>, IFilterDescription>>[]) Add subquery links Declaration IInheritedStructure<T> AddSubqueryLinks<TSubquery>(string alias, params Expression<Func<ISubqueryLinkAdapter<T, TSubquery>, IFilterDescription>>[] filters) where TSubquery : class Parameters Type Name Description String alias Subquery alias Expression < Func < ISubqueryLinkAdapter <T, TSubquery>, IFilterDescription >>[] filters Links to add Returns Type Description IInheritedStructure <T> Inherited repository structure Type Parameters Name Description TSubquery | Improve this Doc View Source Column<TResult>(String, Expression<Func<IRepositoryStructureAdapter<T>, TResult>>) Dynamic repository hidden property mapping Declaration IInheritedStructure<T> Column<TResult>(string name, Expression<Func<IRepositoryStructureAdapter<T>, TResult>> mapper) Parameters Type Name Description String name Hidden property name Expression < Func < IRepositoryStructureAdapter <T>, TResult>> mapper Property mapping expression Returns Type Description IInheritedStructure <T> Inherited repository structure Type Parameters Name Description TResult Hidden property type See Also GetStructure(String, String, DataStructureFlag, Variable[]) IQueryStructure IQueryStructureAdapter | Improve this Doc View Source DataTable(String, String, Expression<Func<IInnerFilterAdapter, IFilterDescription>>[]) Dynamic repository table mapping Declaration IInheritedStructure<T> DataTable(string name, string alias, params Expression<Func<IInnerFilterAdapter, IFilterDescription>>[] filters) Parameters Type Name Description String name Table name String alias Table alias Expression < Func < IInnerFilterAdapter , IFilterDescription >>[] filters Filters and links applied to table Returns Type Description IInheritedStructure <T> Inherited repository structure See Also GetStructure(String, String, DataStructureFlag, Variable[]) IQueryStructure IFilterDescription | Improve this Doc View Source DataTable(String, String, String, Expression<Func<IInnerFilterAdapter, IFilterDescription>>[]) Dynamic repository table mapping Declaration IInheritedStructure<T> DataTable(string name, string alias, string parent = null, params Expression<Func<IInnerFilterAdapter, IFilterDescription>>[] filters) Parameters Type Name Description String name Table name String alias Table alias String parent Parent table alias Expression < Func < IInnerFilterAdapter , IFilterDescription >>[] filters Filters and links applied to table Returns Type Description IInheritedStructure <T> Inherited repository structure See Also GetStructure(String, String, DataStructureFlag, Variable[]) IQueryStructure IFilterDescription | Improve this Doc View Source Hint(String, String, HintType) Dynamic repository data source hint Declaration IInheritedStructure<T> Hint(string alias, string hint, HintType hintType = HintType.Select) Parameters Type Name Description String alias Data source alias String hint Hint HintType hintType Hint type Returns Type Description IInheritedStructure <T> Inherited repository structure See Also GetStructure(String, String, DataStructureFlag, Variable[]) | Improve this Doc View Source InnerView(String, Type, Expression<Func<ISubqueryLinkAdapter<T>, IFilterDescription>>[]) Dynamic repository inner view mapping Declaration IInheritedStructure<T> InnerView(string alias, Type innerViewType, params Expression<Func<ISubqueryLinkAdapter<T>, IFilterDescription>>[] filters) Parameters Type Name Description String alias Inner view alias Type innerViewType Inner view statically mapped type Expression < Func < ISubqueryLinkAdapter <T>, IFilterDescription >>[] filters Filters and links applied to inner view Returns Type Description IInheritedStructure <T> Inherited repository structure See Also GetStructure(String, String, DataStructureFlag, Variable[]) IQueryStructure IFilterDescription | Improve this Doc View Source InnerView<TInnerView>(String, Expression<Func<ISubqueryLinkAdapter<T, TInnerView>, IFilterDescription>>[]) Dynamic repository inner view mapping Declaration IInheritedStructure<T> InnerView<TInnerView>(string alias, params Expression<Func<ISubqueryLinkAdapter<T, TInnerView>, IFilterDescription>>[] filters) where TInnerView : class Parameters Type Name Description String alias Inner view alias Expression < Func < ISubqueryLinkAdapter <T, TInnerView>, IFilterDescription >>[] filters Filters and links applied to inner view Returns Type Description IInheritedStructure <T> Inherited repository structure Type Parameters Name Description TInnerView Inner view statically mapped type See Also GetStructure(String, String, DataStructureFlag, Variable[]) IQueryStructure IFilterDescription | Improve this Doc View Source InnerView<TInnerView>(String, IQueryDescription<TInnerView>, Expression<Func<ISubqueryLinkAdapter<T, TInnerView>, IFilterDescription>>[]) Dynamic repository inner view mapping Declaration IInheritedStructure<T> InnerView<TInnerView>(string alias, IQueryDescription<TInnerView> sub, params Expression<Func<ISubqueryLinkAdapter<T, TInnerView>, IFilterDescription>>[] filters) where TInnerView : class Parameters Type Name Description String alias Inner view alias IQueryDescription <TInnerView> sub Inner view query structure Expression < Func < ISubqueryLinkAdapter <T, TInnerView>, IFilterDescription >>[] filters Filters and links applied to inner view Returns Type Description IInheritedStructure <T> Inherited repository structure Type Parameters Name Description TInnerView See Also GetStructure(String, String, DataStructureFlag, Variable[]) IQueryStructure IQueryDescription IFilterDescription | Improve this Doc View Source InnerView<TInnerView>(String, Variable[], Expression<Func<ISubqueryLinkAdapter<T, TInnerView>, IFilterDescription>>[]) Dynamic repository inner view mapping Declaration IInheritedStructure<T> InnerView<TInnerView>(string alias, Variable[] variables, params Expression<Func<ISubqueryLinkAdapter<T, TInnerView>, IFilterDescription>>[] filters) where TInnerView : class Parameters Type Name Description String alias Inner view alias Variable [] variables Inner view variables Expression < Func < ISubqueryLinkAdapter <T, TInnerView>, IFilterDescription >>[] filters Filters and links applied to inner view Returns Type Description IInheritedStructure <T> Inherited repository structure Type Parameters Name Description TInnerView Inner view statically mapped type See Also GetStructure(String, String, DataStructureFlag, Variable[]) IQueryStructure Variable IFilterDescription | Improve this Doc View Source Map(Expression<Func<IExternalLinkDefinitionAdapter<T>, IExternalLinkDefinition>>[]) Dynamic repository properties mapping Declaration IRepositoryDescription<T> Map(params Expression<Func<IExternalLinkDefinitionAdapter<T>, IExternalLinkDefinition>>[] externalLinks) Parameters Type Name Description Expression < Func < IExternalLinkDefinitionAdapter <T>, IExternalLinkDefinition >>[] externalLinks External link descriptions Returns Type Description IRepositoryDescription <T> Dynamic repository description See Also GetStructure(String, String, DataStructureFlag, Variable[]) IQueryStructure IQueryDescription <T> IQueryStructureAdapter | Improve this Doc View Source Map(Expression<Func<IRepositoryStructureAdapter<T>, T>>, Expression<Func<IExternalLinkDefinitionAdapter<T>, IExternalLinkDefinition>>[]) Dynamic repository properties mapping Declaration IRepositoryDescription<T> Map(Expression<Func<IRepositoryStructureAdapter<T>, T>> mapper, params Expression<Func<IExternalLinkDefinitionAdapter<T>, IExternalLinkDefinition>>[] externalLinks) Parameters Type Name Description Expression < Func < IRepositoryStructureAdapter <T>, T>> mapper Mapping expression Expression < Func < IExternalLinkDefinitionAdapter <T>, IExternalLinkDefinition >>[] externalLinks External link descriptions Returns Type Description IRepositoryDescription <T> Dynamic repository description See Also GetStructure(String, String, DataStructureFlag, Variable[]) IQueryStructure IQueryDescription <T> IQueryStructureAdapter | Improve this Doc View Source Parameter<TResult>(String, Int32, String, DbType, Expression<Func<IProcedureParameterAdapter, IProcedureParameterFlag>>[]) Dynamic repository procedure parameter mapping Declaration IInheritedStructure<T> Parameter<TResult>(string alias, int order, string binding, DbType type, params Expression<Func<IProcedureParameterAdapter, IProcedureParameterFlag>>[] attributes) Parameters Type Name Description String alias Procedure alias Int32 order Parameter order String binding Parameter value binding DbType type Parameter SQL data type Expression < Func < IProcedureParameterAdapter , IProcedureParameterFlag >>[] attributes Parameter attributes Returns Type Description IInheritedStructure <T> Inherited repository structure Type Parameters Name Description TResult Parameter data type | Improve this Doc View Source Procedure(String, String, ProcedureType, Expression<Func<IInnerFilterAdapter, IFilterDescription>>[]) Dynamic repository procedure mapping Declaration IInheritedStructure<T> Procedure(string alias, string name, ProcedureType type, params Expression<Func<IInnerFilterAdapter, IFilterDescription>>[] filters) Parameters Type Name Description String alias Procedure alias String name Procedure name ProcedureType type Procedure type Expression < Func < IInnerFilterAdapter , IFilterDescription >>[] filters Filters and links applied to table Returns Type Description IInheritedStructure <T> Inherited repository structure See Also GetStructure(String, String, DataStructureFlag, Variable[]) IQueryStructure IFilterDescription | Improve this Doc View Source ReadOnlyProperty<TResult>(Expression<Func<T, TResult>>, Expression<Func<IRepositoryStructureAdapter<T>, TResult>>) Dynamic repository read only properties mapping Declaration IInheritedStructure<T> ReadOnlyProperty<TResult>(Expression<Func<T, TResult>> property, Expression<Func<IRepositoryStructureAdapter<T>, TResult>> mapper) Parameters Type Name Description Expression < Func <T, TResult>> property Property name expression Expression < Func < IRepositoryStructureAdapter <T>, TResult>> mapper Property mapping Returns Type Description IInheritedStructure <T> Inherited repository structure Type Parameters Name Description TResult Property type | Improve this Doc View Source Return(String) Dynamic repository procedure default result set mapping Declaration IInheritedStructure<T> Return(string alias) Parameters Type Name Description String alias Procedure alias Returns Type Description IInheritedStructure <T> Inherited repository structure | Improve this Doc View Source Return<TResult>(String, String, Int32, Expression<Func<IQueryStructureAdapter, T>>) Dynamic repository procedure result set mapping Declaration IInheritedStructure<T> Return<TResult>(string alias, string name, int order, Expression<Func<IQueryStructureAdapter, T>> mapper = null) where TResult : class Parameters Type Name Description String alias Procedure alias String name Result set name Int32 order Result set order Expression < Func < IQueryStructureAdapter , T>> mapper Result set mapper Returns Type Description IInheritedStructure <T> Inherited repository structure Type Parameters Name Description TResult Result set data type | Improve this Doc View Source SetSubqueryVariables(String, Variable[]) Set subquery variable values Declaration IInheritedStructure<T> SetSubqueryVariables(string alias, params Variable[] variables) Parameters Type Name Description String alias Subquery alias Variable [] variables Variables to set Returns Type Description IInheritedStructure <T> Inherited repository structure | Improve this Doc View Source Subquery(String, Type, String, DataGrouping, Expression<Func<ISubqueryLinkAdapter<T>, IFilterDescription>>[]) Dynamic repository subquery mapping Declaration IInheritedStructure<T> Subquery(string alias, Type subqueryType, string property, DataGrouping grouping = DataGrouping.None, params Expression<Func<ISubqueryLinkAdapter<T>, IFilterDescription>>[] filters) Parameters Type Name Description String alias Subquery alias Type subqueryType Subquery statically mapped type String property Subquery selected property DataGrouping grouping Subquery selected property aggregate function Expression < Func < ISubqueryLinkAdapter <T>, IFilterDescription >>[] filters Filters and links applied to subquery Returns Type Description IInheritedStructure <T> Inherited repository structure See Also GetStructure(String, String, DataStructureFlag, Variable[]) IQueryStructure IFilterDescription | Improve this Doc View Source Subquery<TSubquery>(String, Expression<Func<TSubquery, Object>>, DataGrouping, Expression<Func<ISubqueryLinkAdapter<T, TSubquery>, IFilterDescription>>[]) Dynamic repository subquery mapping Declaration IInheritedStructure<T> Subquery<TSubquery>(string alias, Expression<Func<TSubquery, object>> property, DataGrouping grouping = DataGrouping.None, params Expression<Func<ISubqueryLinkAdapter<T, TSubquery>, IFilterDescription>>[] filters) where TSubquery : class Parameters Type Name Description String alias Subquery alias Expression < Func <TSubquery, Object >> property Subquery selected property expression DataGrouping grouping Subquery selected property aggregate function Expression < Func < ISubqueryLinkAdapter <T, TSubquery>, IFilterDescription >>[] filters Filters and links applied to subquery Returns Type Description IInheritedStructure <T> Inherited repository structure Type Parameters Name Description TSubquery Subquery statically mapped type See Also GetStructure(String, String, DataStructureFlag, Variable[]) IQueryStructure IFilterDescription | Improve this Doc View Source Subquery<TSubquery>(String, Expression<Func<TSubquery, Object>>, DataGrouping, Variable[], Expression<Func<ISubqueryLinkAdapter<T, TSubquery>, IFilterDescription>>[]) Dynamic repository subquery mapping Declaration IInheritedStructure<T> Subquery<TSubquery>(string alias, Expression<Func<TSubquery, object>> property, DataGrouping grouping, Variable[] variables, params Expression<Func<ISubqueryLinkAdapter<T, TSubquery>, IFilterDescription>>[] filters) where TSubquery : class Parameters Type Name Description String alias Subquery alias Expression < Func <TSubquery, Object >> property Subquery selected property expression DataGrouping grouping Subquery selected property aggregate function Variable [] variables Subquery variables Expression < Func < ISubqueryLinkAdapter <T, TSubquery>, IFilterDescription >>[] filters Filters and links applied to subquery Returns Type Description IInheritedStructure <T> Inherited repository structure Type Parameters Name Description TSubquery Subquery statically mapped type See Also GetStructure(String, String, DataStructureFlag, Variable[]) IQueryStructure IFilterDescription Variable | Improve this Doc View Source Subquery<TSubquery>(String, IQueryDescription<TSubquery>, String, DataGrouping, Expression<Func<ISubqueryLinkAdapter<T, TSubquery>, IFilterDescription>>[]) Dynamic repository subquery mapping Declaration IInheritedStructure<T> Subquery<TSubquery>(string alias, IQueryDescription<TSubquery> sub, string property, DataGrouping grouping = DataGrouping.None, params Expression<Func<ISubqueryLinkAdapter<T, TSubquery>, IFilterDescription>>[] filters) where TSubquery : class Parameters Type Name Description String alias Subquery alias IQueryDescription <TSubquery> sub Subquery query structure String property Subquery selected property DataGrouping grouping Subquery selected property aggregate function Expression < Func < ISubqueryLinkAdapter <T, TSubquery>, IFilterDescription >>[] filters Filters and links applied to subquery Returns Type Description IInheritedStructure <T> Inherited repository structure Type Parameters Name Description TSubquery See Also GetStructure(String, String, DataStructureFlag, Variable[]) IQueryStructure IQueryDescription DataGrouping IFilterDescription | Improve this Doc View Source With<TRoot>(String, IQueryDescription<TRoot>, Expression<Func<IQueryWithAdapter<TRoot>, IQueryWithFlag>>[]) Dynamic repository Common-Table-Expression (WITH) subquery mapping Declaration IInheritedStructure<T> With<TRoot>(string alias, IQueryDescription<TRoot> sub, params Expression<Func<IQueryWithAdapter<TRoot>, IQueryWithFlag>>[] attributes) where TRoot : class Parameters Type Name Description String alias Common-Table-Expression (WITH) subquery alias IQueryDescription <TRoot> sub Common-Table-Expression (WITH) initial subquery description Expression < Func < IQueryWithAdapter <TRoot>, IQueryWithFlag >>[] attributes Common-Table-Expression (WITH) attributes Returns Type Description IInheritedStructure <T> Inherited repository structure Type Parameters Name Description TRoot Common-Table-Expression (WITH) initial subquery mapped type Extension Methods SerializationExtensions.ToXml<T>(T) CollectionsExtensions.SetValue<TKey, T>(TKey, T) CollectionsExtensions.AsEnum<T>(T) DataObjectQueryableExtensions.CompareVariable(Object, FilterOperation, String) Processing.Do<T>(T, Action<IProcess<T>>[]) TypeExtensions.TryConvert<T, TResult>(T, Func<T, TResult>) TypeExtensions.TryConvert<T, TResult>(T, Func<T, TResult>, TResult) TypeExtensions.ChangeType<T>(Object) TypeExtensions.ChangeType(Object, Type) TypeExtensions.InvokeMethod<TRet>(Object, Type[], Expression<Func<TRet>>, BindingFlags) TypeExtensions.InvokeMethod(Object, Type[], Expression<Action>, BindingFlags) TypeExtensions.InvokeMethod<TRet>(Object, Expression<Func<TRet>>, BindingFlags) TypeExtensions.InvokeMethod(Object, Expression<Action>, BindingFlags) SqlBlockExtensions.SetExpression<TTag, TResult>(TTag, Expression<Func<IBlockQueryAdapter, TResult>>) QueryDescriptionExtensions.SetExpression<TTag, TResult>(TTag, Expression<Func<IQueryStructureAdapter, TResult>>)"
  },
  "api/XData.Interfaces.ISequenceNameRule.html": {
    "href": "api/XData.Interfaces.ISequenceNameRule.html",
    "title": "Interface ISequenceNameRule | XData website",
    "keywords": "Interface ISequenceNameRule Sequence name rule interface Namespace : XData.Interfaces Assembly : XData.docfx.dll Syntax public interface ISequenceNameRule Methods | Improve this Doc View Source GetSequenceName(String, String, String) Returns sequence name Declaration string GetSequenceName(string context, string tableName, string columnName) Parameters Type Name Description String context Context name String tableName Table name String columnName Column name Returns Type Description String Sequence name Extension Methods SerializationExtensions.ToXml<T>(T) CollectionsExtensions.SetValue<TKey, T>(TKey, T) CollectionsExtensions.AsEnum<T>(T) DataObjectQueryableExtensions.CompareVariable(Object, FilterOperation, String) Processing.Do<T>(T, Action<IProcess<T>>[]) TypeExtensions.TryConvert<T, TResult>(T, Func<T, TResult>) TypeExtensions.TryConvert<T, TResult>(T, Func<T, TResult>, TResult) TypeExtensions.ChangeType<T>(Object) TypeExtensions.ChangeType(Object, Type) TypeExtensions.InvokeMethod<TRet>(Object, Type[], Expression<Func<TRet>>, BindingFlags) TypeExtensions.InvokeMethod(Object, Type[], Expression<Action>, BindingFlags) TypeExtensions.InvokeMethod<TRet>(Object, Expression<Func<TRet>>, BindingFlags) TypeExtensions.InvokeMethod(Object, Expression<Action>, BindingFlags) SqlBlockExtensions.SetExpression<TTag, TResult>(TTag, Expression<Func<IBlockQueryAdapter, TResult>>) QueryDescriptionExtensions.SetExpression<TTag, TResult>(TTag, Expression<Func<IQueryStructureAdapter, TResult>>)"
  },
  "api/XData.IDataObject.html": {
    "href": "api/XData.IDataObject.html",
    "title": "Interface IDataObject | XData website",
    "keywords": "Interface IDataObject Data object interface Namespace : XData Assembly : XData.docfx.dll Syntax [JsonConverter(typeof(JsonDataObjectConverter<IDataObject>))] public interface IDataObject : ISqlObject Remarks Mapping domain object to database WARNING! Data object mapping requires DataObjectAttribute ! Hint: Use DataTableAttribute , SubqueryAttribute and InnerViewAttribute to map data object to data sources Hint: Use FilterAttribute 's specific successor to link data sources and apply filters to data Hint: Use ExternalLinkAttribute to declare master/slave relations between repositories Hint: Use Lob to map binary fields [Property(\"scan\", \"SC\", Flags = DataPropertyFlag.OuterFlag)] public Lob Scan { get; set; } Hint: Use Xml to map Xml fields [Property(\"source\", \"SR\", Flags = DataPropertyFlag.OuterFlag)] public Xml Source { get; set; } Hint: Use Link<TVal, TSrc> to map data link [Property(\"name\", \"S\"), DictionaryProperty(\"Name\", \"DocState\"), DictionaryProperty(\"Code\", \"DocStateCode\")] public Link<string, DocState> DocState { get; set; } Hint: Use ColumnAttribute to map data without declaring property (for example to declare Id ) [DataObject(\"S\"), DataTable(\"T_DOC_STATE\", \"S\"), Column(\"DocStateId\", \"doc_state_id\", typeof(long?), \"S\", Flags = DataPropertyFlag.Id)] Hint: Use PropertyExpressionAttribute or ColumnExpressionAttribute to use SQL expression or subquery as property (or mapped column) data source [Property(\"doc_amount\"), PropertyExpression(\"A\", DataExpressionType.SubQuery, DbType.Decimal, ExprSize = 17, ExprScale = 5)] public double? DocAmount { get { return this.GetProperty(() => DocAmount); } } Hint: Use PropertyDefaultAttribute or ColumnDefaultAttribute to set default value generation rule to property (or mapped column) [Property(\"doc_date\", \"D\"), PropertyDefault(DefaultType.CurrentDate)] public DateTime? DocDate { get; set; } Hint: Use ReferenceAttribute to use inner view property in parent data object [PropertyLink(\"HistoryDate\", \"H\")] public DateTime? DocLastChange { get { return this.GetProperty(() => DocLastChange); } } Hint: Declare readonly fields as [PropertyLink(\"HistoryDate\", \"H\")] public DateTime? DocLastChange { get { return this.GetProperty(() => DocLastChange); } } Hint: Declare custom logic functions (see IDataLogic<T> and Execute<T>(ICollection<T>, String, IDictionary<String, Action<Byte[]>>, IDictionary<String, Func<Byte[], Byte[]>>) ) as //generate unique action key and use it for mark it realization in IDataLogic<Invoice> [CustomAction(\"{ab12d6f0-69d0-4997-bb0b-5f5f7c0581d1}\")] public static CustomLogic<Invoice> TestCustomLogic; //using obj.Execute(() => Invoice.TestCustomLogic); Hint: Variables can be used as temporary values storage // store obj.GetRepository().Variables.Add(\"SomeName\", \"SomeValue\"); // and somewhere you can get it var something = obj.GetRepository().Variables[\"SomeName\"]; Hint: HierarchyAttribute can be used to fill and maintain hierarchy tables automatically // Table T_TEST has parent_id field tree linked to test_id (T_TEST's pk) // Table L_TEST has two fields parent_id and child_id all linked to T_TEST.test_id // Table L_TEST contains all subtree relations inside T_TEST // For example: for T_TEST (test_id, parent_id): (1, null) : (2, 1) : (3, 2) // L_TEST will contain (parent_id, child_id): (1, 1) : (1, 2) : (1, 3) : (2, 2) : (2, 3) : (3, 3) [DataObject(\"T\"), DataTable(\"T_TEST\", \"T\"), Hierarchy(\"T\", \"L_TEST\", \"parent_id\", \"parent_id\", \"child_id\"), Column(\"TestId\", \"test_id\", typeof(long?), \"T\", Flags = DataPropertyFlag.Id)] Examples [DataObject(\"T\"), DataTable(\"T_DOC_TYPE\", \"T\"), Column(\"DocTypeId\", \"doc_type_id\", typeof(long?), \"T\", Flags = DataPropertyFlag.Id)] public class DocType : IDataObject { [Property(\"name\", \"T\")] public string Name { get; set; } [Property(\"code\", \"T\")] public string Code { get; set; } } Extension Methods DataObjectExtensions.Modify<T>(T, Action<T>[]) DataObjectExtensions.GetProperties<T>(T, IEnumerable<String>, DataVersion) DataObjectExtensions.GetProperties<T>(T, String[]) DataObjectExtensions.GetProperties<T>(T, DataVersion, String[]) DataObjectExtensions.IsCleared<T>(T, String) DataObjectExtensions.IsChanged<T>(T, String) DataObjectExtensions.IsChanged<T>(T, Expression<Func<T, Object>>[]) DataObjectExtensions.IsEmpty<T>(T, String) DataObjectExtensions.IsEmpty<T>(T, Expression<Func<T, Object>>) DataObjectExtensions.GetProperty<TRet>(IDataObject, String) DataObjectExtensions.GetContext(IDataObject) DataObjectExtensions.GetLayer(IDataObject) DataObjectExtensions.GetRepositoryAlias(IDataObject) DataObjectExtensions.IsAttached(IDataObject, Type) DataObjectExtensions.GetState<T>(T) DataObjectExtensions.CheckState<T>(T, DataObjectState) SerializationExtensions.ToXml<T>(T) CollectionsExtensions.SetValue<TKey, T>(TKey, T) CollectionsExtensions.AsEnum<T>(T) DataObjectQueryableExtensions.CompareVariable(Object, FilterOperation, String) Processing.Do<T>(T, Action<IProcess<T>>[]) TypeExtensions.TryConvert<T, TResult>(T, Func<T, TResult>) TypeExtensions.TryConvert<T, TResult>(T, Func<T, TResult>, TResult) TypeExtensions.ChangeType<T>(Object) TypeExtensions.ChangeType(Object, Type) TypeExtensions.InvokeMethod<TRet>(Object, Type[], Expression<Func<TRet>>, BindingFlags) TypeExtensions.InvokeMethod(Object, Type[], Expression<Action>, BindingFlags) TypeExtensions.InvokeMethod<TRet>(Object, Expression<Func<TRet>>, BindingFlags) TypeExtensions.InvokeMethod(Object, Expression<Action>, BindingFlags) SqlBlockExtensions.SetExpression<TTag, TResult>(TTag, Expression<Func<IBlockQueryAdapter, TResult>>) QueryDescriptionExtensions.SetExpression<TTag, TResult>(TTag, Expression<Func<IQueryStructureAdapter, TResult>>) QueryDescriptionExtensions.GetProperty(ISqlObject, String) See Also IRepository <T> IDataLogic <T> CheckState<T> (T, DataObjectState ) SetDeleted<T> (T, Boolean ) Execute<T> (T, Expression < Func < CustomLogic <T>>>, IDictionary < String , Action < Byte []>>, IDictionary < String , Func < Byte [], Byte []>>) Serialize<T> (T) Restore<T> (T, SerializedData ) GetProperties<T> (T, DataVersion , String []) GetProperty<T, TRet> (T, Expression < Func <T, TRet>>, DataVersion ) XData.DataObjectExtensions.GetProperty``1(``0,System.String,XData.DataVersion) GetRepository<T> (T) IsChanged<T> (T, Expression < Func <T, Object >>[]) IsEmpty<T> (T, Expression < Func <T, Object >>) IsCleared<T> (T, String ) SetCurrent<T> (T) Submit<T> (T, DataSubmitFlag ) Lock<T> (T)"
  },
  "api/XData.IDataLogic-1.html": {
    "href": "api/XData.IDataLogic-1.html",
    "title": "Interface IDataLogic<T> | XData website",
    "keywords": "Interface IDataLogic<T> Data logic interface Namespace : XData Assembly : XData.docfx.dll Syntax public interface IDataLogic<T> where T : class, IDataObject Type Parameters Name Description T Remarks Marking interface for classes contains data aware logic of mapped objects Used to divide data aware logic from mapping Hint: Separating mapping and logic to different assemblies allows to run data aware logic on XData application server Hint: Application can use XData application server or direct connect to database depending of configuration (see IConfiguration ) Examples public abstract class InvoiceLogic : IDataLogic<Invoice> { [Action(DataActionType.BeforeClear)] public readonly static RepositoryTrigger<Invoice> ClearHistoryBatch = ((IRepository<Invoice> invoiceRepository, ref DataTriggerFlag flag) => DoSomething()); [CustomAction(\"{ab12d6f0-69d0-4997-bb0b-5f5f7c0581d1}\")] public static readonly CustomLogic<Invoice> TestCustomLogic = (objects => { return DoSomethingElse(); }); } Extension Methods SerializationExtensions.ToXml<T>(T) CollectionsExtensions.SetValue<TKey, T>(TKey, T) CollectionsExtensions.AsEnum<T>(T) DataObjectQueryableExtensions.CompareVariable(Object, FilterOperation, String) Processing.Do<T>(T, Action<IProcess<T>>[]) TypeExtensions.TryConvert<T, TResult>(T, Func<T, TResult>) TypeExtensions.TryConvert<T, TResult>(T, Func<T, TResult>, TResult) TypeExtensions.ChangeType<T>(Object) TypeExtensions.ChangeType(Object, Type) TypeExtensions.InvokeMethod<TRet>(Object, Type[], Expression<Func<TRet>>, BindingFlags) TypeExtensions.InvokeMethod(Object, Type[], Expression<Action>, BindingFlags) TypeExtensions.InvokeMethod<TRet>(Object, Expression<Func<TRet>>, BindingFlags) TypeExtensions.InvokeMethod(Object, Expression<Action>, BindingFlags) SqlBlockExtensions.SetExpression<TTag, TResult>(TTag, Expression<Func<IBlockQueryAdapter, TResult>>) QueryDescriptionExtensions.SetExpression<TTag, TResult>(TTag, Expression<Func<IQueryStructureAdapter, TResult>>) See Also IDataObject InitRepository <T> InvalidateRepository <T> InitObject <T> InvalidateObject <T> Trigger <T> CustomLogic <T>"
  },
  "api/XData.Mapping.PropertyBaseAttribute.html": {
    "href": "api/XData.Mapping.PropertyBaseAttribute.html",
    "title": "Class PropertyBaseAttribute | XData website",
    "keywords": "Class PropertyBaseAttribute Data property base attribute Inheritance Object Attribute PropertyBaseAttribute PropertyAttribute ReferenceAttribute Inherited Members Attribute.Equals(Object) Attribute.GetCustomAttribute(Assembly, Type) Attribute.GetCustomAttribute(Assembly, Type, Boolean) Attribute.GetCustomAttribute(MemberInfo, Type) Attribute.GetCustomAttribute(MemberInfo, Type, Boolean) Attribute.GetCustomAttribute(Module, Type) Attribute.GetCustomAttribute(Module, Type, Boolean) Attribute.GetCustomAttribute(ParameterInfo, Type) Attribute.GetCustomAttribute(ParameterInfo, Type, Boolean) Attribute.GetCustomAttributes(Assembly) Attribute.GetCustomAttributes(Assembly, Boolean) Attribute.GetCustomAttributes(Assembly, Type) Attribute.GetCustomAttributes(Assembly, Type, Boolean) Attribute.GetCustomAttributes(MemberInfo) Attribute.GetCustomAttributes(MemberInfo, Boolean) Attribute.GetCustomAttributes(MemberInfo, Type) Attribute.GetCustomAttributes(MemberInfo, Type, Boolean) Attribute.GetCustomAttributes(Module) Attribute.GetCustomAttributes(Module, Boolean) Attribute.GetCustomAttributes(Module, Type) Attribute.GetCustomAttributes(Module, Type, Boolean) Attribute.GetCustomAttributes(ParameterInfo) Attribute.GetCustomAttributes(ParameterInfo, Boolean) Attribute.GetCustomAttributes(ParameterInfo, Type) Attribute.GetCustomAttributes(ParameterInfo, Type, Boolean) Attribute.GetHashCode() Attribute.IsDefaultAttribute() Attribute.IsDefined(Assembly, Type) Attribute.IsDefined(Assembly, Type, Boolean) Attribute.IsDefined(MemberInfo, Type) Attribute.IsDefined(MemberInfo, Type, Boolean) Attribute.IsDefined(Module, Type) Attribute.IsDefined(Module, Type, Boolean) Attribute.IsDefined(ParameterInfo, Type) Attribute.IsDefined(ParameterInfo, Type, Boolean) Attribute.Match(Object) Attribute.TypeId Object.Equals(Object, Object) Object.GetType() Object.MemberwiseClone() Object.ReferenceEquals(Object, Object) Object.ToString() Namespace : XData.Mapping Assembly : XData.docfx.dll Syntax public abstract class PropertyBaseAttribute : Attribute Properties | Improve this Doc View Source Flags Property flags Declaration public DataPropertyFlag Flags { get; set; } Property Value Type Description DataPropertyFlag See Also DataPropertyFlag | Improve this Doc View Source IsLink Property link flag Declaration public abstract bool IsLink { get; } Property Value Type Description Boolean | Improve this Doc View Source NativeSqlType Native SQL type name Declaration public string NativeSqlType { get; set; } Property Value Type Description String Remarks Used to specify native SQL column type when conflicted with default type mapping WARNING! May be not supported by database adapter! | Improve this Doc View Source OrderBy Order by priority Declaration public int OrderBy { get; set; } Property Value Type Description Int32 | Improve this Doc View Source OrderByDesc Order by desc flag Declaration public bool OrderByDesc { get; set; } Property Value Type Description Boolean | Improve this Doc View Source Source Source alias Declaration public string Source { get; } Property Value Type Description String See Also Alias Extension Methods SerializationExtensions.ToXml<T>(T) CollectionsExtensions.SetValue<TKey, T>(TKey, T) CollectionsExtensions.AsEnum<T>(T) DataObjectQueryableExtensions.CompareVariable(Object, FilterOperation, String) Processing.Do<T>(T, Action<IProcess<T>>[]) TypeExtensions.TryConvert<T, TResult>(T, Func<T, TResult>) TypeExtensions.TryConvert<T, TResult>(T, Func<T, TResult>, TResult) TypeExtensions.ChangeType<T>(Object) TypeExtensions.ChangeType(Object, Type) TypeExtensions.InvokeMethod<TRet>(Object, Type[], Expression<Func<TRet>>, BindingFlags) TypeExtensions.InvokeMethod(Object, Type[], Expression<Action>, BindingFlags) TypeExtensions.InvokeMethod<TRet>(Object, Expression<Func<TRet>>, BindingFlags) TypeExtensions.InvokeMethod(Object, Expression<Action>, BindingFlags) SqlBlockExtensions.SetExpression<TTag, TResult>(TTag, Expression<Func<IBlockQueryAdapter, TResult>>) QueryDescriptionExtensions.SetExpression<TTag, TResult>(TTag, Expression<Func<IQueryStructureAdapter, TResult>>) See Also PropertyAttribute ReferenceAttribute"
  },
  "api/XData.Mapping.PropertyAttribute.html": {
    "href": "api/XData.Mapping.PropertyAttribute.html",
    "title": "Class PropertyAttribute | XData website",
    "keywords": "Class PropertyAttribute Data object property attribute Inheritance Object Attribute PropertyBaseAttribute PropertyAttribute Inherited Members PropertyBaseAttribute.Source PropertyBaseAttribute.Flags PropertyBaseAttribute.NativeSqlType PropertyBaseAttribute.OrderBy PropertyBaseAttribute.OrderByDesc Attribute.Equals(Object) Attribute.GetCustomAttribute(Assembly, Type) Attribute.GetCustomAttribute(Assembly, Type, Boolean) Attribute.GetCustomAttribute(MemberInfo, Type) Attribute.GetCustomAttribute(MemberInfo, Type, Boolean) Attribute.GetCustomAttribute(Module, Type) Attribute.GetCustomAttribute(Module, Type, Boolean) Attribute.GetCustomAttribute(ParameterInfo, Type) Attribute.GetCustomAttribute(ParameterInfo, Type, Boolean) Attribute.GetCustomAttributes(Assembly) Attribute.GetCustomAttributes(Assembly, Boolean) Attribute.GetCustomAttributes(Assembly, Type) Attribute.GetCustomAttributes(Assembly, Type, Boolean) Attribute.GetCustomAttributes(MemberInfo) Attribute.GetCustomAttributes(MemberInfo, Boolean) Attribute.GetCustomAttributes(MemberInfo, Type) Attribute.GetCustomAttributes(MemberInfo, Type, Boolean) Attribute.GetCustomAttributes(Module) Attribute.GetCustomAttributes(Module, Boolean) Attribute.GetCustomAttributes(Module, Type) Attribute.GetCustomAttributes(Module, Type, Boolean) Attribute.GetCustomAttributes(ParameterInfo) Attribute.GetCustomAttributes(ParameterInfo, Boolean) Attribute.GetCustomAttributes(ParameterInfo, Type) Attribute.GetCustomAttributes(ParameterInfo, Type, Boolean) Attribute.GetHashCode() Attribute.IsDefaultAttribute() Attribute.IsDefined(Assembly, Type) Attribute.IsDefined(Assembly, Type, Boolean) Attribute.IsDefined(MemberInfo, Type) Attribute.IsDefined(MemberInfo, Type, Boolean) Attribute.IsDefined(Module, Type) Attribute.IsDefined(Module, Type, Boolean) Attribute.IsDefined(ParameterInfo, Type) Attribute.IsDefined(ParameterInfo, Type, Boolean) Attribute.Match(Object) Attribute.TypeId Object.Equals(Object, Object) Object.GetType() Object.MemberwiseClone() Object.ReferenceEquals(Object, Object) Object.ToString() Namespace : XData.Mapping Assembly : XData.docfx.dll Syntax [AttributeUsage(AttributeTargets.Property)] public sealed class PropertyAttribute : PropertyBaseAttribute Constructors | Improve this Doc View Source PropertyAttribute(String, String) Data object property attribute Declaration public PropertyAttribute(string source = \"\", string fieldName = \"\") Parameters Type Name Description String source Source alias String fieldName Field name Exceptions Type Condition XDataRuntimeException Field name cannot be null or empty string Properties | Improve this Doc View Source FieldName Field name Declaration public string FieldName { get; } Property Value Type Description String | Improve this Doc View Source IsLink Property link flag Declaration public override bool IsLink { get; } Property Value Type Description Boolean False Overrides PropertyBaseAttribute.IsLink Extension Methods SerializationExtensions.ToXml<T>(T) CollectionsExtensions.SetValue<TKey, T>(TKey, T) CollectionsExtensions.AsEnum<T>(T) DataObjectQueryableExtensions.CompareVariable(Object, FilterOperation, String) Processing.Do<T>(T, Action<IProcess<T>>[]) TypeExtensions.TryConvert<T, TResult>(T, Func<T, TResult>) TypeExtensions.TryConvert<T, TResult>(T, Func<T, TResult>, TResult) TypeExtensions.ChangeType<T>(Object) TypeExtensions.ChangeType(Object, Type) TypeExtensions.InvokeMethod<TRet>(Object, Type[], Expression<Func<TRet>>, BindingFlags) TypeExtensions.InvokeMethod(Object, Type[], Expression<Action>, BindingFlags) TypeExtensions.InvokeMethod<TRet>(Object, Expression<Func<TRet>>, BindingFlags) TypeExtensions.InvokeMethod(Object, Expression<Action>, BindingFlags) SqlBlockExtensions.SetExpression<TTag, TResult>(TTag, Expression<Func<IBlockQueryAdapter, TResult>>) QueryDescriptionExtensions.SetExpression<TTag, TResult>(TTag, Expression<Func<IQueryStructureAdapter, TResult>>)"
  },
  "api/XData.Extensions.Indexer-1.html": {
    "href": "api/XData.Extensions.Indexer-1.html",
    "title": "Class Indexer<T> | XData website",
    "keywords": "Class Indexer<T> Indexed objects comparer Hint: Objects can be indexed by annotation attribute IndexAttribute Inheritance Object Indexer<T> Implements IComparer <T> IEqualityComparer <T> Inherited Members Object.Equals(Object) Object.Equals(Object, Object) Object.GetHashCode() Object.GetType() Object.MemberwiseClone() Object.ReferenceEquals(Object, Object) Object.ToString() Namespace : XData.Extensions Assembly : XData.docfx.dll Syntax public class Indexer<T> : IIndexer, IComparer<T>, IEqualityComparer<T> Type Parameters Name Description T Indexed object type Constructors | Improve this Doc View Source Indexer(String) Indexer parametrized constructor Declaration public Indexer(string propertyName) Parameters Type Name Description String propertyName Comparable property name Methods | Improve this Doc View Source Compare(T, T) Compares two objects and returns a value indicating whether one is less than, equal to, or greater than the other. Declaration public int Compare(T x, T y) Parameters Type Name Description T x The first object to compare. T y The second object to compare. Returns Type Description Int32 A signed integer that indicates the relative values of x and y , as shown in the following table.Value Meaning Less than zero x is less than y .Zero x equals y .Greater than zero x is greater than y . Exceptions Type Condition XDataRuntimeException IndexedAttribute not found | Improve this Doc View Source Equals(T, T) Determines whether the specified objects are equal. Declaration public bool Equals(T x, T y) Parameters Type Name Description T x The first object to compare. T y The second object to compare. Returns Type Description Boolean true if the specified objects are equal; otherwise, false. Exceptions Type Condition XDataRuntimeException IndexedAttribute not found | Improve this Doc View Source GetHashCode(T) Returns a hash code for the specified object. Declaration public int GetHashCode(T obj) Parameters Type Name Description T obj The Object for which a hash code is to be returned. Returns Type Description Int32 A hash code for the specified object. Exceptions Type Condition ArgumentNullException The type of obj is a reference type and obj is null. XDataRuntimeException IndexedAttribute not found | Improve this Doc View Source GetInstance() Singleton comparer instance Declaration public static Indexer<T> GetInstance() Returns Type Description Indexer <T> Comparer instance Implements System.Collections.Generic.IComparer<T> System.Collections.Generic.IEqualityComparer<T> Extension Methods SerializationExtensions.ToXml<T>(T) CollectionsExtensions.SetValue<TKey, T>(TKey, T) CollectionsExtensions.AsEnum<T>(T) DataObjectQueryableExtensions.CompareVariable(Object, FilterOperation, String) Processing.Do<T>(T, Action<IProcess<T>>[]) TypeExtensions.TryConvert<T, TResult>(T, Func<T, TResult>) TypeExtensions.TryConvert<T, TResult>(T, Func<T, TResult>, TResult) TypeExtensions.ChangeType<T>(Object) TypeExtensions.ChangeType(Object, Type) TypeExtensions.InvokeMethod<TRet>(Object, Type[], Expression<Func<TRet>>, BindingFlags) TypeExtensions.InvokeMethod(Object, Type[], Expression<Action>, BindingFlags) TypeExtensions.InvokeMethod<TRet>(Object, Expression<Func<TRet>>, BindingFlags) TypeExtensions.InvokeMethod(Object, Expression<Action>, BindingFlags) SqlBlockExtensions.SetExpression<TTag, TResult>(TTag, Expression<Func<IBlockQueryAdapter, TResult>>) QueryDescriptionExtensions.SetExpression<TTag, TResult>(TTag, Expression<Func<IQueryStructureAdapter, TResult>>)"
  },
  "api/XData.Extensions.IndexAttribute.html": {
    "href": "api/XData.Extensions.IndexAttribute.html",
    "title": "Class IndexAttribute | XData website",
    "keywords": "Class IndexAttribute Attribute to compare objects by property value Inheritance Object Attribute IndexAttribute Inherited Members Attribute.Equals(Object) Attribute.GetCustomAttribute(Assembly, Type) Attribute.GetCustomAttribute(Assembly, Type, Boolean) Attribute.GetCustomAttribute(MemberInfo, Type) Attribute.GetCustomAttribute(MemberInfo, Type, Boolean) Attribute.GetCustomAttribute(Module, Type) Attribute.GetCustomAttribute(Module, Type, Boolean) Attribute.GetCustomAttribute(ParameterInfo, Type) Attribute.GetCustomAttribute(ParameterInfo, Type, Boolean) Attribute.GetCustomAttributes(Assembly) Attribute.GetCustomAttributes(Assembly, Boolean) Attribute.GetCustomAttributes(Assembly, Type) Attribute.GetCustomAttributes(Assembly, Type, Boolean) Attribute.GetCustomAttributes(MemberInfo) Attribute.GetCustomAttributes(MemberInfo, Boolean) Attribute.GetCustomAttributes(MemberInfo, Type) Attribute.GetCustomAttributes(MemberInfo, Type, Boolean) Attribute.GetCustomAttributes(Module) Attribute.GetCustomAttributes(Module, Boolean) Attribute.GetCustomAttributes(Module, Type) Attribute.GetCustomAttributes(Module, Type, Boolean) Attribute.GetCustomAttributes(ParameterInfo) Attribute.GetCustomAttributes(ParameterInfo, Boolean) Attribute.GetCustomAttributes(ParameterInfo, Type) Attribute.GetCustomAttributes(ParameterInfo, Type, Boolean) Attribute.GetHashCode() Attribute.IsDefaultAttribute() Attribute.IsDefined(Assembly, Type) Attribute.IsDefined(Assembly, Type, Boolean) Attribute.IsDefined(MemberInfo, Type) Attribute.IsDefined(MemberInfo, Type, Boolean) Attribute.IsDefined(Module, Type) Attribute.IsDefined(Module, Type, Boolean) Attribute.IsDefined(ParameterInfo, Type) Attribute.IsDefined(ParameterInfo, Type, Boolean) Attribute.Match(Object) Attribute.TypeId Object.Equals(Object, Object) Object.GetType() Object.MemberwiseClone() Object.ReferenceEquals(Object, Object) Object.ToString() Namespace : XData.Extensions Assembly : XData.docfx.dll Syntax [AttributeUsage(AttributeTargets.Property)] public class IndexAttribute : Attribute Extension Methods SerializationExtensions.ToXml<T>(T) CollectionsExtensions.SetValue<TKey, T>(TKey, T) CollectionsExtensions.AsEnum<T>(T) DataObjectQueryableExtensions.CompareVariable(Object, FilterOperation, String) Processing.Do<T>(T, Action<IProcess<T>>[]) TypeExtensions.TryConvert<T, TResult>(T, Func<T, TResult>) TypeExtensions.TryConvert<T, TResult>(T, Func<T, TResult>, TResult) TypeExtensions.ChangeType<T>(Object) TypeExtensions.ChangeType(Object, Type) TypeExtensions.InvokeMethod<TRet>(Object, Type[], Expression<Func<TRet>>, BindingFlags) TypeExtensions.InvokeMethod(Object, Type[], Expression<Action>, BindingFlags) TypeExtensions.InvokeMethod<TRet>(Object, Expression<Func<TRet>>, BindingFlags) TypeExtensions.InvokeMethod(Object, Expression<Action>, BindingFlags) SqlBlockExtensions.SetExpression<TTag, TResult>(TTag, Expression<Func<IBlockQueryAdapter, TResult>>) QueryDescriptionExtensions.SetExpression<TTag, TResult>(TTag, Expression<Func<IQueryStructureAdapter, TResult>>)"
  },
  "api/XData.DataSource.Structure.FilterState.html": {
    "href": "api/XData.DataSource.Structure.FilterState.html",
    "title": "Class FilterState | XData website",
    "keywords": "Class FilterState Filter state info Inheritance Object FilterState Implements ISubqueryLink IInnerViewLink IInnerLink IDictionaryFilter ISubqueryFilter IExpressionFilter IRangeFilter IConstantFilter IRuntimeFilter INamedFilter IOptionalFilter IFilter ICloneable IEquatable < FilterState > Inherited Members Object.Equals(Object) Object.Equals(Object, Object) Object.GetHashCode() Object.GetType() Object.MemberwiseClone() Object.ReferenceEquals(Object, Object) Object.ToString() Namespace : XData.DataSource.Structure Assembly : XData.docfx.dll Syntax [Serializable] [DataContract] public sealed class FilterState : ISubqueryLink, IInnerViewLink, IInnerLink, IDictionaryFilter, ISubqueryFilter, IExpressionFilter, IRangeFilter, IConstantFilter, IRuntimeFilter, INamedFilter, IOptionalFilter, IFilter, ICloneable, IEquatable<FilterState> Properties | Improve this Doc View Source Combination Parent filter combination name Declaration [DataMember] public string Combination { get; set; } Property Value Type Description String | Improve this Doc View Source ConstantType Constant type Declaration [DataMember] public FilterConstantType ConstantType { get; set; } Property Value Type Description FilterConstantType | Improve this Doc View Source ConstantValue Filter constant value Declaration [DataMember] public object ConstantValue { get; set; } Property Value Type Description Object | Improve this Doc View Source DictionaryCode Dictionary filter code column name Declaration [DataMember] public string DictionaryCode { get; set; } Property Value Type Description String | Improve this Doc View Source DictionaryId Dictionary filter id column name Declaration [DataMember] public string DictionaryId { get; set; } Property Value Type Description String | Improve this Doc View Source DictionaryTableName Dictionary table name Declaration [DataMember] public string DictionaryTableName { get; set; } Property Value Type Description String | Improve this Doc View Source DictionaryValue Dictionary value Declaration [DataMember] public string DictionaryValue { get; set; } Property Value Type Description String | Improve this Doc View Source Dynamic Filter dynamic flag Declaration [DataMember] public bool Dynamic { get; set; } Property Value Type Description Boolean | Improve this Doc View Source ExprText Expression filter text Declaration [DataMember] public string ExprText { get; set; } Property Value Type Description String | Improve this Doc View Source Field Filter field name Declaration [DataMember] public string Field { get; set; } Property Value Type Description String | Improve this Doc View Source FilterType Filter type Declaration [DataMember] public FilterType FilterType { get; set; } Property Value Type Description FilterType | Improve this Doc View Source IsVariableValue Dictionary filter value is variable flag Declaration [DataMember] public bool IsVariableValue { get; set; } Property Value Type Description Boolean | Improve this Doc View Source IteratorFilter Iterator filter flag Declaration [DataMember] public bool IteratorFilter { get; set; } Property Value Type Description Boolean | Improve this Doc View Source LinkedAlias Linked subquery source alias Declaration [DataMember] public string LinkedAlias { get; set; } Property Value Type Description String | Improve this Doc View Source LinkedField Linked field name Declaration [DataMember] public string LinkedField { get; set; } Property Value Type Description String | Improve this Doc View Source LinkedPropertyName Outer link linked property name Declaration [DataMember] public string LinkedPropertyName { get; set; } Property Value Type Description String | Improve this Doc View Source LinkedSourceAlias Linked source alias Declaration [DataMember] public string LinkedSourceAlias { get; set; } Property Value Type Description String | Improve this Doc View Source LinkedType Linked subquery type name Declaration [DataMember] public string LinkedType { get; set; } Property Value Type Description String | Improve this Doc View Source Name Filter name Declaration [DataMember] public string Name { get; set; } Property Value Type Description String | Improve this Doc View Source Nullable Filter null value handling type Declaration [DataMember] public FilterNullable Nullable { get; set; } Property Value Type Description FilterNullable | Improve this Doc View Source Operation Filter operation Declaration [DataMember] public FilterOperation Operation { get; set; } Property Value Type Description FilterOperation | Improve this Doc View Source Primary Primary filter flag Declaration [DataMember] public bool Primary { get; set; } Property Value Type Description Boolean | Improve this Doc View Source PropertyName Outer link property name Declaration [DataMember] public string PropertyName { get; set; } Property Value Type Description String | Improve this Doc View Source RangeValues Range filter values Declaration [DataMember] public object[] RangeValues { get; set; } Property Value Type Description Object [] | Improve this Doc View Source SourceAlias Filter field source alias Declaration [DataMember] public string SourceAlias { get; set; } Property Value Type Description String | Improve this Doc View Source SubqueryAlias Filter subquery alias Declaration [DataMember] public string SubqueryAlias { get; set; } Property Value Type Description String Methods | Improve this Doc View Source Clone() Clone filter state Declaration public object Clone() Returns Type Description Object Empty filter state | Improve this Doc View Source Equals(FilterState) FilterState equality check Declaration public bool Equals(FilterState other) Parameters Type Name Description FilterState other FilterState instance to compare Returns Type Description Boolean Instances are contains the same data | Improve this Doc View Source GetAliases() Link aliases Declaration public string[] GetAliases() Returns Type Description String [] | Improve this Doc View Source GetCaption() Filter caption Declaration public string GetCaption() Returns Type Description String | Improve this Doc View Source GetIsLink() Filter link flag Declaration public bool GetIsLink() Returns Type Description Boolean Implements ISubqueryLink IInnerViewLink IInnerLink IDictionaryFilter ISubqueryFilter IExpressionFilter IRangeFilter IConstantFilter IRuntimeFilter INamedFilter IOptionalFilter IFilter System.ICloneable System.IEquatable<T> Extension Methods SerializationExtensions.ToXml<T>(T) CollectionsExtensions.SetValue<TKey, T>(TKey, T) CollectionsExtensions.AsEnum<T>(T) DataObjectQueryableExtensions.CompareVariable(Object, FilterOperation, String) Processing.Do<T>(T, Action<IProcess<T>>[]) TypeExtensions.TryConvert<T, TResult>(T, Func<T, TResult>) TypeExtensions.TryConvert<T, TResult>(T, Func<T, TResult>, TResult) TypeExtensions.ChangeType<T>(Object) TypeExtensions.ChangeType(Object, Type) TypeExtensions.InvokeMethod<TRet>(Object, Type[], Expression<Func<TRet>>, BindingFlags) TypeExtensions.InvokeMethod(Object, Type[], Expression<Action>, BindingFlags) TypeExtensions.InvokeMethod<TRet>(Object, Expression<Func<TRet>>, BindingFlags) TypeExtensions.InvokeMethod(Object, Expression<Action>, BindingFlags) SqlBlockExtensions.SetExpression<TTag, TResult>(TTag, Expression<Func<IBlockQueryAdapter, TResult>>) QueryDescriptionExtensions.SetExpression<TTag, TResult>(TTag, Expression<Func<IQueryStructureAdapter, TResult>>)"
  },
  "api/XData.DataSource.Structure.FilterName.html": {
    "href": "api/XData.DataSource.Structure.FilterName.html",
    "title": "Class FilterName | XData website",
    "keywords": "Class FilterName FilterName helper class to initialize named RuntimeFilter Inheritance Object FilterName Inherited Members Object.Equals(Object) Object.Equals(Object, Object) Object.GetHashCode() Object.GetType() Object.MemberwiseClone() Object.ReferenceEquals(Object, Object) Object.ToString() Namespace : XData.DataSource.Structure Assembly : XData.docfx.dll Syntax public class FilterName Constructors | Improve this Doc View Source FilterName(String) FilterName constructor Declaration public FilterName(string name) Parameters Type Name Description String name Properties | Improve this Doc View Source Name Filter name Declaration public string Name { get; } Property Value Type Description String Extension Methods SerializationExtensions.ToXml<T>(T) CollectionsExtensions.SetValue<TKey, T>(TKey, T) CollectionsExtensions.AsEnum<T>(T) DataObjectQueryableExtensions.CompareVariable(Object, FilterOperation, String) Processing.Do<T>(T, Action<IProcess<T>>[]) TypeExtensions.TryConvert<T, TResult>(T, Func<T, TResult>) TypeExtensions.TryConvert<T, TResult>(T, Func<T, TResult>, TResult) TypeExtensions.ChangeType<T>(Object) TypeExtensions.ChangeType(Object, Type) TypeExtensions.InvokeMethod<TRet>(Object, Type[], Expression<Func<TRet>>, BindingFlags) TypeExtensions.InvokeMethod(Object, Type[], Expression<Action>, BindingFlags) TypeExtensions.InvokeMethod<TRet>(Object, Expression<Func<TRet>>, BindingFlags) TypeExtensions.InvokeMethod(Object, Expression<Action>, BindingFlags) SqlBlockExtensions.SetExpression<TTag, TResult>(TTag, Expression<Func<IBlockQueryAdapter, TResult>>) QueryDescriptionExtensions.SetExpression<TTag, TResult>(TTag, Expression<Func<IQueryStructureAdapter, TResult>>)"
  },
  "api/XData.Database.SqlBlock.IMergeBlockAdapter.html": {
    "href": "api/XData.Database.SqlBlock.IMergeBlockAdapter.html",
    "title": "Interface IMergeBlockAdapter | XData website",
    "keywords": "Interface IMergeBlockAdapter Merge mapping adapter Inherited Members ISetBlockAdapter.Value<TValue>(Expression<Func<ISqlValueAdapter, ISqlValue<TValue>>>) ISetBlockAdapter.Value<TValue>(String, Expression<Func<ISqlValueAdapter, ISqlValue<TValue>>>) Namespace : XData.Database.SqlBlock Assembly : XData.docfx.dll Syntax public interface IMergeBlockAdapter : ISetBlockAdapter Methods | Improve this Doc View Source Field<TValue>(Expression<Func<ISqlValueAdapter, ISqlValue<TValue>>>, Expression<Func<IMergeAttributeAdapter, IStructureFlag>>[]) Field mapping Declaration TValue Field<TValue>(Expression<Func<ISqlValueAdapter, ISqlValue<TValue>>> value, params Expression<Func<IMergeAttributeAdapter, IStructureFlag>>[] attributes) Parameters Type Name Description Expression < Func < ISqlValueAdapter , ISqlValue <TValue>>> value Property mapping value Expression < Func < IMergeAttributeAdapter , IStructureFlag >>[] attributes Merge roles structure flags Returns Type Description TValue Field value Type Parameters Name Description TValue Field type | Improve this Doc View Source Field<TValue>(String, Expression<Func<ISqlValueAdapter, ISqlValue<TValue>>>, Expression<Func<IMergeAttributeAdapter, IStructureFlag>>[]) Field mapping Declaration TValue Field<TValue>(string fieldName, Expression<Func<ISqlValueAdapter, ISqlValue<TValue>>> value, params Expression<Func<IMergeAttributeAdapter, IStructureFlag>>[] attributes) Parameters Type Name Description String fieldName Field name Expression < Func < ISqlValueAdapter , ISqlValue <TValue>>> value Property mapping value Expression < Func < IMergeAttributeAdapter , IStructureFlag >>[] attributes Merge roles structure flags Returns Type Description TValue Field value Type Parameters Name Description TValue Field type Extension Methods SerializationExtensions.ToXml<T>(T) CollectionsExtensions.SetValue<TKey, T>(TKey, T) CollectionsExtensions.AsEnum<T>(T) DataObjectQueryableExtensions.CompareVariable(Object, FilterOperation, String) Processing.Do<T>(T, Action<IProcess<T>>[]) TypeExtensions.TryConvert<T, TResult>(T, Func<T, TResult>) TypeExtensions.TryConvert<T, TResult>(T, Func<T, TResult>, TResult) TypeExtensions.ChangeType<T>(Object) TypeExtensions.ChangeType(Object, Type) TypeExtensions.InvokeMethod<TRet>(Object, Type[], Expression<Func<TRet>>, BindingFlags) TypeExtensions.InvokeMethod(Object, Type[], Expression<Action>, BindingFlags) TypeExtensions.InvokeMethod<TRet>(Object, Expression<Func<TRet>>, BindingFlags) TypeExtensions.InvokeMethod(Object, Expression<Action>, BindingFlags) SqlBlockExtensions.SetExpression<TTag, TResult>(TTag, Expression<Func<IBlockQueryAdapter, TResult>>) QueryDescriptionExtensions.SetExpression<TTag, TResult>(TTag, Expression<Func<IQueryStructureAdapter, TResult>>)"
  },
  "api/XData.Database.Dialect.MergeFlag.html": {
    "href": "api/XData.Database.Dialect.MergeFlag.html",
    "title": "Enum MergeFlag | XData website",
    "keywords": "Enum MergeFlag Namespace : XData.Database.Dialect Assembly : XData.docfx.dll Syntax [Flags] public enum MergeFlag Fields Name Description Insert Link None Update Extension Methods SerializationExtensions.ToXml<MergeFlag>() CollectionsExtensions.SetValue<MergeFlag, T>(T) CollectionsExtensions.AsEnum<MergeFlag>() DataObjectQueryableExtensions.CompareVariable(FilterOperation, String) Processing.Do<MergeFlag>(Action<IProcess<MergeFlag>>[]) TypeExtensions.ChangeType<T>() TypeExtensions.ChangeType(Type) TypeExtensions.InvokeMethod<TRet>(Type[], Expression<Func<TRet>>, BindingFlags) TypeExtensions.InvokeMethod(Type[], Expression<Action>, BindingFlags) TypeExtensions.InvokeMethod<TRet>(Expression<Func<TRet>>, BindingFlags) TypeExtensions.InvokeMethod(Expression<Action>, BindingFlags) TypeExtensions.ConvertTo<T>() TypeExtensions.EqualValue(Enum) SqlBlockExtensions.SetExpression<MergeFlag, TResult>(Expression<Func<IBlockQueryAdapter, TResult>>) QueryDescriptionExtensions.SetExpression<MergeFlag, TResult>(Expression<Func<IQueryStructureAdapter, TResult>>)"
  },
  "api/XData.DataActionType.html": {
    "href": "api/XData.DataActionType.html",
    "title": "Enum DataActionType | XData website",
    "keywords": "Enum DataActionType Action type Namespace : XData Assembly : XData.docfx.dll Syntax public enum DataActionType Fields Name Description AfterClear After clear trigger logic AfterDelete After delete trigger logic AfterInsert After insert trigger logic AfterUpdate After update trigger logic BeforeClear Before clear trigger logic BeforeDelete Before delete trigger logic BeforeInsert Before insert trigger logic BeforeUpdate Before update trigger logic InitObject Object instance initialization code InitRepository Repository initialization code InvalidateObject Refresh object event code InvalidateRepository Refresh repository event code See Also ActionType InitRepository InvalidateRepository InvalidateObject InitObject BeforeInsert BeforeUpdate BeforeDelete AfterInsert AfterUpdate AfterDelete BeforeClear AfterClear Extension Methods SerializationExtensions.ToXml<DataActionType>() CollectionsExtensions.SetValue<DataActionType, T>(T) CollectionsExtensions.AsEnum<DataActionType>() DataObjectQueryableExtensions.CompareVariable(FilterOperation, String) Processing.Do<DataActionType>(Action<IProcess<DataActionType>>[]) TypeExtensions.ChangeType<T>() TypeExtensions.ChangeType(Type) TypeExtensions.InvokeMethod<TRet>(Type[], Expression<Func<TRet>>, BindingFlags) TypeExtensions.InvokeMethod(Type[], Expression<Action>, BindingFlags) TypeExtensions.InvokeMethod<TRet>(Expression<Func<TRet>>, BindingFlags) TypeExtensions.InvokeMethod(Expression<Action>, BindingFlags) TypeExtensions.ConvertTo<T>() TypeExtensions.EqualValue(Enum) SqlBlockExtensions.SetExpression<DataActionType, TResult>(Expression<Func<IBlockQueryAdapter, TResult>>) QueryDescriptionExtensions.SetExpression<DataActionType, TResult>(Expression<Func<IQueryStructureAdapter, TResult>>)"
  },
  "api/XData.Async.AsyncExtensions.html": {
    "href": "api/XData.Async.AsyncExtensions.html",
    "title": "Class AsyncExtensions | XData website",
    "keywords": "Class AsyncExtensions Inheritance Object AsyncExtensions Inherited Members Object.Equals(Object) Object.Equals(Object, Object) Object.GetHashCode() Object.GetType() Object.MemberwiseClone() Object.ReferenceEquals(Object, Object) Object.ToString() Namespace : XData.Async Assembly : XData.docfx.dll Syntax public static class AsyncExtensions Methods | Improve this Doc View Source AddAsync<TFrom, T>(IRepository<T>, IEnumerable<TFrom>, DataSubmitFlag) Asynchronous wrapper over Add Declaration public static Task<bool> AddAsync<TFrom, T>(this IRepository<T> source, IEnumerable<TFrom> objects, DataSubmitFlag flag = DataSubmitFlag.None) where TFrom : class where T : class, IDataObject, new() Parameters Type Name Description IRepository <T> source Repository to submit IEnumerable <TFrom> objects Objects to submit DataSubmitFlag flag Data submit flag Returns Type Description Task < Boolean > Asynchronous wrapper over Submit Type Parameters Name Description TFrom T | Improve this Doc View Source AddAsync<TFrom, T>(IRepository<T>, IEnumerable<TFrom>, Mapping<TFrom, T>, DataSubmitFlag) Asynchronous wrapper over Add Declaration public static Task<bool> AddAsync<TFrom, T>(this IRepository<T> source, IEnumerable<TFrom> objects, Mapping<TFrom, T> mapping, DataSubmitFlag flag = DataSubmitFlag.None) where TFrom : class where T : class, IDataObject, new() Parameters Type Name Description IRepository <T> source Repository to submit IEnumerable <TFrom> objects Objects to submit Mapping <TFrom, T> mapping Property mapping DataSubmitFlag flag Data submit flag Returns Type Description Task < Boolean > Asynchronous wrapper over Submit Type Parameters Name Description TFrom T | Improve this Doc View Source AllAsync<T>(IQueryable<T>, Expression<Func<T, Boolean>>) Asynchronous wrapper over All() LINQ function Declaration public static Task<bool> AllAsync<T>(this IQueryable<T> source, Expression<Func<T, bool>> predicate) Parameters Type Name Description IQueryable <T> source Source object sequence Expression < Func <T, Boolean >> predicate A function to test each element for a condition Returns Type Description Task < Boolean > Asynchronous call over All() LINQ function Type Parameters Name Description T Object type | Improve this Doc View Source AllAsync<T>(IQueryable<T>, Expression<Func<T, Boolean>>, CancellationToken) Asynchronous wrapper over All() LINQ function Declaration public static Task<bool> AllAsync<T>(this IQueryable<T> source, Expression<Func<T, bool>> predicate, CancellationToken token) Parameters Type Name Description IQueryable <T> source Source object sequence Expression < Func <T, Boolean >> predicate A function to test each element for a condition CancellationToken token Cancellation token Returns Type Description Task < Boolean > Asynchronous call over All() LINQ function Type Parameters Name Description T Object type | Improve this Doc View Source AllAsync<T>(IDataQuery<T>, Expression<Func<T, Boolean>>) Asynchronous wrapper over All() LINQ function Declaration public static Task<bool> AllAsync<T>(this IDataQuery<T> source, Expression<Func<T, bool>> predicate) Parameters Type Name Description IDataQuery <T> source Source object sequence Expression < Func <T, Boolean >> predicate A function to test each element for a condition Returns Type Description Task < Boolean > Asynchronous call over All() LINQ function Type Parameters Name Description T Object type | Improve this Doc View Source AnyAsync<T>(IQueryable<T>) Asynchronous wrapper over Any() LINQ function Declaration public static Task<bool> AnyAsync<T>(this IQueryable<T> source) Parameters Type Name Description IQueryable <T> source Source object sequence Returns Type Description Task < Boolean > Asynchronous call over Any() LINQ function Type Parameters Name Description T Object type | Improve this Doc View Source AnyAsync<T>(IQueryable<T>, Expression<Func<T, Boolean>>) Asynchronous wrapper over Any() LINQ function Declaration public static Task<bool> AnyAsync<T>(this IQueryable<T> source, Expression<Func<T, bool>> predicate) Parameters Type Name Description IQueryable <T> source Source object sequence Expression < Func <T, Boolean >> predicate A function to test each element for a condition Returns Type Description Task < Boolean > Asynchronous call over Any() LINQ function Type Parameters Name Description T Object type | Improve this Doc View Source AnyAsync<T>(IQueryable<T>, Expression<Func<T, Boolean>>, CancellationToken) Asynchronous wrapper over Any() LINQ function Declaration public static Task<bool> AnyAsync<T>(this IQueryable<T> source, Expression<Func<T, bool>> predicate, CancellationToken token) Parameters Type Name Description IQueryable <T> source Source object sequence Expression < Func <T, Boolean >> predicate A function to test each element for a condition CancellationToken token Cancellation token Returns Type Description Task < Boolean > Asynchronous call over Any() LINQ function Type Parameters Name Description T Object type | Improve this Doc View Source AnyAsync<T>(IDataQuery<T>, Expression<Func<T, Boolean>>) Asynchronous wrapper over Any() LINQ function Declaration public static Task<bool> AnyAsync<T>(this IDataQuery<T> source, Expression<Func<T, bool>> predicate) Parameters Type Name Description IDataQuery <T> source Source object sequence Expression < Func <T, Boolean >> predicate A function to test each element for a condition Returns Type Description Task < Boolean > Asynchronous call over Any() LINQ function Type Parameters Name Description T Object type | Improve this Doc View Source AverageAsync<T>(IQueryable<T>, Expression<Func<T, Decimal>>) Asynchronous wrapper over Average() LINQ function Declaration public static Task<decimal> AverageAsync<T>(this IQueryable<T> source, Expression<Func<T, decimal>> selector) Parameters Type Name Description IQueryable <T> source Source object sequence Expression < Func <T, Decimal >> selector A projection function to apply to each element Returns Type Description Task < Decimal > Asynchronous call over Average() LINQ function Type Parameters Name Description T Object type | Improve this Doc View Source AverageAsync<T>(IQueryable<T>, Expression<Func<T, Decimal>>, CancellationToken) Asynchronous wrapper over Average() LINQ function Declaration public static Task<decimal> AverageAsync<T>(this IQueryable<T> source, Expression<Func<T, decimal>> selector, CancellationToken token) Parameters Type Name Description IQueryable <T> source Source object sequence Expression < Func <T, Decimal >> selector A projection function to apply to each element CancellationToken token Cancellation token Returns Type Description Task < Decimal > Asynchronous call over Average() LINQ function Type Parameters Name Description T Object type | Improve this Doc View Source AverageAsync<T>(IQueryable<T>, Expression<Func<T, Double>>) Asynchronous wrapper over Average() LINQ function Declaration public static Task<double> AverageAsync<T>(this IQueryable<T> source, Expression<Func<T, double>> selector) Parameters Type Name Description IQueryable <T> source Source object sequence Expression < Func <T, Double >> selector A projection function to apply to each element Returns Type Description Task < Double > Asynchronous call over Average() LINQ function Type Parameters Name Description T Object type | Improve this Doc View Source AverageAsync<T>(IQueryable<T>, Expression<Func<T, Double>>, CancellationToken) Asynchronous wrapper over Average() LINQ function Declaration public static Task<double> AverageAsync<T>(this IQueryable<T> source, Expression<Func<T, double>> selector, CancellationToken token) Parameters Type Name Description IQueryable <T> source Source object sequence Expression < Func <T, Double >> selector A projection function to apply to each element CancellationToken token Cancellation token Returns Type Description Task < Double > Asynchronous call over Average() LINQ function Type Parameters Name Description T Object type | Improve this Doc View Source AverageAsync<T>(IQueryable<T>, Expression<Func<T, Int32>>) Asynchronous wrapper over Average() LINQ function Declaration public static Task<double> AverageAsync<T>(this IQueryable<T> source, Expression<Func<T, int>> selector) Parameters Type Name Description IQueryable <T> source Source object sequence Expression < Func <T, Int32 >> selector A projection function to apply to each element Returns Type Description Task < Double > Asynchronous call over Average() LINQ function Type Parameters Name Description T Object type | Improve this Doc View Source AverageAsync<T>(IQueryable<T>, Expression<Func<T, Int32>>, CancellationToken) Asynchronous wrapper over Average() LINQ function Declaration public static Task<double> AverageAsync<T>(this IQueryable<T> source, Expression<Func<T, int>> selector, CancellationToken token) Parameters Type Name Description IQueryable <T> source Source object sequence Expression < Func <T, Int32 >> selector A projection function to apply to each element CancellationToken token Cancellation token Returns Type Description Task < Double > Asynchronous call over Average() LINQ function Type Parameters Name Description T Object type | Improve this Doc View Source AverageAsync<T>(IQueryable<T>, Expression<Func<T, Int64>>) Asynchronous wrapper over Average() LINQ function Declaration public static Task<double> AverageAsync<T>(this IQueryable<T> source, Expression<Func<T, long>> selector) Parameters Type Name Description IQueryable <T> source Source object sequence Expression < Func <T, Int64 >> selector A projection function to apply to each element Returns Type Description Task < Double > Asynchronous call over Average() LINQ function Type Parameters Name Description T Object type | Improve this Doc View Source AverageAsync<T>(IQueryable<T>, Expression<Func<T, Int64>>, CancellationToken) Asynchronous wrapper over Average() LINQ function Declaration public static Task<double> AverageAsync<T>(this IQueryable<T> source, Expression<Func<T, long>> selector, CancellationToken token) Parameters Type Name Description IQueryable <T> source Source object sequence Expression < Func <T, Int64 >> selector A projection function to apply to each element CancellationToken token Cancellation token Returns Type Description Task < Double > Asynchronous call over Average() LINQ function Type Parameters Name Description T Object type | Improve this Doc View Source AverageAsync<T>(IQueryable<T>, Expression<Func<T, Nullable<Decimal>>>) Asynchronous wrapper over Average() LINQ function Declaration public static Task<decimal?> AverageAsync<T>(this IQueryable<T> source, Expression<Func<T, decimal?>> selector) Parameters Type Name Description IQueryable <T> source Source object sequence Expression < Func <T, Nullable < Decimal >>> selector A projection function to apply to each element Returns Type Description Task < Nullable < Decimal >> Asynchronous call over Average() LINQ function Type Parameters Name Description T Object type | Improve this Doc View Source AverageAsync<T>(IQueryable<T>, Expression<Func<T, Nullable<Decimal>>>, CancellationToken) Asynchronous wrapper over Average() LINQ function Declaration public static Task<decimal?> AverageAsync<T>(this IQueryable<T> source, Expression<Func<T, decimal?>> selector, CancellationToken token) Parameters Type Name Description IQueryable <T> source Source object sequence Expression < Func <T, Nullable < Decimal >>> selector A projection function to apply to each element CancellationToken token Cancellation token Returns Type Description Task < Nullable < Decimal >> Asynchronous call over Average() LINQ function Type Parameters Name Description T Object type | Improve this Doc View Source AverageAsync<T>(IQueryable<T>, Expression<Func<T, Nullable<Double>>>) Asynchronous wrapper over Average() LINQ function Declaration public static Task<double?> AverageAsync<T>(this IQueryable<T> source, Expression<Func<T, double?>> selector) Parameters Type Name Description IQueryable <T> source Source object sequence Expression < Func <T, Nullable < Double >>> selector A projection function to apply to each element Returns Type Description Task < Nullable < Double >> Asynchronous call over Average() LINQ function Type Parameters Name Description T Object type | Improve this Doc View Source AverageAsync<T>(IQueryable<T>, Expression<Func<T, Nullable<Double>>>, CancellationToken) Asynchronous wrapper over Average() LINQ function Declaration public static Task<double?> AverageAsync<T>(this IQueryable<T> source, Expression<Func<T, double?>> selector, CancellationToken token) Parameters Type Name Description IQueryable <T> source Source object sequence Expression < Func <T, Nullable < Double >>> selector A projection function to apply to each element CancellationToken token Cancellation token Returns Type Description Task < Nullable < Double >> Asynchronous call over Average() LINQ function Type Parameters Name Description T Object type | Improve this Doc View Source AverageAsync<T>(IQueryable<T>, Expression<Func<T, Nullable<Int32>>>) Asynchronous wrapper over Average() LINQ function Declaration public static Task<double?> AverageAsync<T>(this IQueryable<T> source, Expression<Func<T, int?>> selector) Parameters Type Name Description IQueryable <T> source Source object sequence Expression < Func <T, Nullable < Int32 >>> selector A projection function to apply to each element Returns Type Description Task < Nullable < Double >> Asynchronous call over Average() LINQ function Type Parameters Name Description T Object type | Improve this Doc View Source AverageAsync<T>(IQueryable<T>, Expression<Func<T, Nullable<Int32>>>, CancellationToken) Asynchronous wrapper over Average() LINQ function Declaration public static Task<double?> AverageAsync<T>(this IQueryable<T> source, Expression<Func<T, int?>> selector, CancellationToken token) Parameters Type Name Description IQueryable <T> source Source object sequence Expression < Func <T, Nullable < Int32 >>> selector A projection function to apply to each element CancellationToken token Cancellation token Returns Type Description Task < Nullable < Double >> Asynchronous call over Average() LINQ function Type Parameters Name Description T Object type | Improve this Doc View Source AverageAsync<T>(IQueryable<T>, Expression<Func<T, Nullable<Int64>>>) Asynchronous wrapper over Average() LINQ function Declaration public static Task<double?> AverageAsync<T>(this IQueryable<T> source, Expression<Func<T, long?>> selector) Parameters Type Name Description IQueryable <T> source Source object sequence Expression < Func <T, Nullable < Int64 >>> selector A projection function to apply to each element Returns Type Description Task < Nullable < Double >> Asynchronous call over Average() LINQ function Type Parameters Name Description T Object type | Improve this Doc View Source AverageAsync<T>(IQueryable<T>, Expression<Func<T, Nullable<Int64>>>, CancellationToken) Asynchronous wrapper over Average() LINQ function Declaration public static Task<double?> AverageAsync<T>(this IQueryable<T> source, Expression<Func<T, long?>> selector, CancellationToken token) Parameters Type Name Description IQueryable <T> source Source object sequence Expression < Func <T, Nullable < Int64 >>> selector A projection function to apply to each element CancellationToken token Cancellation token Returns Type Description Task < Nullable < Double >> Asynchronous call over Average() LINQ function Type Parameters Name Description T Object type | Improve this Doc View Source AverageAsync<T>(IQueryable<T>, Expression<Func<T, Nullable<Single>>>) Asynchronous wrapper over Average() LINQ function Declaration public static Task<float?> AverageAsync<T>(this IQueryable<T> source, Expression<Func<T, float?>> selector) Parameters Type Name Description IQueryable <T> source Source object sequence Expression < Func <T, Nullable < Single >>> selector A projection function to apply to each element Returns Type Description Task < Nullable < Single >> Asynchronous call over Average() LINQ function Type Parameters Name Description T Object type | Improve this Doc View Source AverageAsync<T>(IQueryable<T>, Expression<Func<T, Nullable<Single>>>, CancellationToken) Asynchronous wrapper over Average() LINQ function Declaration public static Task<float?> AverageAsync<T>(this IQueryable<T> source, Expression<Func<T, float?>> selector, CancellationToken token) Parameters Type Name Description IQueryable <T> source Source object sequence Expression < Func <T, Nullable < Single >>> selector A projection function to apply to each element CancellationToken token Cancellation token Returns Type Description Task < Nullable < Single >> Asynchronous call over Average() LINQ function Type Parameters Name Description T Object type | Improve this Doc View Source AverageAsync<T>(IQueryable<T>, Expression<Func<T, Single>>) Asynchronous wrapper over Average() LINQ function Declaration public static Task<float> AverageAsync<T>(this IQueryable<T> source, Expression<Func<T, float>> selector) Parameters Type Name Description IQueryable <T> source Source object sequence Expression < Func <T, Single >> selector A projection function to apply to each element Returns Type Description Task < Single > Asynchronous call over Average() LINQ function Type Parameters Name Description T Object type | Improve this Doc View Source AverageAsync<T>(IQueryable<T>, Expression<Func<T, Single>>, CancellationToken) Asynchronous wrapper over Average() LINQ function Declaration public static Task<float> AverageAsync<T>(this IQueryable<T> source, Expression<Func<T, float>> selector, CancellationToken token) Parameters Type Name Description IQueryable <T> source Source object sequence Expression < Func <T, Single >> selector A projection function to apply to each element CancellationToken token Cancellation token Returns Type Description Task < Single > Asynchronous call over Average() LINQ function Type Parameters Name Description T Object type | Improve this Doc View Source AverageAsync<T>(IDataQuery<T>, Expression<Func<T, Decimal>>) Asynchronous wrapper over Average() LINQ function Declaration public static Task<decimal> AverageAsync<T>(this IDataQuery<T> source, Expression<Func<T, decimal>> selector) Parameters Type Name Description IDataQuery <T> source Source object sequence Expression < Func <T, Decimal >> selector A projection function to apply to each element Returns Type Description Task < Decimal > Asynchronous call over Average() LINQ function Type Parameters Name Description T Object type | Improve this Doc View Source AverageAsync<T>(IDataQuery<T>, Expression<Func<T, Double>>) Asynchronous wrapper over Average() LINQ function Declaration public static Task<double> AverageAsync<T>(this IDataQuery<T> source, Expression<Func<T, double>> selector) Parameters Type Name Description IDataQuery <T> source Source object sequence Expression < Func <T, Double >> selector A projection function to apply to each element Returns Type Description Task < Double > Asynchronous call over Average() LINQ function Type Parameters Name Description T Object type | Improve this Doc View Source AverageAsync<T>(IDataQuery<T>, Expression<Func<T, Int32>>) Asynchronous wrapper over Average() LINQ function Declaration public static Task<double> AverageAsync<T>(this IDataQuery<T> source, Expression<Func<T, int>> selector) Parameters Type Name Description IDataQuery <T> source Source object sequence Expression < Func <T, Int32 >> selector A projection function to apply to each element Returns Type Description Task < Double > Asynchronous call over Average() LINQ function Type Parameters Name Description T Object type | Improve this Doc View Source AverageAsync<T>(IDataQuery<T>, Expression<Func<T, Int64>>) Asynchronous wrapper over Average() LINQ function Declaration public static Task<double> AverageAsync<T>(this IDataQuery<T> source, Expression<Func<T, long>> selector) Parameters Type Name Description IDataQuery <T> source Source object sequence Expression < Func <T, Int64 >> selector A projection function to apply to each element Returns Type Description Task < Double > Asynchronous call over Average() LINQ function Type Parameters Name Description T Object type | Improve this Doc View Source AverageAsync<T>(IDataQuery<T>, Expression<Func<T, Nullable<Decimal>>>) Asynchronous wrapper over Average() LINQ function Declaration public static Task<decimal?> AverageAsync<T>(this IDataQuery<T> source, Expression<Func<T, decimal?>> selector) Parameters Type Name Description IDataQuery <T> source Source object sequence Expression < Func <T, Nullable < Decimal >>> selector A projection function to apply to each element Returns Type Description Task < Nullable < Decimal >> Asynchronous call over Average() LINQ function Type Parameters Name Description T Object type | Improve this Doc View Source AverageAsync<T>(IDataQuery<T>, Expression<Func<T, Nullable<Double>>>) Asynchronous wrapper over Average() LINQ function Declaration public static Task<double?> AverageAsync<T>(this IDataQuery<T> source, Expression<Func<T, double?>> selector) Parameters Type Name Description IDataQuery <T> source Source object sequence Expression < Func <T, Nullable < Double >>> selector A projection function to apply to each element Returns Type Description Task < Nullable < Double >> Asynchronous call over Average() LINQ function Type Parameters Name Description T Object type | Improve this Doc View Source AverageAsync<T>(IDataQuery<T>, Expression<Func<T, Nullable<Int32>>>) Asynchronous wrapper over Average() LINQ function Declaration public static Task<double?> AverageAsync<T>(this IDataQuery<T> source, Expression<Func<T, int?>> selector) Parameters Type Name Description IDataQuery <T> source Source object sequence Expression < Func <T, Nullable < Int32 >>> selector A projection function to apply to each element Returns Type Description Task < Nullable < Double >> Asynchronous call over Average() LINQ function Type Parameters Name Description T Object type | Improve this Doc View Source AverageAsync<T>(IDataQuery<T>, Expression<Func<T, Nullable<Int64>>>) Asynchronous wrapper over Average() LINQ function Declaration public static Task<double?> AverageAsync<T>(this IDataQuery<T> source, Expression<Func<T, long?>> selector) Parameters Type Name Description IDataQuery <T> source Source object sequence Expression < Func <T, Nullable < Int64 >>> selector A projection function to apply to each element Returns Type Description Task < Nullable < Double >> Asynchronous call over Average() LINQ function Type Parameters Name Description T Object type | Improve this Doc View Source AverageAsync<T>(IDataQuery<T>, Expression<Func<T, Nullable<Single>>>) Asynchronous wrapper over Average() LINQ function Declaration public static Task<float?> AverageAsync<T>(this IDataQuery<T> source, Expression<Func<T, float?>> selector) Parameters Type Name Description IDataQuery <T> source Source object sequence Expression < Func <T, Nullable < Single >>> selector A projection function to apply to each element Returns Type Description Task < Nullable < Single >> Asynchronous call over Average() LINQ function Type Parameters Name Description T Object type | Improve this Doc View Source AverageAsync<T>(IDataQuery<T>, Expression<Func<T, Single>>) Asynchronous wrapper over Average() LINQ function Declaration public static Task<float> AverageAsync<T>(this IDataQuery<T> source, Expression<Func<T, float>> selector) Parameters Type Name Description IDataQuery <T> source Source object sequence Expression < Func <T, Single >> selector A projection function to apply to each element Returns Type Description Task < Single > Asynchronous call over Average() LINQ function Type Parameters Name Description T Object type | Improve this Doc View Source ClearAsync<T>(IRepository<T>, Expression<Func<T, Boolean>>, DataSubmitFlag) Asynchronous wrapper over Clear Declaration public static Task<bool> ClearAsync<T>(this IRepository<T> repository, Expression<Func<T, bool>> predicate, DataSubmitFlag flag = DataSubmitFlag.None) where T : class, IDataObject, new() Parameters Type Name Description IRepository <T> repository Repository to submit Expression < Func <T, Boolean >> predicate Predicate to filer repository before clear DataSubmitFlag flag Data submit flag Returns Type Description Task < Boolean > Asynchronous wrapper over Submit Type Parameters Name Description T | Improve this Doc View Source ClearAsync<T>(IRepository<T>, DataSubmitFlag) Asynchronous wrapper over Clear Declaration public static Task<bool> ClearAsync<T>(this IRepository<T> repository, DataSubmitFlag flag = DataSubmitFlag.None) where T : class, IDataObject, new() Parameters Type Name Description IRepository <T> repository Repository to submit DataSubmitFlag flag Data submit flag Returns Type Description Task < Boolean > Asynchronous wrapper over Submit Type Parameters Name Description T | Improve this Doc View Source ContainsAsync<T>(IQueryable<T>, T, IEqualityComparer<T>) Asynchronous wrapper over Contains() LINQ function Declaration public static Task<bool> ContainsAsync<T>(this IQueryable<T> source, T item, IEqualityComparer<T> comparer) Parameters Type Name Description IQueryable <T> source Source object sequence T item The object to locate in the sequence. IEqualityComparer <T> comparer Object comparer Returns Type Description Task < Boolean > Asynchronous call over Contains() LINQ function Type Parameters Name Description T Object type | Improve this Doc View Source ContainsAsync<T>(IQueryable<T>, T, IEqualityComparer<T>, CancellationToken) Asynchronous wrapper over Contains() LINQ function Declaration public static Task<bool> ContainsAsync<T>(this IQueryable<T> source, T item, IEqualityComparer<T> comparer, CancellationToken token) Parameters Type Name Description IQueryable <T> source Source object sequence T item The object to locate in the sequence. IEqualityComparer <T> comparer Object comparer CancellationToken token Cancellation token Returns Type Description Task < Boolean > Asynchronous call over Contains() LINQ function Type Parameters Name Description T Object type | Improve this Doc View Source ContainsAsync<T>(IQueryable<T>, T, Func<T, Object>[]) Asynchronous wrapper over Contains() LINQ function Declaration public static Task<bool> ContainsAsync<T>(this IQueryable<T> source, T item, params Func<T, object>[] properties) Parameters Type Name Description IQueryable <T> source Source object sequence T item The object to locate in the sequence. Func <T, Object >[] properties Object properties to compare Returns Type Description Task < Boolean > Asynchronous call over Contains() LINQ function Type Parameters Name Description T Object type | Improve this Doc View Source ContainsAsync<T>(IDataQuery<T>, T) Asynchronous wrapper over Contains() LINQ function Declaration public static Task<bool> ContainsAsync<T>(this IDataQuery<T> source, T item) Parameters Type Name Description IDataQuery <T> source Source object sequence T item The object to locate in the sequence. Returns Type Description Task < Boolean > Asynchronous call over Contains() LINQ function Type Parameters Name Description T Object type | Improve this Doc View Source ContainsAsync<T>(IDataQuery<T>, T, IEqualityComparer<T>) Asynchronous wrapper over Contains() LINQ function Declaration public static Task<bool> ContainsAsync<T>(this IDataQuery<T> source, T item, IEqualityComparer<T> comparer) Parameters Type Name Description IDataQuery <T> source Source object sequence T item The object to locate in the sequence. IEqualityComparer <T> comparer Object comparer Returns Type Description Task < Boolean > Asynchronous call over Contains() LINQ function Type Parameters Name Description T Object type | Improve this Doc View Source CountAsync<T>(IQueryable<T>) Asynchronous wrapper over Count() LINQ function Declaration public static Task<int> CountAsync<T>(this IQueryable<T> source) Parameters Type Name Description IQueryable <T> source Source object sequence Returns Type Description Task < Int32 > Asynchronous call over Count() LINQ function Type Parameters Name Description T Object type | Improve this Doc View Source CountAsync<T>(IQueryable<T>, Expression<Func<T, Boolean>>) Asynchronous wrapper over Count() LINQ function Declaration public static Task<int> CountAsync<T>(this IQueryable<T> source, Expression<Func<T, bool>> predicate) Parameters Type Name Description IQueryable <T> source Source object sequence Expression < Func <T, Boolean >> predicate A function to test each element for a condition Returns Type Description Task < Int32 > Asynchronous call over Count() LINQ function Type Parameters Name Description T Object type | Improve this Doc View Source CountAsync<T>(IQueryable<T>, Expression<Func<T, Boolean>>, CancellationToken) Asynchronous wrapper over Count() LINQ function Declaration public static Task<int> CountAsync<T>(this IQueryable<T> source, Expression<Func<T, bool>> predicate, CancellationToken token) Parameters Type Name Description IQueryable <T> source Source object sequence Expression < Func <T, Boolean >> predicate A function to test each element for a condition CancellationToken token Cancellation token Returns Type Description Task < Int32 > Asynchronous call over Count() LINQ function Type Parameters Name Description T Object type | Improve this Doc View Source CountAsync<T>(IDataQuery<T>) Asynchronous wrapper over Count() LINQ function Declaration public static Task<int> CountAsync<T>(this IDataQuery<T> source) Parameters Type Name Description IDataQuery <T> source Source object sequence Returns Type Description Task < Int32 > Asynchronous call over Count() LINQ function Type Parameters Name Description T Object type | Improve this Doc View Source CountAsync<T>(IDataQuery<T>, Expression<Func<T, Boolean>>) Asynchronous wrapper over Count() LINQ function Declaration public static Task<int> CountAsync<T>(this IDataQuery<T> source, Expression<Func<T, bool>> predicate) Parameters Type Name Description IDataQuery <T> source Source object sequence Expression < Func <T, Boolean >> predicate A function to test each element for a condition Returns Type Description Task < Int32 > Asynchronous call over Count() LINQ function Type Parameters Name Description T Object type | Improve this Doc View Source ExecuteAsync<T>(T, Expression<Func<CustomLogic<T>>>, IDictionary<String, Action<Byte[]>>) Asynchronous wrapper over Execute Declaration public static Task<bool> ExecuteAsync<T>(this T obj, Expression<Func<CustomLogic<T>>> routine, IDictionary<string, Action<byte[]>> post) where T : class, IDataObject, new() Parameters Type Name Description T obj Data object Expression < Func < CustomLogic <T>>> routine Custom logic name IDictionary < String , Action < Byte []>> post Post data handlers Returns Type Description Task < Boolean > Asynchronous wrapper over Submit Type Parameters Name Description T | Improve this Doc View Source ExecuteAsync<T>(T, Expression<Func<CustomLogic<T>>>, IDictionary<String, Action<Byte[]>>, IDictionary<String, Func<Byte[], Byte[]>>) Asynchronous wrapper over Execute Declaration public static Task<bool> ExecuteAsync<T>(this T obj, Expression<Func<CustomLogic<T>>> routine, IDictionary<string, Action<byte[]>> post, IDictionary<string, Func<byte[], byte[]>> callback) where T : class, IDataObject, new() Parameters Type Name Description T obj Data object Expression < Func < CustomLogic <T>>> routine Custom logic name IDictionary < String , Action < Byte []>> post Post data handlers IDictionary < String , Func < Byte [], Byte []>> callback Callback handlers Returns Type Description Task < Boolean > Asynchronous wrapper over Submit Type Parameters Name Description T | Improve this Doc View Source ExecuteAsync<T>(T, Expression<Func<CustomLogic<T>>>, IDictionary<String, Func<Byte[], Byte[]>>) Asynchronous wrapper over Execute Declaration public static Task<bool> ExecuteAsync<T>(this T obj, Expression<Func<CustomLogic<T>>> routine, IDictionary<string, Func<byte[], byte[]>> callback) where T : class, IDataObject, new() Parameters Type Name Description T obj Data object Expression < Func < CustomLogic <T>>> routine Custom logic name IDictionary < String , Func < Byte [], Byte []>> callback Callback handlers Returns Type Description Task < Boolean > Asynchronous wrapper over Submit Type Parameters Name Description T | Improve this Doc View Source ExecuteAsync<T>(T, String, IDictionary<String, Action<Byte[]>>) Asynchronous wrapper over Execute Declaration public static Task<bool> ExecuteAsync<T>(this T obj, string key, IDictionary<string, Action<byte[]>> post) where T : class, IDataObject, new() Parameters Type Name Description T obj Data object String key Custom logic name IDictionary < String , Action < Byte []>> post Post data handlers Returns Type Description Task < Boolean > Asynchronous wrapper over Submit Type Parameters Name Description T | Improve this Doc View Source ExecuteAsync<T>(T, String, IDictionary<String, Action<Byte[]>>, IDictionary<String, Func<Byte[], Byte[]>>) Asynchronous wrapper over Execute Declaration public static Task<bool> ExecuteAsync<T>(this T obj, string key, IDictionary<string, Action<byte[]>> post, IDictionary<string, Func<byte[], byte[]>> callback) where T : class, IDataObject, new() Parameters Type Name Description T obj Data object String key Custom logic name IDictionary < String , Action < Byte []>> post Post data handlers IDictionary < String , Func < Byte [], Byte []>> callback Callback handlers Returns Type Description Task < Boolean > Asynchronous wrapper over Submit Type Parameters Name Description T | Improve this Doc View Source ExecuteAsync<T>(T, String, IDictionary<String, Func<Byte[], Byte[]>>) Asynchronous wrapper over Execute Declaration public static Task<bool> ExecuteAsync<T>(this T obj, string key, IDictionary<string, Func<byte[], byte[]>> callback) where T : class, IDataObject, new() Parameters Type Name Description T obj Data object String key Custom logic name IDictionary < String , Func < Byte [], Byte []>> callback Callback handlers Returns Type Description Task < Boolean > Asynchronous wrapper over Submit Type Parameters Name Description T | Improve this Doc View Source ExecuteAsync<T>(ICollection<T>, Expression<Func<CustomLogic<T>>>, IDictionary<String, Action<Byte[]>>) Asynchronous wrapper over Execute Declaration public static Task<bool> ExecuteAsync<T>(this ICollection<T> objects, Expression<Func<CustomLogic<T>>> routine, IDictionary<string, Action<byte[]>> post) where T : class, IDataObject, new() Parameters Type Name Description ICollection <T> objects Data objects collection Expression < Func < CustomLogic <T>>> routine Custom logic name IDictionary < String , Action < Byte []>> post Post data handlers Returns Type Description Task < Boolean > Asynchronous wrapper over Submit Type Parameters Name Description T | Improve this Doc View Source ExecuteAsync<T>(ICollection<T>, Expression<Func<CustomLogic<T>>>, IDictionary<String, Action<Byte[]>>, IDictionary<String, Func<Byte[], Byte[]>>) Asynchronous wrapper over Execute Declaration public static Task<bool> ExecuteAsync<T>(this ICollection<T> objects, Expression<Func<CustomLogic<T>>> routine, IDictionary<string, Action<byte[]>> post, IDictionary<string, Func<byte[], byte[]>> callback) where T : class, IDataObject, new() Parameters Type Name Description ICollection <T> objects Data objects collection Expression < Func < CustomLogic <T>>> routine Custom logic name IDictionary < String , Action < Byte []>> post Post data handlers IDictionary < String , Func < Byte [], Byte []>> callback Callback handlers Returns Type Description Task < Boolean > Asynchronous wrapper over Submit Type Parameters Name Description T | Improve this Doc View Source ExecuteAsync<T>(ICollection<T>, Expression<Func<CustomLogic<T>>>, IDictionary<String, Func<Byte[], Byte[]>>) Asynchronous wrapper over Execute Declaration public static Task<bool> ExecuteAsync<T>(this ICollection<T> objects, Expression<Func<CustomLogic<T>>> routine, IDictionary<string, Func<byte[], byte[]>> callback) where T : class, IDataObject, new() Parameters Type Name Description ICollection <T> objects Data objects collection Expression < Func < CustomLogic <T>>> routine Custom logic name IDictionary < String , Func < Byte [], Byte []>> callback Callback handlers Returns Type Description Task < Boolean > Asynchronous wrapper over Submit Type Parameters Name Description T | Improve this Doc View Source ExecuteAsync<T>(ICollection<T>, String, IDictionary<String, Action<Byte[]>>) Asynchronous wrapper over Execute Declaration public static Task<bool> ExecuteAsync<T>(this ICollection<T> objects, string key, IDictionary<string, Action<byte[]>> post) where T : class, IDataObject, new() Parameters Type Name Description ICollection <T> objects Data objects collection String key Custom logic name IDictionary < String , Action < Byte []>> post Post data handlers Returns Type Description Task < Boolean > Asynchronous wrapper over Submit Type Parameters Name Description T | Improve this Doc View Source ExecuteAsync<T>(ICollection<T>, String, IDictionary<String, Action<Byte[]>>, IDictionary<String, Func<Byte[], Byte[]>>) Asynchronous wrapper over Execute Declaration public static Task<bool> ExecuteAsync<T>(this ICollection<T> objects, string key, IDictionary<string, Action<byte[]>> post, IDictionary<string, Func<byte[], byte[]>> callback) where T : class, IDataObject, new() Parameters Type Name Description ICollection <T> objects Data objects collection String key Custom logic name IDictionary < String , Action < Byte []>> post Post data handlers IDictionary < String , Func < Byte [], Byte []>> callback Callback handlers Returns Type Description Task < Boolean > Asynchronous wrapper over Submit Type Parameters Name Description T | Improve this Doc View Source ExecuteAsync<T>(ICollection<T>, String, IDictionary<String, Func<Byte[], Byte[]>>) Asynchronous wrapper over Execute Declaration public static Task<bool> ExecuteAsync<T>(this ICollection<T> objects, string key, IDictionary<string, Func<byte[], byte[]>> callback) where T : class, IDataObject, new() Parameters Type Name Description ICollection <T> objects Data objects collection String key Custom logic name IDictionary < String , Func < Byte [], Byte []>> callback Callback handlers Returns Type Description Task < Boolean > Asynchronous wrapper over Submit Type Parameters Name Description T | Improve this Doc View Source ExecuteNonQueryAsync(IDataScope, Query) Asynchronous wrapper over ExecuteNonQuery(Query) call Declaration public static Task ExecuteNonQueryAsync(this IDataScope dataScope, Query query) Parameters Type Name Description IDataScope dataScope Data scope Query query Query Returns Type Description Task Asynchronous call over ExecuteNonQuery | Improve this Doc View Source ExecuteScalarAsync<TResult>(IDataScope, Query) Asynchronous wrapper over ExecuteScalar<TResult>(Query) call Declaration public static Task<TResult> ExecuteScalarAsync<TResult>(this IDataScope dataScope, Query query) Parameters Type Name Description IDataScope dataScope Data scope Query query Query Returns Type Description Task <TResult> Asynchronous call over ExecuteScalar Type Parameters Name Description TResult | Improve this Doc View Source ExecuteSqlBlockAsync(IDataScope, Expression<SqlBlockDefinition>, Expression<Func<ISqlParamAdapter, ISqlParam>>[]) Asynchronous wrapper over SQL block execution Declaration public static Task ExecuteSqlBlockAsync(this IDataScope dataScope, Expression<SqlBlockDefinition> block, params Expression<Func<ISqlParamAdapter, ISqlParam>>[] parameters) Parameters Type Name Description IDataScope dataScope Data scope Expression < SqlBlockDefinition > block Sql block structure Expression < Func < ISqlParamAdapter , ISqlParam >>[] parameters Sql block parameters Returns Type Description Task Asynchronous wrapper over SQL block execution | Improve this Doc View Source ExecuteSqlBlockAsync(IDataScope, CancellationToken, Expression<SqlBlockDefinition>, Expression<Func<ISqlParamAdapter, ISqlParam>>[]) Asynchronous wrapper over SQL block execution Declaration public static Task ExecuteSqlBlockAsync(this IDataScope dataScope, CancellationToken token, Expression<SqlBlockDefinition> block, params Expression<Func<ISqlParamAdapter, ISqlParam>>[] parameters) Parameters Type Name Description IDataScope dataScope Data scope CancellationToken token Cancellation token Expression < SqlBlockDefinition > block Sql block structure Expression < Func < ISqlParamAdapter , ISqlParam >>[] parameters Sql block parameters Returns Type Description Task Asynchronous wrapper over SQL block execution | Improve this Doc View Source FillTableAsync(IDataScope, Query, CommandBehavior) Asynchronous wrapper over FillTable(Query, CommandBehavior) call Declaration public static Task<DataTable> FillTableAsync(this IDataScope dataScope, Query query, CommandBehavior behavior = CommandBehavior.Default) Parameters Type Name Description IDataScope dataScope Data scope Query query Query CommandBehavior behavior Command behavior Returns Type Description Task < DataTable > Asynchronous call over FillTable | Improve this Doc View Source FirstAsync<T>(IQueryable<T>) Asynchronous wrapper over First() LINQ function Declaration public static Task<T> FirstAsync<T>(this IQueryable<T> source) Parameters Type Name Description IQueryable <T> source Source object sequence Returns Type Description Task <T> Asynchronous call over First() LINQ function Type Parameters Name Description T Object type | Improve this Doc View Source FirstAsync<T>(IQueryable<T>, Expression<Func<T, Boolean>>) Asynchronous wrapper over First() LINQ function Declaration public static Task<T> FirstAsync<T>(this IQueryable<T> source, Expression<Func<T, bool>> predicate) Parameters Type Name Description IQueryable <T> source Source object sequence Expression < Func <T, Boolean >> predicate A function to test each element for a condition Returns Type Description Task <T> Asynchronous call over First() LINQ function Type Parameters Name Description T Object type | Improve this Doc View Source FirstAsync<T>(IQueryable<T>, Expression<Func<T, Boolean>>, CancellationToken) Asynchronous wrapper over First() LINQ function Declaration public static Task<T> FirstAsync<T>(this IQueryable<T> source, Expression<Func<T, bool>> predicate, CancellationToken token) Parameters Type Name Description IQueryable <T> source Source object sequence Expression < Func <T, Boolean >> predicate A function to test each element for a condition CancellationToken token Cancellation token Returns Type Description Task <T> Asynchronous call over First() LINQ function Type Parameters Name Description T Object type | Improve this Doc View Source FirstAsync<T>(IDataQuery<T>) Asynchronous wrapper over First() LINQ function Declaration public static Task<T> FirstAsync<T>(this IDataQuery<T> source) Parameters Type Name Description IDataQuery <T> source Source object sequence Returns Type Description Task <T> Asynchronous call over First() LINQ function Type Parameters Name Description T Object type | Improve this Doc View Source FirstAsync<T>(IDataQuery<T>, Func<JsonSettings<T>, JsonSettings<T>>) Asynchronous wrapper over First() LINQ function Declaration public static Task<T> FirstAsync<T>(this IDataQuery<T> source, Func<JsonSettings<T>, JsonSettings<T>> settings) where T : class, IDataObject, new() Parameters Type Name Description IDataQuery <T> source Source object sequence Func < JsonSettings <T>, JsonSettings <T>> settings JSON serialization settings Returns Type Description Task <T> Asynchronous call over First() LINQ function Type Parameters Name Description T Object type | Improve this Doc View Source FirstAsync<T>(IDataQuery<T>, Expression<Func<T, Boolean>>) Asynchronous wrapper over First() LINQ function Declaration public static Task<T> FirstAsync<T>(this IDataQuery<T> source, Expression<Func<T, bool>> predicate) Parameters Type Name Description IDataQuery <T> source Source object sequence Expression < Func <T, Boolean >> predicate A function to test each element for a condition Returns Type Description Task <T> Asynchronous call over First() LINQ function Type Parameters Name Description T Object type | Improve this Doc View Source FirstAsync<T>(IDataQuery<T>, Expression<Func<T, Boolean>>, Func<JsonSettings<T>, JsonSettings<T>>) Asynchronous wrapper over First() LINQ function Declaration public static Task<T> FirstAsync<T>(this IDataQuery<T> source, Expression<Func<T, bool>> predicate, Func<JsonSettings<T>, JsonSettings<T>> settings) where T : class, IDataObject, new() Parameters Type Name Description IDataQuery <T> source Source object sequence Expression < Func <T, Boolean >> predicate A function to test each element for a condition Func < JsonSettings <T>, JsonSettings <T>> settings JSON serialization settings Returns Type Description Task <T> Asynchronous call over First() LINQ function Type Parameters Name Description T Object type | Improve this Doc View Source FirstOrDefaultAsync<T>(IQueryable<T>) Asynchronous wrapper over FirstOrDefault() LINQ function Declaration public static Task<T> FirstOrDefaultAsync<T>(this IQueryable<T> source) Parameters Type Name Description IQueryable <T> source Source object sequence Returns Type Description Task <T> Asynchronous call over FirstOrDefault() LINQ function Type Parameters Name Description T Object type | Improve this Doc View Source FirstOrDefaultAsync<T>(IQueryable<T>, Expression<Func<T, Boolean>>) Asynchronous wrapper over FirstOrDefault() LINQ function Declaration public static Task<T> FirstOrDefaultAsync<T>(this IQueryable<T> source, Expression<Func<T, bool>> predicate) Parameters Type Name Description IQueryable <T> source Source object sequence Expression < Func <T, Boolean >> predicate A function to test each element for a condition Returns Type Description Task <T> Asynchronous call over FirstOrDefault() LINQ function Type Parameters Name Description T Object type | Improve this Doc View Source FirstOrDefaultAsync<T>(IQueryable<T>, Expression<Func<T, Boolean>>, CancellationToken) Asynchronous wrapper over FirstOrDefault() LINQ function Declaration public static Task<T> FirstOrDefaultAsync<T>(this IQueryable<T> source, Expression<Func<T, bool>> predicate, CancellationToken token) Parameters Type Name Description IQueryable <T> source Source object sequence Expression < Func <T, Boolean >> predicate A function to test each element for a condition CancellationToken token Cancellation token Returns Type Description Task <T> Asynchronous call over FirstOrDefault() LINQ function Type Parameters Name Description T Object type | Improve this Doc View Source FirstOrDefaultAsync<T>(IDataQuery<T>) Asynchronous wrapper over FirstOrDefault() LINQ function Declaration public static Task<T> FirstOrDefaultAsync<T>(this IDataQuery<T> source) Parameters Type Name Description IDataQuery <T> source Source object sequence Returns Type Description Task <T> Asynchronous call over FirstOrDefault() LINQ function Type Parameters Name Description T Object type | Improve this Doc View Source FirstOrDefaultAsync<T>(IDataQuery<T>, Func<JsonSettings<T>, JsonSettings<T>>) Asynchronous wrapper over FirstOrDefault() LINQ function Declaration public static Task<T> FirstOrDefaultAsync<T>(this IDataQuery<T> source, Func<JsonSettings<T>, JsonSettings<T>> settings) where T : class, IDataObject, new() Parameters Type Name Description IDataQuery <T> source Source object sequence Func < JsonSettings <T>, JsonSettings <T>> settings JSON serialization settings Returns Type Description Task <T> Asynchronous call over FirstOrDefault() LINQ function Type Parameters Name Description T Object type | Improve this Doc View Source FirstOrDefaultAsync<T>(IDataQuery<T>, Expression<Func<T, Boolean>>) Asynchronous wrapper over FirstOrDefault() LINQ function Declaration public static Task<T> FirstOrDefaultAsync<T>(this IDataQuery<T> source, Expression<Func<T, bool>> predicate) Parameters Type Name Description IDataQuery <T> source Source object sequence Expression < Func <T, Boolean >> predicate A function to test each element for a condition Returns Type Description Task <T> Asynchronous call over FirstOrDefault() LINQ function Type Parameters Name Description T Object type | Improve this Doc View Source FirstOrDefaultAsync<T>(IDataQuery<T>, Expression<Func<T, Boolean>>, Func<JsonSettings<T>, JsonSettings<T>>) Asynchronous wrapper over FirstOrDefault() LINQ function Declaration public static Task<T> FirstOrDefaultAsync<T>(this IDataQuery<T> source, Expression<Func<T, bool>> predicate, Func<JsonSettings<T>, JsonSettings<T>> settings) where T : class, IDataObject, new() Parameters Type Name Description IDataQuery <T> source Source object sequence Expression < Func <T, Boolean >> predicate A function to test each element for a condition Func < JsonSettings <T>, JsonSettings <T>> settings JSON serialization settings Returns Type Description Task <T> Asynchronous call over FirstOrDefault() LINQ function Type Parameters Name Description T Object type | Improve this Doc View Source ForEachAsync<T>(IQueryable<T>, Action<T>) Asynchronous wrapper over query result iteration Declaration public static Task ForEachAsync<T>(this IQueryable<T> source, Action<T> body) Parameters Type Name Description IQueryable <T> source Source object sequence Action <T> body Iteration logic Returns Type Description Task Asynchronous call over query result iteration Type Parameters Name Description T Object type | Improve this Doc View Source ForEachAsync<T>(IQueryable<T>, Action<T>, CancellationToken) Asynchronous wrapper over query result iteration Declaration public static Task ForEachAsync<T>(this IQueryable<T> source, Action<T> body, CancellationToken token) Parameters Type Name Description IQueryable <T> source Source object sequence Action <T> body Iteration logic CancellationToken token Cancellation token Returns Type Description Task Asynchronous call over query result iteration Type Parameters Name Description T Object type | Improve this Doc View Source ForEachAsync<T>(IQueryable<T>, Func<T, Task>) Asynchronous wrapper over query result iteration Declaration public static Task ForEachAsync<T>(this IQueryable<T> source, Func<T, Task> body) Parameters Type Name Description IQueryable <T> source Source object sequence Func <T, Task > body Iteration logic Returns Type Description Task Asynchronous call over query result iteration Type Parameters Name Description T Object type | Improve this Doc View Source ForEachAsync<T>(IQueryable<T>, Func<T, Task>, CancellationToken) Asynchronous wrapper over query result iteration Declaration public static Task ForEachAsync<T>(this IQueryable<T> source, Func<T, Task> body, CancellationToken token) Parameters Type Name Description IQueryable <T> source Source object sequence Func <T, Task > body Iteration logic CancellationToken token Cancellation token Returns Type Description Task Asynchronous call over query result iteration Type Parameters Name Description T Object type | Improve this Doc View Source ForEachAsync<T>(IDataQuery<T>, Action<T>) Asynchronous wrapper over query result iteration Declaration public static Task ForEachAsync<T>(this IDataQuery<T> source, Action<T> body) Parameters Type Name Description IDataQuery <T> source Source object sequence Action <T> body Iteration logic Returns Type Description Task Asynchronous call over query result iteration Type Parameters Name Description T Object type | Improve this Doc View Source ForEachAsync<T>(IDataQuery<T>, Func<T, Task>) Asynchronous wrapper over query result iteration Declaration public static Task ForEachAsync<T>(this IDataQuery<T> source, Func<T, Task> body) Parameters Type Name Description IDataQuery <T> source Source object sequence Func <T, Task > body Iteration logic Returns Type Description Task Asynchronous call over query result iteration Type Parameters Name Description T Object type | Improve this Doc View Source GetParameterAsync<T>(IDataQuery, String) Asynchronous wrapper over GetParameter Declaration public static Task<T> GetParameterAsync<T>(this IDataQuery source, string param) where T : class Parameters Type Name Description IDataQuery source SQL procedure based data source String param Parameter name Returns Type Description Task <T> Asynchronous wrapper over Submit Type Parameters Name Description T | Improve this Doc View Source GetParameterAsync<T, TRet>(T, Expression<Func<T, TRet>>) Asynchronous wrapper over GetParameter Declaration public static Task<TRet> GetParameterAsync<T, TRet>(this T obj, Expression<Func<T, TRet>> param) where T : class, IDataObject, new() Parameters Type Name Description T obj SQL procedure based single object result Expression < Func <T, TRet>> param Parameter name Returns Type Description Task <TRet> Asynchronous wrapper over Submit Type Parameters Name Description T TRet | Improve this Doc View Source GetParameterAsync<T, TRet>(T, String) Asynchronous wrapper over GetParameter Declaration public static Task<TRet> GetParameterAsync<T, TRet>(this T obj, string param) where T : class, IDataObject, new() Parameters Type Name Description T obj SQL procedure based single object result String param Parameter name Returns Type Description Task <TRet> Asynchronous wrapper over Submit Type Parameters Name Description T TRet | Improve this Doc View Source GetParameterAsync<T, TRet>(IDataQuery<T>, Expression<Func<T, TRet>>) Asynchronous wrapper over GetParameter Declaration public static Task<TRet> GetParameterAsync<T, TRet>(this IDataQuery<T> source, Expression<Func<T, TRet>> param) where T : class, new() Parameters Type Name Description IDataQuery <T> source SQL procedure based data source Expression < Func <T, TRet>> param Parameter name Returns Type Description Task <TRet> Asynchronous wrapper over Submit Type Parameters Name Description T TRet | Improve this Doc View Source GetResultSetAsync<TRes>(IDataQuery, Expression<Func<IEnumerable<TRes>>>) Asynchronous wrapper over GetResultSet Declaration public static Task<IEnumerable<TRes>> GetResultSetAsync<TRes>(this IDataQuery source, Expression<Func<IEnumerable<TRes>>> resultSetName) where TRes : class, new() Parameters Type Name Description IDataQuery source SQL procedure based data source Expression < Func < IEnumerable <TRes>>> resultSetName Resultset name Returns Type Description Task < IEnumerable <TRes>> Asynchronous wrapper over Submit Type Parameters Name Description TRes | Improve this Doc View Source GetResultSetAsync<TRes>(IDataQuery, String) Asynchronous wrapper over GetResultSet Declaration public static Task<IEnumerable<TRes>> GetResultSetAsync<TRes>(this IDataQuery source, string resultSetName) where TRes : class, new() Parameters Type Name Description IDataQuery source SQL procedure based data source String resultSetName Resultset name Returns Type Description Task < IEnumerable <TRes>> Asynchronous wrapper over Submit Type Parameters Name Description TRes | Improve this Doc View Source GetResultSetAsync<T, TRes>(T, Expression<Func<T, IEnumerable<TRes>>>) Asynchronous wrapper over GetResultSet Declaration public static Task<IEnumerable<TRes>> GetResultSetAsync<T, TRes>(this T obj, Expression<Func<T, IEnumerable<TRes>>> resultSetName) where T : class, IDataObject, new() where TRes : class Parameters Type Name Description T obj SQL procedure based single object result Expression < Func <T, IEnumerable <TRes>>> resultSetName Resultset name Returns Type Description Task < IEnumerable <TRes>> Asynchronous wrapper over Submit Type Parameters Name Description T TRes | Improve this Doc View Source GetResultSetAsync<T, TRes>(IRepository<T>, Expression<Func<T, IEnumerable<TRes>>>) Asynchronous wrapper over GetResultSet Declaration public static Task<IEnumerable<TRes>> GetResultSetAsync<T, TRes>(this IRepository<T> source, Expression<Func<T, IEnumerable<TRes>>> resultSetName) where T : class, IDataObject, new() where TRes : class Parameters Type Name Description IRepository <T> source SQL procedure based data source Expression < Func <T, IEnumerable <TRes>>> resultSetName Resultset name Returns Type Description Task < IEnumerable <TRes>> Asynchronous wrapper over Submit Type Parameters Name Description T TRes | Improve this Doc View Source GetSqlBlockDataAsync<T>(IDataScope, Func<JsonSettings<T>, JsonSettings<T>>, Expression<SqlBlockDefinition<T>>, Expression<Func<ISqlParamAdapter, ISqlParam>>[]) Asynchronous wrapper over select SQL block data Declaration public static Task<T[]> GetSqlBlockDataAsync<T>(this IDataScope dataScope, Func<JsonSettings<T>, JsonSettings<T>> settings, Expression<SqlBlockDefinition<T>> block, params Expression<Func<ISqlParamAdapter, ISqlParam>>[] parameters) where T : class, IDataObject, new() Parameters Type Name Description IDataScope dataScope Data scope layer Func < JsonSettings <T>, JsonSettings <T>> settings JSON serialization settings Expression < SqlBlockDefinition <T>> block Sql block structure Expression < Func < ISqlParamAdapter , ISqlParam >>[] parameters Sql block parameters Returns Type Description Task <T[]> Asynchronous wrapper over SQL block data selected and mapped Type Parameters Name Description T | Improve this Doc View Source GetSqlBlockDataAsync<T>(IDataScope, Expression<SqlBlockDefinition<T>>, Expression<Func<ISqlParamAdapter, ISqlParam>>[]) Asynchronous wrapper over select SQL block data Declaration public static Task<T[]> GetSqlBlockDataAsync<T>(this IDataScope dataScope, Expression<SqlBlockDefinition<T>> block, params Expression<Func<ISqlParamAdapter, ISqlParam>>[] parameters) where T : class, new() Parameters Type Name Description IDataScope dataScope Data scope layer Expression < SqlBlockDefinition <T>> block Sql block structure Expression < Func < ISqlParamAdapter , ISqlParam >>[] parameters Sql block parameters Returns Type Description Task <T[]> Asynchronous wrapper over SQL block data selected and mapped Type Parameters Name Description T | Improve this Doc View Source LastAsync<T>(IQueryable<T>) Asynchronous wrapper over Last() LINQ function Declaration public static Task<T> LastAsync<T>(this IQueryable<T> source) Parameters Type Name Description IQueryable <T> source Source object sequence Returns Type Description Task <T> Asynchronous call over Last() LINQ function Type Parameters Name Description T Object type | Improve this Doc View Source LastAsync<T>(IQueryable<T>, Expression<Func<T, Boolean>>) Asynchronous wrapper over Last() LINQ function Declaration public static Task<T> LastAsync<T>(this IQueryable<T> source, Expression<Func<T, bool>> predicate) Parameters Type Name Description IQueryable <T> source Source object sequence Expression < Func <T, Boolean >> predicate A function to test each element for a condition Returns Type Description Task <T> Asynchronous call over Last() LINQ function Type Parameters Name Description T Object type | Improve this Doc View Source LastAsync<T>(IQueryable<T>, Expression<Func<T, Boolean>>, CancellationToken) Asynchronous wrapper over Last() LINQ function Declaration public static Task<T> LastAsync<T>(this IQueryable<T> source, Expression<Func<T, bool>> predicate, CancellationToken token) Parameters Type Name Description IQueryable <T> source Source object sequence Expression < Func <T, Boolean >> predicate A function to test each element for a condition CancellationToken token Cancellation token Returns Type Description Task <T> Asynchronous call over Last() LINQ function Type Parameters Name Description T Object type | Improve this Doc View Source LastAsync<T>(IDataQuery<T>) Asynchronous wrapper over Last() LINQ function Declaration public static Task<T> LastAsync<T>(this IDataQuery<T> source) Parameters Type Name Description IDataQuery <T> source Source object sequence Returns Type Description Task <T> Asynchronous call over Last() LINQ function Type Parameters Name Description T Object type | Improve this Doc View Source LastAsync<T>(IDataQuery<T>, Func<JsonSettings<T>, JsonSettings<T>>) Asynchronous wrapper over Last() LINQ function Declaration public static Task<T> LastAsync<T>(this IDataQuery<T> source, Func<JsonSettings<T>, JsonSettings<T>> settings) where T : class, IDataObject, new() Parameters Type Name Description IDataQuery <T> source Source object sequence Func < JsonSettings <T>, JsonSettings <T>> settings JSON serialization settings Returns Type Description Task <T> Asynchronous call over Last() LINQ function Type Parameters Name Description T Object type | Improve this Doc View Source LastAsync<T>(IDataQuery<T>, Expression<Func<T, Boolean>>) Asynchronous wrapper over Last() LINQ function Declaration public static Task<T> LastAsync<T>(this IDataQuery<T> source, Expression<Func<T, bool>> predicate) Parameters Type Name Description IDataQuery <T> source Source object sequence Expression < Func <T, Boolean >> predicate A function to test each element for a condition Returns Type Description Task <T> Asynchronous call over Last() LINQ function Type Parameters Name Description T Object type | Improve this Doc View Source LastAsync<T>(IDataQuery<T>, Expression<Func<T, Boolean>>, Func<JsonSettings<T>, JsonSettings<T>>) Asynchronous wrapper over Last() LINQ function Declaration public static Task<T> LastAsync<T>(this IDataQuery<T> source, Expression<Func<T, bool>> predicate, Func<JsonSettings<T>, JsonSettings<T>> settings) where T : class, IDataObject, new() Parameters Type Name Description IDataQuery <T> source Source object sequence Expression < Func <T, Boolean >> predicate A function to test each element for a condition Func < JsonSettings <T>, JsonSettings <T>> settings JSON serialization settings Returns Type Description Task <T> Asynchronous call over Last() LINQ function Type Parameters Name Description T Object type | Improve this Doc View Source LastOrDefaultAsync<T>(IQueryable<T>) Asynchronous wrapper over LastOrDefault() LINQ function Declaration public static Task<T> LastOrDefaultAsync<T>(this IQueryable<T> source) Parameters Type Name Description IQueryable <T> source Source object sequence Returns Type Description Task <T> Asynchronous call over LastOrDefault() LINQ function Type Parameters Name Description T Object type | Improve this Doc View Source LastOrDefaultAsync<T>(IQueryable<T>, Expression<Func<T, Boolean>>) Asynchronous wrapper over LastOrDefault() LINQ function Declaration public static Task<T> LastOrDefaultAsync<T>(this IQueryable<T> source, Expression<Func<T, bool>> predicate) Parameters Type Name Description IQueryable <T> source Source object sequence Expression < Func <T, Boolean >> predicate A function to test each element for a condition Returns Type Description Task <T> Asynchronous call over LastOrDefault() LINQ function Type Parameters Name Description T Object type | Improve this Doc View Source LastOrDefaultAsync<T>(IQueryable<T>, Expression<Func<T, Boolean>>, CancellationToken) Asynchronous wrapper over LastOrDefault() LINQ function Declaration public static Task<T> LastOrDefaultAsync<T>(this IQueryable<T> source, Expression<Func<T, bool>> predicate, CancellationToken token) Parameters Type Name Description IQueryable <T> source Source object sequence Expression < Func <T, Boolean >> predicate A function to test each element for a condition CancellationToken token Cancellation token Returns Type Description Task <T> Asynchronous call over LastOrDefault() LINQ function Type Parameters Name Description T Object type | Improve this Doc View Source LastOrDefaultAsync<T>(IDataQuery<T>) Asynchronous wrapper over LastOrDefault() LINQ function Declaration public static Task<T> LastOrDefaultAsync<T>(this IDataQuery<T> source) Parameters Type Name Description IDataQuery <T> source Source object sequence Returns Type Description Task <T> Asynchronous call over LastOrDefault() LINQ function Type Parameters Name Description T Object type | Improve this Doc View Source LastOrDefaultAsync<T>(IDataQuery<T>, Func<JsonSettings<T>, JsonSettings<T>>) Asynchronous wrapper over LastOrDefault() LINQ function Declaration public static Task<T> LastOrDefaultAsync<T>(this IDataQuery<T> source, Func<JsonSettings<T>, JsonSettings<T>> settings) where T : class, IDataObject, new() Parameters Type Name Description IDataQuery <T> source Source object sequence Func < JsonSettings <T>, JsonSettings <T>> settings JSON serialization settings Returns Type Description Task <T> Asynchronous call over LastOrDefault() LINQ function Type Parameters Name Description T Object type | Improve this Doc View Source LastOrDefaultAsync<T>(IDataQuery<T>, Expression<Func<T, Boolean>>) Asynchronous wrapper over LastOrDefault() LINQ function Declaration public static Task<T> LastOrDefaultAsync<T>(this IDataQuery<T> source, Expression<Func<T, bool>> predicate) Parameters Type Name Description IDataQuery <T> source Source object sequence Expression < Func <T, Boolean >> predicate A function to test each element for a condition Returns Type Description Task <T> Asynchronous call over LastOrDefault() LINQ function Type Parameters Name Description T Object type | Improve this Doc View Source LastOrDefaultAsync<T>(IDataQuery<T>, Expression<Func<T, Boolean>>, Func<JsonSettings<T>, JsonSettings<T>>) Asynchronous wrapper over LastOrDefault() LINQ function Declaration public static Task<T> LastOrDefaultAsync<T>(this IDataQuery<T> source, Expression<Func<T, bool>> predicate, Func<JsonSettings<T>, JsonSettings<T>> settings) where T : class, IDataObject, new() Parameters Type Name Description IDataQuery <T> source Source object sequence Expression < Func <T, Boolean >> predicate A function to test each element for a condition Func < JsonSettings <T>, JsonSettings <T>> settings JSON serialization settings Returns Type Description Task <T> Asynchronous call over LastOrDefault() LINQ function Type Parameters Name Description T Object type | Improve this Doc View Source LoadLobAsync<T>(T) Asynchronous wrapper over LoadLob Declaration public static Task<T> LoadLobAsync<T>(this T obj) where T : class, IDataObject, new() Parameters Type Name Description T obj Data object to submit Returns Type Description Task <T> Asynchronous wrapper over LoadLob Type Parameters Name Description T | Improve this Doc View Source LoadLobAsync<T>(T, Expression<Func<T, Object>>[]) Asynchronous wrapper over LoadLob Declaration public static Task<T> LoadLobAsync<T>(this T obj, params Expression<Func<T, object>>[] properties) where T : class, IDataObject, new() Parameters Type Name Description T obj Data object to submit Expression < Func <T, Object >>[] properties Large data properties expressions to load Returns Type Description Task <T> Asynchronous wrapper over LoadLob Type Parameters Name Description T | Improve this Doc View Source LoadLobAsync<T>(T, String[]) Asynchronous wrapper over LoadLob Declaration public static Task<T> LoadLobAsync<T>(this T obj, params string[] properties) where T : class, IDataObject, new() Parameters Type Name Description T obj Data object to submit String [] properties Large data properties to load Returns Type Description Task <T> Asynchronous wrapper over LoadLob Type Parameters Name Description T | Improve this Doc View Source LongCountAsync<T>(IQueryable<T>) Asynchronous wrapper over LongCount() LINQ function Declaration public static Task<long> LongCountAsync<T>(this IQueryable<T> source) Parameters Type Name Description IQueryable <T> source Source object sequence Returns Type Description Task < Int64 > Asynchronous call over LongCount() LINQ function Type Parameters Name Description T Object type | Improve this Doc View Source LongCountAsync<T>(IQueryable<T>, Expression<Func<T, Boolean>>) Asynchronous wrapper over LongCount() LINQ function Declaration public static Task<long> LongCountAsync<T>(this IQueryable<T> source, Expression<Func<T, bool>> predicate) Parameters Type Name Description IQueryable <T> source Source object sequence Expression < Func <T, Boolean >> predicate A function to test each element for a condition Returns Type Description Task < Int64 > Asynchronous call over LongCount() LINQ function Type Parameters Name Description T Object type | Improve this Doc View Source LongCountAsync<T>(IQueryable<T>, Expression<Func<T, Boolean>>, CancellationToken) Asynchronous wrapper over LongCount() LINQ function Declaration public static Task<long> LongCountAsync<T>(this IQueryable<T> source, Expression<Func<T, bool>> predicate, CancellationToken token) Parameters Type Name Description IQueryable <T> source Source object sequence Expression < Func <T, Boolean >> predicate A function to test each element for a condition CancellationToken token Cancellation token Returns Type Description Task < Int64 > Asynchronous call over LongCount() LINQ function Type Parameters Name Description T Object type | Improve this Doc View Source LongCountAsync<T>(IDataQuery<T>) Asynchronous wrapper over LongCount() LINQ function Declaration public static Task<long> LongCountAsync<T>(this IDataQuery<T> source) Parameters Type Name Description IDataQuery <T> source Source object sequence Returns Type Description Task < Int64 > Asynchronous call over LongCount() LINQ function Type Parameters Name Description T Object type | Improve this Doc View Source LongCountAsync<T>(IDataQuery<T>, Expression<Func<T, Boolean>>) Asynchronous wrapper over LongCount() LINQ function Declaration public static Task<long> LongCountAsync<T>(this IDataQuery<T> source, Expression<Func<T, bool>> predicate) Parameters Type Name Description IDataQuery <T> source Source object sequence Expression < Func <T, Boolean >> predicate A function to test each element for a condition Returns Type Description Task < Int64 > Asynchronous call over LongCount() LINQ function Type Parameters Name Description T Object type | Improve this Doc View Source MaxAsync<T, TResult>(IQueryable<T>, Expression<Func<T, TResult>>) Asynchronous wrapper over Max() LINQ function Declaration public static Task<TResult> MaxAsync<T, TResult>(this IQueryable<T> source, Expression<Func<T, TResult>> selector) Parameters Type Name Description IQueryable <T> source Source object sequence Expression < Func <T, TResult>> selector A projection function to apply to each element Returns Type Description Task <TResult> Asynchronous call over Max() LINQ function Type Parameters Name Description T Object type TResult Function applied field type | Improve this Doc View Source MaxAsync<T, TResult>(IQueryable<T>, Expression<Func<T, TResult>>, CancellationToken) Asynchronous wrapper over Max() LINQ function Declaration public static Task<TResult> MaxAsync<T, TResult>(this IQueryable<T> source, Expression<Func<T, TResult>> selector, CancellationToken token) Parameters Type Name Description IQueryable <T> source Source object sequence Expression < Func <T, TResult>> selector A projection function to apply to each element CancellationToken token Cancellation token Returns Type Description Task <TResult> Asynchronous call over Max() LINQ function Type Parameters Name Description T Object type TResult Function applied field type | Improve this Doc View Source MaxAsync<T, TResult>(IDataQuery<T>, Expression<Func<T, TResult>>) Asynchronous wrapper over Max() LINQ function Declaration public static Task<TResult> MaxAsync<T, TResult>(this IDataQuery<T> source, Expression<Func<T, TResult>> selector) Parameters Type Name Description IDataQuery <T> source Source object sequence Expression < Func <T, TResult>> selector A projection function to apply to each element Returns Type Description Task <TResult> Asynchronous call over Max() LINQ function Type Parameters Name Description T Object type TResult Function applied field type | Improve this Doc View Source MinAsync<T, TResult>(IQueryable<T>, Expression<Func<T, TResult>>) Asynchronous wrapper over Min() LINQ function Declaration public static Task<TResult> MinAsync<T, TResult>(this IQueryable<T> source, Expression<Func<T, TResult>> selector) Parameters Type Name Description IQueryable <T> source Source object sequence Expression < Func <T, TResult>> selector A projection function to apply to each element Returns Type Description Task <TResult> Asynchronous call over Min() LINQ function Type Parameters Name Description T Object type TResult Function applied field type | Improve this Doc View Source MinAsync<T, TResult>(IQueryable<T>, Expression<Func<T, TResult>>, CancellationToken) Asynchronous wrapper over Min() LINQ function Declaration public static Task<TResult> MinAsync<T, TResult>(this IQueryable<T> source, Expression<Func<T, TResult>> selector, CancellationToken token) Parameters Type Name Description IQueryable <T> source Source object sequence Expression < Func <T, TResult>> selector A projection function to apply to each element CancellationToken token Cancellation token Returns Type Description Task <TResult> Asynchronous call over Min() LINQ function Type Parameters Name Description T Object type TResult Function applied field type | Improve this Doc View Source MinAsync<T, TResult>(IDataQuery<T>, Expression<Func<T, TResult>>) Asynchronous wrapper over Min() LINQ function Declaration public static Task<TResult> MinAsync<T, TResult>(this IDataQuery<T> source, Expression<Func<T, TResult>> selector) Parameters Type Name Description IDataQuery <T> source Source object sequence Expression < Func <T, TResult>> selector A projection function to apply to each element Returns Type Description Task <TResult> Asynchronous call over Min() LINQ function Type Parameters Name Description T Object type TResult Function applied field type | Improve this Doc View Source SingleAsync<T>(IQueryable<T>) Asynchronous wrapper over Single() LINQ function Declaration public static Task<T> SingleAsync<T>(this IQueryable<T> source) Parameters Type Name Description IQueryable <T> source Source object sequence Returns Type Description Task <T> Asynchronous call over Single() LINQ function Type Parameters Name Description T Object type | Improve this Doc View Source SingleAsync<T>(IQueryable<T>, Expression<Func<T, Boolean>>) Asynchronous wrapper over Single() LINQ function Declaration public static Task<T> SingleAsync<T>(this IQueryable<T> source, Expression<Func<T, bool>> predicate) Parameters Type Name Description IQueryable <T> source Source object sequence Expression < Func <T, Boolean >> predicate A function to test each element for a condition Returns Type Description Task <T> Asynchronous call over Single() LINQ function Type Parameters Name Description T Object type | Improve this Doc View Source SingleAsync<T>(IQueryable<T>, Expression<Func<T, Boolean>>, CancellationToken) Asynchronous wrapper over Single() LINQ function Declaration public static Task<T> SingleAsync<T>(this IQueryable<T> source, Expression<Func<T, bool>> predicate, CancellationToken token) Parameters Type Name Description IQueryable <T> source Source object sequence Expression < Func <T, Boolean >> predicate A function to test each element for a condition CancellationToken token Cancellation token Returns Type Description Task <T> Asynchronous call over Single() LINQ function Type Parameters Name Description T Object type | Improve this Doc View Source SingleAsync<T>(IDataQuery<T>) Asynchronous wrapper over Single() LINQ function Declaration public static Task<T> SingleAsync<T>(this IDataQuery<T> source) Parameters Type Name Description IDataQuery <T> source Source object sequence Returns Type Description Task <T> Asynchronous call over Single() LINQ function Type Parameters Name Description T Object type | Improve this Doc View Source SingleAsync<T>(IDataQuery<T>, Func<JsonSettings<T>, JsonSettings<T>>) Asynchronous wrapper over Single() LINQ function Declaration public static Task<T> SingleAsync<T>(this IDataQuery<T> source, Func<JsonSettings<T>, JsonSettings<T>> settings) where T : class, IDataObject, new() Parameters Type Name Description IDataQuery <T> source Source object sequence Func < JsonSettings <T>, JsonSettings <T>> settings JSON serialization settings Returns Type Description Task <T> Asynchronous call over Single() LINQ function Type Parameters Name Description T Object type | Improve this Doc View Source SingleAsync<T>(IDataQuery<T>, Expression<Func<T, Boolean>>) Asynchronous wrapper over Single() LINQ function Declaration public static Task<T> SingleAsync<T>(this IDataQuery<T> source, Expression<Func<T, bool>> predicate) Parameters Type Name Description IDataQuery <T> source Source object sequence Expression < Func <T, Boolean >> predicate A function to test each element for a condition Returns Type Description Task <T> Asynchronous call over Single() LINQ function Type Parameters Name Description T Object type | Improve this Doc View Source SingleAsync<T>(IDataQuery<T>, Expression<Func<T, Boolean>>, Func<JsonSettings<T>, JsonSettings<T>>) Asynchronous wrapper over Single() LINQ function Declaration public static Task<T> SingleAsync<T>(this IDataQuery<T> source, Expression<Func<T, bool>> predicate, Func<JsonSettings<T>, JsonSettings<T>> settings) where T : class, IDataObject, new() Parameters Type Name Description IDataQuery <T> source Source object sequence Expression < Func <T, Boolean >> predicate A function to test each element for a condition Func < JsonSettings <T>, JsonSettings <T>> settings JSON serialization settings Returns Type Description Task <T> Asynchronous call over Single() LINQ function Type Parameters Name Description T Object type | Improve this Doc View Source SingleOrDefaultAsync<T>(IQueryable<T>) Asynchronous wrapper over SingleOrDefault() LINQ function Declaration public static Task<T> SingleOrDefaultAsync<T>(this IQueryable<T> source) Parameters Type Name Description IQueryable <T> source Source object sequence Returns Type Description Task <T> Asynchronous call over SingleOrDefault() LINQ function Type Parameters Name Description T Object type | Improve this Doc View Source SingleOrDefaultAsync<T>(IQueryable<T>, Expression<Func<T, Boolean>>) Asynchronous wrapper over SingleOrDefault() LINQ function Declaration public static Task<T> SingleOrDefaultAsync<T>(this IQueryable<T> source, Expression<Func<T, bool>> predicate) Parameters Type Name Description IQueryable <T> source Source object sequence Expression < Func <T, Boolean >> predicate A function to test each element for a condition Returns Type Description Task <T> Asynchronous call over SingleOrDefault() LINQ function Type Parameters Name Description T Object type | Improve this Doc View Source SingleOrDefaultAsync<T>(IQueryable<T>, Expression<Func<T, Boolean>>, CancellationToken) Asynchronous wrapper over SingleOrDefault() LINQ function Declaration public static Task<T> SingleOrDefaultAsync<T>(this IQueryable<T> source, Expression<Func<T, bool>> predicate, CancellationToken token) Parameters Type Name Description IQueryable <T> source Source object sequence Expression < Func <T, Boolean >> predicate A function to test each element for a condition CancellationToken token Cancellation token Returns Type Description Task <T> Asynchronous call over SingleOrDefault() LINQ function Type Parameters Name Description T Object type | Improve this Doc View Source SingleOrDefaultAsync<T>(IDataQuery<T>) Asynchronous wrapper over SingleOrDefault() LINQ function Declaration public static Task<T> SingleOrDefaultAsync<T>(this IDataQuery<T> source) Parameters Type Name Description IDataQuery <T> source Source object sequence Returns Type Description Task <T> Asynchronous call over SingleOrDefault() LINQ function Type Parameters Name Description T Object type | Improve this Doc View Source SingleOrDefaultAsync<T>(IDataQuery<T>, Func<JsonSettings<T>, JsonSettings<T>>) Asynchronous wrapper over SingleOrDefault() LINQ function Declaration public static Task<T> SingleOrDefaultAsync<T>(this IDataQuery<T> source, Func<JsonSettings<T>, JsonSettings<T>> settings) where T : class, IDataObject, new() Parameters Type Name Description IDataQuery <T> source Source object sequence Func < JsonSettings <T>, JsonSettings <T>> settings JSON serialization settings Returns Type Description Task <T> Asynchronous call over SingleOrDefault() LINQ function Type Parameters Name Description T Object type | Improve this Doc View Source SingleOrDefaultAsync<T>(IDataQuery<T>, Expression<Func<T, Boolean>>) Asynchronous wrapper over SingleOrDefault() LINQ function Declaration public static Task<T> SingleOrDefaultAsync<T>(this IDataQuery<T> source, Expression<Func<T, bool>> predicate) Parameters Type Name Description IDataQuery <T> source Source object sequence Expression < Func <T, Boolean >> predicate A function to test each element for a condition Returns Type Description Task <T> Asynchronous call over SingleOrDefault() LINQ function Type Parameters Name Description T Object type | Improve this Doc View Source SingleOrDefaultAsync<T>(IDataQuery<T>, Expression<Func<T, Boolean>>, Func<JsonSettings<T>, JsonSettings<T>>) Asynchronous wrapper over SingleOrDefault() LINQ function Declaration public static Task<T> SingleOrDefaultAsync<T>(this IDataQuery<T> source, Expression<Func<T, bool>> predicate, Func<JsonSettings<T>, JsonSettings<T>> settings) where T : class, IDataObject, new() Parameters Type Name Description IDataQuery <T> source Source object sequence Expression < Func <T, Boolean >> predicate A function to test each element for a condition Func < JsonSettings <T>, JsonSettings <T>> settings JSON serialization settings Returns Type Description Task <T> Asynchronous call over SingleOrDefault() LINQ function Type Parameters Name Description T Object type | Improve this Doc View Source SubmitAndReturnAsync<T>(T, Func<JsonSettings<T>, JsonSettings<T>>, DataSubmitFlag) Asynchronous wrapper over Submit Declaration public static Task<T> SubmitAndReturnAsync<T>(this T obj, Func<JsonSettings<T>, JsonSettings<T>> settings, DataSubmitFlag flag = DataSubmitFlag.None) where T : class, IDataObject, new() Parameters Type Name Description T obj Data object to submit Func < JsonSettings <T>, JsonSettings <T>> settings JSON serialization settings DataSubmitFlag flag Data submit flag Returns Type Description Task <T> Asynchronous wrapper over Submit Type Parameters Name Description T | Improve this Doc View Source SubmitAndReturnAsync<T>(T, DataSubmitFlag) Asynchronous wrapper over Submit Declaration public static Task<T> SubmitAndReturnAsync<T>(this T obj, DataSubmitFlag flag = DataSubmitFlag.None) where T : class, IDataObject, new() Parameters Type Name Description T obj Data object to submit DataSubmitFlag flag Data submit flag Returns Type Description Task <T> Asynchronous wrapper over Submit Type Parameters Name Description T | Improve this Doc View Source SubmitAsync<T>(T, DataSubmitFlag) Asynchronous wrapper over Submit Declaration public static Task<bool> SubmitAsync<T>(this T obj, DataSubmitFlag flag = DataSubmitFlag.None) where T : class, IDataObject, new() Parameters Type Name Description T obj Data object to submit DataSubmitFlag flag Data submit flag Returns Type Description Task < Boolean > Asynchronous wrapper over Submit Type Parameters Name Description T | Improve this Doc View Source SubmitAsync<T>(IRepository<T>, IEnumerable<T>, DataSubmitFlag) Asynchronous wrapper over Submit Declaration public static Task<bool> SubmitAsync<T>(this IRepository<T> source, IEnumerable<T> objects, DataSubmitFlag flag = DataSubmitFlag.None) where T : class, IDataObject, new() Parameters Type Name Description IRepository <T> source Repository to submit IEnumerable <T> objects Objects to submit DataSubmitFlag flag Data submit flag Returns Type Description Task < Boolean > Asynchronous wrapper over Submit Type Parameters Name Description T | Improve this Doc View Source SumAsync<T>(IQueryable<T>, Expression<Func<T, Decimal>>) Asynchronous wrapper over Sum() LINQ function Declaration public static Task<decimal> SumAsync<T>(this IQueryable<T> source, Expression<Func<T, decimal>> selector) Parameters Type Name Description IQueryable <T> source Source object sequence Expression < Func <T, Decimal >> selector A projection function to apply to each element Returns Type Description Task < Decimal > Asynchronous call over Sum() LINQ function Type Parameters Name Description T Object type | Improve this Doc View Source SumAsync<T>(IQueryable<T>, Expression<Func<T, Decimal>>, CancellationToken) Asynchronous wrapper over Sum() LINQ function Declaration public static Task<decimal> SumAsync<T>(this IQueryable<T> source, Expression<Func<T, decimal>> selector, CancellationToken token) Parameters Type Name Description IQueryable <T> source Source object sequence Expression < Func <T, Decimal >> selector A projection function to apply to each element CancellationToken token Cancellation token Returns Type Description Task < Decimal > Asynchronous call over Sum() LINQ function Type Parameters Name Description T Object type | Improve this Doc View Source SumAsync<T>(IQueryable<T>, Expression<Func<T, Double>>) Asynchronous wrapper over Sum() LINQ function Declaration public static Task<double> SumAsync<T>(this IQueryable<T> source, Expression<Func<T, double>> selector) Parameters Type Name Description IQueryable <T> source Source object sequence Expression < Func <T, Double >> selector A projection function to apply to each element Returns Type Description Task < Double > Asynchronous call over Sum() LINQ function Type Parameters Name Description T Object type | Improve this Doc View Source SumAsync<T>(IQueryable<T>, Expression<Func<T, Double>>, CancellationToken) Asynchronous wrapper over Sum() LINQ function Declaration public static Task<double> SumAsync<T>(this IQueryable<T> source, Expression<Func<T, double>> selector, CancellationToken token) Parameters Type Name Description IQueryable <T> source Source object sequence Expression < Func <T, Double >> selector A projection function to apply to each element CancellationToken token Cancellation token Returns Type Description Task < Double > Asynchronous call over Sum() LINQ function Type Parameters Name Description T Object type | Improve this Doc View Source SumAsync<T>(IQueryable<T>, Expression<Func<T, Int32>>) Asynchronous wrapper over Sum() LINQ function Declaration public static Task<int> SumAsync<T>(this IQueryable<T> source, Expression<Func<T, int>> selector) Parameters Type Name Description IQueryable <T> source Source object sequence Expression < Func <T, Int32 >> selector A projection function to apply to each element Returns Type Description Task < Int32 > Asynchronous call over Sum() LINQ function Type Parameters Name Description T Object type | Improve this Doc View Source SumAsync<T>(IQueryable<T>, Expression<Func<T, Int32>>, CancellationToken) Asynchronous wrapper over Sum() LINQ function Declaration public static Task<int> SumAsync<T>(this IQueryable<T> source, Expression<Func<T, int>> selector, CancellationToken token) Parameters Type Name Description IQueryable <T> source Source object sequence Expression < Func <T, Int32 >> selector A projection function to apply to each element CancellationToken token Cancellation token Returns Type Description Task < Int32 > Asynchronous call over Sum() LINQ function Type Parameters Name Description T Object type | Improve this Doc View Source SumAsync<T>(IQueryable<T>, Expression<Func<T, Int64>>) Asynchronous wrapper over Sum() LINQ function Declaration public static Task<long> SumAsync<T>(this IQueryable<T> source, Expression<Func<T, long>> selector) Parameters Type Name Description IQueryable <T> source Source object sequence Expression < Func <T, Int64 >> selector A projection function to apply to each element Returns Type Description Task < Int64 > Asynchronous call over Sum() LINQ function Type Parameters Name Description T Object type | Improve this Doc View Source SumAsync<T>(IQueryable<T>, Expression<Func<T, Int64>>, CancellationToken) Asynchronous wrapper over Sum() LINQ function Declaration public static Task<long> SumAsync<T>(this IQueryable<T> source, Expression<Func<T, long>> selector, CancellationToken token) Parameters Type Name Description IQueryable <T> source Source object sequence Expression < Func <T, Int64 >> selector A projection function to apply to each element CancellationToken token Cancellation token Returns Type Description Task < Int64 > Asynchronous call over Sum() LINQ function Type Parameters Name Description T Object type | Improve this Doc View Source SumAsync<T>(IQueryable<T>, Expression<Func<T, Nullable<Decimal>>>) Asynchronous wrapper over Sum() LINQ function Declaration public static Task<decimal?> SumAsync<T>(this IQueryable<T> source, Expression<Func<T, decimal?>> selector) Parameters Type Name Description IQueryable <T> source Source object sequence Expression < Func <T, Nullable < Decimal >>> selector A projection function to apply to each element Returns Type Description Task < Nullable < Decimal >> Asynchronous call over Average() LINQ function Type Parameters Name Description T Object type | Improve this Doc View Source SumAsync<T>(IQueryable<T>, Expression<Func<T, Nullable<Decimal>>>, CancellationToken) Asynchronous wrapper over Sum() LINQ function Declaration public static Task<decimal?> SumAsync<T>(this IQueryable<T> source, Expression<Func<T, decimal?>> selector, CancellationToken token) Parameters Type Name Description IQueryable <T> source Source object sequence Expression < Func <T, Nullable < Decimal >>> selector A projection function to apply to each element CancellationToken token Cancellation token Returns Type Description Task < Nullable < Decimal >> Asynchronous call over Sum() LINQ function Type Parameters Name Description T Object type | Improve this Doc View Source SumAsync<T>(IQueryable<T>, Expression<Func<T, Nullable<Double>>>) Asynchronous wrapper over Sum() LINQ function Declaration public static Task<double?> SumAsync<T>(this IQueryable<T> source, Expression<Func<T, double?>> selector) Parameters Type Name Description IQueryable <T> source Source object sequence Expression < Func <T, Nullable < Double >>> selector A projection function to apply to each element Returns Type Description Task < Nullable < Double >> Asynchronous call over Sum() LINQ function Type Parameters Name Description T Object type | Improve this Doc View Source SumAsync<T>(IQueryable<T>, Expression<Func<T, Nullable<Double>>>, CancellationToken) Asynchronous wrapper over Sum() LINQ function Declaration public static Task<double?> SumAsync<T>(this IQueryable<T> source, Expression<Func<T, double?>> selector, CancellationToken token) Parameters Type Name Description IQueryable <T> source Source object sequence Expression < Func <T, Nullable < Double >>> selector A projection function to apply to each element CancellationToken token Cancellation token Returns Type Description Task < Nullable < Double >> Asynchronous call over Sum() LINQ function Type Parameters Name Description T Object type | Improve this Doc View Source SumAsync<T>(IQueryable<T>, Expression<Func<T, Nullable<Int32>>>) Asynchronous wrapper over Sum() LINQ function Declaration public static Task<int?> SumAsync<T>(this IQueryable<T> source, Expression<Func<T, int?>> selector) Parameters Type Name Description IQueryable <T> source Source object sequence Expression < Func <T, Nullable < Int32 >>> selector A projection function to apply to each element Returns Type Description Task < Nullable < Int32 >> Asynchronous call over Sum() LINQ function Type Parameters Name Description T Object type | Improve this Doc View Source SumAsync<T>(IQueryable<T>, Expression<Func<T, Nullable<Int32>>>, CancellationToken) Asynchronous wrapper over Average() LINQ function Declaration public static Task<int?> SumAsync<T>(this IQueryable<T> source, Expression<Func<T, int?>> selector, CancellationToken token) Parameters Type Name Description IQueryable <T> source Source object sequence Expression < Func <T, Nullable < Int32 >>> selector A projection function to apply to each element CancellationToken token Cancellation token Returns Type Description Task < Nullable < Int32 >> Asynchronous call over Average() LINQ function Type Parameters Name Description T Object type | Improve this Doc View Source SumAsync<T>(IQueryable<T>, Expression<Func<T, Nullable<Int64>>>) Asynchronous wrapper over Sum() LINQ function Declaration public static Task<long?> SumAsync<T>(this IQueryable<T> source, Expression<Func<T, long?>> selector) Parameters Type Name Description IQueryable <T> source Source object sequence Expression < Func <T, Nullable < Int64 >>> selector A projection function to apply to each element Returns Type Description Task < Nullable < Int64 >> Asynchronous call over Sum() LINQ function Type Parameters Name Description T Object type | Improve this Doc View Source SumAsync<T>(IQueryable<T>, Expression<Func<T, Nullable<Int64>>>, CancellationToken) Asynchronous wrapper over Average() LINQ function Declaration public static Task<long?> SumAsync<T>(this IQueryable<T> source, Expression<Func<T, long?>> selector, CancellationToken token) Parameters Type Name Description IQueryable <T> source Source object sequence Expression < Func <T, Nullable < Int64 >>> selector A projection function to apply to each element CancellationToken token Cancellation token Returns Type Description Task < Nullable < Int64 >> Asynchronous call over Average() LINQ function Type Parameters Name Description T Object type | Improve this Doc View Source SumAsync<T>(IQueryable<T>, Expression<Func<T, Nullable<Single>>>) Asynchronous wrapper over Sum() LINQ function Declaration public static Task<float?> SumAsync<T>(this IQueryable<T> source, Expression<Func<T, float?>> selector) Parameters Type Name Description IQueryable <T> source Source object sequence Expression < Func <T, Nullable < Single >>> selector A projection function to apply to each element Returns Type Description Task < Nullable < Single >> Asynchronous call over Sum() LINQ function Type Parameters Name Description T Object type | Improve this Doc View Source SumAsync<T>(IQueryable<T>, Expression<Func<T, Nullable<Single>>>, CancellationToken) Asynchronous wrapper over Sum() LINQ function Declaration public static Task<float?> SumAsync<T>(this IQueryable<T> source, Expression<Func<T, float?>> selector, CancellationToken token) Parameters Type Name Description IQueryable <T> source Source object sequence Expression < Func <T, Nullable < Single >>> selector A projection function to apply to each element CancellationToken token Cancellation token Returns Type Description Task < Nullable < Single >> Asynchronous call over Sum() LINQ function Type Parameters Name Description T Object type | Improve this Doc View Source SumAsync<T>(IQueryable<T>, Expression<Func<T, Single>>) Asynchronous wrapper over Sum() LINQ function Declaration public static Task<float> SumAsync<T>(this IQueryable<T> source, Expression<Func<T, float>> selector) Parameters Type Name Description IQueryable <T> source Source object sequence Expression < Func <T, Single >> selector A projection function to apply to each element Returns Type Description Task < Single > Asynchronous call over Sum() LINQ function Type Parameters Name Description T Object type | Improve this Doc View Source SumAsync<T>(IQueryable<T>, Expression<Func<T, Single>>, CancellationToken) Asynchronous wrapper over Sum() LINQ function Declaration public static Task<float> SumAsync<T>(this IQueryable<T> source, Expression<Func<T, float>> selector, CancellationToken token) Parameters Type Name Description IQueryable <T> source Source object sequence Expression < Func <T, Single >> selector A projection function to apply to each element CancellationToken token Cancellation token Returns Type Description Task < Single > Asynchronous call over Sum() LINQ function Type Parameters Name Description T Object type | Improve this Doc View Source SumAsync<T>(IDataQuery<T>, Expression<Func<T, Decimal>>) Asynchronous wrapper over Sum() LINQ function Declaration public static Task<decimal> SumAsync<T>(this IDataQuery<T> source, Expression<Func<T, decimal>> selector) Parameters Type Name Description IDataQuery <T> source Source object sequence Expression < Func <T, Decimal >> selector A projection function to apply to each element Returns Type Description Task < Decimal > Asynchronous call over Sum() LINQ function Type Parameters Name Description T Object type | Improve this Doc View Source SumAsync<T>(IDataQuery<T>, Expression<Func<T, Double>>) Asynchronous wrapper over Sum() LINQ function Declaration public static Task<double> SumAsync<T>(this IDataQuery<T> source, Expression<Func<T, double>> selector) Parameters Type Name Description IDataQuery <T> source Source object sequence Expression < Func <T, Double >> selector A projection function to apply to each element Returns Type Description Task < Double > Asynchronous call over Sum() LINQ function Type Parameters Name Description T Object type | Improve this Doc View Source SumAsync<T>(IDataQuery<T>, Expression<Func<T, Int32>>) Asynchronous wrapper over Sum() LINQ function Declaration public static Task<int> SumAsync<T>(this IDataQuery<T> source, Expression<Func<T, int>> selector) Parameters Type Name Description IDataQuery <T> source Source object sequence Expression < Func <T, Int32 >> selector A projection function to apply to each element Returns Type Description Task < Int32 > Asynchronous call over Sum() LINQ function Type Parameters Name Description T Object type | Improve this Doc View Source SumAsync<T>(IDataQuery<T>, Expression<Func<T, Int64>>) Asynchronous wrapper over Sum() LINQ function Declaration public static Task<long> SumAsync<T>(this IDataQuery<T> source, Expression<Func<T, long>> selector) Parameters Type Name Description IDataQuery <T> source Source object sequence Expression < Func <T, Int64 >> selector A projection function to apply to each element Returns Type Description Task < Int64 > Asynchronous call over Sum() LINQ function Type Parameters Name Description T Object type | Improve this Doc View Source SumAsync<T>(IDataQuery<T>, Expression<Func<T, Nullable<Decimal>>>) Asynchronous wrapper over Sum() LINQ function Declaration public static Task<decimal?> SumAsync<T>(this IDataQuery<T> source, Expression<Func<T, decimal?>> selector) Parameters Type Name Description IDataQuery <T> source Source object sequence Expression < Func <T, Nullable < Decimal >>> selector A projection function to apply to each element Returns Type Description Task < Nullable < Decimal >> Asynchronous call over Sum() LINQ function Type Parameters Name Description T Object type | Improve this Doc View Source SumAsync<T>(IDataQuery<T>, Expression<Func<T, Nullable<Double>>>) Asynchronous wrapper over Sum() LINQ function Declaration public static Task<double?> SumAsync<T>(this IDataQuery<T> source, Expression<Func<T, double?>> selector) Parameters Type Name Description IDataQuery <T> source Source object sequence Expression < Func <T, Nullable < Double >>> selector A projection function to apply to each element Returns Type Description Task < Nullable < Double >> Asynchronous call over Sum() LINQ function Type Parameters Name Description T Object type | Improve this Doc View Source SumAsync<T>(IDataQuery<T>, Expression<Func<T, Nullable<Int32>>>) Asynchronous wrapper over Sum() LINQ function Declaration public static Task<int?> SumAsync<T>(this IDataQuery<T> source, Expression<Func<T, int?>> selector) Parameters Type Name Description IDataQuery <T> source Source object sequence Expression < Func <T, Nullable < Int32 >>> selector A projection function to apply to each element Returns Type Description Task < Nullable < Int32 >> Asynchronous call over Sum() LINQ function Type Parameters Name Description T Object type | Improve this Doc View Source SumAsync<T>(IDataQuery<T>, Expression<Func<T, Nullable<Int64>>>) Asynchronous wrapper over Sum() LINQ function Declaration public static Task<long?> SumAsync<T>(this IDataQuery<T> source, Expression<Func<T, long?>> selector) Parameters Type Name Description IDataQuery <T> source Source object sequence Expression < Func <T, Nullable < Int64 >>> selector A projection function to apply to each element Returns Type Description Task < Nullable < Int64 >> Asynchronous call over Sum() LINQ function Type Parameters Name Description T Object type | Improve this Doc View Source SumAsync<T>(IDataQuery<T>, Expression<Func<T, Nullable<Single>>>) Asynchronous wrapper over Sum() LINQ function Declaration public static Task<float?> SumAsync<T>(this IDataQuery<T> source, Expression<Func<T, float?>> selector) Parameters Type Name Description IDataQuery <T> source Source object sequence Expression < Func <T, Nullable < Single >>> selector A projection function to apply to each element Returns Type Description Task < Nullable < Single >> Asynchronous call over Sum() LINQ function Type Parameters Name Description T Object type | Improve this Doc View Source SumAsync<T>(IDataQuery<T>, Expression<Func<T, Single>>) Asynchronous wrapper over Sum() LINQ function Declaration public static Task<float> SumAsync<T>(this IDataQuery<T> source, Expression<Func<T, float>> selector) Parameters Type Name Description IDataQuery <T> source Source object sequence Expression < Func <T, Single >> selector A projection function to apply to each element Returns Type Description Task < Single > Asynchronous call over Sum() LINQ function Type Parameters Name Description T Object type | Improve this Doc View Source ToArrayAsync<T>(IQueryable<T>) Asynchronous wrapper over ToArray() LINQ function Declaration public static Task<T[]> ToArrayAsync<T>(this IQueryable<T> source) Parameters Type Name Description IQueryable <T> source Source object sequence Returns Type Description Task <T[]> Asynchronous call over ToArray() LINQ function Type Parameters Name Description T Object type | Improve this Doc View Source ToArrayAsync<T>(IQueryable<T>, CancellationToken) Asynchronous wrapper over ToArray() LINQ function Declaration public static Task<T[]> ToArrayAsync<T>(this IQueryable<T> source, CancellationToken token) Parameters Type Name Description IQueryable <T> source Source object sequence CancellationToken token Cancellation token Returns Type Description Task <T[]> Asynchronous call over ToArray() LINQ function Type Parameters Name Description T Object type | Improve this Doc View Source ToArrayAsync<T>(IDataQuery<T>) Asynchronous wrapper over ToArray() LINQ function Declaration public static Task<T[]> ToArrayAsync<T>(this IDataQuery<T> source) Parameters Type Name Description IDataQuery <T> source Source object sequence Returns Type Description Task <T[]> Asynchronous call over ToArray() LINQ function Type Parameters Name Description T Object type | Improve this Doc View Source ToArrayAsync<T>(IDataQuery<T>, Func<JsonSettings<T>, JsonSettings<T>>) Asynchronous wrapper over ToArray() LINQ function Declaration public static Task<T[]> ToArrayAsync<T>(this IDataQuery<T> source, Func<JsonSettings<T>, JsonSettings<T>> settings) where T : class, IDataObject, new() Parameters Type Name Description IDataQuery <T> source Source object sequence Func < JsonSettings <T>, JsonSettings <T>> settings JSON serialization settings Returns Type Description Task <T[]> Asynchronous call over ToArray() LINQ function Type Parameters Name Description T Object type | Improve this Doc View Source ToDictionaryAsync<T, TKey, TValue>(IQueryable<T>, Func<T, TKey>, Func<T, TValue>) Asynchronous wrapper over ToDictionary() LINQ function Declaration public static Task<Dictionary<TKey, TValue>> ToDictionaryAsync<T, TKey, TValue>(this IQueryable<T> source, Func<T, TKey> keySelector, Func<T, TValue> elementSelector) Parameters Type Name Description IQueryable <T> source Source object sequence Func <T, TKey> keySelector Function to extract key from each element Func <T, TValue> elementSelector Function to extract value from each element Returns Type Description Task < Dictionary <TKey, TValue>> Asynchronous call over ToDictionary() LINQ function Type Parameters Name Description T Object type TKey Dictionary key type TValue Dictionary value type | Improve this Doc View Source ToDictionaryAsync<T, TKey, TValue>(IQueryable<T>, Func<T, TKey>, Func<T, TValue>, CancellationToken) Asynchronous wrapper over ToDictionary() LINQ function Declaration public static Task<Dictionary<TKey, TValue>> ToDictionaryAsync<T, TKey, TValue>(this IQueryable<T> source, Func<T, TKey> keySelector, Func<T, TValue> elementSelector, CancellationToken token) Parameters Type Name Description IQueryable <T> source Source object sequence Func <T, TKey> keySelector Function to extract key from each element Func <T, TValue> elementSelector Function to extract value from each element CancellationToken token Cancellation token Returns Type Description Task < Dictionary <TKey, TValue>> Asynchronous call over ToDictionary() LINQ function Type Parameters Name Description T Object type TKey Dictionary key type TValue Dictionary value type | Improve this Doc View Source ToDictionaryAsync<T, TKey, TValue>(IDataQuery<T>, Func<T, TKey>, Func<T, TValue>) Asynchronous wrapper over ToDictionary() LINQ function Declaration public static Task<Dictionary<TKey, TValue>> ToDictionaryAsync<T, TKey, TValue>(this IDataQuery<T> source, Func<T, TKey> keySelector, Func<T, TValue> elementSelector) Parameters Type Name Description IDataQuery <T> source Source object sequence Func <T, TKey> keySelector Function to extract key from each element Func <T, TValue> elementSelector Function to extract value from each element Returns Type Description Task < Dictionary <TKey, TValue>> Asynchronous call over ToDictionary() LINQ function Type Parameters Name Description T Object type TKey Dictionary key type TValue Dictionary value type | Improve this Doc View Source ToListAsync<T>(IQueryable<T>) Asynchronous wrapper over ToList() LINQ function Declaration public static Task<List<T>> ToListAsync<T>(this IQueryable<T> source) Parameters Type Name Description IQueryable <T> source Source object sequence Returns Type Description Task < List <T>> Asynchronous call over ToList() LINQ function Type Parameters Name Description T Object type | Improve this Doc View Source ToListAsync<T>(IQueryable<T>, CancellationToken) Asynchronous wrapper over ToList() LINQ function Declaration public static Task<List<T>> ToListAsync<T>(this IQueryable<T> source, CancellationToken token) Parameters Type Name Description IQueryable <T> source Source object sequence CancellationToken token Cancellation token Returns Type Description Task < List <T>> Asynchronous call over ToList() LINQ function Type Parameters Name Description T Object type | Improve this Doc View Source ToListAsync<T>(IDataQuery<T>) Asynchronous wrapper over ToList() LINQ function Declaration public static Task<List<T>> ToListAsync<T>(this IDataQuery<T> source) Parameters Type Name Description IDataQuery <T> source Source object sequence Returns Type Description Task < List <T>> Asynchronous call over ToList() LINQ function Type Parameters Name Description T Object type"
  },
  "api/XData.Variable.html": {
    "href": "api/XData.Variable.html",
    "title": "Class Variable | XData website",
    "keywords": "Class Variable Data object repository variable Inheritance Object Variable Inherited Members Object.Equals(Object) Object.Equals(Object, Object) Object.GetHashCode() Object.GetType() Object.MemberwiseClone() Object.ReferenceEquals(Object, Object) Namespace : XData Assembly : XData.docfx.dll Syntax public sealed class Variable Constructors | Improve this Doc View Source Variable(String, Object) Data object repository variable constructor Declaration public Variable(string name, object val) Parameters Type Name Description String name Variable name Object val Variable value Properties | Improve this Doc View Source Name Variable name Declaration public string Name { get; } Property Value Type Description String | Improve this Doc View Source Value Variable value Declaration public object Value { get; } Property Value Type Description Object Methods | Improve this Doc View Source ToString() Returns a string that represents the current object. Declaration public override string ToString() Returns Type Description String A string that represents the current object. Overrides Object.ToString() Extension Methods SerializationExtensions.ToXml<T>(T) CollectionsExtensions.SetValue<TKey, T>(TKey, T) CollectionsExtensions.AsEnum<T>(T) DataObjectQueryableExtensions.CompareVariable(Object, FilterOperation, String) Processing.Do<T>(T, Action<IProcess<T>>[]) TypeExtensions.TryConvert<T, TResult>(T, Func<T, TResult>) TypeExtensions.TryConvert<T, TResult>(T, Func<T, TResult>, TResult) TypeExtensions.ChangeType<T>(Object) TypeExtensions.ChangeType(Object, Type) TypeExtensions.InvokeMethod<TRet>(Object, Type[], Expression<Func<TRet>>, BindingFlags) TypeExtensions.InvokeMethod(Object, Type[], Expression<Action>, BindingFlags) TypeExtensions.InvokeMethod<TRet>(Object, Expression<Func<TRet>>, BindingFlags) TypeExtensions.InvokeMethod(Object, Expression<Action>, BindingFlags) SqlBlockExtensions.SetExpression<TTag, TResult>(TTag, Expression<Func<IBlockQueryAdapter, TResult>>) QueryDescriptionExtensions.SetExpression<TTag, TResult>(TTag, Expression<Func<IQueryStructureAdapter, TResult>>)"
  },
  "api/XData.Trigger-1.html": {
    "href": "api/XData.Trigger-1.html",
    "title": "Delegate Trigger<T> | XData website",
    "keywords": "Delegate Trigger<T> Trigger logic delegate type Namespace : XData Assembly : XData.docfx.dll Syntax public delegate bool Trigger<T>(ref T obj, ref DataTriggerFlag flag) where T : class, IDataObject; Parameters Type Name Description T obj Object instance DataTriggerFlag flag Trigger routing flag Returns Type Description Boolean Success flag Type Parameters Name Description T Object type Extension Methods SerializationExtensions.ToXml<T>(T) CollectionsExtensions.SetValue<TKey, T>(TKey, T) CollectionsExtensions.AsEnum<T>(T) DataObjectQueryableExtensions.CompareVariable(Object, FilterOperation, String) Processing.Do<T>(T, Action<IProcess<T>>[]) TypeExtensions.TryConvert<T, TResult>(T, Func<T, TResult>) TypeExtensions.TryConvert<T, TResult>(T, Func<T, TResult>, TResult) TypeExtensions.ChangeType<T>(Object) TypeExtensions.ChangeType(Object, Type) TypeExtensions.InvokeMethod<TRet>(Object, Type[], Expression<Func<TRet>>, BindingFlags) TypeExtensions.InvokeMethod(Object, Type[], Expression<Action>, BindingFlags) TypeExtensions.InvokeMethod<TRet>(Object, Expression<Func<TRet>>, BindingFlags) TypeExtensions.InvokeMethod(Object, Expression<Action>, BindingFlags) SqlBlockExtensions.SetExpression<TTag, TResult>(TTag, Expression<Func<IBlockQueryAdapter, TResult>>) QueryDescriptionExtensions.SetExpression<TTag, TResult>(TTag, Expression<Func<IQueryStructureAdapter, TResult>>) See Also BeforeDelete BeforeInsert BeforeUpdate AfterDelete AfterInsert AfterUpdate"
  },
  "api/XData.DataGrouping.html": {
    "href": "api/XData.DataGrouping.html",
    "title": "Enum DataGrouping | XData website",
    "keywords": "Enum DataGrouping Data aggregation function Namespace : XData Assembly : XData.docfx.dll Syntax [DataContract] public enum DataGrouping Fields Name Description Avg Avg() Count Count() Max Max() Min Min() None No aggregate function applied Sum Sum() See Also Grouping Grouping Grouping None Count Sum Max Min Avg Extension Methods SerializationExtensions.ToXml<DataGrouping>() CollectionsExtensions.SetValue<DataGrouping, T>(T) CollectionsExtensions.AsEnum<DataGrouping>() DataObjectQueryableExtensions.CompareVariable(FilterOperation, String) Processing.Do<DataGrouping>(Action<IProcess<DataGrouping>>[]) TypeExtensions.ChangeType<T>() TypeExtensions.ChangeType(Type) TypeExtensions.InvokeMethod<TRet>(Type[], Expression<Func<TRet>>, BindingFlags) TypeExtensions.InvokeMethod(Type[], Expression<Action>, BindingFlags) TypeExtensions.InvokeMethod<TRet>(Expression<Func<TRet>>, BindingFlags) TypeExtensions.InvokeMethod(Expression<Action>, BindingFlags) TypeExtensions.ConvertTo<T>() TypeExtensions.EqualValue(Enum) SqlBlockExtensions.SetExpression<DataGrouping, TResult>(Expression<Func<IBlockQueryAdapter, TResult>>) QueryDescriptionExtensions.SetExpression<DataGrouping, TResult>(Expression<Func<IQueryStructureAdapter, TResult>>)"
  },
  "api/XData.DataSource.Structure.INamedFilter.html": {
    "href": "api/XData.DataSource.Structure.INamedFilter.html",
    "title": "Interface INamedFilter | XData website",
    "keywords": "Interface INamedFilter Named filter interface Inherited Members IFilter.FilterType IFilter.SourceAlias IFilter.Field IFilter.Operation ICloneable.Clone() Namespace : XData.DataSource.Structure Assembly : XData.docfx.dll Syntax public interface INamedFilter : IFilter, ICloneable Properties | Improve this Doc View Source Name Filter name Declaration string Name { get; } Property Value Type Description String Extension Methods SerializationExtensions.ToXml<T>(T) CollectionsExtensions.SetValue<TKey, T>(TKey, T) CollectionsExtensions.AsEnum<T>(T) DataObjectQueryableExtensions.CompareVariable(Object, FilterOperation, String) Processing.Do<T>(T, Action<IProcess<T>>[]) TypeExtensions.TryConvert<T, TResult>(T, Func<T, TResult>) TypeExtensions.TryConvert<T, TResult>(T, Func<T, TResult>, TResult) TypeExtensions.ChangeType<T>(Object) TypeExtensions.ChangeType(Object, Type) TypeExtensions.InvokeMethod<TRet>(Object, Type[], Expression<Func<TRet>>, BindingFlags) TypeExtensions.InvokeMethod(Object, Type[], Expression<Action>, BindingFlags) TypeExtensions.InvokeMethod<TRet>(Object, Expression<Func<TRet>>, BindingFlags) TypeExtensions.InvokeMethod(Object, Expression<Action>, BindingFlags) SqlBlockExtensions.SetExpression<TTag, TResult>(TTag, Expression<Func<IBlockQueryAdapter, TResult>>) QueryDescriptionExtensions.SetExpression<TTag, TResult>(TTag, Expression<Func<IQueryStructureAdapter, TResult>>)"
  },
  "api/XData.DataSource.Structure.FilterCombinationState.html": {
    "href": "api/XData.DataSource.Structure.FilterCombinationState.html",
    "title": "Class FilterCombinationState | XData website",
    "keywords": "Class FilterCombinationState Filter combination state Inheritance Object FilterCombinationState Implements IEquatable < FilterCombinationState > Inherited Members Object.Equals(Object) Object.Equals(Object, Object) Object.GetHashCode() Object.GetType() Object.MemberwiseClone() Object.ReferenceEquals(Object, Object) Object.ToString() Namespace : XData.DataSource.Structure Assembly : XData.docfx.dll Syntax [Serializable] [DataContract] public sealed class FilterCombinationState : IEquatable<FilterCombinationState> Properties | Improve this Doc View Source Combination Combination Declaration [DataMember] public Combination Combination { get; set; } Property Value Type Description Combination | Improve this Doc View Source FilterCombinations Nested filter combinations Declaration [DataMember] public FilterCombinationState[] FilterCombinations { get; set; } Property Value Type Description FilterCombinationState [] | Improve this Doc View Source Filters Filter states Declaration [DataMember] public FilterState[] Filters { get; set; } Property Value Type Description FilterState [] Methods | Improve this Doc View Source Equals(FilterCombinationState) FilterCombinationState equality check Declaration public bool Equals(FilterCombinationState other) Parameters Type Name Description FilterCombinationState other FilterCombinationState instance to compare Returns Type Description Boolean Instances are contains the same data Implements System.IEquatable<T> Extension Methods SerializationExtensions.ToXml<T>(T) CollectionsExtensions.SetValue<TKey, T>(TKey, T) CollectionsExtensions.AsEnum<T>(T) DataObjectQueryableExtensions.CompareVariable(Object, FilterOperation, String) Processing.Do<T>(T, Action<IProcess<T>>[]) TypeExtensions.TryConvert<T, TResult>(T, Func<T, TResult>) TypeExtensions.TryConvert<T, TResult>(T, Func<T, TResult>, TResult) TypeExtensions.ChangeType<T>(Object) TypeExtensions.ChangeType(Object, Type) TypeExtensions.InvokeMethod<TRet>(Object, Type[], Expression<Func<TRet>>, BindingFlags) TypeExtensions.InvokeMethod(Object, Type[], Expression<Action>, BindingFlags) TypeExtensions.InvokeMethod<TRet>(Object, Expression<Func<TRet>>, BindingFlags) TypeExtensions.InvokeMethod(Object, Expression<Action>, BindingFlags) SqlBlockExtensions.SetExpression<TTag, TResult>(TTag, Expression<Func<IBlockQueryAdapter, TResult>>) QueryDescriptionExtensions.SetExpression<TTag, TResult>(TTag, Expression<Func<IQueryStructureAdapter, TResult>>)"
  },
  "api/XData.Extensions.JoinedEnumerable-1.html": {
    "href": "api/XData.Extensions.JoinedEnumerable-1.html",
    "title": "Class JoinedEnumerable<T> | XData website",
    "keywords": "Class JoinedEnumerable<T> Helper class to use outer joins Inheritance Object JoinedEnumerable<T> Implements IEnumerable <T> IEnumerable Inherited Members Object.Equals(Object) Object.Equals(Object, Object) Object.GetHashCode() Object.GetType() Object.MemberwiseClone() Object.ReferenceEquals(Object, Object) Object.ToString() Namespace : XData.Extensions Assembly : XData.docfx.dll Syntax public class JoinedEnumerable<T> : IEnumerable<T>, IEnumerable Type Parameters Name Description T Element type Constructors | Improve this Doc View Source JoinedEnumerable(IEnumerable<T>) Joined enumerable constructor Declaration public JoinedEnumerable(IEnumerable<T> source) Parameters Type Name Description IEnumerable <T> source Fields | Improve this Doc View Source IsOuter Outer joined enumerable Declaration public bool IsOuter Field Value Type Description Boolean Explicit Interface Implementations | Improve this Doc View Source IEnumerable<T>.GetEnumerator() Declaration IEnumerator<T> IEnumerable<T>.GetEnumerator() Returns Type Description IEnumerator <T> | Improve this Doc View Source IEnumerable.GetEnumerator() Declaration IEnumerator IEnumerable.GetEnumerator() Returns Type Description IEnumerator Implements System.Collections.Generic.IEnumerable<T> System.Collections.IEnumerable Extension Methods SerializationExtensions.ToXml<T>(T) CollectionsExtensions.ToSortedSet<T>(IEnumerable<T>, IComparer<T>) CollectionsExtensions.SetValue<TKey, T>(TKey, T) CollectionsExtensions.AsEnum<T>(T) DataObjectQueryableExtensions.CompareVariable(Object, FilterOperation, String) JoinedEnumerable.Inner<TElement>(IEnumerable<TElement>) JoinedEnumerable.Outer<TElement>(IEnumerable<TElement>) JoinedEnumerable.Join<TOuter, TInner, TKey, TResult>(JoinedEnumerable<TOuter>, IEnumerable<TInner>, Func<TOuter, TKey>, Func<TInner, TKey>, Func<TOuter, TInner, TResult>, IEqualityComparer<TKey>) JoinedEnumerable.LeftOuterJoin<TOuter, TInner, TKey, TResult>(IEnumerable<TOuter>, IEnumerable<TInner>, Func<TOuter, TKey>, Func<TInner, TKey>, Func<TOuter, TInner, TResult>, IEqualityComparer<TKey>) JoinedEnumerable.RightOuterJoin<TOuter, TInner, TKey, TResult>(IEnumerable<TOuter>, IEnumerable<TInner>, Func<TOuter, TKey>, Func<TInner, TKey>, Func<TOuter, TInner, TResult>, IEqualityComparer<TKey>) JoinedEnumerable.FullOuterJoin<TOuter, TInner, TKey, TResult>(IEnumerable<TOuter>, IEnumerable<TInner>, Func<TOuter, TKey>, Func<TInner, TKey>, Func<TOuter, TInner, TResult>, IEqualityComparer<TKey>) Processing.Do<T>(T, Action<IProcess<T>>[]) TypeExtensions.TryConvert<T, TResult>(T, Func<T, TResult>) TypeExtensions.TryConvert<T, TResult>(T, Func<T, TResult>, TResult) TypeExtensions.ChangeType<T>(Object) TypeExtensions.ChangeType(Object, Type) TypeExtensions.InvokeMethod<TRet>(Object, Type[], Expression<Func<TRet>>, BindingFlags) TypeExtensions.InvokeMethod(Object, Type[], Expression<Action>, BindingFlags) TypeExtensions.InvokeMethod<TRet>(Object, Expression<Func<TRet>>, BindingFlags) TypeExtensions.InvokeMethod(Object, Expression<Action>, BindingFlags) SqlBlockExtensions.SetExpression<TTag, TResult>(TTag, Expression<Func<IBlockQueryAdapter, TResult>>) QueryDescriptionExtensions.SetExpression<TTag, TResult>(TTag, Expression<Func<IQueryStructureAdapter, TResult>>) QueryDescriptionExtensions.ToDataSet<T>(IEnumerable<T>, String, ISqlBuilder)"
  },
  "api/XData.Extensions.IProcess-1.html": {
    "href": "api/XData.Extensions.IProcess-1.html",
    "title": "Interface IProcess<T> | XData website",
    "keywords": "Interface IProcess<T> Object processing interface Namespace : XData.Extensions Assembly : XData.docfx.dll Syntax public interface IProcess<T> Type Parameters Name Description T Object type Properties | Improve this Doc View Source Instance Processing source object instance Declaration T Instance { get; set; } Property Value Type Description T | Improve this Doc View Source State Intermediate object processing status Declaration dynamic State { get; set; } Property Value Type Description Object Extension Methods SerializationExtensions.ToXml<T>(T) CollectionsExtensions.SetValue<TKey, T>(TKey, T) CollectionsExtensions.AsEnum<T>(T) DataObjectQueryableExtensions.CompareVariable(Object, FilterOperation, String) Processing.Do<T>(T, Action<IProcess<T>>[]) TypeExtensions.TryConvert<T, TResult>(T, Func<T, TResult>) TypeExtensions.TryConvert<T, TResult>(T, Func<T, TResult>, TResult) TypeExtensions.ChangeType<T>(Object) TypeExtensions.ChangeType(Object, Type) TypeExtensions.InvokeMethod<TRet>(Object, Type[], Expression<Func<TRet>>, BindingFlags) TypeExtensions.InvokeMethod(Object, Type[], Expression<Action>, BindingFlags) TypeExtensions.InvokeMethod<TRet>(Object, Expression<Func<TRet>>, BindingFlags) TypeExtensions.InvokeMethod(Object, Expression<Action>, BindingFlags) SqlBlockExtensions.SetExpression<TTag, TResult>(TTag, Expression<Func<IBlockQueryAdapter, TResult>>) QueryDescriptionExtensions.SetExpression<TTag, TResult>(TTag, Expression<Func<IQueryStructureAdapter, TResult>>)"
  },
  "api/XData.DataSource.Structure.ISubqueryLink.html": {
    "href": "api/XData.DataSource.Structure.ISubqueryLink.html",
    "title": "Interface ISubqueryLink | XData website",
    "keywords": "Interface ISubqueryLink Subquery link interface Inherited Members IInnerLink.LinkedSourceAlias IInnerLink.LinkedField IInnerLink.GetIsLink() IInnerLink.GetAliases() IOptionalFilter.Primary IFilter.FilterType IFilter.SourceAlias IFilter.Field IFilter.Operation ICloneable.Clone() Namespace : XData.DataSource.Structure Assembly : XData.docfx.dll Syntax public interface ISubqueryLink : IInnerLink, IOptionalFilter, IFilter, ICloneable Properties | Improve this Doc View Source LinkedPropertyName Declaration string LinkedPropertyName { get; } Property Value Type Description String | Improve this Doc View Source LinkedType Linked type full name Declaration string LinkedType { get; } Property Value Type Description String | Improve this Doc View Source PropertyName Declaration string PropertyName { get; } Property Value Type Description String Extension Methods SerializationExtensions.ToXml<T>(T) CollectionsExtensions.SetValue<TKey, T>(TKey, T) CollectionsExtensions.AsEnum<T>(T) DataObjectQueryableExtensions.CompareVariable(Object, FilterOperation, String) Processing.Do<T>(T, Action<IProcess<T>>[]) TypeExtensions.TryConvert<T, TResult>(T, Func<T, TResult>) TypeExtensions.TryConvert<T, TResult>(T, Func<T, TResult>, TResult) TypeExtensions.ChangeType<T>(Object) TypeExtensions.ChangeType(Object, Type) TypeExtensions.InvokeMethod<TRet>(Object, Type[], Expression<Func<TRet>>, BindingFlags) TypeExtensions.InvokeMethod(Object, Type[], Expression<Action>, BindingFlags) TypeExtensions.InvokeMethod<TRet>(Object, Expression<Func<TRet>>, BindingFlags) TypeExtensions.InvokeMethod(Object, Expression<Action>, BindingFlags) SqlBlockExtensions.SetExpression<TTag, TResult>(TTag, Expression<Func<IBlockQueryAdapter, TResult>>) QueryDescriptionExtensions.SetExpression<TTag, TResult>(TTag, Expression<Func<IQueryStructureAdapter, TResult>>)"
  },
  "api/XData.Database.Adapter.IDatabaseAdapter.html": {
    "href": "api/XData.Database.Adapter.IDatabaseAdapter.html",
    "title": "Interface IDatabaseAdapter | XData website",
    "keywords": "Interface IDatabaseAdapter Database adapter basic interface Inherited Members IDisposable.Dispose() Namespace : XData.Database.Adapter Assembly : XData.docfx.dll Syntax public interface IDatabaseAdapter : IDisposable Properties | Improve this Doc View Source ConnectType Database connection type Declaration string ConnectType { get; } Property Value Type Description String | Improve this Doc View Source NotSupported Dialect options not supported by adapter Declaration DialectOptions NotSupported { get; } Property Value Type Description DialectOptions Methods | Improve this Doc View Source BeginTransaction(Guid, Boolean, IsolationLevel) Begin transaction Declaration string BeginTransaction(Guid layer, bool read = false, IsolationLevel isolation = IsolationLevel.ReadCommitted) Parameters Type Name Description Guid layer Layer Boolean read Read only transaction flag IsolationLevel isolation Transaction isolation level Returns Type Description String Success flag Exceptions Type Condition XDataSqlException SQL exceptions while beginning transaction. | Improve this Doc View Source Call(Guid, StoredProcedure, CancellationToken) Execute SQL stored procedure Declaration CallResult Call(Guid layer, StoredProcedure procedure, CancellationToken token) Parameters Type Name Description Guid layer Layer StoredProcedure procedure Procedure CancellationToken token Cancellation token Returns Type Description CallResult Call result Exceptions Type Condition XDataSqlException wrong SQL stored procedure | Improve this Doc View Source Close(Guid) Close database adapter Declaration void Close(Guid layer) Parameters Type Name Description Guid layer Layer Exceptions Type Condition XDataSqlException SQL exceptions while closing connection | Improve this Doc View Source Commit(Guid, String) Commit transaction Declaration bool Commit(Guid layer, string transactionId) Parameters Type Name Description Guid layer Layer String transactionId Transaction id Returns Type Description Boolean Success flag | Improve this Doc View Source ExecuteNonQuery(Guid, Enum, Object[]) Execute SQL statement Declaration QueryResult ExecuteNonQuery(Guid layer, Enum queryIndex, params object[] paramValues) Parameters Type Name Description Guid layer Layer Enum queryIndex Predefined query index Object [] paramValues Query parameters Returns Type Description QueryResult Query result Exceptions Type Condition XDataSqlException wrong SQL query parameters | Improve this Doc View Source ExecuteNonQuery(Guid, Query) Execute SQL statement Declaration QueryResult ExecuteNonQuery(Guid layer, Query query) Parameters Type Name Description Guid layer Layer Query query Query Returns Type Description QueryResult Query result Exceptions Type Condition XDataSqlException wrong SQL query | Improve this Doc View Source ExecuteScalar(Guid, Enum, Object[]) Retrieve scalar value Declaration object ExecuteScalar(Guid layer, Enum queryIndex, params object[] paramValues) Parameters Type Name Description Guid layer Layer Enum queryIndex Predefined query index Object [] paramValues Query parameters Returns Type Description Object Object Exceptions Type Condition XDataSqlException wrong SQL query parameters | Improve this Doc View Source ExecuteScalar(Guid, Query) Retrieve scalar value Declaration object ExecuteScalar(Guid layer, Query query) Parameters Type Name Description Guid layer Layer Query query Query Returns Type Description Object Object Exceptions Type Condition XDataSqlException wrong SQL query | Improve this Doc View Source FillTable(Guid, Enum, CommandBehavior, Object[]) Fill data table Declaration DataTable FillTable(Guid layer, Enum queryIndex, CommandBehavior behavior, params object[] paramValues) Parameters Type Name Description Guid layer Layer Enum queryIndex Predefined query index CommandBehavior behavior Command behavior Object [] paramValues Query parameters Returns Type Description DataTable Data table Exceptions Type Condition XDataSqlException wrong SQL query parameters | Improve this Doc View Source FillTable(Guid, Enum, Object[]) Fill data table Declaration DataTable FillTable(Guid layer, Enum queryIndex, params object[] paramValues) Parameters Type Name Description Guid layer Layer Enum queryIndex Predefined query index Object [] paramValues Query parameters Returns Type Description DataTable Data table Exceptions Type Condition XDataSqlException wrong SQL query parameters | Improve this Doc View Source FillTable(Guid, Query, CancellationToken, CommandBehavior) Fill data table Declaration DataTable FillTable(Guid layer, Query query, CancellationToken token, CommandBehavior behavior = CommandBehavior.Default) Parameters Type Name Description Guid layer Layer Query query Query CancellationToken token Cancellation token CommandBehavior behavior Command behavior Returns Type Description DataTable Data table Exceptions Type Condition XDataSqlException wrong SQL query | Improve this Doc View Source GetParameterValue(QueryParam) Read parameter value Declaration object GetParameterValue(QueryParam parameter) Parameters Type Name Description QueryParam parameter Parameter Returns Type Description Object Parameter value | Improve this Doc View Source GetParameterValue<T>(QueryParam) Read parameter value Declaration T GetParameterValue<T>(QueryParam parameter) Parameters Type Name Description QueryParam parameter Parameter Returns Type Description T Parameter value Type Parameters Name Description T | Improve this Doc View Source GetTableFieldInfo(Guid, String) Returns table structure Declaration ReadOnlyCollection<FieldInfo> GetTableFieldInfo(Guid layer, string table) Parameters Type Name Description Guid layer Layer String table Table name Returns Type Description ReadOnlyCollection < FieldInfo > List of fields | Improve this Doc View Source GetTablesInfo(Guid) Returns table list Declaration ReadOnlyCollection<TableInfo> GetTablesInfo(Guid layer) Parameters Type Name Description Guid layer Layer Returns Type Description ReadOnlyCollection < TableInfo > List of table | Improve this Doc View Source Init(ISqlBuilder, String, String, IConfiguration) Initialization routine Declaration void Init(ISqlBuilder dialectAdapter, string context, string connectionString, IConfiguration config) Parameters Type Name Description ISqlBuilder dialectAdapter SQL dialect adapter String context Context name String connectionString Connection string IConfiguration config Adapter configuration | Improve this Doc View Source InTransaction(Guid) Transaction context flag Declaration bool InTransaction(Guid layer) Parameters Type Name Description Guid layer Layer Returns Type Description Boolean | Improve this Doc View Source IsOpen(Guid) Check adapter connection is open Declaration bool IsOpen(Guid layer) Parameters Type Name Description Guid layer Layer Returns Type Description Boolean | Improve this Doc View Source Rollback(Guid, String) Rollback transaction Declaration bool Rollback(Guid layer, string transactionId) Parameters Type Name Description Guid layer Layer String transactionId Transaction id Returns Type Description Boolean Success flag | Improve this Doc View Source SafeConvert<T>(Object) Safe convert data Declaration T SafeConvert<T>(object data) Parameters Type Name Description Object data Data to convert Returns Type Description T Converted data Type Parameters Name Description T Result type | Improve this Doc View Source SelectParameterValue<T>(QueryParam) Iterate user data type (UDT) valued table/array parameter value Declaration IEnumerable<T> SelectParameterValue<T>(QueryParam parameter) Parameters Type Name Description QueryParam parameter Parameter Returns Type Description IEnumerable <T> Parameter value Type Parameters Name Description T | Improve this Doc View Source Test(Guid, Query) Test query Declaration void Test(Guid layer, Query query) Parameters Type Name Description Guid layer Layer Query query Query Extension Methods SerializationExtensions.ToXml<T>(T) CollectionsExtensions.SetValue<TKey, T>(TKey, T) CollectionsExtensions.AsEnum<T>(T) DataObjectQueryableExtensions.CompareVariable(Object, FilterOperation, String) Processing.Do<T>(T, Action<IProcess<T>>[]) TypeExtensions.TryConvert<T, TResult>(T, Func<T, TResult>) TypeExtensions.TryConvert<T, TResult>(T, Func<T, TResult>, TResult) TypeExtensions.ChangeType<T>(Object) TypeExtensions.ChangeType(Object, Type) TypeExtensions.InvokeMethod<TRet>(Object, Type[], Expression<Func<TRet>>, BindingFlags) TypeExtensions.InvokeMethod(Object, Type[], Expression<Action>, BindingFlags) TypeExtensions.InvokeMethod<TRet>(Object, Expression<Func<TRet>>, BindingFlags) TypeExtensions.InvokeMethod(Object, Expression<Action>, BindingFlags) SqlBlockExtensions.SetExpression<TTag, TResult>(TTag, Expression<Func<IBlockQueryAdapter, TResult>>) QueryDescriptionExtensions.SetExpression<TTag, TResult>(TTag, Expression<Func<IQueryStructureAdapter, TResult>>)"
  },
  "api/XData.Mapping.ColumnExpressionAttribute.html": {
    "href": "api/XData.Mapping.ColumnExpressionAttribute.html",
    "title": "Class ColumnExpressionAttribute | XData website",
    "keywords": "Class ColumnExpressionAttribute Column expression attribute Inheritance Object Attribute ColumnExpressionAttribute Inherited Members Attribute.Equals(Object) Attribute.GetCustomAttribute(Assembly, Type) Attribute.GetCustomAttribute(Assembly, Type, Boolean) Attribute.GetCustomAttribute(MemberInfo, Type) Attribute.GetCustomAttribute(MemberInfo, Type, Boolean) Attribute.GetCustomAttribute(Module, Type) Attribute.GetCustomAttribute(Module, Type, Boolean) Attribute.GetCustomAttribute(ParameterInfo, Type) Attribute.GetCustomAttribute(ParameterInfo, Type, Boolean) Attribute.GetCustomAttributes(Assembly) Attribute.GetCustomAttributes(Assembly, Boolean) Attribute.GetCustomAttributes(Assembly, Type) Attribute.GetCustomAttributes(Assembly, Type, Boolean) Attribute.GetCustomAttributes(MemberInfo) Attribute.GetCustomAttributes(MemberInfo, Boolean) Attribute.GetCustomAttributes(MemberInfo, Type) Attribute.GetCustomAttributes(MemberInfo, Type, Boolean) Attribute.GetCustomAttributes(Module) Attribute.GetCustomAttributes(Module, Boolean) Attribute.GetCustomAttributes(Module, Type) Attribute.GetCustomAttributes(Module, Type, Boolean) Attribute.GetCustomAttributes(ParameterInfo) Attribute.GetCustomAttributes(ParameterInfo, Boolean) Attribute.GetCustomAttributes(ParameterInfo, Type) Attribute.GetCustomAttributes(ParameterInfo, Type, Boolean) Attribute.GetHashCode() Attribute.IsDefaultAttribute() Attribute.IsDefined(Assembly, Type) Attribute.IsDefined(Assembly, Type, Boolean) Attribute.IsDefined(MemberInfo, Type) Attribute.IsDefined(MemberInfo, Type, Boolean) Attribute.IsDefined(Module, Type) Attribute.IsDefined(Module, Type, Boolean) Attribute.IsDefined(ParameterInfo, Type) Attribute.IsDefined(ParameterInfo, Type, Boolean) Attribute.Match(Object) Object.Equals(Object, Object) Object.GetType() Object.MemberwiseClone() Object.ReferenceEquals(Object, Object) Object.ToString() Namespace : XData.Mapping Assembly : XData.docfx.dll Syntax [AttributeUsage(AttributeTargets.Class, AllowMultiple = true)] public sealed class ColumnExpressionAttribute : Attribute Remarks Used when ColumnAttribute value is expression ( PlainSql or SubQuery ) according ExprType Constructors | Improve this Doc View Source ColumnExpressionAttribute(String, String, DataExpressionType, DbType) Column expression attribute Declaration public ColumnExpressionAttribute(string propertyName, string exprText, DataExpressionType exprType = DataExpressionType.PlainSql, DbType type = DbType.String) Parameters Type Name Description String propertyName Property name String exprText Expression text DataExpressionType exprType Expression type DbType type Expression DbType Exceptions Type Condition XDataRuntimeException Property name cannot be null or empty string XDataRuntimeException Expression text cannot be null or empty string Properties | Improve this Doc View Source DbType Expression DbType Declaration public DbType DbType { get; } Property Value Type Description DbType | Improve this Doc View Source Exists Exists subquery operation Declaration public ExistsOperation Exists { get; set; } Property Value Type Description ExistsOperation | Improve this Doc View Source ExprScale Expression scale Declaration public int ExprScale { get; set; } Property Value Type Description Int32 | Improve this Doc View Source ExprSize Expression size Declaration public int ExprSize { get; set; } Property Value Type Description Int32 | Improve this Doc View Source ExprText Expression text Declaration public string ExprText { get; } Property Value Type Description String Remarks PlainSql expression text is Sql expression or SqlExpressionAttribute name SubQuery expression text is Alias WARNING! Plain Sql expressions (see ExprType ) can use specific Sql dialect features! Data mapping may be not compatible with other database engines! Use SqlExpressionAttribute instead. | Improve this Doc View Source ExprType Expression type Declaration public DataExpressionType ExprType { get; } Property Value Type Description DataExpressionType Remarks WARNING! Plain Sql expressions can use specific Sql dialect features! Data mapping may be not compatible with other database engines! See Also DataExpressionType | Improve this Doc View Source PropertyName Property name Declaration public string PropertyName { get; } Property Value Type Description String See Also ColumnAttribute | Improve this Doc View Source TypeId When implemented in a derived class, gets a unique identifier for this Attribute . Declaration public override object TypeId { get; } Property Value Type Description Object An Object that is a unique identifier for the attribute. Overrides Attribute.TypeId Extension Methods SerializationExtensions.ToXml<T>(T) CollectionsExtensions.SetValue<TKey, T>(TKey, T) CollectionsExtensions.AsEnum<T>(T) DataObjectQueryableExtensions.CompareVariable(Object, FilterOperation, String) Processing.Do<T>(T, Action<IProcess<T>>[]) TypeExtensions.TryConvert<T, TResult>(T, Func<T, TResult>) TypeExtensions.TryConvert<T, TResult>(T, Func<T, TResult>, TResult) TypeExtensions.ChangeType<T>(Object) TypeExtensions.ChangeType(Object, Type) TypeExtensions.InvokeMethod<TRet>(Object, Type[], Expression<Func<TRet>>, BindingFlags) TypeExtensions.InvokeMethod(Object, Type[], Expression<Action>, BindingFlags) TypeExtensions.InvokeMethod<TRet>(Object, Expression<Func<TRet>>, BindingFlags) TypeExtensions.InvokeMethod(Object, Expression<Action>, BindingFlags) SqlBlockExtensions.SetExpression<TTag, TResult>(TTag, Expression<Func<IBlockQueryAdapter, TResult>>) QueryDescriptionExtensions.SetExpression<TTag, TResult>(TTag, Expression<Func<IQueryStructureAdapter, TResult>>)"
  },
  "api/XData.Database.Dialect.html": {
    "href": "api/XData.Database.Dialect.html",
    "title": "Namespace XData.Database.Dialect | XData website",
    "keywords": "Namespace XData.Database.Dialect Classes BaseSqlBuilder SQL builder base class ExpressionContext SQL expression context MergeMap XConnectionInfo Context connection info Enums MergeFlag SqlStringType SQL dialect specific format strings types SqlTypeSize Sql type size and scale applicable"
  },
  "api/XData.Database.DataQueries.html": {
    "href": "api/XData.Database.DataQueries.html",
    "title": "Enum DataQueries | XData website",
    "keywords": "Enum DataQueries Static adapter queries enumeration Namespace : XData.Database Assembly : XData.docfx.dll Syntax public enum DataQueries Fields Name Description SelectTableColumns Table columns predefined query SelectTableList Tables predefined query See Also SelectTableColumns SelectTableList Extension Methods SerializationExtensions.ToXml<DataQueries>() CollectionsExtensions.SetValue<DataQueries, T>(T) CollectionsExtensions.AsEnum<DataQueries>() DataObjectQueryableExtensions.CompareVariable(FilterOperation, String) Processing.Do<DataQueries>(Action<IProcess<DataQueries>>[]) TypeExtensions.ChangeType<T>() TypeExtensions.ChangeType(Type) TypeExtensions.InvokeMethod<TRet>(Type[], Expression<Func<TRet>>, BindingFlags) TypeExtensions.InvokeMethod(Type[], Expression<Action>, BindingFlags) TypeExtensions.InvokeMethod<TRet>(Expression<Func<TRet>>, BindingFlags) TypeExtensions.InvokeMethod(Expression<Action>, BindingFlags) TypeExtensions.ConvertTo<T>() TypeExtensions.EqualValue(Enum) SqlBlockExtensions.SetExpression<DataQueries, TResult>(Expression<Func<IBlockQueryAdapter, TResult>>) QueryDescriptionExtensions.SetExpression<DataQueries, TResult>(Expression<Func<IQueryStructureAdapter, TResult>>)"
  },
  "api/XData.Database.Adapter.Query.html": {
    "href": "api/XData.Database.Adapter.Query.html",
    "title": "Class Query | XData website",
    "keywords": "Class Query SQL query Inheritance Object Query Implements IEnumerable < QueryParam > IEnumerable Inherited Members Object.Equals(Object) Object.Equals(Object, Object) Object.GetHashCode() Object.GetType() Object.MemberwiseClone() Object.ReferenceEquals(Object, Object) Namespace : XData.Database.Adapter Assembly : XData.docfx.dll Syntax public sealed class Query : IEnumerable<QueryParam>, IEnumerable Constructors | Improve this Doc View Source Query(String, CommandType, QueryParam[]) Query constructor Declaration public Query(string sql, CommandType type = CommandType.Text, params QueryParam[] par) Parameters Type Name Description String sql Sql expression CommandType type Command type QueryParam [] par Parameters Properties | Improve this Doc View Source Item[Int32] Query parameters by index Declaration public QueryParam this[int i] { get; } Parameters Type Name Description Int32 i Parameter index Property Value Type Description QueryParam Query parameter | Improve this Doc View Source Item[String] Query parameters by name Declaration public QueryParam this[string name] { get; set; } Parameters Type Name Description String name Parameter name Property Value Type Description QueryParam Query parameter | Improve this Doc View Source Sql Query SQL expression Declaration public string Sql { get; } Property Value Type Description String | Improve this Doc View Source Type Query command type Declaration public CommandType Type { get; } Property Value Type Description CommandType Methods | Improve this Doc View Source GetEnumerator() Query parameters enumeration Declaration public IEnumerator<QueryParam> GetEnumerator() Returns Type Description IEnumerator < QueryParam > Query parameters enumeration | Improve this Doc View Source ToString() Returns a String that represents the current Object . Declaration public override string ToString() Returns Type Description String A String that represents the current Object . Overrides Object.ToString() Operators | Improve this Doc View Source Implicit(String to Query) Query SQL expression Declaration public static implicit operator Query(string s) Parameters Type Name Description String s Sql expression Returns Type Description Query Query Explicit Interface Implementations | Improve this Doc View Source IEnumerable.GetEnumerator() Query parameters enumeration Declaration IEnumerator IEnumerable.GetEnumerator() Returns Type Description IEnumerator Query parameters enumeration Implements System.Collections.Generic.IEnumerable<T> System.Collections.IEnumerable Extension Methods SerializationExtensions.ToXml<T>(T) CollectionsExtensions.ToSortedSet<T>(IEnumerable<T>, IComparer<T>) CollectionsExtensions.SetValue<TKey, T>(TKey, T) CollectionsExtensions.AsEnum<T>(T) DataObjectQueryableExtensions.CompareVariable(Object, FilterOperation, String) JoinedEnumerable.Inner<TElement>(IEnumerable<TElement>) JoinedEnumerable.Outer<TElement>(IEnumerable<TElement>) JoinedEnumerable.LeftOuterJoin<TOuter, TInner, TKey, TResult>(IEnumerable<TOuter>, IEnumerable<TInner>, Func<TOuter, TKey>, Func<TInner, TKey>, Func<TOuter, TInner, TResult>, IEqualityComparer<TKey>) JoinedEnumerable.RightOuterJoin<TOuter, TInner, TKey, TResult>(IEnumerable<TOuter>, IEnumerable<TInner>, Func<TOuter, TKey>, Func<TInner, TKey>, Func<TOuter, TInner, TResult>, IEqualityComparer<TKey>) JoinedEnumerable.FullOuterJoin<TOuter, TInner, TKey, TResult>(IEnumerable<TOuter>, IEnumerable<TInner>, Func<TOuter, TKey>, Func<TInner, TKey>, Func<TOuter, TInner, TResult>, IEqualityComparer<TKey>) Processing.Do<T>(T, Action<IProcess<T>>[]) TypeExtensions.TryConvert<T, TResult>(T, Func<T, TResult>) TypeExtensions.TryConvert<T, TResult>(T, Func<T, TResult>, TResult) TypeExtensions.ChangeType<T>(Object) TypeExtensions.ChangeType(Object, Type) TypeExtensions.InvokeMethod<TRet>(Object, Type[], Expression<Func<TRet>>, BindingFlags) TypeExtensions.InvokeMethod(Object, Type[], Expression<Action>, BindingFlags) TypeExtensions.InvokeMethod<TRet>(Object, Expression<Func<TRet>>, BindingFlags) TypeExtensions.InvokeMethod(Object, Expression<Action>, BindingFlags) SqlBlockExtensions.SetExpression<TTag, TResult>(TTag, Expression<Func<IBlockQueryAdapter, TResult>>) QueryDescriptionExtensions.SetExpression<TTag, TResult>(TTag, Expression<Func<IQueryStructureAdapter, TResult>>) QueryDescriptionExtensions.ToDataSet<T>(IEnumerable<T>, String, ISqlBuilder)"
  },
  "api/XData.CustomMapping-1.html": {
    "href": "api/XData.CustomMapping-1.html",
    "title": "Delegate CustomMapping<T> | XData website",
    "keywords": "Delegate CustomMapping<T> Custom mapping delegate type Namespace : XData Assembly : XData.docfx.dll Syntax public delegate IRepositoryDescription<T> CustomMapping<out T>() where T : class, ISqlObject, new(); Returns Type Description IRepositoryDescription <T> Success flag Type Parameters Name Description T Object type Extension Methods SerializationExtensions.ToXml<T>(T) CollectionsExtensions.SetValue<TKey, T>(TKey, T) CollectionsExtensions.AsEnum<T>(T) DataObjectQueryableExtensions.CompareVariable(Object, FilterOperation, String) Processing.Do<T>(T, Action<IProcess<T>>[]) TypeExtensions.TryConvert<T, TResult>(T, Func<T, TResult>) TypeExtensions.TryConvert<T, TResult>(T, Func<T, TResult>, TResult) TypeExtensions.ChangeType<T>(Object) TypeExtensions.ChangeType(Object, Type) TypeExtensions.InvokeMethod<TRet>(Object, Type[], Expression<Func<TRet>>, BindingFlags) TypeExtensions.InvokeMethod(Object, Type[], Expression<Action>, BindingFlags) TypeExtensions.InvokeMethod<TRet>(Object, Expression<Func<TRet>>, BindingFlags) TypeExtensions.InvokeMethod(Object, Expression<Action>, BindingFlags) SqlBlockExtensions.SetExpression<TTag, TResult>(TTag, Expression<Func<IBlockQueryAdapter, TResult>>) QueryDescriptionExtensions.SetExpression<TTag, TResult>(TTag, Expression<Func<IQueryStructureAdapter, TResult>>)"
  },
  "api/XData.Mapping.ResultSetAttribute.html": {
    "href": "api/XData.Mapping.ResultSetAttribute.html",
    "title": "Class ResultSetAttribute | XData website",
    "keywords": "Class ResultSetAttribute SQL stored procedure/function result set Inheritance Object Attribute ResultSetAttribute Inherited Members Attribute.Equals(Object) Attribute.GetCustomAttribute(Assembly, Type) Attribute.GetCustomAttribute(Assembly, Type, Boolean) Attribute.GetCustomAttribute(MemberInfo, Type) Attribute.GetCustomAttribute(MemberInfo, Type, Boolean) Attribute.GetCustomAttribute(Module, Type) Attribute.GetCustomAttribute(Module, Type, Boolean) Attribute.GetCustomAttribute(ParameterInfo, Type) Attribute.GetCustomAttribute(ParameterInfo, Type, Boolean) Attribute.GetCustomAttributes(Assembly) Attribute.GetCustomAttributes(Assembly, Boolean) Attribute.GetCustomAttributes(Assembly, Type) Attribute.GetCustomAttributes(Assembly, Type, Boolean) Attribute.GetCustomAttributes(MemberInfo) Attribute.GetCustomAttributes(MemberInfo, Boolean) Attribute.GetCustomAttributes(MemberInfo, Type) Attribute.GetCustomAttributes(MemberInfo, Type, Boolean) Attribute.GetCustomAttributes(Module) Attribute.GetCustomAttributes(Module, Boolean) Attribute.GetCustomAttributes(Module, Type) Attribute.GetCustomAttributes(Module, Type, Boolean) Attribute.GetCustomAttributes(ParameterInfo) Attribute.GetCustomAttributes(ParameterInfo, Boolean) Attribute.GetCustomAttributes(ParameterInfo, Type) Attribute.GetCustomAttributes(ParameterInfo, Type, Boolean) Attribute.GetHashCode() Attribute.IsDefaultAttribute() Attribute.IsDefined(Assembly, Type) Attribute.IsDefined(Assembly, Type, Boolean) Attribute.IsDefined(MemberInfo, Type) Attribute.IsDefined(MemberInfo, Type, Boolean) Attribute.IsDefined(Module, Type) Attribute.IsDefined(Module, Type, Boolean) Attribute.IsDefined(ParameterInfo, Type) Attribute.IsDefined(ParameterInfo, Type, Boolean) Attribute.Match(Object) Object.Equals(Object, Object) Object.GetType() Object.MemberwiseClone() Object.ReferenceEquals(Object, Object) Object.ToString() Namespace : XData.Mapping Assembly : XData.docfx.dll Syntax [AttributeUsage(AttributeTargets.Class, AllowMultiple = true)] public sealed class ResultSetAttribute : Attribute Remarks Result sets can be accessed by GetResultSet<T, TRes>(IRepository<T>, Expression<Func<T, IEnumerable<TRes>>>) repository method Constructors | Improve this Doc View Source ResultSetAttribute(String) Result set attribute constructor Declaration public ResultSetAttribute(string alias) Parameters Type Name Description String alias SQL procedure/function alias | Improve this Doc View Source ResultSetAttribute(String, String) Result set attribute constructor Declaration public ResultSetAttribute(string alias, string name) Parameters Type Name Description String alias SQL procedure/function alias String name Result set name Properties | Improve this Doc View Source IsDefault Result set is used to fill procedure output data object Declaration public bool IsDefault { get; set; } Property Value Type Description Boolean | Improve this Doc View Source Order Result set order Declaration public int Order { get; set; } Property Value Type Description Int32 | Improve this Doc View Source ResultType Result set mapped type Declaration public Type ResultType { get; set; } Property Value Type Description Type | Improve this Doc View Source TypeId When implemented in a derived class, gets a unique identifier for this Attribute . Declaration public override object TypeId { get; } Property Value Type Description Object An Object that is a unique identifier for the attribute. Overrides Attribute.TypeId Extension Methods SerializationExtensions.ToXml<T>(T) CollectionsExtensions.SetValue<TKey, T>(TKey, T) CollectionsExtensions.AsEnum<T>(T) DataObjectQueryableExtensions.CompareVariable(Object, FilterOperation, String) Processing.Do<T>(T, Action<IProcess<T>>[]) TypeExtensions.TryConvert<T, TResult>(T, Func<T, TResult>) TypeExtensions.TryConvert<T, TResult>(T, Func<T, TResult>, TResult) TypeExtensions.ChangeType<T>(Object) TypeExtensions.ChangeType(Object, Type) TypeExtensions.InvokeMethod<TRet>(Object, Type[], Expression<Func<TRet>>, BindingFlags) TypeExtensions.InvokeMethod(Object, Type[], Expression<Action>, BindingFlags) TypeExtensions.InvokeMethod<TRet>(Object, Expression<Func<TRet>>, BindingFlags) TypeExtensions.InvokeMethod(Object, Expression<Action>, BindingFlags) SqlBlockExtensions.SetExpression<TTag, TResult>(TTag, Expression<Func<IBlockQueryAdapter, TResult>>) QueryDescriptionExtensions.SetExpression<TTag, TResult>(TTag, Expression<Func<IQueryStructureAdapter, TResult>>)"
  },
  "api/XData.Mapping.ReferenceAttribute.html": {
    "href": "api/XData.Mapping.ReferenceAttribute.html",
    "title": "Class ReferenceAttribute | XData website",
    "keywords": "Class ReferenceAttribute Data object referenced inner view property attribute Inheritance Object Attribute PropertyBaseAttribute ReferenceAttribute Inherited Members PropertyBaseAttribute.Source PropertyBaseAttribute.Flags PropertyBaseAttribute.NativeSqlType PropertyBaseAttribute.OrderBy PropertyBaseAttribute.OrderByDesc Attribute.Equals(Object) Attribute.GetCustomAttribute(Assembly, Type) Attribute.GetCustomAttribute(Assembly, Type, Boolean) Attribute.GetCustomAttribute(MemberInfo, Type) Attribute.GetCustomAttribute(MemberInfo, Type, Boolean) Attribute.GetCustomAttribute(Module, Type) Attribute.GetCustomAttribute(Module, Type, Boolean) Attribute.GetCustomAttribute(ParameterInfo, Type) Attribute.GetCustomAttribute(ParameterInfo, Type, Boolean) Attribute.GetCustomAttributes(Assembly) Attribute.GetCustomAttributes(Assembly, Boolean) Attribute.GetCustomAttributes(Assembly, Type) Attribute.GetCustomAttributes(Assembly, Type, Boolean) Attribute.GetCustomAttributes(MemberInfo) Attribute.GetCustomAttributes(MemberInfo, Boolean) Attribute.GetCustomAttributes(MemberInfo, Type) Attribute.GetCustomAttributes(MemberInfo, Type, Boolean) Attribute.GetCustomAttributes(Module) Attribute.GetCustomAttributes(Module, Boolean) Attribute.GetCustomAttributes(Module, Type) Attribute.GetCustomAttributes(Module, Type, Boolean) Attribute.GetCustomAttributes(ParameterInfo) Attribute.GetCustomAttributes(ParameterInfo, Boolean) Attribute.GetCustomAttributes(ParameterInfo, Type) Attribute.GetCustomAttributes(ParameterInfo, Type, Boolean) Attribute.GetHashCode() Attribute.IsDefaultAttribute() Attribute.IsDefined(Assembly, Type) Attribute.IsDefined(Assembly, Type, Boolean) Attribute.IsDefined(MemberInfo, Type) Attribute.IsDefined(MemberInfo, Type, Boolean) Attribute.IsDefined(Module, Type) Attribute.IsDefined(Module, Type, Boolean) Attribute.IsDefined(ParameterInfo, Type) Attribute.IsDefined(ParameterInfo, Type, Boolean) Attribute.Match(Object) Attribute.TypeId Object.Equals(Object, Object) Object.GetType() Object.MemberwiseClone() Object.ReferenceEquals(Object, Object) Object.ToString() Namespace : XData.Mapping Assembly : XData.docfx.dll Syntax [AttributeUsage(AttributeTargets.Property)] public sealed class ReferenceAttribute : PropertyBaseAttribute Remarks Used to map property to data of inner view declared PropertyAttribute or ColumnAttribute Constructors | Improve this Doc View Source ReferenceAttribute(String, String) Data object referenced inner view property attribute Declaration public ReferenceAttribute(string source, string propertyName = \"\") Parameters Type Name Description String source Source alias String propertyName Linked property name Exceptions Type Condition XDataRuntimeException Linked property name cannot be null or empty string Properties | Improve this Doc View Source IsLink Property reference flag Declaration public override bool IsLink { get; } Property Value Type Description Boolean True Overrides PropertyBaseAttribute.IsLink | Improve this Doc View Source PropertyName Referenced property (or column) name Declaration public string PropertyName { get; } Property Value Type Description String Extension Methods SerializationExtensions.ToXml<T>(T) CollectionsExtensions.SetValue<TKey, T>(TKey, T) CollectionsExtensions.AsEnum<T>(T) DataObjectQueryableExtensions.CompareVariable(Object, FilterOperation, String) Processing.Do<T>(T, Action<IProcess<T>>[]) TypeExtensions.TryConvert<T, TResult>(T, Func<T, TResult>) TypeExtensions.TryConvert<T, TResult>(T, Func<T, TResult>, TResult) TypeExtensions.ChangeType<T>(Object) TypeExtensions.ChangeType(Object, Type) TypeExtensions.InvokeMethod<TRet>(Object, Type[], Expression<Func<TRet>>, BindingFlags) TypeExtensions.InvokeMethod(Object, Type[], Expression<Action>, BindingFlags) TypeExtensions.InvokeMethod<TRet>(Object, Expression<Func<TRet>>, BindingFlags) TypeExtensions.InvokeMethod(Object, Expression<Action>, BindingFlags) SqlBlockExtensions.SetExpression<TTag, TResult>(TTag, Expression<Func<IBlockQueryAdapter, TResult>>) QueryDescriptionExtensions.SetExpression<TTag, TResult>(TTag, Expression<Func<IQueryStructureAdapter, TResult>>)"
  },
  "api/XData.Mapping.Dynamic.ISubqueryLinkAdapter-1.html": {
    "href": "api/XData.Mapping.Dynamic.ISubqueryLinkAdapter-1.html",
    "title": "Interface ISubqueryLinkAdapter<TDObj> | XData website",
    "keywords": "Interface ISubqueryLinkAdapter<TDObj> Subquery link filter description adapter Inherited Members ISubqueryLinkAdapter.SubqueryLink(String) ISubqueryLinkAdapter.SubqueryLink(String, String) IFilterAdapter.Combination(String, Combination, String) IFilterAdapter.Combination(String, Combination) Namespace : XData.Mapping.Dynamic Assembly : XData.docfx.dll Syntax public interface ISubqueryLinkAdapter<TDObj> : ISubqueryLinkAdapter, IFilterAdapter where TDObj : class Type Parameters Name Description TDObj Subquery mapped type Methods | Improve this Doc View Source SubqueryLink(Expression<Func<TDObj, Object>>) Subquery link filter description Declaration IFilterDescription SubqueryLink(Expression<Func<TDObj, object>> subqueryProperty) Parameters Type Name Description Expression < Func <TDObj, Object >> subqueryProperty Subquery property name expression to link with Returns Type Description IFilterDescription Filter description | Improve this Doc View Source SubqueryLink(Expression<Func<TDObj, Object>>, String) Subquery link filter description Declaration IFilterDescription SubqueryLink(Expression<Func<TDObj, object>> subqueryProperty, string property) Parameters Type Name Description Expression < Func <TDObj, Object >> subqueryProperty Subquery property name expression to link with String property Base query property name to link with Returns Type Description IFilterDescription Filter description Extension Methods SerializationExtensions.ToXml<T>(T) CollectionsExtensions.SetValue<TKey, T>(TKey, T) CollectionsExtensions.AsEnum<T>(T) DataObjectQueryableExtensions.CompareVariable(Object, FilterOperation, String) Processing.Do<T>(T, Action<IProcess<T>>[]) TypeExtensions.TryConvert<T, TResult>(T, Func<T, TResult>) TypeExtensions.TryConvert<T, TResult>(T, Func<T, TResult>, TResult) TypeExtensions.ChangeType<T>(Object) TypeExtensions.ChangeType(Object, Type) TypeExtensions.InvokeMethod<TRet>(Object, Type[], Expression<Func<TRet>>, BindingFlags) TypeExtensions.InvokeMethod(Object, Type[], Expression<Action>, BindingFlags) TypeExtensions.InvokeMethod<TRet>(Object, Expression<Func<TRet>>, BindingFlags) TypeExtensions.InvokeMethod(Object, Expression<Action>, BindingFlags) SqlBlockExtensions.SetExpression<TTag, TResult>(TTag, Expression<Func<IBlockQueryAdapter, TResult>>) QueryDescriptionExtensions.SetExpression<TTag, TResult>(TTag, Expression<Func<IQueryStructureAdapter, TResult>>)"
  },
  "api/XData.RepositoryAttachedHandler-1.html": {
    "href": "api/XData.RepositoryAttachedHandler-1.html",
    "title": "Class RepositoryAttachedHandler<T> | XData website",
    "keywords": "Class RepositoryAttachedHandler<T> Repository level attached handler wrapper Inheritance Object AttachedHandler <T> RepositoryAttachedHandler<T> Inherited Members AttachedHandler<T>.Type AttachedHandler<T>.Handler Object.Equals(Object) Object.Equals(Object, Object) Object.GetHashCode() Object.GetType() Object.MemberwiseClone() Object.ReferenceEquals(Object, Object) Object.ToString() Namespace : XData Assembly : XData.docfx.dll Syntax public sealed class RepositoryAttachedHandler<T> : AttachedHandler<T> where T : class, IDataObject Type Parameters Name Description T Operators | Improve this Doc View Source Explicit(RepositoryAttachedHandler<T> to ClearAttachedHandler) Explicitly unwrap clear handler Declaration public static explicit operator ClearAttachedHandler(RepositoryAttachedHandler<T> handler) Parameters Type Name Description RepositoryAttachedHandler <T> handler Wrapped handler Returns Type Description ClearAttachedHandler Unwrapped attached handler | Improve this Doc View Source Explicit(RepositoryAttachedHandler<T> to ExecuteAttachedHandler<T>) Explicitly unwrap execute handler Declaration public static explicit operator ExecuteAttachedHandler<T>(RepositoryAttachedHandler<T> handler) Parameters Type Name Description RepositoryAttachedHandler <T> handler Wrapped handler Returns Type Description ExecuteAttachedHandler <T> Unwrapped attached handler | Improve this Doc View Source Explicit(RepositoryAttachedHandler<T> to SubmitAttachedHandler<T>) Explicitly unwrap submit handler Declaration public static explicit operator SubmitAttachedHandler<T>(RepositoryAttachedHandler<T> handler) Parameters Type Name Description RepositoryAttachedHandler <T> handler Wrapped handler Returns Type Description SubmitAttachedHandler <T> Unwrapped attached handler | Improve this Doc View Source Implicit(ClearAttachedHandler to RepositoryAttachedHandler<T>) Implicitly wrap clear handler Declaration public static implicit operator RepositoryAttachedHandler<T>(ClearAttachedHandler handler) Parameters Type Name Description ClearAttachedHandler handler Clear handler Returns Type Description RepositoryAttachedHandler <T> Repository attached handler | Improve this Doc View Source Implicit(ExecuteAttachedHandler<T> to RepositoryAttachedHandler<T>) Implicitly wrap execute handler Declaration public static implicit operator RepositoryAttachedHandler<T>(ExecuteAttachedHandler<T> handler) Parameters Type Name Description ExecuteAttachedHandler <T> handler Execute handler Returns Type Description RepositoryAttachedHandler <T> Repository attached handler | Improve this Doc View Source Implicit(SubmitAttachedHandler<T> to RepositoryAttachedHandler<T>) Implicitly wrap submit handler Declaration public static implicit operator RepositoryAttachedHandler<T>(SubmitAttachedHandler<T> handler) Parameters Type Name Description SubmitAttachedHandler <T> handler Submit handler Returns Type Description RepositoryAttachedHandler <T> Repository attached handler Extension Methods SerializationExtensions.ToXml<T>(T) CollectionsExtensions.SetValue<TKey, T>(TKey, T) CollectionsExtensions.AsEnum<T>(T) DataObjectQueryableExtensions.CompareVariable(Object, FilterOperation, String) Processing.Do<T>(T, Action<IProcess<T>>[]) TypeExtensions.TryConvert<T, TResult>(T, Func<T, TResult>) TypeExtensions.TryConvert<T, TResult>(T, Func<T, TResult>, TResult) TypeExtensions.ChangeType<T>(Object) TypeExtensions.ChangeType(Object, Type) TypeExtensions.InvokeMethod<TRet>(Object, Type[], Expression<Func<TRet>>, BindingFlags) TypeExtensions.InvokeMethod(Object, Type[], Expression<Action>, BindingFlags) TypeExtensions.InvokeMethod<TRet>(Object, Expression<Func<TRet>>, BindingFlags) TypeExtensions.InvokeMethod(Object, Expression<Action>, BindingFlags) SqlBlockExtensions.SetExpression<TTag, TResult>(TTag, Expression<Func<IBlockQueryAdapter, TResult>>) QueryDescriptionExtensions.SetExpression<TTag, TResult>(TTag, Expression<Func<IQueryStructureAdapter, TResult>>)"
  },
  "api/XData.RefreshAttachedHandler-1.html": {
    "href": "api/XData.RefreshAttachedHandler-1.html",
    "title": "Delegate RefreshAttachedHandler<T> | XData website",
    "keywords": "Delegate RefreshAttachedHandler<T> Refresh attached handler delegate Namespace : XData Assembly : XData.docfx.dll Syntax public delegate bool RefreshAttachedHandler<T>(ref T obj) where T : class, IDataObject; Parameters Type Name Description T obj Object instance Returns Type Description Boolean Type Parameters Name Description T Object type Extension Methods SerializationExtensions.ToXml<T>(T) CollectionsExtensions.SetValue<TKey, T>(TKey, T) CollectionsExtensions.AsEnum<T>(T) DataObjectQueryableExtensions.CompareVariable(Object, FilterOperation, String) Processing.Do<T>(T, Action<IProcess<T>>[]) TypeExtensions.TryConvert<T, TResult>(T, Func<T, TResult>) TypeExtensions.TryConvert<T, TResult>(T, Func<T, TResult>, TResult) TypeExtensions.ChangeType<T>(Object) TypeExtensions.ChangeType(Object, Type) TypeExtensions.InvokeMethod<TRet>(Object, Type[], Expression<Func<TRet>>, BindingFlags) TypeExtensions.InvokeMethod(Object, Type[], Expression<Action>, BindingFlags) TypeExtensions.InvokeMethod<TRet>(Object, Expression<Func<TRet>>, BindingFlags) TypeExtensions.InvokeMethod(Object, Expression<Action>, BindingFlags) SqlBlockExtensions.SetExpression<TTag, TResult>(TTag, Expression<Func<IBlockQueryAdapter, TResult>>) QueryDescriptionExtensions.SetExpression<TTag, TResult>(TTag, Expression<Func<IQueryStructureAdapter, TResult>>)"
  },
  "api/XData.ProcedureType.html": {
    "href": "api/XData.ProcedureType.html",
    "title": "Enum ProcedureType | XData website",
    "keywords": "Enum ProcedureType SQL stored procedure type Namespace : XData Assembly : XData.docfx.dll Syntax public enum ProcedureType Fields Name Description Function Function Procedure Stored procedure See Also Procedure Function Extension Methods SerializationExtensions.ToXml<ProcedureType>() CollectionsExtensions.SetValue<ProcedureType, T>(T) CollectionsExtensions.AsEnum<ProcedureType>() DataObjectQueryableExtensions.CompareVariable(FilterOperation, String) Processing.Do<ProcedureType>(Action<IProcess<ProcedureType>>[]) TypeExtensions.ChangeType<T>() TypeExtensions.ChangeType(Type) TypeExtensions.InvokeMethod<TRet>(Type[], Expression<Func<TRet>>, BindingFlags) TypeExtensions.InvokeMethod(Type[], Expression<Action>, BindingFlags) TypeExtensions.InvokeMethod<TRet>(Expression<Func<TRet>>, BindingFlags) TypeExtensions.InvokeMethod(Expression<Action>, BindingFlags) TypeExtensions.ConvertTo<T>() TypeExtensions.EqualValue(Enum) SqlBlockExtensions.SetExpression<ProcedureType, TResult>(Expression<Func<IBlockQueryAdapter, TResult>>) QueryDescriptionExtensions.SetExpression<ProcedureType, TResult>(Expression<Func<IQueryStructureAdapter, TResult>>)"
  },
  "api/XData.XDataLogic-1.html": {
    "href": "api/XData.XDataLogic-1.html",
    "title": "Class XDataLogic<T> | XData website",
    "keywords": "Class XDataLogic<T> Inheritance Object XDataLogic<T> Implements IDataLogic <T> Inherited Members Object.Equals(Object) Object.Equals(Object, Object) Object.GetHashCode() Object.GetType() Object.MemberwiseClone() Object.ReferenceEquals(Object, Object) Object.ToString() Namespace : XData Assembly : XData.docfx.dll Syntax public class XDataLogic<T> : IDataLogic<T> where T : class, IDataObject, new() Type Parameters Name Description T Methods | Improve this Doc View Source BeginTransaction(Guid, String, Boolean, IsolationLevel) Declaration protected ITransaction BeginTransaction(Guid layer, string context = null, bool read = false, IsolationLevel isolation = IsolationLevel.ReadCommitted) Parameters Type Name Description Guid layer String context Boolean read IsolationLevel isolation Returns Type Description ITransaction | Improve this Doc View Source GetDictionaryValue<TDict>(Expression<Func<TDict, Boolean>>, Guid, String, String, ISecuritySession, Variable[]) Declaration protected TDict GetDictionaryValue<TDict>(Expression<Func<TDict, bool>> findExpression, Guid layer, string alias = null, string context = null, ISecuritySession security = null, params Variable[] variables) where TDict : class, IDataObject, new() Parameters Type Name Description Expression < Func <TDict, Boolean >> findExpression Guid layer String alias String context ISecuritySession security Variable [] variables Returns Type Description TDict Type Parameters Name Description TDict | Improve this Doc View Source GetRepository<TRep>(Guid, String, String, ISecuritySession, Variable[]) Declaration protected IRepository<TRep> GetRepository<TRep>(Guid layer, string alias = null, string context = null, ISecuritySession security = null, params Variable[] variables) where TRep : class, IDataObject, new() Parameters Type Name Description Guid layer String alias String context ISecuritySession security Variable [] variables Returns Type Description IRepository <TRep> Type Parameters Name Description TRep Implements IDataLogic<T> Extension Methods SerializationExtensions.ToXml<T>(T) CollectionsExtensions.SetValue<TKey, T>(TKey, T) CollectionsExtensions.AsEnum<T>(T) DataObjectQueryableExtensions.CompareVariable(Object, FilterOperation, String) Processing.Do<T>(T, Action<IProcess<T>>[]) TypeExtensions.TryConvert<T, TResult>(T, Func<T, TResult>) TypeExtensions.TryConvert<T, TResult>(T, Func<T, TResult>, TResult) TypeExtensions.ChangeType<T>(Object) TypeExtensions.ChangeType(Object, Type) TypeExtensions.InvokeMethod<TRet>(Object, Type[], Expression<Func<TRet>>, BindingFlags) TypeExtensions.InvokeMethod(Object, Type[], Expression<Action>, BindingFlags) TypeExtensions.InvokeMethod<TRet>(Object, Expression<Func<TRet>>, BindingFlags) TypeExtensions.InvokeMethod(Object, Expression<Action>, BindingFlags) SqlBlockExtensions.SetExpression<TTag, TResult>(TTag, Expression<Func<IBlockQueryAdapter, TResult>>) QueryDescriptionExtensions.SetExpression<TTag, TResult>(TTag, Expression<Func<IQueryStructureAdapter, TResult>>)"
  },
  "api/XData.Mapping.RangeFilterAttribute.html": {
    "href": "api/XData.Mapping.RangeFilterAttribute.html",
    "title": "Class RangeFilterAttribute | XData website",
    "keywords": "Class RangeFilterAttribute Data object range filter attribute Inheritance Object Attribute FilterBaseAttribute FilterAttribute RangeFilterAttribute Inherited Members FilterAttribute.Source FilterAttribute.FieldName FilterAttribute.Operation FilterAttribute.Combination Attribute.Equals(Object) Attribute.GetCustomAttribute(Assembly, Type) Attribute.GetCustomAttribute(Assembly, Type, Boolean) Attribute.GetCustomAttribute(MemberInfo, Type) Attribute.GetCustomAttribute(MemberInfo, Type, Boolean) Attribute.GetCustomAttribute(Module, Type) Attribute.GetCustomAttribute(Module, Type, Boolean) Attribute.GetCustomAttribute(ParameterInfo, Type) Attribute.GetCustomAttribute(ParameterInfo, Type, Boolean) Attribute.GetCustomAttributes(Assembly) Attribute.GetCustomAttributes(Assembly, Boolean) Attribute.GetCustomAttributes(Assembly, Type) Attribute.GetCustomAttributes(Assembly, Type, Boolean) Attribute.GetCustomAttributes(MemberInfo) Attribute.GetCustomAttributes(MemberInfo, Boolean) Attribute.GetCustomAttributes(MemberInfo, Type) Attribute.GetCustomAttributes(MemberInfo, Type, Boolean) Attribute.GetCustomAttributes(Module) Attribute.GetCustomAttributes(Module, Boolean) Attribute.GetCustomAttributes(Module, Type) Attribute.GetCustomAttributes(Module, Type, Boolean) Attribute.GetCustomAttributes(ParameterInfo) Attribute.GetCustomAttributes(ParameterInfo, Boolean) Attribute.GetCustomAttributes(ParameterInfo, Type) Attribute.GetCustomAttributes(ParameterInfo, Type, Boolean) Attribute.GetHashCode() Attribute.IsDefaultAttribute() Attribute.IsDefined(Assembly, Type) Attribute.IsDefined(Assembly, Type, Boolean) Attribute.IsDefined(MemberInfo, Type) Attribute.IsDefined(MemberInfo, Type, Boolean) Attribute.IsDefined(Module, Type) Attribute.IsDefined(Module, Type, Boolean) Attribute.IsDefined(ParameterInfo, Type) Attribute.IsDefined(ParameterInfo, Type, Boolean) Attribute.Match(Object) Object.Equals(Object, Object) Object.GetType() Object.MemberwiseClone() Object.ReferenceEquals(Object, Object) Object.ToString() Namespace : XData.Mapping Assembly : XData.docfx.dll Syntax [AttributeUsage(AttributeTargets.Class, AllowMultiple = true)] public sealed class RangeFilterAttribute : FilterAttribute Remarks Used to filter data by range of values (for example: some_field in (1, 2, 3) or some_field not in (1, 2, 3) ) Hint: Using dynamic LINQ range filters will increase code flexibility (see example). Examples var states = new List<int>(); // fill states from somewhere dataScope.GetRepository<Invoice>().Where(x => states.Contains(x.State)); Constructors | Improve this Doc View Source RangeFilterAttribute(String, String, Object[]) Range filter attribute Declaration public RangeFilterAttribute(string source, string fieldName, params object[] range) Parameters Type Name Description String source Primary source alias String fieldName Primary field name Object [] range Range values Exceptions Type Condition XDataRuntimeException Range values cannot be null or empty array Properties | Improve this Doc View Source FilterType Filter type Declaration public override FilterType FilterType { get; } Property Value Type Description FilterType Range Overrides FilterBaseAttribute.FilterType | Improve this Doc View Source Range Range values Declaration public object[] Range { get; } Property Value Type Description Object [] | Improve this Doc View Source TypeId When implemented in a derived class, gets a unique identifier for this Attribute . Declaration public override object TypeId { get; } Property Value Type Description Object An Object that is a unique identifier for the attribute. Overrides Attribute.TypeId Extension Methods SerializationExtensions.ToXml<T>(T) CollectionsExtensions.SetValue<TKey, T>(TKey, T) CollectionsExtensions.AsEnum<T>(T) DataObjectQueryableExtensions.CompareVariable(Object, FilterOperation, String) Processing.Do<T>(T, Action<IProcess<T>>[]) TypeExtensions.TryConvert<T, TResult>(T, Func<T, TResult>) TypeExtensions.TryConvert<T, TResult>(T, Func<T, TResult>, TResult) TypeExtensions.ChangeType<T>(Object) TypeExtensions.ChangeType(Object, Type) TypeExtensions.InvokeMethod<TRet>(Object, Type[], Expression<Func<TRet>>, BindingFlags) TypeExtensions.InvokeMethod(Object, Type[], Expression<Action>, BindingFlags) TypeExtensions.InvokeMethod<TRet>(Object, Expression<Func<TRet>>, BindingFlags) TypeExtensions.InvokeMethod(Object, Expression<Action>, BindingFlags) SqlBlockExtensions.SetExpression<TTag, TResult>(TTag, Expression<Func<IBlockQueryAdapter, TResult>>) QueryDescriptionExtensions.SetExpression<TTag, TResult>(TTag, Expression<Func<IQueryStructureAdapter, TResult>>)"
  },
  "api/XData.Mapping.PropertyUpdateWithAttribute.html": {
    "href": "api/XData.Mapping.PropertyUpdateWithAttribute.html",
    "title": "Class PropertyUpdateWithAttribute | XData website",
    "keywords": "Class PropertyUpdateWithAttribute Data object property update source expression attribute Inheritance Object Attribute PropertyUpdateWithAttribute Inherited Members Attribute.Equals(Object) Attribute.GetCustomAttribute(Assembly, Type) Attribute.GetCustomAttribute(Assembly, Type, Boolean) Attribute.GetCustomAttribute(MemberInfo, Type) Attribute.GetCustomAttribute(MemberInfo, Type, Boolean) Attribute.GetCustomAttribute(Module, Type) Attribute.GetCustomAttribute(Module, Type, Boolean) Attribute.GetCustomAttribute(ParameterInfo, Type) Attribute.GetCustomAttribute(ParameterInfo, Type, Boolean) Attribute.GetCustomAttributes(Assembly) Attribute.GetCustomAttributes(Assembly, Boolean) Attribute.GetCustomAttributes(Assembly, Type) Attribute.GetCustomAttributes(Assembly, Type, Boolean) Attribute.GetCustomAttributes(MemberInfo) Attribute.GetCustomAttributes(MemberInfo, Boolean) Attribute.GetCustomAttributes(MemberInfo, Type) Attribute.GetCustomAttributes(MemberInfo, Type, Boolean) Attribute.GetCustomAttributes(Module) Attribute.GetCustomAttributes(Module, Boolean) Attribute.GetCustomAttributes(Module, Type) Attribute.GetCustomAttributes(Module, Type, Boolean) Attribute.GetCustomAttributes(ParameterInfo) Attribute.GetCustomAttributes(ParameterInfo, Boolean) Attribute.GetCustomAttributes(ParameterInfo, Type) Attribute.GetCustomAttributes(ParameterInfo, Type, Boolean) Attribute.GetHashCode() Attribute.IsDefaultAttribute() Attribute.IsDefined(Assembly, Type) Attribute.IsDefined(Assembly, Type, Boolean) Attribute.IsDefined(MemberInfo, Type) Attribute.IsDefined(MemberInfo, Type, Boolean) Attribute.IsDefined(Module, Type) Attribute.IsDefined(Module, Type, Boolean) Attribute.IsDefined(ParameterInfo, Type) Attribute.IsDefined(ParameterInfo, Type, Boolean) Attribute.Match(Object) Attribute.TypeId Object.Equals(Object, Object) Object.GetType() Object.MemberwiseClone() Object.ReferenceEquals(Object, Object) Object.ToString() Namespace : XData.Mapping Assembly : XData.docfx.dll Syntax [AttributeUsage(AttributeTargets.Property)] public sealed class PropertyUpdateWithAttribute : Attribute Remarks Used when PropertyAttribute value must to be updated with expression ( PlainSql or SubQuery ) result according ExprType Constructors | Improve this Doc View Source PropertyUpdateWithAttribute(String, DataExpressionType) Data object property plain expression attribute Declaration public PropertyUpdateWithAttribute(string exprText, DataExpressionType exprType = DataExpressionType.PlainSql) Parameters Type Name Description String exprText Expression text DataExpressionType exprType Expression type Exceptions Type Condition XDataRuntimeException Expression text cannot be null or empty string Properties | Improve this Doc View Source ExprText Expression text Declaration public string ExprText { get; } Property Value Type Description String Remarks PlainSql expression text is Sql expression or SqlExpressionAttribute name SubQuery expression text is Alias WARNING! Plain Sql expressions (see ExprType ) can use specific SQL dialect features! Data mapping may be not compatible with other database engines! Use SqlExpressionAttribute instead. | Improve this Doc View Source ExprType Expression type Declaration public DataExpressionType ExprType { get; } Property Value Type Description DataExpressionType Remarks WARNING! Plain Sql expressions can use specific Sql dialect features! Data mapping may be not compatible with other database engines! Use SqlExpressionAttribute instead. See Also DataExpressionType Extension Methods SerializationExtensions.ToXml<T>(T) CollectionsExtensions.SetValue<TKey, T>(TKey, T) CollectionsExtensions.AsEnum<T>(T) DataObjectQueryableExtensions.CompareVariable(Object, FilterOperation, String) Processing.Do<T>(T, Action<IProcess<T>>[]) TypeExtensions.TryConvert<T, TResult>(T, Func<T, TResult>) TypeExtensions.TryConvert<T, TResult>(T, Func<T, TResult>, TResult) TypeExtensions.ChangeType<T>(Object) TypeExtensions.ChangeType(Object, Type) TypeExtensions.InvokeMethod<TRet>(Object, Type[], Expression<Func<TRet>>, BindingFlags) TypeExtensions.InvokeMethod(Object, Type[], Expression<Action>, BindingFlags) TypeExtensions.InvokeMethod<TRet>(Object, Expression<Func<TRet>>, BindingFlags) TypeExtensions.InvokeMethod(Object, Expression<Action>, BindingFlags) SqlBlockExtensions.SetExpression<TTag, TResult>(TTag, Expression<Func<IBlockQueryAdapter, TResult>>) QueryDescriptionExtensions.SetExpression<TTag, TResult>(TTag, Expression<Func<IQueryStructureAdapter, TResult>>)"
  },
  "api/XData.Mapping.PropertyGroupingAttribute.html": {
    "href": "api/XData.Mapping.PropertyGroupingAttribute.html",
    "title": "Class PropertyGroupingAttribute | XData website",
    "keywords": "Class PropertyGroupingAttribute Data object property grouping attribute Inheritance Object Attribute PropertyGroupingAttribute Inherited Members Attribute.Equals(Object) Attribute.GetCustomAttribute(Assembly, Type) Attribute.GetCustomAttribute(Assembly, Type, Boolean) Attribute.GetCustomAttribute(MemberInfo, Type) Attribute.GetCustomAttribute(MemberInfo, Type, Boolean) Attribute.GetCustomAttribute(Module, Type) Attribute.GetCustomAttribute(Module, Type, Boolean) Attribute.GetCustomAttribute(ParameterInfo, Type) Attribute.GetCustomAttribute(ParameterInfo, Type, Boolean) Attribute.GetCustomAttributes(Assembly) Attribute.GetCustomAttributes(Assembly, Boolean) Attribute.GetCustomAttributes(Assembly, Type) Attribute.GetCustomAttributes(Assembly, Type, Boolean) Attribute.GetCustomAttributes(MemberInfo) Attribute.GetCustomAttributes(MemberInfo, Boolean) Attribute.GetCustomAttributes(MemberInfo, Type) Attribute.GetCustomAttributes(MemberInfo, Type, Boolean) Attribute.GetCustomAttributes(Module) Attribute.GetCustomAttributes(Module, Boolean) Attribute.GetCustomAttributes(Module, Type) Attribute.GetCustomAttributes(Module, Type, Boolean) Attribute.GetCustomAttributes(ParameterInfo) Attribute.GetCustomAttributes(ParameterInfo, Boolean) Attribute.GetCustomAttributes(ParameterInfo, Type) Attribute.GetCustomAttributes(ParameterInfo, Type, Boolean) Attribute.GetHashCode() Attribute.IsDefaultAttribute() Attribute.IsDefined(Assembly, Type) Attribute.IsDefined(Assembly, Type, Boolean) Attribute.IsDefined(MemberInfo, Type) Attribute.IsDefined(MemberInfo, Type, Boolean) Attribute.IsDefined(Module, Type) Attribute.IsDefined(Module, Type, Boolean) Attribute.IsDefined(ParameterInfo, Type) Attribute.IsDefined(ParameterInfo, Type, Boolean) Attribute.Match(Object) Attribute.TypeId Object.Equals(Object, Object) Object.GetType() Object.MemberwiseClone() Object.ReferenceEquals(Object, Object) Object.ToString() Namespace : XData.Mapping Assembly : XData.docfx.dll Syntax [AttributeUsage(AttributeTargets.Property)] public sealed class PropertyGroupingAttribute : Attribute Constructors | Improve this Doc View Source PropertyGroupingAttribute() Data object property grouping attribute Declaration public PropertyGroupingAttribute() Properties | Improve this Doc View Source Grouping Property data aggregate function Declaration public DataGrouping Grouping { get; set; } Property Value Type Description DataGrouping See Also DataGrouping | Improve this Doc View Source GroupOrder Property group order Declaration public int GroupOrder { get; set; } Property Value Type Description Int32 Extension Methods SerializationExtensions.ToXml<T>(T) CollectionsExtensions.SetValue<TKey, T>(TKey, T) CollectionsExtensions.AsEnum<T>(T) DataObjectQueryableExtensions.CompareVariable(Object, FilterOperation, String) Processing.Do<T>(T, Action<IProcess<T>>[]) TypeExtensions.TryConvert<T, TResult>(T, Func<T, TResult>) TypeExtensions.TryConvert<T, TResult>(T, Func<T, TResult>, TResult) TypeExtensions.ChangeType<T>(Object) TypeExtensions.ChangeType(Object, Type) TypeExtensions.InvokeMethod<TRet>(Object, Type[], Expression<Func<TRet>>, BindingFlags) TypeExtensions.InvokeMethod(Object, Type[], Expression<Action>, BindingFlags) TypeExtensions.InvokeMethod<TRet>(Object, Expression<Func<TRet>>, BindingFlags) TypeExtensions.InvokeMethod(Object, Expression<Action>, BindingFlags) SqlBlockExtensions.SetExpression<TTag, TResult>(TTag, Expression<Func<IBlockQueryAdapter, TResult>>) QueryDescriptionExtensions.SetExpression<TTag, TResult>(TTag, Expression<Func<IQueryStructureAdapter, TResult>>) See Also DataGrouping"
  },
  "api/XData.DataSource.Structure.IConstantFilter.html": {
    "href": "api/XData.DataSource.Structure.IConstantFilter.html",
    "title": "Interface IConstantFilter | XData website",
    "keywords": "Interface IConstantFilter Constant value filter interface Inherited Members INamedFilter.Name IFilter.FilterType IFilter.SourceAlias IFilter.Field IFilter.Operation ICloneable.Clone() Namespace : XData.DataSource.Structure Assembly : XData.docfx.dll Syntax public interface IConstantFilter : INamedFilter, IFilter, ICloneable Properties | Improve this Doc View Source ConstantType Constant value type Declaration FilterConstantType ConstantType { get; } Property Value Type Description FilterConstantType | Improve this Doc View Source ConstantValue Constant value Declaration object ConstantValue { get; } Property Value Type Description Object | Improve this Doc View Source Nullable Constant value null value handling mode Declaration FilterNullable Nullable { get; } Property Value Type Description FilterNullable Extension Methods SerializationExtensions.ToXml<T>(T) CollectionsExtensions.SetValue<TKey, T>(TKey, T) CollectionsExtensions.AsEnum<T>(T) DataObjectQueryableExtensions.CompareVariable(Object, FilterOperation, String) Processing.Do<T>(T, Action<IProcess<T>>[]) TypeExtensions.TryConvert<T, TResult>(T, Func<T, TResult>) TypeExtensions.TryConvert<T, TResult>(T, Func<T, TResult>, TResult) TypeExtensions.ChangeType<T>(Object) TypeExtensions.ChangeType(Object, Type) TypeExtensions.InvokeMethod<TRet>(Object, Type[], Expression<Func<TRet>>, BindingFlags) TypeExtensions.InvokeMethod(Object, Type[], Expression<Action>, BindingFlags) TypeExtensions.InvokeMethod<TRet>(Object, Expression<Func<TRet>>, BindingFlags) TypeExtensions.InvokeMethod(Object, Expression<Action>, BindingFlags) SqlBlockExtensions.SetExpression<TTag, TResult>(TTag, Expression<Func<IBlockQueryAdapter, TResult>>) QueryDescriptionExtensions.SetExpression<TTag, TResult>(TTag, Expression<Func<IQueryStructureAdapter, TResult>>)"
  },
  "api/XData.Database.SqlBlock.html": {
    "href": "api/XData.Database.SqlBlock.html",
    "title": "Namespace XData.Database.SqlBlock | XData website",
    "keywords": "Namespace XData.Database.SqlBlock Classes SqlBlockExtensions Sql block extensions SqlType SQL block variable/constant/parameter type description Interfaces IBlockQueryAdapter SQL block query structure adapter IBlockQueryDescription Base SQL block query description interface IBlockQueryDescription<T> SQL block query description interface IBlockQueryStructure SQL block query structure interface IExpressionMergeAdapter Expression structure adapter for SQL block queries ILoopVariableAdapter<T> Loop variables mapping adapter IMergeAttributeAdapter Merge role structure adapter IMergeBlockAdapter Merge mapping adapter IPropertyMergeAdapter Dynamic structure adapter for SQL block queries ISetBlockAdapter Set/Insert block query adapter ISetSqlVarAdapter SQL variable assignment adapter ISqlBlock SQL block definition interface ISqlBlockAdapter SQL block adapter ISqlBlockAdapter<T> Adapter of SQL block returning data ISqlParam SQL block parameter interface ISqlParamAdapter Adapter to describe SQL block parameters ISqlTableAdapter ISqlValue Base SQL block value description ISqlValue<T> Typed SQL value ISqlValueAdapter SQL value description adapter ISqlVarAdapter SQL variable value adapter ISqlVariable SQL variable description Delegates SqlBlockDefinition SQL block definition expression type SqlBlockDefinition<T> SQL block definition expression type"
  },
  "api/XData.Database.SqlBlock.SqlType.html": {
    "href": "api/XData.Database.SqlBlock.SqlType.html",
    "title": "Class SqlType | XData website",
    "keywords": "Class SqlType SQL block variable/constant/parameter type description Inheritance Object SqlType Inherited Members Object.Equals(Object) Object.Equals(Object, Object) Object.GetHashCode() Object.GetType() Object.MemberwiseClone() Object.ReferenceEquals(Object, Object) Object.ToString() Namespace : XData.Database.SqlBlock Assembly : XData.docfx.dll Syntax public class SqlType Properties | Improve this Doc View Source DbType Database type Declaration public DbType DbType { get; set; } Property Value Type Description DbType | Improve this Doc View Source Length Value type length Declaration public int Length { get; set; } Property Value Type Description Int32 | Improve this Doc View Source NativeSqlType Value type native name Declaration public string NativeSqlType { get; set; } Property Value Type Description String | Improve this Doc View Source Scale Value type scale Declaration public int Scale { get; set; } Property Value Type Description Int32 Extension Methods SerializationExtensions.ToXml<T>(T) CollectionsExtensions.SetValue<TKey, T>(TKey, T) CollectionsExtensions.AsEnum<T>(T) DataObjectQueryableExtensions.CompareVariable(Object, FilterOperation, String) Processing.Do<T>(T, Action<IProcess<T>>[]) TypeExtensions.TryConvert<T, TResult>(T, Func<T, TResult>) TypeExtensions.TryConvert<T, TResult>(T, Func<T, TResult>, TResult) TypeExtensions.ChangeType<T>(Object) TypeExtensions.ChangeType(Object, Type) TypeExtensions.InvokeMethod<TRet>(Object, Type[], Expression<Func<TRet>>, BindingFlags) TypeExtensions.InvokeMethod(Object, Type[], Expression<Action>, BindingFlags) TypeExtensions.InvokeMethod<TRet>(Object, Expression<Func<TRet>>, BindingFlags) TypeExtensions.InvokeMethod(Object, Expression<Action>, BindingFlags) SqlBlockExtensions.SetExpression<TTag, TResult>(TTag, Expression<Func<IBlockQueryAdapter, TResult>>) QueryDescriptionExtensions.SetExpression<TTag, TResult>(TTag, Expression<Func<IQueryStructureAdapter, TResult>>)"
  },
  "api/XData.Database.SqlBlock.ISqlTableAdapter.html": {
    "href": "api/XData.Database.SqlBlock.ISqlTableAdapter.html",
    "title": "Interface ISqlTableAdapter | XData website",
    "keywords": "Interface ISqlTableAdapter Namespace : XData.Database.SqlBlock Assembly : XData.docfx.dll Syntax public interface ISqlTableAdapter Methods | Improve this Doc View Source Field(String, DbType) Declaration void Field(string fieldName, DbType dbType) Parameters Type Name Description String fieldName DbType dbType | Improve this Doc View Source Field(String, DbType, Int32) Declaration void Field(string fieldName, DbType dbType, int length) Parameters Type Name Description String fieldName DbType dbType Int32 length | Improve this Doc View Source Field(String, String) Declaration void Field(string fieldName, string nativeSqlType) Parameters Type Name Description String fieldName String nativeSqlType | Improve this Doc View Source Field(String, String, Int32) Declaration void Field(string fieldName, string nativeSqlType, int length) Parameters Type Name Description String fieldName String nativeSqlType Int32 length | Improve this Doc View Source Field(String, SqlType) Declaration void Field(string fieldName, SqlType sqlType) Parameters Type Name Description String fieldName SqlType sqlType Extension Methods SerializationExtensions.ToXml<T>(T) CollectionsExtensions.SetValue<TKey, T>(TKey, T) CollectionsExtensions.AsEnum<T>(T) DataObjectQueryableExtensions.CompareVariable(Object, FilterOperation, String) Processing.Do<T>(T, Action<IProcess<T>>[]) TypeExtensions.TryConvert<T, TResult>(T, Func<T, TResult>) TypeExtensions.TryConvert<T, TResult>(T, Func<T, TResult>, TResult) TypeExtensions.ChangeType<T>(Object) TypeExtensions.ChangeType(Object, Type) TypeExtensions.InvokeMethod<TRet>(Object, Type[], Expression<Func<TRet>>, BindingFlags) TypeExtensions.InvokeMethod(Object, Type[], Expression<Action>, BindingFlags) TypeExtensions.InvokeMethod<TRet>(Object, Expression<Func<TRet>>, BindingFlags) TypeExtensions.InvokeMethod(Object, Expression<Action>, BindingFlags) SqlBlockExtensions.SetExpression<TTag, TResult>(TTag, Expression<Func<IBlockQueryAdapter, TResult>>) QueryDescriptionExtensions.SetExpression<TTag, TResult>(TTag, Expression<Func<IQueryStructureAdapter, TResult>>)"
  },
  "api/XData.SerializedData.html": {
    "href": "api/XData.SerializedData.html",
    "title": "Class SerializedData | XData website",
    "keywords": "Class SerializedData Serialized data Inheritance Object SerializedData Inherited Members Object.Equals(Object) Object.Equals(Object, Object) Object.GetHashCode() Object.GetType() Object.MemberwiseClone() Object.ReferenceEquals(Object, Object) Namespace : XData Assembly : XData.docfx.dll Syntax [DataContract] [Serializable] public class SerializedData Constructors | Improve this Doc View Source SerializedData(IRepository, IDataObject) Serialized data constructor Declaration public SerializedData(IRepository repository, IDataObject obj) Parameters Type Name Description IRepository repository Repository IDataObject obj Data object to serialize Properties | Improve this Doc View Source Data Serialized data Declaration [DataMember] public SerializedValue[] Data { get; set; } Property Value Type Description SerializedValue [] | Improve this Doc View Source ObjectType Object type Declaration [DataMember] public string ObjectType { get; } Property Value Type Description String | Improve this Doc View Source State DataObject state Declaration [DataMember] public DataObjectState State { get; set; } Property Value Type Description DataObjectState Methods | Improve this Doc View Source GetFieldValue(Type, String) Returns field value Declaration public object GetFieldValue(Type type, string fieldName) Parameters Type Name Description Type type Field type String fieldName Field name Returns Type Description Object Field value Exceptions Type Condition XDataRuntimeException serialized data has not contains requested field. | Improve this Doc View Source HasFieldValue(String) Serialized data has field value Declaration public bool HasFieldValue(string fieldName) Parameters Type Name Description String fieldName Field name Returns Type Description Boolean Field value found | Improve this Doc View Source IsFieldNull(String) Serialized data field value is null Declaration public bool IsFieldNull(string fieldName) Parameters Type Name Description String fieldName Field name Returns Type Description Boolean Field value is null | Improve this Doc View Source ToString() Returns a String that represents the current Object . Declaration public override string ToString() Returns Type Description String A String that represents the current Object . Overrides Object.ToString() Extension Methods SerializationExtensions.ToXml<T>(T) CollectionsExtensions.SetValue<TKey, T>(TKey, T) CollectionsExtensions.AsEnum<T>(T) DataObjectQueryableExtensions.CompareVariable(Object, FilterOperation, String) Processing.Do<T>(T, Action<IProcess<T>>[]) TypeExtensions.TryConvert<T, TResult>(T, Func<T, TResult>) TypeExtensions.TryConvert<T, TResult>(T, Func<T, TResult>, TResult) TypeExtensions.ChangeType<T>(Object) TypeExtensions.ChangeType(Object, Type) TypeExtensions.InvokeMethod<TRet>(Object, Type[], Expression<Func<TRet>>, BindingFlags) TypeExtensions.InvokeMethod(Object, Type[], Expression<Action>, BindingFlags) TypeExtensions.InvokeMethod<TRet>(Object, Expression<Func<TRet>>, BindingFlags) TypeExtensions.InvokeMethod(Object, Expression<Action>, BindingFlags) SqlBlockExtensions.SetExpression<TTag, TResult>(TTag, Expression<Func<IBlockQueryAdapter, TResult>>) QueryDescriptionExtensions.SetExpression<TTag, TResult>(TTag, Expression<Func<IQueryStructureAdapter, TResult>>)"
  },
  "api/XData.SerializationExtensions.html": {
    "href": "api/XData.SerializationExtensions.html",
    "title": "Class SerializationExtensions | XData website",
    "keywords": "Class SerializationExtensions Serialization extensions Inheritance Object SerializationExtensions Inherited Members Object.Equals(Object) Object.Equals(Object, Object) Object.GetHashCode() Object.GetType() Object.MemberwiseClone() Object.ReferenceEquals(Object, Object) Object.ToString() Namespace : XData Assembly : XData.docfx.dll Syntax public static class SerializationExtensions Methods | Improve this Doc View Source ObjectToXml(Object) Serialize object data to Xml Declaration public static string ObjectToXml(object source) Parameters Type Name Description Object source Object to serialize Returns Type Description String Xml string | Improve this Doc View Source ReadXml<T>(String) Deserialize helper Declaration public static T ReadXml<T>(this string source) Parameters Type Name Description String source String contained serialized object Returns Type Description T De-serialized object Type Parameters Name Description T Object type | Improve this Doc View Source Restore<T>(T, SerializedData) Set serialized data to object Declaration public static void Restore<T>(this T obj, SerializedData data) where T : class, IDataObject, new() Parameters Type Name Description T obj Data object instance SerializedData data Serialized data Type Parameters Name Description T Data object type Exceptions Type Condition XDataQueryStructureException serialized data contains not mapped properties. XDataRuntimeException serialized data is null. XDataRuntimeException serialized data have a wrong type. See Also Serialize<T>(T) Serialize<T>(IEnumerable<T>) | Improve this Doc View Source Serialize<T>(T) Get serialized data from object Declaration public static SerializedData Serialize<T>(this T obj) where T : class, IDataObject, new() Parameters Type Name Description T obj Data object instance Returns Type Description SerializedData Serialized data Type Parameters Name Description T Data object type See Also Restore<T>(T, SerializedData) | Improve this Doc View Source Serialize<T>(IEnumerable<T>) Get serialized data from objects sequence Declaration public static SerializedData[] Serialize<T>(this IEnumerable<T> objects) where T : class, IDataObject, new() Parameters Type Name Description IEnumerable <T> objects Data objects sequence Returns Type Description SerializedData [] Serialized data Type Parameters Name Description T Data object type See Also Restore<T>(T, SerializedData) | Improve this Doc View Source Serialize<T>(IDataQuery<T>, TextWriter) Serialize data query helper Declaration public static void Serialize<T>(this IDataQuery<T> query, TextWriter writer) where T : class, IDataObject, new() Parameters Type Name Description IDataQuery <T> query Query TextWriter writer Writer to serialize Type Parameters Name Description T Data object type Exceptions Type Condition XDataRuntimeException Writer is null See Also GetRepository<T>(TextReader) | Improve this Doc View Source Serialize<T>(IRepository<T>, TextWriter) Serialize repository helper Declaration public static void Serialize<T>(this IRepository<T> repository, TextWriter writer) where T : class, IDataObject, new() Parameters Type Name Description IRepository <T> repository Repository TextWriter writer Writer to serialize Type Parameters Name Description T Data object type Exceptions Type Condition XDataRuntimeException Writer is null See Also GetRepository<T>(TextReader) | Improve this Doc View Source ToXml<T>(T) Serialize helper Declaration public static string ToXml<T>(this T source) Parameters Type Name Description T source Object to serialize Returns Type Description String Serialized collection Type Parameters Name Description T Object type"
  },
  "api/XData.Mapping-2.html": {
    "href": "api/XData.Mapping-2.html",
    "title": "Delegate Mapping<TFrom, T> | XData website",
    "keywords": "Delegate Mapping<TFrom, T> Mapping logic delegate type Namespace : XData Assembly : XData.docfx.dll Syntax public delegate void Mapping<in TFrom, T>(TFrom source, ref T result) where TFrom : class where T : class, IDataObject; Parameters Type Name Description TFrom source Source object instance T result Target object instance Type Parameters Name Description TFrom Source object type T Target object type Extension Methods SerializationExtensions.ToXml<T>(T) CollectionsExtensions.SetValue<TKey, T>(TKey, T) CollectionsExtensions.AsEnum<T>(T) DataObjectQueryableExtensions.CompareVariable(Object, FilterOperation, String) Processing.Do<T>(T, Action<IProcess<T>>[]) TypeExtensions.TryConvert<T, TResult>(T, Func<T, TResult>) TypeExtensions.TryConvert<T, TResult>(T, Func<T, TResult>, TResult) TypeExtensions.ChangeType<T>(Object) TypeExtensions.ChangeType(Object, Type) TypeExtensions.InvokeMethod<TRet>(Object, Type[], Expression<Func<TRet>>, BindingFlags) TypeExtensions.InvokeMethod(Object, Type[], Expression<Action>, BindingFlags) TypeExtensions.InvokeMethod<TRet>(Object, Expression<Func<TRet>>, BindingFlags) TypeExtensions.InvokeMethod(Object, Expression<Action>, BindingFlags) SqlBlockExtensions.SetExpression<TTag, TResult>(TTag, Expression<Func<IBlockQueryAdapter, TResult>>) QueryDescriptionExtensions.SetExpression<TTag, TResult>(TTag, Expression<Func<IQueryStructureAdapter, TResult>>) See Also Add<TFrom>(IEnumerable<TFrom>, Mapping<TFrom, T>, DataSubmitFlag)"
  },
  "api/XData.Log.html": {
    "href": "api/XData.Log.html",
    "title": "Class Log | XData website",
    "keywords": "Class Log Log helper Inheritance Object Log Inherited Members Object.Equals(Object) Object.Equals(Object, Object) Object.GetHashCode() Object.GetType() Object.MemberwiseClone() Object.ReferenceEquals(Object, Object) Object.ToString() Namespace : XData Assembly : XData.docfx.dll Syntax public static class Log Methods | Improve this Doc View Source Write(MessageType, Func<String>, Func<AdditionalInfo>[]) Write message to log Declaration public static void Write(MessageType msgType, Func<string> getMsgText, params Func<AdditionalInfo>[] getInfo) Parameters Type Name Description MessageType msgType Message type Func < String > getMsgText Get message text handler Func < AdditionalInfo >[] getInfo Get additional information handlers"
  },
  "api/XData.Database.TableInfo.html": {
    "href": "api/XData.Database.TableInfo.html",
    "title": "Class TableInfo | XData website",
    "keywords": "Class TableInfo Table information Inheritance Object TableInfo Implements IEquatable < TableInfo > ICloneable Inherited Members Object.Equals(Object) Object.Equals(Object, Object) Object.GetHashCode() Object.GetType() Object.MemberwiseClone() Object.ReferenceEquals(Object, Object) Namespace : XData.Database Assembly : XData.docfx.dll Syntax [Serializable] public class TableInfo : IEquatable<TableInfo>, ICloneable Properties | Improve this Doc View Source Fields Table fields Declaration public List<FieldInfo> Fields { get; set; } Property Value Type Description List < FieldInfo > | Improve this Doc View Source Name Table name Declaration public string Name { get; set; } Property Value Type Description String Methods | Improve this Doc View Source Clone() Creates a new object that is a copy of the current instance. Declaration public object Clone() Returns Type Description Object A new object that is a copy of this instance. | Improve this Doc View Source Equals(TableInfo) Indicates whether the current object is equal to another object of the same type. Declaration public virtual bool Equals(TableInfo other) Parameters Type Name Description TableInfo other An object to compare with this object. Returns Type Description Boolean true if the current object is equal to the other parameter; otherwise, false. | Improve this Doc View Source RefreshFields(String, IConfiguration) Refresh table info Declaration public TableInfo RefreshFields(string context, IConfiguration cfg = null) Parameters Type Name Description String context Context name IConfiguration cfg Configuration Returns Type Description TableInfo Refreshed table info | Improve this Doc View Source ToString() Returns a string that represents the current object. Declaration public override string ToString() Returns Type Description String A string that represents the current object. Overrides Object.ToString() Implements System.IEquatable<T> System.ICloneable Extension Methods SerializationExtensions.ToXml<T>(T) CollectionsExtensions.SetValue<TKey, T>(TKey, T) CollectionsExtensions.AsEnum<T>(T) DataObjectQueryableExtensions.CompareVariable(Object, FilterOperation, String) Processing.Do<T>(T, Action<IProcess<T>>[]) TypeExtensions.TryConvert<T, TResult>(T, Func<T, TResult>) TypeExtensions.TryConvert<T, TResult>(T, Func<T, TResult>, TResult) TypeExtensions.ChangeType<T>(Object) TypeExtensions.ChangeType(Object, Type) TypeExtensions.InvokeMethod<TRet>(Object, Type[], Expression<Func<TRet>>, BindingFlags) TypeExtensions.InvokeMethod(Object, Type[], Expression<Action>, BindingFlags) TypeExtensions.InvokeMethod<TRet>(Object, Expression<Func<TRet>>, BindingFlags) TypeExtensions.InvokeMethod(Object, Expression<Action>, BindingFlags) SqlBlockExtensions.SetExpression<TTag, TResult>(TTag, Expression<Func<IBlockQueryAdapter, TResult>>) QueryDescriptionExtensions.SetExpression<TTag, TResult>(TTag, Expression<Func<IQueryStructureAdapter, TResult>>)"
  },
  "api/XData.Database.SqlBlock.ISqlValue-1.html": {
    "href": "api/XData.Database.SqlBlock.ISqlValue-1.html",
    "title": "Interface ISqlValue<T> | XData website",
    "keywords": "Interface ISqlValue<T> Typed SQL value Namespace : XData.Database.SqlBlock Assembly : XData.docfx.dll Syntax public interface ISqlValue<T> : ISqlValue Type Parameters Name Description T Extension Methods SerializationExtensions.ToXml<T>(T) CollectionsExtensions.SetValue<TKey, T>(TKey, T) CollectionsExtensions.AsEnum<T>(T) DataObjectQueryableExtensions.CompareVariable(Object, FilterOperation, String) Processing.Do<T>(T, Action<IProcess<T>>[]) TypeExtensions.TryConvert<T, TResult>(T, Func<T, TResult>) TypeExtensions.TryConvert<T, TResult>(T, Func<T, TResult>, TResult) TypeExtensions.ChangeType<T>(Object) TypeExtensions.ChangeType(Object, Type) TypeExtensions.InvokeMethod<TRet>(Object, Type[], Expression<Func<TRet>>, BindingFlags) TypeExtensions.InvokeMethod(Object, Type[], Expression<Action>, BindingFlags) TypeExtensions.InvokeMethod<TRet>(Object, Expression<Func<TRet>>, BindingFlags) TypeExtensions.InvokeMethod(Object, Expression<Action>, BindingFlags) SqlBlockExtensions.SetExpression<TTag, TResult>(TTag, Expression<Func<IBlockQueryAdapter, TResult>>) QueryDescriptionExtensions.SetExpression<TTag, TResult>(TTag, Expression<Func<IQueryStructureAdapter, TResult>>)"
  },
  "api/XData.Mapping.ProcedureAttribute.html": {
    "href": "api/XData.Mapping.ProcedureAttribute.html",
    "title": "Class ProcedureAttribute | XData website",
    "keywords": "Class ProcedureAttribute Data object SQL procedure / function attribute Inheritance Object Attribute DataSourceAttribute ProcedureAttribute Inherited Members Attribute.Equals(Object) Attribute.GetCustomAttribute(Assembly, Type) Attribute.GetCustomAttribute(Assembly, Type, Boolean) Attribute.GetCustomAttribute(MemberInfo, Type) Attribute.GetCustomAttribute(MemberInfo, Type, Boolean) Attribute.GetCustomAttribute(Module, Type) Attribute.GetCustomAttribute(Module, Type, Boolean) Attribute.GetCustomAttribute(ParameterInfo, Type) Attribute.GetCustomAttribute(ParameterInfo, Type, Boolean) Attribute.GetCustomAttributes(Assembly) Attribute.GetCustomAttributes(Assembly, Boolean) Attribute.GetCustomAttributes(Assembly, Type) Attribute.GetCustomAttributes(Assembly, Type, Boolean) Attribute.GetCustomAttributes(MemberInfo) Attribute.GetCustomAttributes(MemberInfo, Boolean) Attribute.GetCustomAttributes(MemberInfo, Type) Attribute.GetCustomAttributes(MemberInfo, Type, Boolean) Attribute.GetCustomAttributes(Module) Attribute.GetCustomAttributes(Module, Boolean) Attribute.GetCustomAttributes(Module, Type) Attribute.GetCustomAttributes(Module, Type, Boolean) Attribute.GetCustomAttributes(ParameterInfo) Attribute.GetCustomAttributes(ParameterInfo, Boolean) Attribute.GetCustomAttributes(ParameterInfo, Type) Attribute.GetCustomAttributes(ParameterInfo, Type, Boolean) Attribute.GetHashCode() Attribute.IsDefaultAttribute() Attribute.IsDefined(Assembly, Type) Attribute.IsDefined(Assembly, Type, Boolean) Attribute.IsDefined(MemberInfo, Type) Attribute.IsDefined(MemberInfo, Type, Boolean) Attribute.IsDefined(Module, Type) Attribute.IsDefined(Module, Type, Boolean) Attribute.IsDefined(ParameterInfo, Type) Attribute.IsDefined(ParameterInfo, Type, Boolean) Attribute.Match(Object) Attribute.TypeId Object.Equals(Object, Object) Object.GetType() Object.MemberwiseClone() Object.ReferenceEquals(Object, Object) Object.ToString() Namespace : XData.Mapping Assembly : XData.docfx.dll Syntax [AttributeUsage(AttributeTargets.Class)] public sealed class ProcedureAttribute : DataSourceAttribute Examples Procedure(\"C\", \"dbo.GetCustomers\", ProcedureType.Function) Constructors | Improve this Doc View Source ProcedureAttribute(String, String, ProcedureType) Data object SQL procedure / function attribute Declaration public ProcedureAttribute(string alias, string name, ProcedureType type) Parameters Type Name Description String alias Procedure / function alias String name Procedure / function name ProcedureType type Stored procedure type Exceptions Type Condition XDataRuntimeException Procedure alias cannot be null or empty string XDataRuntimeException Procedure name cannot be null or empty string Properties | Improve this Doc View Source Alias Procedure / function alias Set procedure alias as BaseSource Hint: Alias used with table-valued functions as from-structure alias Declaration public override string Alias { get; protected set; } Property Value Type Description String Overrides DataSourceAttribute.Alias | Improve this Doc View Source Name SQL stored procedure / function name WARNING! Specify full qualified name of procedure! Declaration public string Name { get; } Property Value Type Description String | Improve this Doc View Source ProcedureType Stored procedure type Declaration public ProcedureType ProcedureType { get; } Property Value Type Description ProcedureType See Also ProcedureType | Improve this Doc View Source Type Data source type Declaration public override DataSourceType Type { get; } Property Value Type Description DataSourceType Procedure Overrides DataSourceAttribute.Type Extension Methods SerializationExtensions.ToXml<T>(T) CollectionsExtensions.SetValue<TKey, T>(TKey, T) CollectionsExtensions.AsEnum<T>(T) DataObjectQueryableExtensions.CompareVariable(Object, FilterOperation, String) Processing.Do<T>(T, Action<IProcess<T>>[]) TypeExtensions.TryConvert<T, TResult>(T, Func<T, TResult>) TypeExtensions.TryConvert<T, TResult>(T, Func<T, TResult>, TResult) TypeExtensions.ChangeType<T>(Object) TypeExtensions.ChangeType(Object, Type) TypeExtensions.InvokeMethod<TRet>(Object, Type[], Expression<Func<TRet>>, BindingFlags) TypeExtensions.InvokeMethod(Object, Type[], Expression<Action>, BindingFlags) TypeExtensions.InvokeMethod<TRet>(Object, Expression<Func<TRet>>, BindingFlags) TypeExtensions.InvokeMethod(Object, Expression<Action>, BindingFlags) SqlBlockExtensions.SetExpression<TTag, TResult>(TTag, Expression<Func<IBlockQueryAdapter, TResult>>) QueryDescriptionExtensions.SetExpression<TTag, TResult>(TTag, Expression<Func<IQueryStructureAdapter, TResult>>) See Also DataTableAttribute InnerViewAttribute SubqueryAttribute ParameterAttribute ResultSetAttribute"
  },
  "api/XData.Mapping.ColumnAttribute.html": {
    "href": "api/XData.Mapping.ColumnAttribute.html",
    "title": "Class ColumnAttribute | XData website",
    "keywords": "Class ColumnAttribute Column mapping attribute Inheritance Object Attribute ColumnAttribute Inherited Members Attribute.Equals(Object) Attribute.GetCustomAttribute(Assembly, Type) Attribute.GetCustomAttribute(Assembly, Type, Boolean) Attribute.GetCustomAttribute(MemberInfo, Type) Attribute.GetCustomAttribute(MemberInfo, Type, Boolean) Attribute.GetCustomAttribute(Module, Type) Attribute.GetCustomAttribute(Module, Type, Boolean) Attribute.GetCustomAttribute(ParameterInfo, Type) Attribute.GetCustomAttribute(ParameterInfo, Type, Boolean) Attribute.GetCustomAttributes(Assembly) Attribute.GetCustomAttributes(Assembly, Boolean) Attribute.GetCustomAttributes(Assembly, Type) Attribute.GetCustomAttributes(Assembly, Type, Boolean) Attribute.GetCustomAttributes(MemberInfo) Attribute.GetCustomAttributes(MemberInfo, Boolean) Attribute.GetCustomAttributes(MemberInfo, Type) Attribute.GetCustomAttributes(MemberInfo, Type, Boolean) Attribute.GetCustomAttributes(Module) Attribute.GetCustomAttributes(Module, Boolean) Attribute.GetCustomAttributes(Module, Type) Attribute.GetCustomAttributes(Module, Type, Boolean) Attribute.GetCustomAttributes(ParameterInfo) Attribute.GetCustomAttributes(ParameterInfo, Boolean) Attribute.GetCustomAttributes(ParameterInfo, Type) Attribute.GetCustomAttributes(ParameterInfo, Type, Boolean) Attribute.GetHashCode() Attribute.IsDefaultAttribute() Attribute.IsDefined(Assembly, Type) Attribute.IsDefined(Assembly, Type, Boolean) Attribute.IsDefined(MemberInfo, Type) Attribute.IsDefined(MemberInfo, Type, Boolean) Attribute.IsDefined(Module, Type) Attribute.IsDefined(Module, Type, Boolean) Attribute.IsDefined(ParameterInfo, Type) Attribute.IsDefined(ParameterInfo, Type, Boolean) Attribute.Match(Object) Object.Equals(Object, Object) Object.GetType() Object.MemberwiseClone() Object.ReferenceEquals(Object, Object) Object.ToString() Namespace : XData.Mapping Assembly : XData.docfx.dll Syntax [AttributeUsage(AttributeTargets.Class, AllowMultiple = true)] public sealed class ColumnAttribute : Attribute Remarks Used to map data without declaring real property This useful for declare Id , introduce \"virtual\" property for PropertyName , ChildProperty or can be used for grouping (see GroupOrder ) Constructors | Improve this Doc View Source ColumnAttribute(String, Type, String, String) Column attribute Declaration public ColumnAttribute(string propertyName, Type propertyType, string source = \"\", string fieldName = \"\") Parameters Type Name Description String propertyName Property name Type propertyType Property type String source Source alias String fieldName Field name Exceptions Type Condition XDataRuntimeException Property name cannot be null or empty string XDataRuntimeException Field name cannot be null or empty string XDataRuntimeException Property type cannot be null Properties | Improve this Doc View Source FieldName Field name Declaration public string FieldName { get; } Property Value Type Description String | Improve this Doc View Source Flags Property flags Declaration public DataPropertyFlag Flags { get; set; } Property Value Type Description DataPropertyFlag See Also DataPropertyFlag | Improve this Doc View Source Grouping Grouping mode Declaration public DataGrouping Grouping { get; set; } Property Value Type Description DataGrouping See Also DataGrouping | Improve this Doc View Source GroupOrder Grouping order Declaration public int GroupOrder { get; set; } Property Value Type Description Int32 | Improve this Doc View Source Hidden Hidden column flag Declaration public bool Hidden { get; set; } Property Value Type Description Boolean Remarks Used to exclude column from query selected columns Hidden column can be used as: PropertyName , ChildProperty or for grouping (see GroupOrder ) | Improve this Doc View Source NativeSqlType Native SQL type name Declaration public string NativeSqlType { get; set; } Property Value Type Description String Remarks Used to specify native SQL column type when conflicted with default type mapping WARNING! May be not supported by database adapter! | Improve this Doc View Source OrderBy Order by priority Declaration public int OrderBy { get; set; } Property Value Type Description Int32 | Improve this Doc View Source OrderByDesc Order by desc flag Declaration public bool OrderByDesc { get; set; } Property Value Type Description Boolean | Improve this Doc View Source PropertyName Property name Declaration public string PropertyName { get; } Property Value Type Description String | Improve this Doc View Source PropertyType Property type Declaration public Type PropertyType { get; } Property Value Type Description Type | Improve this Doc View Source Reference Referenced property name Declaration public string Reference { get; set; } Property Value Type Description String | Improve this Doc View Source ReferenceSource Referenced property source alias Declaration public string ReferenceSource { get; set; } Property Value Type Description String | Improve this Doc View Source Source Data source alias Declaration public string Source { get; } Property Value Type Description String | Improve this Doc View Source TypeId When implemented in a derived class, gets a unique identifier for this Attribute . Declaration public override object TypeId { get; } Property Value Type Description Object An Object that is a unique identifier for the attribute. Overrides Attribute.TypeId Extension Methods SerializationExtensions.ToXml<T>(T) CollectionsExtensions.SetValue<TKey, T>(TKey, T) CollectionsExtensions.AsEnum<T>(T) DataObjectQueryableExtensions.CompareVariable(Object, FilterOperation, String) Processing.Do<T>(T, Action<IProcess<T>>[]) TypeExtensions.TryConvert<T, TResult>(T, Func<T, TResult>) TypeExtensions.TryConvert<T, TResult>(T, Func<T, TResult>, TResult) TypeExtensions.ChangeType<T>(Object) TypeExtensions.ChangeType(Object, Type) TypeExtensions.InvokeMethod<TRet>(Object, Type[], Expression<Func<TRet>>, BindingFlags) TypeExtensions.InvokeMethod(Object, Type[], Expression<Action>, BindingFlags) TypeExtensions.InvokeMethod<TRet>(Object, Expression<Func<TRet>>, BindingFlags) TypeExtensions.InvokeMethod(Object, Expression<Action>, BindingFlags) SqlBlockExtensions.SetExpression<TTag, TResult>(TTag, Expression<Func<IBlockQueryAdapter, TResult>>) QueryDescriptionExtensions.SetExpression<TTag, TResult>(TTag, Expression<Func<IQueryStructureAdapter, TResult>>)"
  },
  "api/XData.Exceptions.XDataException.html": {
    "href": "api/XData.Exceptions.XDataException.html",
    "title": "Class XDataException | XData website",
    "keywords": "Class XDataException Base XData exception class Inheritance Object Exception ApplicationException XDataException XDataAdapterException XDataConcurrencyException XDataConfigurationException XDataQueryStructureException XDataRuntimeException XDataSecurityException XDataSqlException Implements ISerializable Inherited Members Exception.GetBaseException() Exception.GetObjectData(SerializationInfo, StreamingContext) Exception.GetType() Exception.ToString() Exception.Data Exception.HelpLink Exception.HResult Exception.InnerException Exception.Message Exception.Source Exception.StackTrace Exception.TargetSite Exception.SerializeObjectState Object.Equals(Object) Object.Equals(Object, Object) Object.GetHashCode() Object.MemberwiseClone() Object.ReferenceEquals(Object, Object) Namespace : XData.Exceptions Assembly : XData.docfx.dll Syntax public abstract class XDataException : ApplicationException, ISerializable Constructors | Improve this Doc View Source XDataException(String) Base XData exception class constructor Declaration protected XDataException(string message) Parameters Type Name Description String message | Improve this Doc View Source XDataException(String, Exception) Base XData exception class constructor Declaration protected XDataException(string message, Exception innerException) Parameters Type Name Description String message Exception innerException Implements System.Runtime.Serialization.ISerializable Extension Methods SerializationExtensions.ToXml<T>(T) CollectionsExtensions.SetValue<TKey, T>(TKey, T) CollectionsExtensions.AsEnum<T>(T) DataObjectQueryableExtensions.CompareVariable(Object, FilterOperation, String) Processing.Do<T>(T, Action<IProcess<T>>[]) TypeExtensions.TryConvert<T, TResult>(T, Func<T, TResult>) TypeExtensions.TryConvert<T, TResult>(T, Func<T, TResult>, TResult) TypeExtensions.ChangeType<T>(Object) TypeExtensions.ChangeType(Object, Type) TypeExtensions.InvokeMethod<TRet>(Object, Type[], Expression<Func<TRet>>, BindingFlags) TypeExtensions.InvokeMethod(Object, Type[], Expression<Action>, BindingFlags) TypeExtensions.InvokeMethod<TRet>(Object, Expression<Func<TRet>>, BindingFlags) TypeExtensions.InvokeMethod(Object, Expression<Action>, BindingFlags) SqlBlockExtensions.SetExpression<TTag, TResult>(TTag, Expression<Func<IBlockQueryAdapter, TResult>>) QueryDescriptionExtensions.SetExpression<TTag, TResult>(TTag, Expression<Func<IQueryStructureAdapter, TResult>>)"
  },
  "api/XData.ApplyFlag.html": {
    "href": "api/XData.ApplyFlag.html",
    "title": "Enum ApplyFlag | XData website",
    "keywords": "Enum ApplyFlag Apply detached object properties flags Namespace : XData Assembly : XData.docfx.dll Syntax [Flags] public enum ApplyFlag Fields Name Description AddWhenNotFound Add new entity when not found in DB CopyReadOnlyProperties Copy readonly properties Default Default apply values behavior Add a new entity to repository when keys has empty values Or try to find object in DB by key and concurrency token values and throw concurrency exception when not found Then copy all object properties to found or a new object, or properties restricted by optional properties parameter ExceptProperties Copy all properties EXCEPT listed in optional properties parameter IgnoreConcurrency Ignore concurrency token on find Extension Methods SerializationExtensions.ToXml<ApplyFlag>() CollectionsExtensions.SetValue<ApplyFlag, T>(T) CollectionsExtensions.AsEnum<ApplyFlag>() DataObjectQueryableExtensions.CompareVariable(FilterOperation, String) Processing.Do<ApplyFlag>(Action<IProcess<ApplyFlag>>[]) TypeExtensions.ChangeType<T>() TypeExtensions.ChangeType(Type) TypeExtensions.InvokeMethod<TRet>(Type[], Expression<Func<TRet>>, BindingFlags) TypeExtensions.InvokeMethod(Type[], Expression<Action>, BindingFlags) TypeExtensions.InvokeMethod<TRet>(Expression<Func<TRet>>, BindingFlags) TypeExtensions.InvokeMethod(Expression<Action>, BindingFlags) TypeExtensions.ConvertTo<T>() TypeExtensions.EqualValue(Enum) SqlBlockExtensions.SetExpression<ApplyFlag, TResult>(Expression<Func<IBlockQueryAdapter, TResult>>) QueryDescriptionExtensions.SetExpression<ApplyFlag, TResult>(Expression<Func<IQueryStructureAdapter, TResult>>)"
  },
  "api/XData.MessageType.html": {
    "href": "api/XData.MessageType.html",
    "title": "Enum MessageType | XData website",
    "keywords": "Enum MessageType Log message type Namespace : XData Assembly : XData.docfx.dll Syntax public enum MessageType Fields Name Description Debug Debug log entry Error Error log entry Information Information log entry Warning Warning log entry See Also Error Information Debug Extension Methods SerializationExtensions.ToXml<MessageType>() CollectionsExtensions.SetValue<MessageType, T>(T) CollectionsExtensions.AsEnum<MessageType>() DataObjectQueryableExtensions.CompareVariable(FilterOperation, String) Processing.Do<MessageType>(Action<IProcess<MessageType>>[]) TypeExtensions.ChangeType<T>() TypeExtensions.ChangeType(Type) TypeExtensions.InvokeMethod<TRet>(Type[], Expression<Func<TRet>>, BindingFlags) TypeExtensions.InvokeMethod(Type[], Expression<Action>, BindingFlags) TypeExtensions.InvokeMethod<TRet>(Expression<Func<TRet>>, BindingFlags) TypeExtensions.InvokeMethod(Expression<Action>, BindingFlags) TypeExtensions.ConvertTo<T>() TypeExtensions.EqualValue(Enum) SqlBlockExtensions.SetExpression<MessageType, TResult>(Expression<Func<IBlockQueryAdapter, TResult>>) QueryDescriptionExtensions.SetExpression<MessageType, TResult>(Expression<Func<IQueryStructureAdapter, TResult>>)"
  },
  "api/XData.Mapping.html": {
    "href": "api/XData.Mapping.html",
    "title": "Namespace XData.Mapping | XData website",
    "keywords": "Namespace XData.Mapping Classes ActionAttribute Data action attribute ColumnAttribute Column mapping attribute ColumnDefaultAttribute Column default value attribute ColumnExpressionAttribute Column expression attribute ColumnUpdateWithAttribute Column update source expression attribute ConstantFilterAttribute Data object constant value filter attribute DataObjectAttribute Data object metadata attribute DataSourceAttribute Base data object source attribute DataTableAttribute Data object table attribute DictionaryFilterAttribute Data object dictionary filter attribute ExpressionFilterAttribute Data object plain SQL expression filter attribute ExternalLinkAttribute Data object external link to other (child) data objects attribute FilterAttribute Base inner filter attribute FilterBaseAttribute Base filter description attribute FilterCombinationAttribute Data object filter combination (filter group) attribute HierarchyAttribute Hierarchy attribute HintAttribute HintInfo Hint description InnerViewAttribute Data object inner view attribute Link<TVal, TSrc> Dictionary link wrapper LinkAttribute Base link attribute LinkPropertyAttribute Data object link property attribute Lob Blob field wrapper OptionalFilterAttribute Base optional filter attribute ParameterAttribute SQL stored procedure/function parameter ProcedureAttribute Data object SQL procedure / function attribute PropertyAttribute Data object property attribute PropertyBaseAttribute Data property base attribute PropertyDefaultAttribute Data object property default value attribute PropertyExpressionAttribute Data object property plain expression attribute PropertyGroupingAttribute Data object property grouping attribute PropertyUpdateWithAttribute Data object property update source expression attribute RangeFilterAttribute Data object range filter attribute ReferenceAttribute Data object referenced inner view property attribute ResultSetAttribute SQL stored procedure/function result set SqlExpressionAttribute Sql expression name SubqueryAttribute Data object subquery attribute SubqueryFilterAttribute Data object subquery filter attribute SubqueryLinkAttribute Data object link to subquery attribute SubqueryVariableAttribute Data object subquery variable attribute WithAttribute Common-Table-Expression (WITH) Subquery data source WithRecursiveAttribute Common-Table-Expression (WITH) recursive subquery data source Xml Xml field wrapper Enums HintType Hint type"
  },
  "api/XData.Mapping.Xml.html": {
    "href": "api/XData.Mapping.Xml.html",
    "title": "Class Xml | XData website",
    "keywords": "Class Xml Xml field wrapper Inheritance Object Xml Inherited Members Object.Equals(Object) Object.Equals(Object, Object) Object.GetHashCode() Object.GetType() Object.MemberwiseClone() Object.ReferenceEquals(Object, Object) Object.ToString() Namespace : XData.Mapping Assembly : XData.docfx.dll Syntax public abstract class Xml Examples // declaration [Property(\"source\", \"SR\", Flags = DataPropertyFlag.OuterFlag)] public Xml Source { get; set; } // using newInvoice.Source += new XDocument(new XElement(\"invoice\", new XAttribute(\"number\", number), new XAttribute(\"state\", \"CREATED\"))); // is the same as newInvoice.Source.Document = new XDocument(new XElement(\"invoice\", new XAttribute(\"number\", number), new XAttribute(\"state\", \"CREATED\"))); Properties | Improve this Doc View Source Assigned Xml is value is changed from null value Declaration public abstract bool Assigned { get; } Property Value Type Description Boolean | Improve this Doc View Source Cleared Xml is value is cleared Declaration public abstract bool Cleared { get; } Property Value Type Description Boolean | Improve this Doc View Source Document Xml document Declaration public abstract XDocument Document { get; set; } Property Value Type Description XDocument | Improve this Doc View Source EmptyKeys Xml table keys are empty Declaration public abstract bool EmptyKeys { get; } Property Value Type Description Boolean Methods | Improve this Doc View Source Extract(String, KeyValuePair<String, String>[]) Extract value by xpath expression Declaration public abstract string Extract(string path, params KeyValuePair<string, string>[] namespaces) Parameters Type Name Description String path XPath expression KeyValuePair < String , String >[] namespaces Xml namespaces Returns Type Description String Value Operators | Improve this Doc View Source Addition(Xml, XDocument) Set Xml document Declaration public static Xml operator +(Xml xml, XDocument document) Parameters Type Name Description Xml xml Xml property XDocument document Xml document Returns Type Description Xml Updated xml property | Improve this Doc View Source Implicit(Xml to XDocument) Implicit Xml document conversion Declaration public static implicit operator XDocument(Xml xml) Parameters Type Name Description Xml xml Xml property Returns Type Description XDocument Xml document Extension Methods DataObjectExtensions.Modify(Xml, Action<XDocument>) SerializationExtensions.ToXml<T>(T) CollectionsExtensions.SetValue<TKey, T>(TKey, T) CollectionsExtensions.AsEnum<T>(T) DataObjectQueryableExtensions.CompareVariable(Object, FilterOperation, String) Processing.Do<T>(T, Action<IProcess<T>>[]) TypeExtensions.TryConvert<T, TResult>(T, Func<T, TResult>) TypeExtensions.TryConvert<T, TResult>(T, Func<T, TResult>, TResult) TypeExtensions.ChangeType<T>(Object) TypeExtensions.ChangeType(Object, Type) TypeExtensions.InvokeMethod<TRet>(Object, Type[], Expression<Func<TRet>>, BindingFlags) TypeExtensions.InvokeMethod(Object, Type[], Expression<Action>, BindingFlags) TypeExtensions.InvokeMethod<TRet>(Object, Expression<Func<TRet>>, BindingFlags) TypeExtensions.InvokeMethod(Object, Expression<Action>, BindingFlags) SqlBlockExtensions.SetExpression<TTag, TResult>(TTag, Expression<Func<IBlockQueryAdapter, TResult>>) QueryDescriptionExtensions.SetExpression<TTag, TResult>(TTag, Expression<Func<IQueryStructureAdapter, TResult>>) See Also XData.Mapping.Xml.Value Addition(Xml, XDocument) Implicit(Xml to XDocument) Modify ( Xml , Action < XDocument >) Assigned Cleared EmptyKeys Extract(String, KeyValuePair<String, String>[])"
  },
  "api/XData.Mapping.WithRecursiveAttribute.html": {
    "href": "api/XData.Mapping.WithRecursiveAttribute.html",
    "title": "Class WithRecursiveAttribute | XData website",
    "keywords": "Class WithRecursiveAttribute Common-Table-Expression (WITH) recursive subquery data source Inheritance Object Attribute WithRecursiveAttribute Inherited Members Attribute.Equals(Object) Attribute.GetCustomAttribute(Assembly, Type) Attribute.GetCustomAttribute(Assembly, Type, Boolean) Attribute.GetCustomAttribute(MemberInfo, Type) Attribute.GetCustomAttribute(MemberInfo, Type, Boolean) Attribute.GetCustomAttribute(Module, Type) Attribute.GetCustomAttribute(Module, Type, Boolean) Attribute.GetCustomAttribute(ParameterInfo, Type) Attribute.GetCustomAttribute(ParameterInfo, Type, Boolean) Attribute.GetCustomAttributes(Assembly) Attribute.GetCustomAttributes(Assembly, Boolean) Attribute.GetCustomAttributes(Assembly, Type) Attribute.GetCustomAttributes(Assembly, Type, Boolean) Attribute.GetCustomAttributes(MemberInfo) Attribute.GetCustomAttributes(MemberInfo, Boolean) Attribute.GetCustomAttributes(MemberInfo, Type) Attribute.GetCustomAttributes(MemberInfo, Type, Boolean) Attribute.GetCustomAttributes(Module) Attribute.GetCustomAttributes(Module, Boolean) Attribute.GetCustomAttributes(Module, Type) Attribute.GetCustomAttributes(Module, Type, Boolean) Attribute.GetCustomAttributes(ParameterInfo) Attribute.GetCustomAttributes(ParameterInfo, Boolean) Attribute.GetCustomAttributes(ParameterInfo, Type) Attribute.GetCustomAttributes(ParameterInfo, Type, Boolean) Attribute.GetHashCode() Attribute.IsDefaultAttribute() Attribute.IsDefined(Assembly, Type) Attribute.IsDefined(Assembly, Type, Boolean) Attribute.IsDefined(MemberInfo, Type) Attribute.IsDefined(MemberInfo, Type, Boolean) Attribute.IsDefined(Module, Type) Attribute.IsDefined(Module, Type, Boolean) Attribute.IsDefined(ParameterInfo, Type) Attribute.IsDefined(ParameterInfo, Type, Boolean) Attribute.Match(Object) Object.Equals(Object, Object) Object.GetType() Object.MemberwiseClone() Object.ReferenceEquals(Object, Object) Object.ToString() Namespace : XData.Mapping Assembly : XData.docfx.dll Syntax [AttributeUsage(AttributeTargets.Class, AllowMultiple = true)] public sealed class WithRecursiveAttribute : Attribute Constructors | Improve this Doc View Source WithRecursiveAttribute(String, Type, String) Common-Table-Expression (WITH) Subquery recursive data source constructor Declaration public WithRecursiveAttribute(string alias, Type subqueryType, string initialAlas) Parameters Type Name Description String alias Subquery alias Type subqueryType Subquery type String initialAlas Common-Table-Expression alias Properties | Improve this Doc View Source Alias Data source alias Declaration public string Alias { get; } Property Value Type Description String | Improve this Doc View Source InitialAlias Initial Common-Table-Expression (WITH) Subquery alias Declaration public string InitialAlias { get; } Property Value Type Description String | Improve this Doc View Source SubqueryType Subquery type Declaration public Type SubqueryType { get; } Property Value Type Description Type | Improve this Doc View Source TypeId When implemented in a derived class, gets a unique identifier for this Attribute . Declaration public override object TypeId { get; } Property Value Type Description Object An Object that is a unique identifier for the attribute. Overrides Attribute.TypeId Extension Methods SerializationExtensions.ToXml<T>(T) CollectionsExtensions.SetValue<TKey, T>(TKey, T) CollectionsExtensions.AsEnum<T>(T) DataObjectQueryableExtensions.CompareVariable(Object, FilterOperation, String) Processing.Do<T>(T, Action<IProcess<T>>[]) TypeExtensions.TryConvert<T, TResult>(T, Func<T, TResult>) TypeExtensions.TryConvert<T, TResult>(T, Func<T, TResult>, TResult) TypeExtensions.ChangeType<T>(Object) TypeExtensions.ChangeType(Object, Type) TypeExtensions.InvokeMethod<TRet>(Object, Type[], Expression<Func<TRet>>, BindingFlags) TypeExtensions.InvokeMethod(Object, Type[], Expression<Action>, BindingFlags) TypeExtensions.InvokeMethod<TRet>(Object, Expression<Func<TRet>>, BindingFlags) TypeExtensions.InvokeMethod(Object, Expression<Action>, BindingFlags) SqlBlockExtensions.SetExpression<TTag, TResult>(TTag, Expression<Func<IBlockQueryAdapter, TResult>>) QueryDescriptionExtensions.SetExpression<TTag, TResult>(TTag, Expression<Func<IQueryStructureAdapter, TResult>>)"
  },
  "api/XData.Mapping.FilterBaseAttribute.html": {
    "href": "api/XData.Mapping.FilterBaseAttribute.html",
    "title": "Class FilterBaseAttribute | XData website",
    "keywords": "Class FilterBaseAttribute Base filter description attribute Inheritance Object Attribute FilterBaseAttribute FilterAttribute SubqueryLinkAttribute Inherited Members Attribute.Equals(Object) Attribute.GetCustomAttribute(Assembly, Type) Attribute.GetCustomAttribute(Assembly, Type, Boolean) Attribute.GetCustomAttribute(MemberInfo, Type) Attribute.GetCustomAttribute(MemberInfo, Type, Boolean) Attribute.GetCustomAttribute(Module, Type) Attribute.GetCustomAttribute(Module, Type, Boolean) Attribute.GetCustomAttribute(ParameterInfo, Type) Attribute.GetCustomAttribute(ParameterInfo, Type, Boolean) Attribute.GetCustomAttributes(Assembly) Attribute.GetCustomAttributes(Assembly, Boolean) Attribute.GetCustomAttributes(Assembly, Type) Attribute.GetCustomAttributes(Assembly, Type, Boolean) Attribute.GetCustomAttributes(MemberInfo) Attribute.GetCustomAttributes(MemberInfo, Boolean) Attribute.GetCustomAttributes(MemberInfo, Type) Attribute.GetCustomAttributes(MemberInfo, Type, Boolean) Attribute.GetCustomAttributes(Module) Attribute.GetCustomAttributes(Module, Boolean) Attribute.GetCustomAttributes(Module, Type) Attribute.GetCustomAttributes(Module, Type, Boolean) Attribute.GetCustomAttributes(ParameterInfo) Attribute.GetCustomAttributes(ParameterInfo, Boolean) Attribute.GetCustomAttributes(ParameterInfo, Type) Attribute.GetCustomAttributes(ParameterInfo, Type, Boolean) Attribute.GetHashCode() Attribute.IsDefaultAttribute() Attribute.IsDefined(Assembly, Type) Attribute.IsDefined(Assembly, Type, Boolean) Attribute.IsDefined(MemberInfo, Type) Attribute.IsDefined(MemberInfo, Type, Boolean) Attribute.IsDefined(Module, Type) Attribute.IsDefined(Module, Type, Boolean) Attribute.IsDefined(ParameterInfo, Type) Attribute.IsDefined(ParameterInfo, Type, Boolean) Attribute.Match(Object) Attribute.TypeId Object.Equals(Object, Object) Object.GetType() Object.MemberwiseClone() Object.ReferenceEquals(Object, Object) Object.ToString() Namespace : XData.Mapping Assembly : XData.docfx.dll Syntax public abstract class FilterBaseAttribute : Attribute Properties | Improve this Doc View Source FilterType Filter type Declaration public abstract FilterType FilterType { get; } Property Value Type Description FilterType See Also FilterType Extension Methods SerializationExtensions.ToXml<T>(T) CollectionsExtensions.SetValue<TKey, T>(TKey, T) CollectionsExtensions.AsEnum<T>(T) DataObjectQueryableExtensions.CompareVariable(Object, FilterOperation, String) Processing.Do<T>(T, Action<IProcess<T>>[]) TypeExtensions.TryConvert<T, TResult>(T, Func<T, TResult>) TypeExtensions.TryConvert<T, TResult>(T, Func<T, TResult>, TResult) TypeExtensions.ChangeType<T>(Object) TypeExtensions.ChangeType(Object, Type) TypeExtensions.InvokeMethod<TRet>(Object, Type[], Expression<Func<TRet>>, BindingFlags) TypeExtensions.InvokeMethod(Object, Type[], Expression<Action>, BindingFlags) TypeExtensions.InvokeMethod<TRet>(Object, Expression<Func<TRet>>, BindingFlags) TypeExtensions.InvokeMethod(Object, Expression<Action>, BindingFlags) SqlBlockExtensions.SetExpression<TTag, TResult>(TTag, Expression<Func<IBlockQueryAdapter, TResult>>) QueryDescriptionExtensions.SetExpression<TTag, TResult>(TTag, Expression<Func<IQueryStructureAdapter, TResult>>)"
  },
  "api/XData.Mapping.FilterAttribute.html": {
    "href": "api/XData.Mapping.FilterAttribute.html",
    "title": "Class FilterAttribute | XData website",
    "keywords": "Class FilterAttribute Base inner filter attribute Inheritance Object Attribute FilterBaseAttribute FilterAttribute ConstantFilterAttribute DictionaryFilterAttribute ExpressionFilterAttribute OptionalFilterAttribute RangeFilterAttribute Inherited Members FilterBaseAttribute.FilterType Attribute.Equals(Object) Attribute.GetCustomAttribute(Assembly, Type) Attribute.GetCustomAttribute(Assembly, Type, Boolean) Attribute.GetCustomAttribute(MemberInfo, Type) Attribute.GetCustomAttribute(MemberInfo, Type, Boolean) Attribute.GetCustomAttribute(Module, Type) Attribute.GetCustomAttribute(Module, Type, Boolean) Attribute.GetCustomAttribute(ParameterInfo, Type) Attribute.GetCustomAttribute(ParameterInfo, Type, Boolean) Attribute.GetCustomAttributes(Assembly) Attribute.GetCustomAttributes(Assembly, Boolean) Attribute.GetCustomAttributes(Assembly, Type) Attribute.GetCustomAttributes(Assembly, Type, Boolean) Attribute.GetCustomAttributes(MemberInfo) Attribute.GetCustomAttributes(MemberInfo, Boolean) Attribute.GetCustomAttributes(MemberInfo, Type) Attribute.GetCustomAttributes(MemberInfo, Type, Boolean) Attribute.GetCustomAttributes(Module) Attribute.GetCustomAttributes(Module, Boolean) Attribute.GetCustomAttributes(Module, Type) Attribute.GetCustomAttributes(Module, Type, Boolean) Attribute.GetCustomAttributes(ParameterInfo) Attribute.GetCustomAttributes(ParameterInfo, Boolean) Attribute.GetCustomAttributes(ParameterInfo, Type) Attribute.GetCustomAttributes(ParameterInfo, Type, Boolean) Attribute.GetHashCode() Attribute.IsDefaultAttribute() Attribute.IsDefined(Assembly, Type) Attribute.IsDefined(Assembly, Type, Boolean) Attribute.IsDefined(MemberInfo, Type) Attribute.IsDefined(MemberInfo, Type, Boolean) Attribute.IsDefined(Module, Type) Attribute.IsDefined(Module, Type, Boolean) Attribute.IsDefined(ParameterInfo, Type) Attribute.IsDefined(ParameterInfo, Type, Boolean) Attribute.Match(Object) Attribute.TypeId Object.Equals(Object, Object) Object.GetType() Object.MemberwiseClone() Object.ReferenceEquals(Object, Object) Object.ToString() Namespace : XData.Mapping Assembly : XData.docfx.dll Syntax [AttributeUsage(AttributeTargets.Class, AllowMultiple = true)] public abstract class FilterAttribute : FilterBaseAttribute Constructors | Improve this Doc View Source FilterAttribute(String, String) Base filter attribute Declaration protected FilterAttribute(string source, string fieldName) Parameters Type Name Description String source Primary source alias String fieldName Primary field name Exceptions Type Condition XDataRuntimeException Primary source alias cannot be null or empty string XDataRuntimeException Primary field name cannot be null or empty string Properties | Improve this Doc View Source Combination Filter combination (filter group) name Declaration public string Combination { get; set; } Property Value Type Description String See Also FilterCombinationAttribute | Improve this Doc View Source FieldName Primary field name Declaration public string FieldName { get; } Property Value Type Description String | Improve this Doc View Source Operation Filter operation Declaration public FilterOperation Operation { get; set; } Property Value Type Description FilterOperation See Also FilterOperation | Improve this Doc View Source Source Primary source alias Declaration public string Source { get; } Property Value Type Description String Extension Methods SerializationExtensions.ToXml<T>(T) CollectionsExtensions.SetValue<TKey, T>(TKey, T) CollectionsExtensions.AsEnum<T>(T) DataObjectQueryableExtensions.CompareVariable(Object, FilterOperation, String) Processing.Do<T>(T, Action<IProcess<T>>[]) TypeExtensions.TryConvert<T, TResult>(T, Func<T, TResult>) TypeExtensions.TryConvert<T, TResult>(T, Func<T, TResult>, TResult) TypeExtensions.ChangeType<T>(Object) TypeExtensions.ChangeType(Object, Type) TypeExtensions.InvokeMethod<TRet>(Object, Type[], Expression<Func<TRet>>, BindingFlags) TypeExtensions.InvokeMethod(Object, Type[], Expression<Action>, BindingFlags) TypeExtensions.InvokeMethod<TRet>(Object, Expression<Func<TRet>>, BindingFlags) TypeExtensions.InvokeMethod(Object, Expression<Action>, BindingFlags) SqlBlockExtensions.SetExpression<TTag, TResult>(TTag, Expression<Func<IBlockQueryAdapter, TResult>>) QueryDescriptionExtensions.SetExpression<TTag, TResult>(TTag, Expression<Func<IQueryStructureAdapter, TResult>>) See Also FilterCombinationAttribute LinkAttribute SubqueryLinkAttribute ConstantFilterAttribute DictionaryFilterAttribute SubqueryFilterAttribute RangeFilterAttribute ExpressionFilterAttribute RuntimeFilter"
  },
  "api/XData.Mapping.ExternalLinkAttribute.html": {
    "href": "api/XData.Mapping.ExternalLinkAttribute.html",
    "title": "Class ExternalLinkAttribute | XData website",
    "keywords": "Class ExternalLinkAttribute Data object external link to other (child) data objects attribute Inheritance Object Attribute ExternalLinkAttribute Inherited Members Attribute.Equals(Object) Attribute.GetCustomAttribute(Assembly, Type) Attribute.GetCustomAttribute(Assembly, Type, Boolean) Attribute.GetCustomAttribute(MemberInfo, Type) Attribute.GetCustomAttribute(MemberInfo, Type, Boolean) Attribute.GetCustomAttribute(Module, Type) Attribute.GetCustomAttribute(Module, Type, Boolean) Attribute.GetCustomAttribute(ParameterInfo, Type) Attribute.GetCustomAttribute(ParameterInfo, Type, Boolean) Attribute.GetCustomAttributes(Assembly) Attribute.GetCustomAttributes(Assembly, Boolean) Attribute.GetCustomAttributes(Assembly, Type) Attribute.GetCustomAttributes(Assembly, Type, Boolean) Attribute.GetCustomAttributes(MemberInfo) Attribute.GetCustomAttributes(MemberInfo, Boolean) Attribute.GetCustomAttributes(MemberInfo, Type) Attribute.GetCustomAttributes(MemberInfo, Type, Boolean) Attribute.GetCustomAttributes(Module) Attribute.GetCustomAttributes(Module, Boolean) Attribute.GetCustomAttributes(Module, Type) Attribute.GetCustomAttributes(Module, Type, Boolean) Attribute.GetCustomAttributes(ParameterInfo) Attribute.GetCustomAttributes(ParameterInfo, Boolean) Attribute.GetCustomAttributes(ParameterInfo, Type) Attribute.GetCustomAttributes(ParameterInfo, Type, Boolean) Attribute.GetHashCode() Attribute.IsDefaultAttribute() Attribute.IsDefined(Assembly, Type) Attribute.IsDefined(Assembly, Type, Boolean) Attribute.IsDefined(MemberInfo, Type) Attribute.IsDefined(MemberInfo, Type, Boolean) Attribute.IsDefined(Module, Type) Attribute.IsDefined(Module, Type, Boolean) Attribute.IsDefined(ParameterInfo, Type) Attribute.IsDefined(ParameterInfo, Type, Boolean) Attribute.Match(Object) Object.Equals(Object, Object) Object.GetType() Object.MemberwiseClone() Object.ReferenceEquals(Object, Object) Object.ToString() Namespace : XData.Mapping Assembly : XData.docfx.dll Syntax [AttributeUsage(AttributeTargets.Class, AllowMultiple = true)] public sealed class ExternalLinkAttribute : Attribute Remarks Used to organize master/detail relation between repositories Constructors | Improve this Doc View Source ExternalLinkAttribute(Type, String, String, String) External link attribute Declaration public ExternalLinkAttribute(Type childType, string childProperty, string property = \"\", string filterName = \"\") Parameters Type Name Description Type childType Child data object description type String childProperty Child property to link String property Parent property contains value to link String filterName Filter name Exceptions Type Condition XDataRuntimeException Child data object description type cannot be null XDataRuntimeException Child property to link cannot be null or empty string Properties | Improve this Doc View Source ChildLinkType Child linked property type Declaration public Type ChildLinkType { get; set; } Property Value Type Description Type Remarks Used when child repository linked through subquery | Improve this Doc View Source ChildProperty Child property to link Declaration public string ChildProperty { get; } Property Value Type Description String | Improve this Doc View Source ChildType Child data object type Declaration public Type ChildType { get; } Property Value Type Description Type | Improve this Doc View Source Combination Filter combination (filter group) name Declaration public string Combination { get; set; } Property Value Type Description String See Also FilterCombinationAttribute | Improve this Doc View Source DirectLink Direct link slave to selected tree node Declaration public bool DirectLink { get; set; } Property Value Type Description Boolean Remarks Used to show/hide subtree related items in slave view when master is tree When ShowSubtree = false - slave contains selected node child items only When ShowSubtree = true - selected node and it's subtree child items Works with ShowSubtree : External links marked as DirectLink is filled while ShowSubtree is false and omitted otherwise | Improve this Doc View Source FilterName Filter name Declaration public string FilterName { get; } Property Value Type Description String Remarks If not assigned used FilterBy ChildProperty pattern | Improve this Doc View Source MasterRefresh Refresh parent object notification on child submit Declaration public bool MasterRefresh { get; set; } Property Value Type Description Boolean Remarks Used when parent object contains calculated fields over child objects | Improve this Doc View Source Nullable Filter null value handling Declaration public FilterNullable Nullable { get; set; } Property Value Type Description FilterNullable See Also FilterNullable | Improve this Doc View Source Operation Filter operation Declaration public FilterOperation Operation { get; set; } Property Value Type Description FilterOperation See Also FilterOperation | Improve this Doc View Source PrimaryFilter Primary filter flag Declaration public bool PrimaryFilter { get; set; } Property Value Type Description Boolean See Also OptionalFilterAttribute | Improve this Doc View Source PropertyName Property to link Declaration public string PropertyName { get; } Property Value Type Description String Remarks If not assigned used ChildProperty name | Improve this Doc View Source TypeId When implemented in a derived class, gets a unique identifier for this Attribute . Declaration public override object TypeId { get; } Property Value Type Description Object An Object that is a unique identifier for the attribute. Overrides Attribute.TypeId Extension Methods SerializationExtensions.ToXml<T>(T) CollectionsExtensions.SetValue<TKey, T>(TKey, T) CollectionsExtensions.AsEnum<T>(T) DataObjectQueryableExtensions.CompareVariable(Object, FilterOperation, String) Processing.Do<T>(T, Action<IProcess<T>>[]) TypeExtensions.TryConvert<T, TResult>(T, Func<T, TResult>) TypeExtensions.TryConvert<T, TResult>(T, Func<T, TResult>, TResult) TypeExtensions.ChangeType<T>(Object) TypeExtensions.ChangeType(Object, Type) TypeExtensions.InvokeMethod<TRet>(Object, Type[], Expression<Func<TRet>>, BindingFlags) TypeExtensions.InvokeMethod(Object, Type[], Expression<Action>, BindingFlags) TypeExtensions.InvokeMethod<TRet>(Object, Expression<Func<TRet>>, BindingFlags) TypeExtensions.InvokeMethod(Object, Expression<Action>, BindingFlags) SqlBlockExtensions.SetExpression<TTag, TResult>(TTag, Expression<Func<IBlockQueryAdapter, TResult>>) QueryDescriptionExtensions.SetExpression<TTag, TResult>(TTag, Expression<Func<IQueryStructureAdapter, TResult>>)"
  },
  "api/XData.DataExpressionType.html": {
    "href": "api/XData.DataExpressionType.html",
    "title": "Enum DataExpressionType | XData website",
    "keywords": "Enum DataExpressionType Expression type Namespace : XData Assembly : XData.docfx.dll Syntax [DataContract] public enum DataExpressionType Fields Name Description LinqExpression LINQ-style defined expression PlainSql Plain SQL expression SubQuery Subquery expression See Also ExprType ExprType PlainSql SubQuery Extension Methods SerializationExtensions.ToXml<DataExpressionType>() CollectionsExtensions.SetValue<DataExpressionType, T>(T) CollectionsExtensions.AsEnum<DataExpressionType>() DataObjectQueryableExtensions.CompareVariable(FilterOperation, String) Processing.Do<DataExpressionType>(Action<IProcess<DataExpressionType>>[]) TypeExtensions.ChangeType<T>() TypeExtensions.ChangeType(Type) TypeExtensions.InvokeMethod<TRet>(Type[], Expression<Func<TRet>>, BindingFlags) TypeExtensions.InvokeMethod(Type[], Expression<Action>, BindingFlags) TypeExtensions.InvokeMethod<TRet>(Expression<Func<TRet>>, BindingFlags) TypeExtensions.InvokeMethod(Expression<Action>, BindingFlags) TypeExtensions.ConvertTo<T>() TypeExtensions.EqualValue(Enum) SqlBlockExtensions.SetExpression<DataExpressionType, TResult>(Expression<Func<IBlockQueryAdapter, TResult>>) QueryDescriptionExtensions.SetExpression<DataExpressionType, TResult>(Expression<Func<IQueryStructureAdapter, TResult>>)"
  },
  "api/XData.Database.SqlBlock.ISqlValueAdapter.html": {
    "href": "api/XData.Database.SqlBlock.ISqlValueAdapter.html",
    "title": "Interface ISqlValueAdapter | XData website",
    "keywords": "Interface ISqlValueAdapter SQL value description adapter Inherited Members ISqlVarAdapter.Var<T>(String) Namespace : XData.Database.SqlBlock Assembly : XData.docfx.dll Syntax public interface ISqlValueAdapter : ISqlVarAdapter Methods | Improve this Doc View Source Const<T>(T, DbType) SQL constant value Declaration ISqlValue<T> Const<T>(T value, DbType dbType) Parameters Type Name Description T value Constant value DbType dbType Constant DbType Returns Type Description ISqlValue <T> SQL value description Type Parameters Name Description T Constant mapped type | Improve this Doc View Source Data<T>(String) Data value Declaration ISqlValue<T> Data<T>(string name) Parameters Type Name Description String name Data column or parameter name Returns Type Description ISqlValue <T> SQL value description Type Parameters Name Description T Data type | Improve this Doc View Source Default<T>(DefaultType) Default value mapping Declaration ISqlValue<T> Default<T>(DefaultType defaultType) Parameters Type Name Description DefaultType defaultType Default value type Returns Type Description ISqlValue <T> SQL value description Type Parameters Name Description T Value mapped type | Improve this Doc View Source Default<T>(DefaultType, Object) Default value mapping Declaration ISqlValue<T> Default<T>(DefaultType defaultType, object defaultValue) Parameters Type Name Description DefaultType defaultType Default value type Object defaultValue Default value Returns Type Description ISqlValue <T> SQL value description Type Parameters Name Description T Value mapped type | Improve this Doc View Source Expr<T>(Expression<Func<IBlockQueryAdapter, T>>, DbType) SQL expression mapping Declaration ISqlValue<T> Expr<T>(Expression<Func<IBlockQueryAdapter, T>> expr, DbType dbType) Parameters Type Name Description Expression < Func < IBlockQueryAdapter , T>> expr Expression DbType dbType Expression database type Returns Type Description ISqlValue <T> SQL value description Type Parameters Name Description T Value mapped type | Improve this Doc View Source Expr<T>(String, DbType) SQL expression mapping Declaration ISqlValue<T> Expr<T>(string exprText, DbType dbType) Parameters Type Name Description String exprText Expression text DbType dbType Expression database type Returns Type Description ISqlValue <T> SQL value description Type Parameters Name Description T Value mapped type | Improve this Doc View Source Field<T>(String, String) SQL field mapping Declaration ISqlValue<T> Field<T>(string alias, string fieldName) Parameters Type Name Description String alias Data source alias String fieldName Field name Returns Type Description ISqlValue <T> SQL value description Type Parameters Name Description T Value mapped type | Improve this Doc View Source Subquery<T>(Expression<Func<IBlockQueryStructure, IBlockQueryStructure>>, Expression<Func<IBlockQueryAdapter, T>>) Single column subquery as value Declaration ISqlValue<T> Subquery<T>(Expression<Func<IBlockQueryStructure, IBlockQueryStructure>> query, Expression<Func<IBlockQueryAdapter, T>> field) Parameters Type Name Description Expression < Func < IBlockQueryStructure , IBlockQueryStructure >> query Query structure Expression < Func < IBlockQueryAdapter , T>> field Result field Returns Type Description ISqlValue <T> SQL value description Type Parameters Name Description T Value mapped type | Improve this Doc View Source Subquery<T>(Expression<Func<IBlockQueryStructure, IBlockQueryStructure>>, Expression<Func<IBlockQueryAdapter, T>>, DataStructureFlag) Single column subquery as value Declaration ISqlValue<T> Subquery<T>(Expression<Func<IBlockQueryStructure, IBlockQueryStructure>> query, Expression<Func<IBlockQueryAdapter, T>> field, DataStructureFlag flag) Parameters Type Name Description Expression < Func < IBlockQueryStructure , IBlockQueryStructure >> query Query structure Expression < Func < IBlockQueryAdapter , T>> field Result field DataStructureFlag flag Query structure flag Returns Type Description ISqlValue <T> SQL value description Type Parameters Name Description T Value mapped type Extension Methods SerializationExtensions.ToXml<T>(T) CollectionsExtensions.SetValue<TKey, T>(TKey, T) CollectionsExtensions.AsEnum<T>(T) DataObjectQueryableExtensions.CompareVariable(Object, FilterOperation, String) Processing.Do<T>(T, Action<IProcess<T>>[]) TypeExtensions.TryConvert<T, TResult>(T, Func<T, TResult>) TypeExtensions.TryConvert<T, TResult>(T, Func<T, TResult>, TResult) TypeExtensions.ChangeType<T>(Object) TypeExtensions.ChangeType(Object, Type) TypeExtensions.InvokeMethod<TRet>(Object, Type[], Expression<Func<TRet>>, BindingFlags) TypeExtensions.InvokeMethod(Object, Type[], Expression<Action>, BindingFlags) TypeExtensions.InvokeMethod<TRet>(Object, Expression<Func<TRet>>, BindingFlags) TypeExtensions.InvokeMethod(Object, Expression<Action>, BindingFlags) SqlBlockExtensions.SetExpression<TTag, TResult>(TTag, Expression<Func<IBlockQueryAdapter, TResult>>) QueryDescriptionExtensions.SetExpression<TTag, TResult>(TTag, Expression<Func<IQueryStructureAdapter, TResult>>)"
  },
  "api/XData.Database.SqlBlock.ISqlBlockAdapter-1.html": {
    "href": "api/XData.Database.SqlBlock.ISqlBlockAdapter-1.html",
    "title": "Interface ISqlBlockAdapter<T> | XData website",
    "keywords": "Interface ISqlBlockAdapter<T> Adapter of SQL block returning data Inherited Members ISqlBlockAdapter.Block(Expression<Func<ISqlBlockAdapter, ISqlBlock>>[]) ISqlBlockAdapter.Block<T>(Expression<Func<ISqlBlockAdapter<T>, ISqlBlock>>[]) ISqlBlockAdapter.Block(String) ISqlBlockAdapter.Declare(Expression<Func<ISqlVariable, ISqlValue>>[]) ISqlBlockAdapter.SetVar(Expression<Func<ISetSqlVarAdapter, ISqlValue>>[]) ISqlBlockAdapter.SetVar<TValue>(Expression<Func<IBlockQueryStructure, IBlockQueryDescription<TValue>>>, Expression<Func<ISqlVarAdapter, ISqlValue>>[]) ISqlBlockAdapter.Update<T>(Expression<Func<IBlockQueryStructure, IBlockQueryStructure>>, Expression<Func<ISetBlockAdapter, T>>) ISqlBlockAdapter.Insert<TResult>(String, Expression<Func<ISetBlockAdapter, TResult>>) ISqlBlockAdapter.Insert<TResult>(String, DataTable, Expression<Func<ISetBlockAdapter, TResult>>) ISqlBlockAdapter.Insert<T>(String, Expression<Func<IBlockQueryStructure, IBlockQueryDescription<T>>>) ISqlBlockAdapter.Delete(Expression<Func<IBlockQueryStructure, IBlockQueryStructure>>) ISqlBlockAdapter.Merge<T>(String, String, String, Expression<Func<IMergeBlockAdapter, T>>) ISqlBlockAdapter.Merge<T, TSource>(String, String, Expression<Func<IBlockQueryStructure, IBlockQueryDescription<TSource>>>, String, Expression<Func<IMergeBlockAdapter, T>>) ISqlBlockAdapter.If<T>(Expression<Func<ISqlValueAdapter, ISqlValue<T>>>, Expression<Func<ISqlValueAdapter, ISqlValue<T>>>, FilterOperation, Expression<Func<ISqlBlockAdapter, ISqlBlock>>[]) ISqlBlockAdapter.If(Expression<Func<IBlockQueryStructure, IBlockQueryStructure>>, FilterOperation, Expression<Func<ISqlBlockAdapter, ISqlBlock>>[]) ISqlBlockAdapter.ForEach<T>(Expression<Func<IBlockQueryStructure, IBlockQueryDescription<T>>>, String, Expression<Func<ISqlBlockAdapter, ISqlBlock>>, Expression<Action<ILoopVariableAdapter<T>>>[]) Namespace : XData.Database.SqlBlock Assembly : XData.docfx.dll Syntax public interface ISqlBlockAdapter<T> : ISqlBlockAdapter where T : class, new() Type Parameters Name Description T Returned data type Methods | Improve this Doc View Source Return(Expression<Func<IBlockQueryStructure, IBlockQueryDescription<T>>>) Returning data out of sql block Declaration ISqlBlock Return(Expression<Func<IBlockQueryStructure, IBlockQueryDescription<T>>> selectQuery) Parameters Type Name Description Expression < Func < IBlockQueryStructure , IBlockQueryDescription <T>>> selectQuery Select query description Returns Type Description ISqlBlock SQL block description See Also GetSqlBlockData<T> ( IDataScope , Expression < SqlBlockDefinition <T>>, Expression < Func < ISqlParamAdapter , ISqlParam >>[]) Extension Methods SerializationExtensions.ToXml<T>(T) CollectionsExtensions.SetValue<TKey, T>(TKey, T) CollectionsExtensions.AsEnum<T>(T) DataObjectQueryableExtensions.CompareVariable(Object, FilterOperation, String) Processing.Do<T>(T, Action<IProcess<T>>[]) TypeExtensions.TryConvert<T, TResult>(T, Func<T, TResult>) TypeExtensions.TryConvert<T, TResult>(T, Func<T, TResult>, TResult) TypeExtensions.ChangeType<T>(Object) TypeExtensions.ChangeType(Object, Type) TypeExtensions.InvokeMethod<TRet>(Object, Type[], Expression<Func<TRet>>, BindingFlags) TypeExtensions.InvokeMethod(Object, Type[], Expression<Action>, BindingFlags) TypeExtensions.InvokeMethod<TRet>(Object, Expression<Func<TRet>>, BindingFlags) TypeExtensions.InvokeMethod(Object, Expression<Action>, BindingFlags) SqlBlockExtensions.SetExpression<TTag, TResult>(TTag, Expression<Func<IBlockQueryAdapter, TResult>>) QueryDescriptionExtensions.SetExpression<TTag, TResult>(TTag, Expression<Func<IQueryStructureAdapter, TResult>>)"
  },
  "api/XData.Database.SqlBlock.IBlockQueryStructure.html": {
    "href": "api/XData.Database.SqlBlock.IBlockQueryStructure.html",
    "title": "Interface IBlockQueryStructure | XData website",
    "keywords": "Interface IBlockQueryStructure SQL block query structure interface Namespace : XData.Database.SqlBlock Assembly : XData.docfx.dll Syntax public interface IBlockQueryStructure Methods | Improve this Doc View Source GetStructure(String, Expression<Func<IQueryStructure, IQueryStructure>>) Returns SQL block query structure Declaration IBlockQueryStructure GetStructure(string baseTableAlias, Expression<Func<IQueryStructure, IQueryStructure>> query) Parameters Type Name Description String baseTableAlias Expression < Func < IQueryStructure , IQueryStructure >> query Returns Type Description IBlockQueryStructure SQL block query structure See Also ExecuteSqlBlock ( IDataScope , Expression < SqlBlockDefinition >, Expression < Func < ISqlParamAdapter , ISqlParam >>[]) GetSqlBlockData<T> ( IDataScope , Expression < SqlBlockDefinition <T>>, Expression < Func < ISqlParamAdapter , ISqlParam >>[]) | Improve this Doc View Source GetStructure<T>(String, Expression<Func<IQueryStructure, IQueryStructure>>) Returns SQL block query structure Declaration IBlockQueryStructure GetStructure<T>(string baseTableAlias, Expression<Func<IQueryStructure, IQueryStructure>> query) where T : class, IDataObject, new() Parameters Type Name Description String baseTableAlias Expression < Func < IQueryStructure , IQueryStructure >> query Returns Type Description IBlockQueryStructure SQL block query structure Type Parameters Name Description T Base data object type See Also ExecuteSqlBlock ( IDataScope , Expression < SqlBlockDefinition >, Expression < Func < ISqlParamAdapter , ISqlParam >>[]) GetSqlBlockData<T> ( IDataScope , Expression < SqlBlockDefinition <T>>, Expression < Func < ISqlParamAdapter , ISqlParam >>[]) | Improve this Doc View Source Select<TResult>(Expression<Func<IBlockQueryAdapter, TResult>>) SQL block query result mapping Declaration IBlockQueryDescription<TResult> Select<TResult>(Expression<Func<IBlockQueryAdapter, TResult>> mapper) where TResult : class Parameters Type Name Description Expression < Func < IBlockQueryAdapter , TResult>> mapper Mapping expression Returns Type Description IBlockQueryDescription <TResult> Dynamic query description Type Parameters Name Description TResult Dynamic query result type See Also GetStructure(String, Expression<Func<IQueryStructure, IQueryStructure>>) | Improve this Doc View Source Var(String) SQL variable name including prefix Declaration string Var(string varName) Parameters Type Name Description String varName Variable name Returns Type Description String SQL variable name including prefix Extension Methods SerializationExtensions.ToXml<T>(T) CollectionsExtensions.SetValue<TKey, T>(TKey, T) CollectionsExtensions.AsEnum<T>(T) DataObjectQueryableExtensions.CompareVariable(Object, FilterOperation, String) Processing.Do<T>(T, Action<IProcess<T>>[]) TypeExtensions.TryConvert<T, TResult>(T, Func<T, TResult>) TypeExtensions.TryConvert<T, TResult>(T, Func<T, TResult>, TResult) TypeExtensions.ChangeType<T>(Object) TypeExtensions.ChangeType(Object, Type) TypeExtensions.InvokeMethod<TRet>(Object, Type[], Expression<Func<TRet>>, BindingFlags) TypeExtensions.InvokeMethod(Object, Type[], Expression<Action>, BindingFlags) TypeExtensions.InvokeMethod<TRet>(Object, Expression<Func<TRet>>, BindingFlags) TypeExtensions.InvokeMethod(Object, Expression<Action>, BindingFlags) SqlBlockExtensions.SetExpression<TTag, TResult>(TTag, Expression<Func<IBlockQueryAdapter, TResult>>) QueryDescriptionExtensions.SetExpression<TTag, TResult>(TTag, Expression<Func<IQueryStructureAdapter, TResult>>)"
  },
  "api/XData.Database.Dialect.SqlTypeSize.html": {
    "href": "api/XData.Database.Dialect.SqlTypeSize.html",
    "title": "Enum SqlTypeSize | XData website",
    "keywords": "Enum SqlTypeSize Sql type size and scale applicable Namespace : XData.Database.Dialect Assembly : XData.docfx.dll Syntax [Flags] public enum SqlTypeSize Fields Name Description None None applicable Precision Precision applicable Scale Scale applicable Size Size applicable Extension Methods SerializationExtensions.ToXml<SqlTypeSize>() CollectionsExtensions.SetValue<SqlTypeSize, T>(T) CollectionsExtensions.AsEnum<SqlTypeSize>() DataObjectQueryableExtensions.CompareVariable(FilterOperation, String) Processing.Do<SqlTypeSize>(Action<IProcess<SqlTypeSize>>[]) TypeExtensions.ChangeType<T>() TypeExtensions.ChangeType(Type) TypeExtensions.InvokeMethod<TRet>(Type[], Expression<Func<TRet>>, BindingFlags) TypeExtensions.InvokeMethod(Type[], Expression<Action>, BindingFlags) TypeExtensions.InvokeMethod<TRet>(Expression<Func<TRet>>, BindingFlags) TypeExtensions.InvokeMethod(Expression<Action>, BindingFlags) TypeExtensions.ConvertTo<T>() TypeExtensions.EqualValue(Enum) SqlBlockExtensions.SetExpression<SqlTypeSize, TResult>(Expression<Func<IBlockQueryAdapter, TResult>>) QueryDescriptionExtensions.SetExpression<SqlTypeSize, TResult>(Expression<Func<IQueryStructureAdapter, TResult>>)"
  },
  "api/XData.Database.Adapter.UdtSqlType.html": {
    "href": "api/XData.Database.Adapter.UdtSqlType.html",
    "title": "Class UdtSqlType | XData website",
    "keywords": "Class UdtSqlType User defined type (UDT) description Inheritance Object UdtSqlType Inherited Members Object.Equals(Object) Object.Equals(Object, Object) Object.GetHashCode() Object.GetType() Object.MemberwiseClone() Object.ReferenceEquals(Object, Object) Object.ToString() Namespace : XData.Database.Adapter Assembly : XData.docfx.dll Syntax public sealed class UdtSqlType Properties | Improve this Doc View Source ElementSqlTypeName User defined type (UDT) element type name for parameter Declaration public string ElementSqlTypeName { get; set; } Property Value Type Description String | Improve this Doc View Source IsArray User defined type (UDT) collection is VARARRAY for parameter Declaration public bool IsArray { get; set; } Property Value Type Description Boolean | Improve this Doc View Source MappedType User defined type (UDT) mapped type Declaration public Type MappedType { get; set; } Property Value Type Description Type | Improve this Doc View Source SqlTypeName User defined type (UDT) name for parameter Declaration public string SqlTypeName { get; set; } Property Value Type Description String Extension Methods SerializationExtensions.ToXml<T>(T) CollectionsExtensions.SetValue<TKey, T>(TKey, T) CollectionsExtensions.AsEnum<T>(T) DataObjectQueryableExtensions.CompareVariable(Object, FilterOperation, String) Processing.Do<T>(T, Action<IProcess<T>>[]) TypeExtensions.TryConvert<T, TResult>(T, Func<T, TResult>) TypeExtensions.TryConvert<T, TResult>(T, Func<T, TResult>, TResult) TypeExtensions.ChangeType<T>(Object) TypeExtensions.ChangeType(Object, Type) TypeExtensions.InvokeMethod<TRet>(Object, Type[], Expression<Func<TRet>>, BindingFlags) TypeExtensions.InvokeMethod(Object, Type[], Expression<Action>, BindingFlags) TypeExtensions.InvokeMethod<TRet>(Object, Expression<Func<TRet>>, BindingFlags) TypeExtensions.InvokeMethod(Object, Expression<Action>, BindingFlags) SqlBlockExtensions.SetExpression<TTag, TResult>(TTag, Expression<Func<IBlockQueryAdapter, TResult>>) QueryDescriptionExtensions.SetExpression<TTag, TResult>(TTag, Expression<Func<IQueryStructureAdapter, TResult>>)"
  },
  "api/XData.Database.Adapter.IDatabaseAdapterMetadata.html": {
    "href": "api/XData.Database.Adapter.IDatabaseAdapterMetadata.html",
    "title": "Interface IDatabaseAdapterMetadata | XData website",
    "keywords": "Interface IDatabaseAdapterMetadata Database adapter description interface Namespace : XData.Database.Adapter Assembly : XData.docfx.dll Syntax public interface IDatabaseAdapterMetadata Properties | Improve this Doc View Source Database Database connection type Declaration string Database { get; } Property Value Type Description String Extension Methods SerializationExtensions.ToXml<T>(T) CollectionsExtensions.SetValue<TKey, T>(TKey, T) CollectionsExtensions.AsEnum<T>(T) DataObjectQueryableExtensions.CompareVariable(Object, FilterOperation, String) Processing.Do<T>(T, Action<IProcess<T>>[]) TypeExtensions.TryConvert<T, TResult>(T, Func<T, TResult>) TypeExtensions.TryConvert<T, TResult>(T, Func<T, TResult>, TResult) TypeExtensions.ChangeType<T>(Object) TypeExtensions.ChangeType(Object, Type) TypeExtensions.InvokeMethod<TRet>(Object, Type[], Expression<Func<TRet>>, BindingFlags) TypeExtensions.InvokeMethod(Object, Type[], Expression<Action>, BindingFlags) TypeExtensions.InvokeMethod<TRet>(Object, Expression<Func<TRet>>, BindingFlags) TypeExtensions.InvokeMethod(Object, Expression<Action>, BindingFlags) SqlBlockExtensions.SetExpression<TTag, TResult>(TTag, Expression<Func<IBlockQueryAdapter, TResult>>) QueryDescriptionExtensions.SetExpression<TTag, TResult>(TTag, Expression<Func<IQueryStructureAdapter, TResult>>)"
  },
  "api/XData.CustomLogic-1.html": {
    "href": "api/XData.CustomLogic-1.html",
    "title": "Delegate CustomLogic<T> | XData website",
    "keywords": "Delegate CustomLogic<T> Custom server logic delegate type Namespace : XData Assembly : XData.docfx.dll Syntax public delegate bool CustomLogic<in T>(params T[] objects) where T : class, IDataObject; Parameters Type Name Description T[] objects Object instances to process Returns Type Description Boolean Success flag Type Parameters Name Description T Object type Extension Methods SerializationExtensions.ToXml<T>(T) CollectionsExtensions.SetValue<TKey, T>(TKey, T) CollectionsExtensions.AsEnum<T>(T) DataObjectQueryableExtensions.CompareVariable(Object, FilterOperation, String) Processing.Do<T>(T, Action<IProcess<T>>[]) TypeExtensions.TryConvert<T, TResult>(T, Func<T, TResult>) TypeExtensions.TryConvert<T, TResult>(T, Func<T, TResult>, TResult) TypeExtensions.ChangeType<T>(Object) TypeExtensions.ChangeType(Object, Type) TypeExtensions.InvokeMethod<TRet>(Object, Type[], Expression<Func<TRet>>, BindingFlags) TypeExtensions.InvokeMethod(Object, Type[], Expression<Action>, BindingFlags) TypeExtensions.InvokeMethod<TRet>(Object, Expression<Func<TRet>>, BindingFlags) TypeExtensions.InvokeMethod(Object, Expression<Action>, BindingFlags) SqlBlockExtensions.SetExpression<TTag, TResult>(TTag, Expression<Func<IBlockQueryAdapter, TResult>>) QueryDescriptionExtensions.SetExpression<TTag, TResult>(TTag, Expression<Func<IQueryStructureAdapter, TResult>>)"
  },
  "api/XData.Exceptions.XDataAdapterException.html": {
    "href": "api/XData.Exceptions.XDataAdapterException.html",
    "title": "Class XDataAdapterException | XData website",
    "keywords": "Class XDataAdapterException Adapter exception Inheritance Object Exception ApplicationException XDataException XDataAdapterException Implements ISerializable Inherited Members Exception.GetBaseException() Exception.GetObjectData(SerializationInfo, StreamingContext) Exception.GetType() Exception.ToString() Exception.Data Exception.HelpLink Exception.HResult Exception.InnerException Exception.Message Exception.Source Exception.StackTrace Exception.TargetSite Exception.SerializeObjectState Object.Equals(Object) Object.Equals(Object, Object) Object.GetHashCode() Object.MemberwiseClone() Object.ReferenceEquals(Object, Object) Namespace : XData.Exceptions Assembly : XData.docfx.dll Syntax [Serializable] public class XDataAdapterException : XDataException, ISerializable Constructors | Improve this Doc View Source XDataAdapterException(XDataAdapterExceptionType, String) Adapter exception Declaration public XDataAdapterException(XDataAdapterExceptionType type, string path) Parameters Type Name Description XDataAdapterExceptionType type Exception type String path Adapter file path | Improve this Doc View Source XDataAdapterException(XDataAdapterExceptionType, String, Type) Adapter exception Declaration public XDataAdapterException(XDataAdapterExceptionType type, string details, Type adapterType) Parameters Type Name Description XDataAdapterExceptionType type Exception type String details Exception details Type adapterType Adapter type | Improve this Doc View Source XDataAdapterException(XDataAdapterExceptionType, Type) Adapter exception Declaration public XDataAdapterException(XDataAdapterExceptionType type, Type adapterType) Parameters Type Name Description XDataAdapterExceptionType type Exception type Type adapterType Adapter type Properties | Improve this Doc View Source AdapterType Adapter type Declaration public Type AdapterType { get; } Property Value Type Description Type | Improve this Doc View Source Details Exception details Declaration public string Details { get; } Property Value Type Description String | Improve this Doc View Source FilePath Adapter file path Declaration public string FilePath { get; } Property Value Type Description String | Improve this Doc View Source Type Adapter exception type Declaration public XDataAdapterExceptionType Type { get; } Property Value Type Description XDataAdapterExceptionType Implements System.Runtime.Serialization.ISerializable Extension Methods SerializationExtensions.ToXml<T>(T) CollectionsExtensions.SetValue<TKey, T>(TKey, T) CollectionsExtensions.AsEnum<T>(T) DataObjectQueryableExtensions.CompareVariable(Object, FilterOperation, String) Processing.Do<T>(T, Action<IProcess<T>>[]) TypeExtensions.TryConvert<T, TResult>(T, Func<T, TResult>) TypeExtensions.TryConvert<T, TResult>(T, Func<T, TResult>, TResult) TypeExtensions.ChangeType<T>(Object) TypeExtensions.ChangeType(Object, Type) TypeExtensions.InvokeMethod<TRet>(Object, Type[], Expression<Func<TRet>>, BindingFlags) TypeExtensions.InvokeMethod(Object, Type[], Expression<Action>, BindingFlags) TypeExtensions.InvokeMethod<TRet>(Object, Expression<Func<TRet>>, BindingFlags) TypeExtensions.InvokeMethod(Object, Expression<Action>, BindingFlags) SqlBlockExtensions.SetExpression<TTag, TResult>(TTag, Expression<Func<IBlockQueryAdapter, TResult>>) QueryDescriptionExtensions.SetExpression<TTag, TResult>(TTag, Expression<Func<IQueryStructureAdapter, TResult>>)"
  },
  "api/XData.DataSource.Structure.html": {
    "href": "api/XData.DataSource.Structure.html",
    "title": "Namespace XData.DataSource.Structure | XData website",
    "keywords": "Namespace XData.DataSource.Structure Classes DataQueryState Data query state DataStructureState Data structure state Field Field object FilterCombinationState Filter combination state FilterName FilterName helper class to initialize named RuntimeFilter FilterState Filter state info Grouping Grouping element Hierarchy Hierarchy Order Order by element RepositoryState Repository state RuntimeFilter Runtime value filter Structs SelectedField Selected field description TaggedValue Named value Interfaces IConstantFilter Constant value filter interface IDataSource Data object source IDataStructure Data object structure IDictionaryFilter Dictionary filter interface IExpressionFilter Expression filter interface IExternalLink External link interface IField Field interface IFilter Filter interface IFilterCombination Filter combination interface IInnerLink Link interface IInnerViewLink Inner view link interface INamedFilter Named filter interface IOptionalFilter Optional filter interface Hint: Optional filters can rise flag to skip their sources if no value assigned in runtime or their subquery is skipped by other optional filters IProcedure Procedure based structure IRangeFilter Range filter interface IRuntimeFilter Runtime filter interface ISqlPart Subquery base interface ISubqueryFilter Subquery filter interface ISubqueryLink Subquery link interface ITable Table ITableLike Temporary table ITempTable IXmlSource XML data source"
  },
  "api/XData.DataSource.Structure.TaggedValue.html": {
    "href": "api/XData.DataSource.Structure.TaggedValue.html",
    "title": "Struct TaggedValue | XData website",
    "keywords": "Struct TaggedValue Named value Inherited Members ValueType.Equals(Object) ValueType.GetHashCode() ValueType.ToString() Object.Equals(Object, Object) Object.GetType() Object.ReferenceEquals(Object, Object) Namespace : XData.DataSource.Structure Assembly : XData.docfx.dll Syntax [Serializable] [DataContract] public struct TaggedValue Properties | Improve this Doc View Source Key Name Declaration [DataMember] public string Key { get; set; } Property Value Type Description String | Improve this Doc View Source Value Value Declaration [DataMember] public object Value { get; set; } Property Value Type Description Object Extension Methods SerializationExtensions.ToXml<T>(T) CollectionsExtensions.SetValue<TKey, T>(TKey, T) CollectionsExtensions.AsEnum<T>(T) DataObjectQueryableExtensions.CompareVariable(Object, FilterOperation, String) Processing.Do<T>(T, Action<IProcess<T>>[]) TypeExtensions.ChangeType<T>(Object) TypeExtensions.ChangeType(Object, Type) TypeExtensions.InvokeMethod<TRet>(Object, Type[], Expression<Func<TRet>>, BindingFlags) TypeExtensions.InvokeMethod(Object, Type[], Expression<Action>, BindingFlags) TypeExtensions.InvokeMethod<TRet>(Object, Expression<Func<TRet>>, BindingFlags) TypeExtensions.InvokeMethod(Object, Expression<Action>, BindingFlags) SqlBlockExtensions.SetExpression<TTag, TResult>(TTag, Expression<Func<IBlockQueryAdapter, TResult>>) QueryDescriptionExtensions.SetExpression<TTag, TResult>(TTag, Expression<Func<IQueryStructureAdapter, TResult>>)"
  },
  "api/XData.DataSource.Structure.IOptionalFilter.html": {
    "href": "api/XData.DataSource.Structure.IOptionalFilter.html",
    "title": "Interface IOptionalFilter | XData website",
    "keywords": "Interface IOptionalFilter Optional filter interface Hint: Optional filters can rise flag to skip their sources if no value assigned in runtime or their subquery is skipped by other optional filters Inherited Members IFilter.FilterType IFilter.SourceAlias IFilter.Field IFilter.Operation ICloneable.Clone() Namespace : XData.DataSource.Structure Assembly : XData.docfx.dll Syntax public interface IOptionalFilter : IFilter, ICloneable Properties | Improve this Doc View Source Primary Primary filter flag Declaration bool Primary { get; } Property Value Type Description Boolean Extension Methods SerializationExtensions.ToXml<T>(T) CollectionsExtensions.SetValue<TKey, T>(TKey, T) CollectionsExtensions.AsEnum<T>(T) DataObjectQueryableExtensions.CompareVariable(Object, FilterOperation, String) Processing.Do<T>(T, Action<IProcess<T>>[]) TypeExtensions.TryConvert<T, TResult>(T, Func<T, TResult>) TypeExtensions.TryConvert<T, TResult>(T, Func<T, TResult>, TResult) TypeExtensions.ChangeType<T>(Object) TypeExtensions.ChangeType(Object, Type) TypeExtensions.InvokeMethod<TRet>(Object, Type[], Expression<Func<TRet>>, BindingFlags) TypeExtensions.InvokeMethod(Object, Type[], Expression<Action>, BindingFlags) TypeExtensions.InvokeMethod<TRet>(Object, Expression<Func<TRet>>, BindingFlags) TypeExtensions.InvokeMethod(Object, Expression<Action>, BindingFlags) SqlBlockExtensions.SetExpression<TTag, TResult>(TTag, Expression<Func<IBlockQueryAdapter, TResult>>) QueryDescriptionExtensions.SetExpression<TTag, TResult>(TTag, Expression<Func<IQueryStructureAdapter, TResult>>)"
  },
  "api/XData.Extensions.ExpressionExtensions.html": {
    "href": "api/XData.Extensions.ExpressionExtensions.html",
    "title": "Class ExpressionExtensions | XData website",
    "keywords": "Class ExpressionExtensions Expression extensions Inheritance Object ExpressionExtensions Inherited Members Object.Equals(Object) Object.Equals(Object, Object) Object.GetHashCode() Object.GetType() Object.MemberwiseClone() Object.ReferenceEquals(Object, Object) Object.ToString() Namespace : XData.Extensions Assembly : XData.docfx.dll Syntax public static class ExpressionExtensions"
  },
  "api/XData.Exceptions.XDataConfigurationException.html": {
    "href": "api/XData.Exceptions.XDataConfigurationException.html",
    "title": "Class XDataConfigurationException | XData website",
    "keywords": "Class XDataConfigurationException XData configuration exception Inheritance Object Exception ApplicationException XDataException XDataConfigurationException Implements ISerializable Inherited Members Exception.GetBaseException() Exception.GetObjectData(SerializationInfo, StreamingContext) Exception.GetType() Exception.ToString() Exception.Data Exception.HelpLink Exception.HResult Exception.InnerException Exception.Message Exception.Source Exception.StackTrace Exception.TargetSite Exception.SerializeObjectState Object.Equals(Object) Object.Equals(Object, Object) Object.GetHashCode() Object.MemberwiseClone() Object.ReferenceEquals(Object, Object) Namespace : XData.Exceptions Assembly : XData.docfx.dll Syntax [Serializable] public class XDataConfigurationException : XDataException, ISerializable Constructors | Improve this Doc View Source XDataConfigurationException(XDataConfigurationExceptionType) Query structure build failed Declaration public XDataConfigurationException(XDataConfigurationExceptionType type) Parameters Type Name Description XDataConfigurationExceptionType type Query structure exception type | Improve this Doc View Source XDataConfigurationException(XDataConfigurationExceptionType, String) Query structure build failed Declaration public XDataConfigurationException(XDataConfigurationExceptionType type, string details) Parameters Type Name Description XDataConfigurationExceptionType type Query structure exception type String details Error details | Improve this Doc View Source XDataConfigurationException(XDataConfigurationExceptionType, String, Exception) Query structure build failed Declaration public XDataConfigurationException(XDataConfigurationExceptionType type, string details, Exception inner) Parameters Type Name Description XDataConfigurationExceptionType type Query structure exception type String details Error details Exception inner Inner exception Properties | Improve this Doc View Source DetailsInfo Exception details info Declaration public string DetailsInfo { get; } Property Value Type Description String | Improve this Doc View Source Type Type of exception Declaration public XDataConfigurationExceptionType Type { get; } Property Value Type Description XDataConfigurationExceptionType Implements System.Runtime.Serialization.ISerializable Extension Methods SerializationExtensions.ToXml<T>(T) CollectionsExtensions.SetValue<TKey, T>(TKey, T) CollectionsExtensions.AsEnum<T>(T) DataObjectQueryableExtensions.CompareVariable(Object, FilterOperation, String) Processing.Do<T>(T, Action<IProcess<T>>[]) TypeExtensions.TryConvert<T, TResult>(T, Func<T, TResult>) TypeExtensions.TryConvert<T, TResult>(T, Func<T, TResult>, TResult) TypeExtensions.ChangeType<T>(Object) TypeExtensions.ChangeType(Object, Type) TypeExtensions.InvokeMethod<TRet>(Object, Type[], Expression<Func<TRet>>, BindingFlags) TypeExtensions.InvokeMethod(Object, Type[], Expression<Action>, BindingFlags) TypeExtensions.InvokeMethod<TRet>(Object, Expression<Func<TRet>>, BindingFlags) TypeExtensions.InvokeMethod(Object, Expression<Action>, BindingFlags) SqlBlockExtensions.SetExpression<TTag, TResult>(TTag, Expression<Func<IBlockQueryAdapter, TResult>>) QueryDescriptionExtensions.SetExpression<TTag, TResult>(TTag, Expression<Func<IQueryStructureAdapter, TResult>>)"
  },
  "api/XData.Exceptions.XDataConcurrencyException.html": {
    "href": "api/XData.Exceptions.XDataConcurrencyException.html",
    "title": "Class XDataConcurrencyException | XData website",
    "keywords": "Class XDataConcurrencyException Concurrency exception Inheritance Object Exception ApplicationException XDataException XDataConcurrencyException Implements ISerializable Inherited Members Exception.GetBaseException() Exception.GetObjectData(SerializationInfo, StreamingContext) Exception.GetType() Exception.ToString() Exception.Data Exception.HelpLink Exception.HResult Exception.InnerException Exception.Message Exception.Source Exception.StackTrace Exception.TargetSite Exception.SerializeObjectState Object.Equals(Object) Object.Equals(Object, Object) Object.GetHashCode() Object.MemberwiseClone() Object.ReferenceEquals(Object, Object) Namespace : XData.Exceptions Assembly : XData.docfx.dll Syntax [Serializable] public sealed class XDataConcurrencyException : XDataException, ISerializable Constructors | Improve this Doc View Source XDataConcurrencyException(Exception, Query) Concurrency exception Declaration public XDataConcurrencyException(Exception exception, Query query) Parameters Type Name Description Exception exception Inner exception Query query Query | Improve this Doc View Source XDataConcurrencyException(Exception, AdditionalInfo[]) Concurrency exception Declaration public XDataConcurrencyException(Exception exception, params AdditionalInfo[] addInfo) Parameters Type Name Description Exception exception Inner exception AdditionalInfo [] addInfo Additional information | Improve this Doc View Source XDataConcurrencyException(String) Concurrency exception Declaration public XDataConcurrencyException(string exception) Parameters Type Name Description String exception Exception text Properties | Improve this Doc View Source Query Query Declaration public Query Query { get; } Property Value Type Description Query Implements System.Runtime.Serialization.ISerializable Extension Methods SerializationExtensions.ToXml<T>(T) CollectionsExtensions.SetValue<TKey, T>(TKey, T) CollectionsExtensions.AsEnum<T>(T) DataObjectQueryableExtensions.CompareVariable(Object, FilterOperation, String) Processing.Do<T>(T, Action<IProcess<T>>[]) TypeExtensions.TryConvert<T, TResult>(T, Func<T, TResult>) TypeExtensions.TryConvert<T, TResult>(T, Func<T, TResult>, TResult) TypeExtensions.ChangeType<T>(Object) TypeExtensions.ChangeType(Object, Type) TypeExtensions.InvokeMethod<TRet>(Object, Type[], Expression<Func<TRet>>, BindingFlags) TypeExtensions.InvokeMethod(Object, Type[], Expression<Action>, BindingFlags) TypeExtensions.InvokeMethod<TRet>(Object, Expression<Func<TRet>>, BindingFlags) TypeExtensions.InvokeMethod(Object, Expression<Action>, BindingFlags) SqlBlockExtensions.SetExpression<TTag, TResult>(TTag, Expression<Func<IBlockQueryAdapter, TResult>>) QueryDescriptionExtensions.SetExpression<TTag, TResult>(TTag, Expression<Func<IQueryStructureAdapter, TResult>>)"
  },
  "api/XData.DataSource.Structure.SelectedField.html": {
    "href": "api/XData.DataSource.Structure.SelectedField.html",
    "title": "Struct SelectedField | XData website",
    "keywords": "Struct SelectedField Selected field description Inherited Members ValueType.Equals(Object) ValueType.GetHashCode() ValueType.ToString() Object.Equals(Object, Object) Object.GetType() Object.ReferenceEquals(Object, Object) Namespace : XData.DataSource.Structure Assembly : XData.docfx.dll Syntax public struct SelectedField Constructors | Improve this Doc View Source SelectedField(IField, String, String, String) Selected field constructor Declaration public SelectedField(IField field, string alias, string fieldName, string property = null) Parameters Type Name Description IField field Field object String alias Source alias String fieldName Field name String property Property name Fields | Improve this Doc View Source Alias Alias Declaration public readonly string Alias Field Value Type Description String | Improve this Doc View Source Field Field description Declaration public readonly IField Field Field Value Type Description IField | Improve this Doc View Source FieldName Full field name Declaration public readonly string FieldName Field Value Type Description String | Improve this Doc View Source Property Property name Declaration public readonly string Property Field Value Type Description String Extension Methods SerializationExtensions.ToXml<T>(T) CollectionsExtensions.SetValue<TKey, T>(TKey, T) CollectionsExtensions.AsEnum<T>(T) DataObjectQueryableExtensions.CompareVariable(Object, FilterOperation, String) Processing.Do<T>(T, Action<IProcess<T>>[]) TypeExtensions.ChangeType<T>(Object) TypeExtensions.ChangeType(Object, Type) TypeExtensions.InvokeMethod<TRet>(Object, Type[], Expression<Func<TRet>>, BindingFlags) TypeExtensions.InvokeMethod(Object, Type[], Expression<Action>, BindingFlags) TypeExtensions.InvokeMethod<TRet>(Object, Expression<Func<TRet>>, BindingFlags) TypeExtensions.InvokeMethod(Object, Expression<Action>, BindingFlags) SqlBlockExtensions.SetExpression<TTag, TResult>(TTag, Expression<Func<IBlockQueryAdapter, TResult>>) QueryDescriptionExtensions.SetExpression<TTag, TResult>(TTag, Expression<Func<IQueryStructureAdapter, TResult>>)"
  },
  "api/XData.Mapping.PropertyExpressionAttribute.html": {
    "href": "api/XData.Mapping.PropertyExpressionAttribute.html",
    "title": "Class PropertyExpressionAttribute | XData website",
    "keywords": "Class PropertyExpressionAttribute Data object property plain expression attribute Inheritance Object Attribute PropertyExpressionAttribute Inherited Members Attribute.Equals(Object) Attribute.GetCustomAttribute(Assembly, Type) Attribute.GetCustomAttribute(Assembly, Type, Boolean) Attribute.GetCustomAttribute(MemberInfo, Type) Attribute.GetCustomAttribute(MemberInfo, Type, Boolean) Attribute.GetCustomAttribute(Module, Type) Attribute.GetCustomAttribute(Module, Type, Boolean) Attribute.GetCustomAttribute(ParameterInfo, Type) Attribute.GetCustomAttribute(ParameterInfo, Type, Boolean) Attribute.GetCustomAttributes(Assembly) Attribute.GetCustomAttributes(Assembly, Boolean) Attribute.GetCustomAttributes(Assembly, Type) Attribute.GetCustomAttributes(Assembly, Type, Boolean) Attribute.GetCustomAttributes(MemberInfo) Attribute.GetCustomAttributes(MemberInfo, Boolean) Attribute.GetCustomAttributes(MemberInfo, Type) Attribute.GetCustomAttributes(MemberInfo, Type, Boolean) Attribute.GetCustomAttributes(Module) Attribute.GetCustomAttributes(Module, Boolean) Attribute.GetCustomAttributes(Module, Type) Attribute.GetCustomAttributes(Module, Type, Boolean) Attribute.GetCustomAttributes(ParameterInfo) Attribute.GetCustomAttributes(ParameterInfo, Boolean) Attribute.GetCustomAttributes(ParameterInfo, Type) Attribute.GetCustomAttributes(ParameterInfo, Type, Boolean) Attribute.GetHashCode() Attribute.IsDefaultAttribute() Attribute.IsDefined(Assembly, Type) Attribute.IsDefined(Assembly, Type, Boolean) Attribute.IsDefined(MemberInfo, Type) Attribute.IsDefined(MemberInfo, Type, Boolean) Attribute.IsDefined(Module, Type) Attribute.IsDefined(Module, Type, Boolean) Attribute.IsDefined(ParameterInfo, Type) Attribute.IsDefined(ParameterInfo, Type, Boolean) Attribute.Match(Object) Attribute.TypeId Object.Equals(Object, Object) Object.GetType() Object.MemberwiseClone() Object.ReferenceEquals(Object, Object) Object.ToString() Namespace : XData.Mapping Assembly : XData.docfx.dll Syntax [AttributeUsage(AttributeTargets.Property)] public sealed class PropertyExpressionAttribute : Attribute Remarks Used when PropertyAttribute value is expression ( PlainSql or SubQuery ) according ExprType Constructors | Improve this Doc View Source PropertyExpressionAttribute(String, DataExpressionType, DbType) Data object property plain expression attribute Declaration public PropertyExpressionAttribute(string exprText, DataExpressionType exprType = DataExpressionType.PlainSql, DbType type = DbType.String) Parameters Type Name Description String exprText Expression text DataExpressionType exprType Expression type DbType type Expression DbType Exceptions Type Condition XDataRuntimeException Expression text cannot be null or empty string Properties | Improve this Doc View Source DbType Expression DbType Declaration public DbType DbType { get; } Property Value Type Description DbType | Improve this Doc View Source Exists Exists subquery operation Declaration public ExistsOperation Exists { get; set; } Property Value Type Description ExistsOperation | Improve this Doc View Source ExprScale Expression scale Declaration public int ExprScale { get; set; } Property Value Type Description Int32 | Improve this Doc View Source ExprSize Expression size Declaration public int ExprSize { get; set; } Property Value Type Description Int32 | Improve this Doc View Source ExprText Expression text Declaration public string ExprText { get; } Property Value Type Description String Remarks PlainSql expression text is Sql expression or SqlExpressionAttribute name SubQuery expression text is Alias WARNING! Plain Sql expressions (see ExprType ) can use specific SQL dialect features! Data mapping may be not compatible with other database engines! Use SqlExpressionAttribute instead. | Improve this Doc View Source ExprType Expression type Declaration public DataExpressionType ExprType { get; } Property Value Type Description DataExpressionType Remarks WARNING! Plain Sql expressions can use specific Sql dialect features! Data mapping may be not compatible with other database engines! Use SqlExpressionAttribute instead. See Also DataExpressionType Extension Methods SerializationExtensions.ToXml<T>(T) CollectionsExtensions.SetValue<TKey, T>(TKey, T) CollectionsExtensions.AsEnum<T>(T) DataObjectQueryableExtensions.CompareVariable(Object, FilterOperation, String) Processing.Do<T>(T, Action<IProcess<T>>[]) TypeExtensions.TryConvert<T, TResult>(T, Func<T, TResult>) TypeExtensions.TryConvert<T, TResult>(T, Func<T, TResult>, TResult) TypeExtensions.ChangeType<T>(Object) TypeExtensions.ChangeType(Object, Type) TypeExtensions.InvokeMethod<TRet>(Object, Type[], Expression<Func<TRet>>, BindingFlags) TypeExtensions.InvokeMethod(Object, Type[], Expression<Action>, BindingFlags) TypeExtensions.InvokeMethod<TRet>(Object, Expression<Func<TRet>>, BindingFlags) TypeExtensions.InvokeMethod(Object, Expression<Action>, BindingFlags) SqlBlockExtensions.SetExpression<TTag, TResult>(TTag, Expression<Func<IBlockQueryAdapter, TResult>>) QueryDescriptionExtensions.SetExpression<TTag, TResult>(TTag, Expression<Func<IQueryStructureAdapter, TResult>>)"
  },
  "api/XData.Mapping.Dynamic.ParameterDescription.html": {
    "href": "api/XData.Mapping.Dynamic.ParameterDescription.html",
    "title": "Class ParameterDescription | XData website",
    "keywords": "Class ParameterDescription SQL procedure / function parameter description Inheritance Object ParameterDescription Implements IParameterDescription Inherited Members Object.Equals(Object) Object.Equals(Object, Object) Object.GetHashCode() Object.GetType() Object.MemberwiseClone() Object.ReferenceEquals(Object, Object) Object.ToString() Namespace : XData.Mapping.Dynamic Assembly : XData.docfx.dll Syntax public class ParameterDescription : IParameterDescription Properties | Improve this Doc View Source Alias Procedure alias Declaration public string Alias { get; set; } Property Value Type Description String | Improve this Doc View Source Binding Parameter XData binding name Declaration public string Binding { get; set; } Property Value Type Description String | Improve this Doc View Source DbType Parameter database type Declaration public DbType DbType { get; set; } Property Value Type Description DbType | Improve this Doc View Source DefaultValue Parameter default value Declaration public object DefaultValue { get; set; } Property Value Type Description Object | Improve this Doc View Source DefaultValueType Parameter default value type Declaration public DefaultType DefaultValueType { get; set; } Property Value Type Description DefaultType | Improve this Doc View Source Direction Parameter direction Declaration public ParameterDirection Direction { get; set; } Property Value Type Description ParameterDirection | Improve this Doc View Source Name Parameter name Declaration public string Name { get; set; } Property Value Type Description String | Improve this Doc View Source NativeSqlType Parameter native SQL type Declaration public string NativeSqlType { get; set; } Property Value Type Description String | Improve this Doc View Source Order Parameter order Declaration public int Order { get; set; } Property Value Type Description Int32 | Improve this Doc View Source Scale Parameter scale Declaration public int Scale { get; set; } Property Value Type Description Int32 | Improve this Doc View Source Size Parameter size Declaration public int Size { get; set; } Property Value Type Description Int32 | Improve this Doc View Source Type Parameter mapped type Declaration public Type Type { get; set; } Property Value Type Description Type | Improve this Doc View Source TypeIsArray Parameter is VARARRAY Declaration public bool TypeIsArray { get; set; } Property Value Type Description Boolean | Improve this Doc View Source UdtSqlType Parameter user-defined-type definition Declaration public UdtSqlType UdtSqlType { get; set; } Property Value Type Description UdtSqlType | Improve this Doc View Source Value Parameter value Declaration public object Value { get; set; } Property Value Type Description Object Methods | Improve this Doc View Source Clone() Parameter clone Declaration public IParameterDescription Clone() Returns Type Description IParameterDescription | Improve this Doc View Source Copy(Object) Parameter copy Declaration public IParameterDescription Copy(object value) Parameters Type Name Description Object value Parameter value Returns Type Description IParameterDescription Parameter description | Improve this Doc View Source GetValue<T>() Parameter conversion Declaration public T GetValue<T>() Returns Type Description T Type Parameters Name Description T Conversion result type Implements IParameterDescription Extension Methods SerializationExtensions.ToXml<T>(T) CollectionsExtensions.SetValue<TKey, T>(TKey, T) CollectionsExtensions.AsEnum<T>(T) DataObjectQueryableExtensions.CompareVariable(Object, FilterOperation, String) Processing.Do<T>(T, Action<IProcess<T>>[]) TypeExtensions.TryConvert<T, TResult>(T, Func<T, TResult>) TypeExtensions.TryConvert<T, TResult>(T, Func<T, TResult>, TResult) TypeExtensions.ChangeType<T>(Object) TypeExtensions.ChangeType(Object, Type) TypeExtensions.InvokeMethod<TRet>(Object, Type[], Expression<Func<TRet>>, BindingFlags) TypeExtensions.InvokeMethod(Object, Type[], Expression<Action>, BindingFlags) TypeExtensions.InvokeMethod<TRet>(Object, Expression<Func<TRet>>, BindingFlags) TypeExtensions.InvokeMethod(Object, Expression<Action>, BindingFlags) SqlBlockExtensions.SetExpression<TTag, TResult>(TTag, Expression<Func<IBlockQueryAdapter, TResult>>) QueryDescriptionExtensions.SetExpression<TTag, TResult>(TTag, Expression<Func<IQueryStructureAdapter, TResult>>)"
  },
  "api/XData.Mapping.Dynamic.ITaggedExpression.html": {
    "href": "api/XData.Mapping.Dynamic.ITaggedExpression.html",
    "title": "Interface ITaggedExpression | XData website",
    "keywords": "Interface ITaggedExpression Object tagged expression interface Namespace : XData.Mapping.Dynamic Assembly : XData.docfx.dll Syntax public interface ITaggedExpression Properties | Improve this Doc View Source Key Key value Declaration object Key { get; } Property Value Type Description Object | Improve this Doc View Source KeyType Key type Declaration Type KeyType { get; } Property Value Type Description Type | Improve this Doc View Source Value Value type Declaration Expression Value { get; } Property Value Type Description Expression Extension Methods SerializationExtensions.ToXml<T>(T) CollectionsExtensions.SetValue<TKey, T>(TKey, T) CollectionsExtensions.AsEnum<T>(T) DataObjectQueryableExtensions.CompareVariable(Object, FilterOperation, String) Processing.Do<T>(T, Action<IProcess<T>>[]) TypeExtensions.TryConvert<T, TResult>(T, Func<T, TResult>) TypeExtensions.TryConvert<T, TResult>(T, Func<T, TResult>, TResult) TypeExtensions.ChangeType<T>(Object) TypeExtensions.ChangeType(Object, Type) TypeExtensions.InvokeMethod<TRet>(Object, Type[], Expression<Func<TRet>>, BindingFlags) TypeExtensions.InvokeMethod(Object, Type[], Expression<Action>, BindingFlags) TypeExtensions.InvokeMethod<TRet>(Object, Expression<Func<TRet>>, BindingFlags) TypeExtensions.InvokeMethod(Object, Expression<Action>, BindingFlags) SqlBlockExtensions.SetExpression<TTag, TResult>(TTag, Expression<Func<IBlockQueryAdapter, TResult>>) QueryDescriptionExtensions.SetExpression<TTag, TResult>(TTag, Expression<Func<IQueryStructureAdapter, TResult>>)"
  },
  "tips/dictionary.html": {
    "href": "tips/dictionary.html",
    "title": "Using dictionaries | XData website",
    "keywords": "Using dictionaries Dictionaries can be used to reduce data re-query count when rarely changed data of dictionary will linked multiple times through Link<T,TSource> data type properties over small amount of time (one business process). Dictionaries is cached as single mapped objects (not a data cahe as described in Caching repository data topic)."
  },
  "tips/default_features.html": {
    "href": "tips/default_features.html",
    "title": "Default value features | XData website",
    "keywords": "Default value features Data object properties (or hidden properties ) can be assigned by default values described by mapping. Using DefaultFeature enumeration it's possible to extend basic functionality of default value assignment with... UseOnUpdate - use default value not only on insert, but on update also. SkipWhenAssigned - skip insert into table when PK value assigned explicitly. UpdateWhenAssigned - change insert operation over table to update when PK value assigned explicitly. Last two of features is usable when data object 's primary table is linked with another table in data object mapping as one-to-one, and insert into base table can be skipped (or replaced with update statement) when it's primary key is assigned explicitly in application code. This features helps logically combine mappings to hide technological entities, which don't reflect business object model of application. Default features can be combined. For example: DefaultFeature.UseOnUpdate | DefaultFeature.SkipWhenAssigned"
  },
  "tips/conditional.html": {
    "href": "tips/conditional.html",
    "title": "Conditional filters | XData website",
    "keywords": "Conditional filters XData realization of LINQ \"Where\" method has provide ability to use runtime condition evaluation during predicate compilation into SQL statements to analyze runtime data and conditionally omit non valued data (0, empty or null) filters. // string author, int rating, decimal? lowerPrice and decimal? higherPrice is an optional filter values return dataScope.GetRepository<Book>() .Where(x => (string.IsNullOrEmpty(author) || x.Author == author) && (rating <= 0 || x.Rating >= rating) && (lowerPrice.HasValue || x.Price >= lowerPrice) && (higherPrice.HasValue || x.Price <= higherPrice)) .ToArray(); When runtime condition is true and LINQ expression is OrElse whole expression is omitted while predicate compilation into SQL statements."
  },
  "tips/cast_type.html": {
    "href": "tips/cast_type.html",
    "title": "Cast to type | XData website",
    "keywords": "Cast to type To cast type of Field or Expression while mapping declaration can be reached using CastTo method. ... OrgSubType = x.Expr(\"org_subtype\", z => z.CastTo<OrgSubType>().Field<string>(\"S\", \"param_value\"), DbType.String) ..."
  },
  "tips/callback.html": {
    "href": "tips/callback.html",
    "title": "Using business logic callbacks | XData website",
    "keywords": "Using business logic callbacks XData allows to use business logic callbacks to interact back-end modules with front-end using synchronous Callback and asynchronous PostData models. Synchronous calls can return result value. Callbacks can be used with three-tier-architecture as well as with client-server model. Callbacks has provided business logic clear, complete view and allows debug same code in two-tier environment as code will be executed in three-tier. public class InvoiceLogic : XDataLogic<Invoice> { public CustomLogic<Invoice> TestCustomLogic => (objects => { Log.Write(MessageType.Information, () => $\"TestCustomLogic called with {objects.Length} objects\"); foreach (var invoice in objects) { var i = invoice; invoice.PostData(\"testPost\", () => Encoding.UTF8.GetBytes(i.DocNumb)); var p = Encoding.UTF8.GetBytes(i.DocNumb); var r = i.Callback(\"testCall\", ref p); Log.Write(MessageType.Information, () => @$\"Call for \\\"{i.DocNumb}\\\" returned \\\"{r}\\\" with data \\\"{(p == null ? null : Encoding.UTF8.GetString(p))}\\\"\"); } return true; }); }"
  },
  "tips/calculated.html": {
    "href": "tips/calculated.html",
    "title": "Business logic calculated fields | XData website",
    "keywords": "Business logic calculated fields XData allowed to calculate fields not only using SQL expressions . You can subscribe OnInvalidateObject event and calculate some fields on client side. More detailed events discussed below ."
  },
  "tips/adapter_config.html": {
    "href": "tips/adapter_config.html",
    "title": "Adapter and dialect specific configuration | XData website",
    "keywords": "Adapter and dialect specific configuration Some of adapters and dialects has their own specific configuration settings to setup unique features and behaviors. That specific settings can be defined in configuration file or dynamically with AddAdapter or AddDialect methods options parameter. Tip Function signatures is slightly different for .Net 4.0 version. XData.PostgreSql.NpgSql.Adapter: ... when XML configuration file is used: <adapter name=\"POSTGRESQL_NPG\" assembly=\"XData.PostgreSql.NpgSql.Adapter\"> <schema name=\"public\"/> </adapter> ... when YAML configuration file is used: adapter: - name: \"DICT_POSTGRESQL\" assembly: \"XData.PostgreSql.NpgSql.Adapter\" schema: dictionaries: ... when configuration is provided in runtime: // replace someschemaname to real schema name var source = new MemoryConfigurationSource { InitialData = new[] { new KeyValuePair<string, string>(\"schema:someschemaname\", null) }}; var conf = new ConfigurationBuilder().Add(source).Build(); ... .AddAdapter(\"postgresql\", XDataAdapter.PostgreSql.Adapter, conf) XData.MsSqlServer.Dialect: ... when XML configuration file is used (for modern versions of MSSQL): <dialect name=\"MSSQL\" assembly=\"XData.MsSqlServer.Dialect\"/> or if you have to use MSSQL 2005/2008 <dialect name=\"MSSQL\" assembly=\"XData.MsSqlServer.Dialect\"> <useOldOrderBy value=\"true\"/> </dialect> ... when YAML configuration file is used (for MSSQL 2005/2008): dialect: - name: \"DICT_MSSQL\" assembly: \"XData.MsSqlServer.Dialect\" useOldOrderBy: value: true ... when configuration is provided in runtime (for MSSQL 2005/2008): var source = new MemoryConfigurationSource { InitialData = new[] { new KeyValuePair<string, string>(\"useOldOrderBy:value\", \"true\") }}; var conf = new ConfigurationBuilder().Add(source).Build(); ... .AddDialect(\"mssql\", XDataAdapter.MsSqlServer.Dialect, conf)"
  },
  "quick_start/variables/variables.html": {
    "href": "quick_start/variables/variables.html",
    "title": "Use variable in mapping | XData website",
    "keywords": "Use variable in mapping Some filters can use variables as values. This allows more flexible use of the same mapping in different situations. Having described such a filter during mapping, you can specify various values of variables when using the repository. Use variables in Constant filters x => x.ConstFilter(\"ParamCode\", \"param_code\", FilterConstantType.Variable, \"ParamCode\") Here, the ConstFilter method is used to describe the filter. The constantType parameter in this case has the value FilterConstantType.Variable and the parameter value constantValue will already be interpreted not as a filter value, but as a variable name, the value of which will be used as a filter value. Use variables in Dictionary filters x => x.DictFilter(\"T_DOC_TYPE\", \"doc_type_id\", \"code\", \"DocType\", true) Now, to describe the filter, the DictFilter method overload is used with the bool parameter valueIsVariable . And if it is set to true , the value of the dictValue parameter will be interpreted as the name of the variable, the value of which will be used as the filter value. Use variables as SQL procedure parameter If in the description of data object the SQL procedure or function is used, then the values of their parameters are also transmitted as variables. .Procedure(\"ORG\", \"bids.get_org_list_by_period_id\", ProcedureType.Function) .Parameter<long>(\"ORG\", 1, \"p_period_id\", DbType.Int64) .Return(\"ORG\") To call the data object with that SQL function used, we must set parameter p_period_id value with one of followed methods... Set data object variable value To set the values of variables data object , when receiving an instance of the repository using the GetRepository method, we can specify the values of the variables that are used in the mapping of this object. To do this, use the variables parameter. dataScope.GetRepository<Doc>(\"DocType\".SetVar(\"INVOICE\")); Warning Variable name is case sensitive! When describing an object being reused as a subquery (or inner view), it may often be necessary to use variables to filter data within the subquery. The value of the variable can be set for the final date of the object. But if the value of a subquery variable is dictated by the logic of its use in external mapping or in external mapping, does such a subquery participate several times? In this case, it is possible to use an overload of the Subquery (or InnerView ) method with the variables parameter: //subquery define public class DocPropertyValue : ISqlObject { [UsedImplicitly] private static Expression<CustomMapping<DocPropertyValue>> _ = () => XDataMapping.CustomMapping<DocPropertyValue>() .DataTable(\"public.t_param\", \"P\", x => x.ConstFilter(\"ParamCode\", \"param_code\", FilterConstantType.Variable, \"ParamCode\")) //<= look here .DataTable(\"bids.t_doc_param\", \"V\", x => x.Link(\"P\", \"param_id\").SetOperation(FilterOperation.OuterJoin), x => x.ConstFilter(\"ParamActual\", \"version_state\", VersionState.Actual)) .Column(\"DocId\", x => x.Field<long>(\"V\", string.Empty, z => z.Hidden())) .Column(\"ParamValue\", x => x.Field<string>(\"V\", string.Empty, z => z.Hidden())) .Map().SetBaseTable(\"P\"); } ... .Subquery<DocPropertyValue>(\"EN\", x => x.GetProperty(\"ParamValue\"), DataGrouping.None, //set variable for EN subquery new[] { \"ParamCode\".SetVar(\"EXEC_FIO\") }, x => x.SubqueryLink(\"DocId\")) .Subquery<DocPropertyValue>(\"ET\", x => x.GetProperty(\"ParamValue\"), DataGrouping.None, //set variable for ET subquery new[] { \"ParamCode\".SetVar(\"EXEC_TEL\") }, x => x.SubqueryLink(\"DocId\"))"
  },
  "quick_start/inheritance/intro.html": {
    "href": "quick_start/inheritance/intro.html",
    "title": "Introduction | XData website",
    "keywords": "Introduction The topic of this lesson requires a small theoretical introduction... In large projects, the need often arises for developed hierarchies of inheritance of classes describing business logic. And it is logical that their reflection on the database structure should also reuse the repeating parts of mapping using the DRY principle... But there its not so simple. The storage structure is often built on principles different from those on which the application based on this data is built. Sometimes it is justified, sometimes not, and more often it would be justified logically, but the use of certain basic software products does not allow this. In XData, the implementation of the mapping inheritance model is based on the idea of giving the programmer the choice of the hierarchy according to which mapping will be built. Or it will be a class inheritance hierarchy . Or a separate hierarchy . And also the programmer can refuse the inheritance of mapping and describe mapping from scratch without using the mapping of the base class."
  },
  "quick_start/inheritance/base_class.html": {
    "href": "quick_start/inheritance/base_class.html",
    "title": "Using parts of mapping from base class | XData website",
    "keywords": "Using parts of mapping from base class * The example given here is divorced from reality. More important here is to provide a simple and understandable example of the use of map inheritance. And You must to decide whether or not to use this opportunity to take in each specific project situation. 1) Suppose we have a database of the following structure... <!--MD5=[5ea577eca533bfca935d04f775d3f167] class t_doc--> t_doc doc_id numb <!--MD5=[b7e230e1778b9287fe97f7db08279b34] class t_doc_date--> t_doc_date doc_id date_kind doc_date <!--MD5=[4ed4cd12cd2eeb59e644791b1ec40217] class t_doc_spec--> t_doc_spec doc_spec_id doc_id <!--MD5=[025ac326a6ab31b45989aa42f37da176] class t_doc_spec_amount--> t_doc_spec_amount doc_spec_id amount <!--MD5=[d8af03929ab85326d3ff8963ed505034] link t_doc to t_doc_date--> doc_id <!--MD5=[cef6fc7600387b202b7e697154b0ecaf] link t_doc to t_doc_spec--> doc_id <!--MD5=[542647722f52d6ccd9b263e63b85e2d8] link t_doc_spec to t_doc_spec_amount--> doc_spec_id <!--MD5=[501d614aa0835685237bf46a7dfec613] @startuml hide circle skinparam ClassHeaderBackgroundColor lightgray skinparam ClassBorderColor black skinparam ClassBorderThickness 1 skinparam ClassBackgroundColor transparent skinparam ArrowFontSize 8 skinparam ArrowColor black entity t_doc { <&key> doc_id - - numb } entity t_doc_date { <&key> doc_id <&key> date_kind - - <&clock> doc_date } t_doc - -{ t_doc_date : doc_id entity t_doc_spec { <&key> doc_spec_id - - <&arrow-circle-right> doc_id } t_doc -right-{ t_doc_spec : doc_id entity t_doc_spec_amount { <&key> doc_spec_id - - <&dollar> amount } t_doc_spec - -o{ t_doc_spec_amount : doc_spec_id @enduml PlantUML version 1.2020.12(Sat Jun 06 10:54:15 UTC 2020) (GPL source distribution) Java Runtime: Java(TM) SE Runtime Environment JVM: Java HotSpot(TM) 64-Bit Server VM Default Encoding: UTF-8 Language: en Country: US --> 2) According to the application logic, we have a class structure... <!--MD5=[f38cdfa93a4420874a477654256d5f0f] class Doc--> Doc long DocId DateTime DocDate string Numb <!--MD5=[c3682c00519be24b748d419855c05489] class DocSpec--> DocSpec long DocSpecId long DocId <!--MD5=[894442645724153f40a9f7a43026dbfc] class Invoice--> Invoice decimal Amount InvoiceSpec[] Spec <!--MD5=[da5f0169623022e12a96aadf2be5bc74] class InvoiceSpec--> InvoiceSpec decimal Amount <!--MD5=[741b2ac005bca3f334b15562c9c82984] reverse link Doc to Invoice--> <!--MD5=[790b08f7f34e4d01ba6cceac3d1b6d1f] reverse link DocSpec to InvoiceSpec--> <!--MD5=[63e17fbfafe6c8b9398044e8eea0dca8] reverse link Doc to DocSpec--> <!--MD5=[ece9c93eb4644dbe024812fb02b184b4] @startuml hide circle skinparam ClassHeaderBackgroundColor white skinparam ClassBorderColor black skinparam ClassBorderThickness 1 skinparam ClassBackgroundColor transparent skinparam ArrowFontSize 8 skinparam ArrowColor black class Doc { long DocId - - DateTime DocDate string Numb } class DocSpec { long DocSpecId - - long DocId } class Invoice { - - decimal Amount InvoiceSpec[] Spec } class InvoiceSpec { - - decimal Amount } Doc <|- - Invoice DocSpec <|- - InvoiceSpec Doc *-right- DocSpec @enduml PlantUML version 1.2020.12(Sat Jun 06 10:54:15 UTC 2020) (GPL source distribution) Java Runtime: Java(TM) SE Runtime Environment JVM: Java HotSpot(TM) 64-Bit Server VM Default Encoding: UTF-8 Language: en Country: US --> 3) Mapping Doc and DocSpec are understandable (for those who dont know how mapping is done in XData it is recommended to read the first lesson first) using System.Linq.Expressions; using XData; using XData.Mapping.Dynamic; namespace <..Your namespace..>.Models { public partial class Doc : IDataObject { private static Expression<CustomMapping<Doc>> _ = () => XDataMapping.CustomMapping<Doc>() .DataTable(\"T_DOC\", \"D\") .DataTable(\"T_DOC_DATE\", \"DD\", x => x.Link(\"D\", \"doc_id\"), x => x.ConstFilter(\"DocDate\", \"date_kind\", DocDateKind.DocDate)) .ReadOnlyProperty(x => x.DocId, x => x.Field<long>(\"D\", string.Empty, z => z.Key(), z => z.Default(DefaultType.AutoIncrement))) .Map(x => new Doc { DocDate = x.Field<DateTime>(\"DD\", string.Empty), Numb = x.Field<string>(\"D\", string.Empty) }).SetBaseTable(\"D\"); } } using System.Linq.Expressions; using XData; using XData.Mapping.Dynamic; namespace <..Your namespace..>.Models { public partial class DocSpec : IDataObject { private static Expression<CustomMapping<DocSpec>> _ = () => XDataMapping.CustomMapping<DocSpec>() .DataTable(\"T_DOC_SPEC\", \"DS\") .ReadOnlyProperty(x => x.DocSpecId, x => x.Field<long>(\"DS\", string.Empty, z => z.Key(), z => z.Default(DefaultType.AutoIncrement))) .Map(x => new DocSpec { DocId = x.Field<long>(\"DS\", string.Empty), }).SetBaseTable(\"DS\"); } } 4) Add InvoiceSpec mapping using System.Linq.Expressions; using XData; using XData.Mapping.Dynamic; namespace <..Your namespace..>.Models { public partial class InvoiceSpec : IDataObject { private static Expression<CustomMapping<InvoiceSpec>> _ = () => XDataMapping.UseMapping<InvoiceSpec>() .DataTable(\"T_DOC_SPEC_AMOUNT\", \"SA\", \"DS\", x => x.Link(\"DS\", \"doc_spc_id\")) .Map(x => new InvoiceSpec{ Amount = x.Field<decimal>(\"SA\", string.Empty) }); } } * Of course, in this case there was absolutely no reason to use inheritance, but for training purposes... 5) Here, the only new but very important thing for us is the use of the XDataMapping.UseMapping method to initiate mapping based on the mapping of the base class. 6) Add Invoice mapping using System.Linq.Expressions; using XData; using XData.Mapping.Dynamic; namespace <..Your namespace..>.Models { public partial class Invoice : Doc { private static Expression<CustomMapping<Invoice>> _ = () => XDataMapping.UseMapping<Invoice>() .Subquery<DocSpecAmount>(\"A\", x => x.GetProperty(\"Amount\"), DataGrouping.Sum, x => x.SubqueryLink(z => z.DocId)) .ReadOnlyProperty(x => x.Amount, x => x.Expr<decimal?>(null, DataExpressionType.SubQuery, \"A\", DbType.Decimal, z => z.Size(17, 5))) .Map(); } } 7) Add service object DocSpecAmount to use in Subquery defining public class DocSpecAmount: ISqlObject { private static Expression<CustomMapping<DocSpecAmount>> _ = ( () => XDataMapping.CustomMapping<DocSpecAmount>() .DataTable(\"T_DOC_SPEC\", \"DS\") .DataTable(\"T_DOC_SPEC_AMOUNT\", \"SA\", \"DS\", x => x.Link(\"DS\", \"doc_spc_id\")) .Column(\"DocId\", x => x.Field<long>(\"DS\", string.Empty, z => z.Hidden())) .Column(\"Amount\", x => x.Field<decimal>(\"SA\", string.Empty)) .Map().SetBaseTable(\"DS\")); }"
  },
  "quick_start/intro.html": {
    "href": "quick_start/intro.html",
    "title": "Introduction | XData website",
    "keywords": "Introduction This section is organized a little differently compared to the rest of the documentation, which is organized as a reference and answers the question What is implemented in XData?. This section is divided into lessons and answers the question \"How to use XData in a particular case?\". The number of lessons will gradually grow and topics of future lessons depend on the people who order them. Suggest topics that interest you and as far as possible they will be covered in new lessons... A few words about how the lessons will be built and what will be in them and what will not be in them: The lessons will focus solely on the use of XData and will assume that the reader learns about using other packages and technologies from other sources and during the lessons it will be assumed that he will already know how to use them Theoretical questions regarding XData will be given in the form of links to documentation. Here we will consider just a concrete example without thinking about why so and how otherwise. Answers to such questions are described as far as possible in the main part of documentation"
  },
  "index.html": {
    "href": "index.html",
    "title": "XData | XData website",
    "keywords": "XData XData is .Net domain object oriented data access layer component. It is not \"yet another ORM\", but a complete feature rich data access layer for Your solutions. Basic idea to create this component was a suppling high quality tool to professional developers, having deep competences in data storage modeling and access. version 1.2.0 Nuget packages XData Data Access Layer package XData WorkSet (UnitOfWork) package - required to use XData WorkSet (UnitOfWork) implementation XData Security package - ISecuritySession interface implementation helper required to use XData security functionality XData Three-tier client proxy package - client proxy to use in three-tier environment (Net 4.0 version only, required full Net 4.0 Framework version) XData Cache package - time limited object caching (Net 4.0 version only, required full Net 4.0 Framework version. Net Standard 2.0 version does not require additional packages) XData MsSqlSever adapter package - Ms SQL Server database dialect and adapter XData Oracle adapter package - Oracle database dialect and adapter based on Oracle ODP provider XData PostgreSql adapter package - PostgreSQL database dialect and adapter based on NpgSql provider XData SQLite adapter package - SQLite database dialect and adapter (Net 4.0 version has used System.Data.SQLite provider, Net Standard 2.0 version has used Microsoft.Data.Sqlite provider) XData MySql adapter package - MySQL database dialect and adapter based on MySql.Data provider XData net 4.0 System.Diagnostics.Trace log writer package - (Net 4.0 only) Log writer over System.Diagnostics.Trace XData net 4.0 log4net log writer package - (Net 4.0 only) Log writer over Log4Net XData net 4.0 Inversion of Control container package - Support for registering logic modules using the IoC container (Net 4.0 version only, required full Net 4.5 Framework version). Any IoC container with IDependencyResolver interface implementation is supported. Net Standard 2.0 version does not require additional packages since .Net Standard has built-in support for IoC containers XData net standard 2.0 Asynchronous Disposable support package - Support for IAsyncDisposable interface for disposable objects (Net Standard 2.0 version only, required Net Standard 2.1 specification version support) XData net standard 2.0 Asp.Net Core HealthChecks support package - Support for Asp.Net Core HealthChecks (Net Standard 2.0 version only, required Net Standard 2.1 specification version support) Plugins Net 4.0 XData net 4.0 Three-tier server Net Standard 2.0 XData Net Standard 2.0 has no plugins. Three-tier architecture is currently not supported in Net Standard 2.0 version. Online documentation Online documentation PDF documentation PDF documentation Contacts Denis Dawydenko AKA Mick Fierte  d.dawydenko@gmail.com Thanx Special thank to my friends who help me to make it project possible with supporting me, great ideas, working problem solutions and laborious testing: Alex Lukinov Andrew Ustinov Stanislav Kovanovsky Pavel Kryukov Max Lapotkov Olzhas Khalelov"
  },
  "RELEASENOTE.html": {
    "href": "RELEASENOTE.html",
    "title": "Version Notes (Current Version: v1.2.0) | XData website",
    "keywords": "Version Notes (Current Version: v1.2.0) 1.2.0 SQL Blocks is now supported IAsyncDisposable is now supported Asp.Net Core HealthChecks is now supported Using DI containers for trigger logic modules Using hierarchical organized objects Mapping inheritance Bugs are fixed, algorithms are improved 1.1.0 .Net Standard 2.0 version released MySql is now supported XML data sources is now supported in dynamic queries Local temporary tables is now supported in dynamic queries JSON serialization without DTO Lot of bugs are fixed Documentation is available now 1.0.0 Initially published (deprecated now)"
  },
  "tutorial/mapping/static/procedure/sample_udt.html": {
    "href": "tutorial/mapping/static/procedure/sample_udt.html",
    "title": "SQL procedure with UDT parameter sample | XData website",
    "keywords": "SQL procedure with UDT parameter sample MS SQL Server Not supported Tip MS SQL Server does not support passing single UDT object as a parameter value, but support array of UDT Oracle Not supported Warning Oracle ODP.Net provider does not support UDT PostgreSQL CREATE TYPE public.classifier_rec AS ( Id integer, Name varchar(20) ); CREATE or REPLACE function TestFunction5(p_obj classifier_rec) returns varchar as $$ begin return p_obj.Id || ' - ' || p_obj.Name; end $$ LANGUAGE plpgsql; MySQL Not supported Mapping /* Type mapped to UDT required to be Xml serializable */ [Serializable] public class Classifier { [XmlAttribute] public int Id { get; set; } [XmlAttribute] public string Name { get; set; } } ... [DataObject(\"T\"), Procedure(\"T\", \"TestFunction5\", ProcedureType.Function), Parameter(\"T\", 1, \"p_obj\", typeof(Classifier), DbType.Object, UdtTypeName = \"classifier_rec\" /* Full qualified name of UDT */ ), Parameter(\"T\", 2, \"Result\", typeof(string), DbType.String, Size = 20, Direction = ParameterDirection.ReturnValue)] public class TestFunction5 : IDataObject { public string Result => this.GetParameter(x => x.Result); }"
  },
  "tutorial/mapping/static/procedure/sample_table_func.html": {
    "href": "tutorial/mapping/static/procedure/sample_table_func.html",
    "title": "SQL table valued function as query sample | XData website",
    "keywords": "SQL table valued function as query sample MS SQL Server CREATE FUNCTION [dbo].[TestFunction] ( @param1 int, @param2 varchar(20) ) RETURNS TABLE AS RETURN ( SELECT @param1 as Id, @param2 as Name ) Oracle CREATE OR REPLACE type classifier_rec is object (Id int, Name varchar2(20)); CREATE OR REPLACE type classifier_tab is table of classifier_rec; function TestFunction(p_Id int, p_Name varchar2) return classifier_tab pipelined is begin for curr in (select p_Id as Id, p_Name as Name from dual) loop pipe row (classifier_rec(curr.Id, curr.Name)); end loop; end TestFunction; PostgreSQL CREATE or REPLACE function TestFunction(p_id integer, p_name varchar) returns TABLE ( Id bigint, Name varchar ) as $$ select p_id as Id, p_name as Name; $$ LANGUAGE SQL; ... or with the same mapping syntax... CREATE TYPE public.classifier_rec AS ( Id integer, Name varchar(20) ); CREATE or REPLACE function TestFunction(p_Id integer, p_Name varchar) returns setof classifier_rec as $$ select p_Id as Id, p_Name as Name; $$ LANGUAGE SQL; MySQL Not supported Mapping [DataObject(\"T\"), Procedure(\"T\", \"dbo.TestFunction\", ProcedureType.Function), Parameter(\"T\", 1, \"param1\", typeof(int), DbType.Int32), Parameter(\"T\", 2, \"param2\", typeof(string), DbType.String), ResultSet(\"T\")] public class TestFunction : IDataObject { [Property(\"T\", \"Id\", Flags = DataPropertyFlag.Id)] public int Id { get { return this.GetProperty(x => x.Id); } } [Property(\"T\", \"Name\")] public string Name { get { return this.GetProperty(x => x.Name); } } } Mapping table function with joined table [DataObject(\"D\"), Procedure(\"T\", \"dbo.TestFunction\", ProcedureType.Function), Parameter(\"T\", 1, \"param1\", typeof(int), DbType.Int32), Parameter(\"T\", 2, \"param2\", typeof(string), DbType.String), ResultSet(\"T\"), DataTable(\"T_DOC_TYPE\", \"D\"), Link(\"D\", \"doc_type_id\", \"T\", \"Id\")] public class TestFunctionJoin : IDataObject { [Property(\"T\", \"Id\", Flags = DataPropertyFlag.Id)] public int Id { get; set; } [Property(\"T\", \"Name\")] public string Name { get; set; } [Property(\"D\", \"Code\")] public string Code { get; set; } }"
  },
  "tutorial/mapping/static/procedure/sample_scalar_func.html": {
    "href": "tutorial/mapping/static/procedure/sample_scalar_func.html",
    "title": "SQL scalar function as property data source sample | XData website",
    "keywords": "SQL scalar function as property data source sample MS SQL Server CREATE FUNCTION [dbo].[TestFunction2] ( @param1 int, @param2 varchar(20) ) RETURNS varchar(20) AS BEGIN DECLARE @res varchar(20) SET @res = convert(varchar(20), @param1) + ' - ' + @param2 RETURN @res END Oracle function TestFunction2(p_Id int, p_Name varchar2) return varchar2 is begin return p_Id || ' - ' || p_Name; end TestFunction2; PostgreSQL CREATE or REPLACE function TestFunction2(p_id integer, p_name varchar) returns varchar as $$ DECLARE ret varchar; begin select p_id || ' - ' || p_name into ret; return ret; end $$ LANGUAGE plpgsql; MySQL create function TestFunction2(p_Id int, p_Name varchar(20)) returns varchar(100) begin declare res varchar(100); select CONCAT(p_Id, ' - ', p_Name) into res; return(res); end Mapping [DataObject(\"T\"), DataTable(\"T_DOC_TYPE\", \"T\"), Column(\"DocTypeId\", typeof(long), Flags = DataPropertyFlag.Id)] public class TestFunction4 : IDataObject { [Property(\"T\")] public string Code { get; set; } [Property(\"T\")] public string Name { get; set; } [Property, // Property expression attribute \"name\" is the name of private static field // with type Calculate<string> and attributed by SqlExpressionAttribute PropertyExpression(\"test\", DataExpressionType.LinqExpression, ExprSize = 20)] public string Test { get { return this.GetProperty(x => x.Test); } } // Private static field with type Calculate<string> and attributed by // SqlExpressionAttribute [SqlExpression] private static Calculate<string> test z => z.SqlFn<string>(\"dbo.TestFunction2\", y => y.Field<long>(\"T\", \"doc_type_id\"), y => y.Field<string>(\"T\", \"name\")) }"
  },
  "tutorial/mapping/static/property/column.html": {
    "href": "tutorial/mapping/static/property/column.html",
    "title": "Hidden properties | XData website",
    "keywords": "Hidden properties Hidden properties statically defined using couple of specific attributes: ColumnAttribute , ColumnExpressionAttribute and ColumnDefaultAttribute as analog with similar attributes of properties . ColumnAttribute has parameters: PropertyName - name of hidden property, PropertyType - type of hidden property, Source - data source alias, FieldName - optional, DB field name (can be omitted when correspond default mapping rule (example: some_field_name is mapped to SomeFieldName )), Flags - optional, bit mask of property flags , Grouping - optional, defined aggregation type , default is None , GroupOrder - optional, group order when Grouping = DataGrouping . None , Hidden - optional, mapped field omitted in SELECT expression of result query (when grouping limitations demand this), default is false , NativeSqlType - optional, native SQL type name. NativeSqlType is used when default data type mapping is conflicted with result set data type. ColumnExpressionAttribute has parameters: PropertyName - name of hidden property (same as defined by ColumnAttribute ), ExprText - depends on ExprType (see below): subquery alias / SQL expression text / field name with LINQ style expression definition, ExprType - optional, SQL expression type default is DataExpressionType . PlainSql , DbType - data type on ADO .Net provider level (optional, default is DbType . String ), ExprSize - optional, expression field size (if applicable), ExprScale - optional, expression field precision (if applicable). ColumnDefaultAttribute has parameters: PropertyName - hidden property name (same as defined by ColumnAttribute ), DefaultSource - default value type , DefaultValue optional, depends on DefaultSource , DefaultFeature - optional, default is DefaultFeature.UseOnInsert , default value assignment will be applied with some extended features . [Column(\"DocId\", typeof(long?), \"D\", Flags = DataPropertyFlag.Id), ColumnDefault(\"DocId\", DefaultType.AutoIncrement)]"
  },
  "tutorial/mapping/static/procedure/source.html": {
    "href": "tutorial/mapping/static/procedure/source.html",
    "title": "SQL procedure as query | XData website",
    "keywords": "SQL procedure as query To define procedure as data source of mapping used ProcedureAttribute with parameters: Alias - procedure alias, Name - procedure or function name, ProcedureType - ProcedureType : ProcedureType . Procedure or ProcedureType . Function ."
  },
  "tutorial/mapping/static/procedure/sample_udt_array.html": {
    "href": "tutorial/mapping/static/procedure/sample_udt_array.html",
    "title": "SQL procedure with UDT array parameter sample | XData website",
    "keywords": "SQL procedure with UDT array parameter sample MS SQL Server CREATE TYPE [dbo].[Classifier] AS TABLE( [Id] [int] NULL, [Name] [varchar](20) NULL ) CREATE PROCEDURE [dbo].[TestProcedure7] (@param1 Classifier READONLY) AS SELECT * from @param1 Oracle Not supported Warning Oracle ODP.Net provider does not support UDT PostgreSQL CREATE TYPE public.classifier_rec AS ( Id integer, Name varchar(20) ); CREATE or REPLACE function TestProcedure7(p_tab classifier_rec[]) returns setof classifier_rec as $$ select a.Id, a.Name from unnest(p_tab) a; $$ LANGUAGE sql; MySQL Not supported Mapping /* Type mapped to UDT required to be Xml serializable */ [Serializable] public class Classifier { [XmlAttribute] public int Id { get; set; } [XmlAttribute] public string Name { get; set; } } ... [DataObject(\"T\"), Procedure(\"T\", \"dbo.TestProcedure7\", ProcedureType.Procedure), Parameter(\"T\", 1, \"param1\", typeof(Classifier[]) /* Parameter type must be an array of mapped type */, DbType.Object, UdtTypeName = \"dbo.Classifier\" /* Full qualified name of UDT */ ), ResultSet(\"T\")] public class TestProcedure7 : IDataObject { [Property(\"T\", \"Id\", Flags = DataPropertyFlag.Id)] public int Id => this.GetProperty(x => x.Id); [Property(\"T\", \"Name\")] public string Name => this.GetProperty(x => x.Name); }"
  },
  "tutorial/mapping/static/procedure/sample_cursor.html": {
    "href": "tutorial/mapping/static/procedure/sample_cursor.html",
    "title": "SQL procedure result set as query sample | XData website",
    "keywords": "SQL procedure result set as query sample MS SQL Server CREATE PROCEDURE [dbo].[TestProcedure] ( @param1 int, @param2 varchar(20) ) AS SELECT @param1 as Id, @param2 as Name Oracle procedure TestProcedure(p_Id int, p_Name varchar2, p_Out out SYS_REFCURSOR) as begin open p_Out for select p_Id as Id, p_Name as Name from dual; end TestProcedure; PostgreSQL CREATE OR REPLACE FUNCTION public.TestProcedure (p_id integer, p_name varchar, refcursor) RETURNS refcursor AS $$ begin open $3 for select p_id as Id, p_name as Name; return $3; end $$ LANGUAGE plpgsql; MySQL create procedure TestProcedure(p_Id int, p_Name varchar(50)) begin select p_Id as Id, p_Name as Name; end Mapping [DataObject(\"T\"), Procedure(\"T\", \"dbo.TestProcedure\", ProcedureType.Procedure), Parameter(\"T\", 1, \"param1\", typeof(int), DbType.Int32), Parameter(\"T\", 2, \"param2\", typeof(string), DbType.String), ResultSet(\"T\")] public class TestProcedure : IDataObject { [Property(\"T\", \"Id\", Flags = DataPropertyFlag.Id)] public int Id { get { return this.GetProperty(x => x.Id); } } [Property(\"T\", \"Name\")] public string Name { get { return this.GetProperty(x => x.Name); } } }"
  },
  "tutorial/mapping/static/procedure/sample_array.html": {
    "href": "tutorial/mapping/static/procedure/sample_array.html",
    "title": "SQL procedure with simple array parameter sample | XData website",
    "keywords": "SQL procedure with simple array parameter sample MS SQL Server Not supported Oracle Not supported PostgreSQL CREATE or REPLACE function TestFunction6(p_arr INTEGER[]) returns integer as $$ begin return sum(s) from unnest(p_arr) s; end $$ LANGUAGE plpgsql; MySQL Not supported Mapping [DataObject(\"T\"), Procedure(\"T\", \"TestFunction\", ProcedureType.Function), Parameter(\"T\", 1, \"param1\", typeof(int[]), DbType.Int32, IsArray = true), Parameter(\"T\", 2, \"Result\", typeof(int), DbType.Int32, Direction = ParameterDirection.ReturnValue)] public class TestFunction : IDataObject { public int Result { get { return this.GetParameter(x => x.Result); } } }"
  },
  "tutorial/mapping/static/procedure/result.html": {
    "href": "tutorial/mapping/static/procedure/result.html",
    "title": "SQL procedure result set | XData website",
    "keywords": "SQL procedure result set To describe result set of SQL procedure used ResultSetAttribute with parameters: Alias - procedure alias, Name - result set name used inside application code, when result set is not mapped to procedure parameter set it to \"\" (empty string), Order - optional, order number of result set (required to procedures returns multiple result sets), ResultType - optional, mapped type of result set, default is attributed class itself, IsDefault - optional, result set is default - mapped to attributed class (used when procedure returns multiple result sets), default is false ."
  },
  "tutorial/mapping/static/procedure/procedure.html": {
    "href": "tutorial/mapping/static/procedure/procedure.html",
    "title": "SQL procedures & functions | XData website",
    "keywords": "SQL procedures & functions Common information about mapping to SQL procedures and functions has described in common mapping rules description and here we just represent static mapping rules for various procedure types. Warning SQLite not supported SQL procedures & functions Warning PostgreSql functions has restrictions: returning refcursor or set of refcursor requires transaction! parameters use lower case names ONLY! result set names (refcursor names) use lower case names ONLY! SQL procedure as query To define procedure as data source of mapping used ProcedureAttribute with parameters: Alias - procedure alias, Name - procedure or function name, ProcedureType - ProcedureType : ProcedureType . Procedure or ProcedureType . Function . SQL procedure parameter To define SQL procedure parameter used ParameterAttribute with parameters: Alias - procedure alias, Order - order number of parameter, Binding - name used inside application code (it's handy to use parameter with another name, not the name defined inside DB), Type - data type used inside application code, DbType - data type on ADO .Net provider level, Direction - optional, parameter direction, default is ParameterDirection . Input , Size - optional, parameter size(if applicable), Scale - optional, parameter precision (if applicable), Name - optional, parameter name, default is equal with Binding , DefaultType - default value type , DefaultValue optional, depends on DefaultType , NativeSqlType - optional, SQL type name ( NativeSqlType is used when type default mapping is conflicted with real SQL type), UdtTypeName - optional, user defined type (UDT), UdtElementTypeName - optional, user defined type (UDT) of UdtTypeName element (in case where UdtTypeName - array or table), IsArray - optional, parameter is array of UdtElementTypeName (when UdtElementTypeName is omitted, array of DbType ), default is false . SQL procedure result set To describe result set of SQL procedure used ResultSetAttribute with parameters: Alias - procedure alias, Name - result set name used inside application code, when result set is not mapped to procedure parameter set it to \"\" (empty string), Order - optional, order number of result set (required to procedures returns multiple result sets), ResultType - optional, mapped type of result set, default is attributed class itself, IsDefault - optional, result set is default - mapped to attributed class (used when procedure returns multiple result sets), default is false . SQL procedure result set as query sample MS SQL Server CREATE PROCEDURE [dbo].[TestProcedure] ( @param1 int, @param2 varchar(20) ) AS SELECT @param1 as Id, @param2 as Name Oracle procedure TestProcedure(p_Id int, p_Name varchar2, p_Out out SYS_REFCURSOR) as begin open p_Out for select p_Id as Id, p_Name as Name from dual; end TestProcedure; PostgreSQL CREATE OR REPLACE FUNCTION public.TestProcedure (p_id integer, p_name varchar, refcursor) RETURNS refcursor AS $$ begin open $3 for select p_id as Id, p_name as Name; return $3; end $$ LANGUAGE plpgsql; MySQL create procedure TestProcedure(p_Id int, p_Name varchar(50)) begin select p_Id as Id, p_Name as Name; end Mapping [DataObject(\"T\"), Procedure(\"T\", \"dbo.TestProcedure\", ProcedureType.Procedure), Parameter(\"T\", 1, \"param1\", typeof(int), DbType.Int32), Parameter(\"T\", 2, \"param2\", typeof(string), DbType.String), ResultSet(\"T\")] public class TestProcedure : IDataObject { [Property(\"T\", \"Id\", Flags = DataPropertyFlag.Id)] public int Id { get { return this.GetProperty(x => x.Id); } } [Property(\"T\", \"Name\")] public string Name { get { return this.GetProperty(x => x.Name); } } } SQL procedure with multiple result sets sample MS SQL Server CREATE PROCEDURE [dbo].[TestProcedure2] ( @param1 int, @param2 varchar(20), @param3 int, @param4 varchar(20) ) AS BEGIN SELECT @param1 as Id, @param2 as Name SELECT @param3 as Id, @param4 as Name END Oracle procedure TestProcedure2(p_Id int, p_Name varchar2, p_Out out SYS_REFCURSOR, p_Out2 out SYS_REFCURSOR) as begin open p_Out for select p_Id as Id, p_Name as Name from dual; open p_Out2 for select p_Id as Id, p_Name as Name from dual; end TestProcedure2; Tip Use refcursor parameters names as ResultSet names! PostgreSQL CREATE OR REPLACE FUNCTION public.TestProcedure2 (p_id integer, p_name varchar, refcursor, refcursor) RETURNS SETOF refcursor AS $$ begin open $3 for select p_id as Id, p_name as Name; return NEXT $3; open $4 for select p_id as Id, p_name as Name; return NEXT $4; end $$ LANGUAGE plpgsql; Warning Functions witch returns setof refcursor is not supported by NpgSql .Net Standard 2.0 Edition :( XData net4.0 version can call that type functions with the same mapping rules as described here... Tip If refcursor parameters have a names it must be used as ResultSet names! MySQL create procedure TestProcedure2(p_Id int, p_Name varchar(50)) begin select p_Id as Id, p_Name as Name; select p_Id as Id, p_Name as Name; end Mapping [DataObject(\"T\"), Procedure(\"T\", \"dbo.TestProcedure2\", ProcedureType.Procedure), Parameter(\"T\", 1, \"param1\", typeof(int), DbType.Int32), Parameter(\"T\", 2, \"param2\", typeof(string), DbType.String), Parameter(\"T\", 3, \"param3\", typeof(int), DbType.Int32), Parameter(\"T\", 4, \"param4\", typeof(string), DbType.String), ResultSet(\"T\", IsDefault = true), ResultSet(\"T\", \"SecondResult\", ResultType = typeof(TestResult), Order = 2)] public class TestProcedure2 : IDataObject { [Property(\"T\", \"Id\", Flags = DataPropertyFlag.Id)] public int Id { get { return this.GetProperty(x => x.Id); } } [Property(\"T\", \"Name\")] public string Name { get { return this.GetProperty(x => x.Name); } } public IEnumerable<TestResult> SecondResult { get { return this.GetResultSet(x => x.SecondResult); } } } SQL procedure with out parameter sample MS SQL Server CREATE PROCEDURE [dbo].[TestProcedure3] ( @param1 int, @param2 varchar(20), @param3 varchar(20) OUTPUT ) AS SET @param3 = convert(varchar(20), @param1) + ' - ' + @param2 RETURN Oracle procedure TestProcedure3(p_Id int, p_Name varchar2, p_Out out varchar2) as begin select p_Id || ' - ' || p_Name into p_Out from dual; end TestProcedure3; PostgreSQL CREATE or REPLACE function TestProcedure3(p_id integer, p_name varchar, out p_out varchar) as $$ begin p_Out := p_id || ' - ' || p_name; end $$ LANGUAGE plpgsql; MySQL create procedure TestProcedure3(p_Id int, p_Name varchar(50), out p_Out varchar(100)) begin set p_Out = CONCAT(p_Id, ' - ', p_Name); end Mapping [DataObject(\"T\"), Procedure(\"T\", \"dbo.TestProcedure3\", ProcedureType.Procedure), Parameter(\"T\", 1, \"param1\", typeof(int), DbType.Int32), Parameter(\"T\", 2, \"param2\", typeof(string), DbType.String), Parameter(\"T\", 3, \"OutParameter\", typeof(string), DbType.String, Size = 20, Direction = ParameterDirection.Output, Name = \"param3\")] public class TestProcedure3 : IDataObject { public string OutParameter { get { return this.GetParameter(x => x.OutParameter); } } } SQL procedure with out parameter and result set sample MS SQL Server CREATE PROCEDURE [dbo].[TestProcedure4] ( @param1 int, @param2 varchar(20) ) AS SELECT @param1 as Id, @param2 as Name RETURN(@param1) Oracle procedure TestProcedure4(p_Tab in classifier_tab, p_Out out SYS_REFCURSOR) as begin open p_Out for select Id, Name from table(p_Tab); end TestProcedure4; Tip Use refcursor parameters names as ResultSet names! PostgreSQL CREATE OR REPLACE FUNCTION public.TestProcedure4 (p_tab public.classifier_rec [], refcursor) RETURNS refcursor AS $$ begin open $2 for select Id, Name from unnest(p_tab); return $2; end $$ LANGUAGE plpgsql; Tip If refcursor parameters have a names it must be used as ResultSet names! MySQL Not supported Mapping [DataObject(\"T\"), Procedure(\"T\", \"dbo.TestProcedure4\", ProcedureType.Procedure), Parameter(\"T\", 1, \"param1\", typeof(int), DbType.Int32), Parameter(\"T\", 2, \"param2\", typeof(string), DbType.String), Parameter(\"T\", 3, \"OutParameter\", typeof(string), DbType.String, Size = 20, Direction = ParameterDirection.Output, Name = \"param3\"), ResultSet(\"T\")] public class TestProcedure4 : IDataObject { [Property(\"T\", \"Id\", Flags = DataPropertyFlag.Id)] public int Id { get { return this.GetProperty(x => x.Id); } } [Property(\"T\", \"Name\")] public string Name { get { return this.GetProperty(x => x.Name); } } public string OutParameter { get { return this.GetParameter(x => x.OutParameter); } } } SQL procedure with return value sample MS SQL Server CREATE PROCEDURE [dbo].[TestProcedure5] ( @param1 int, @param2 varchar(20) ) AS RETURN(@param1) Oracle Not supported PostgreSQL Not supported MySQL Not supported Mapping [DataObject(\"T\"), Procedure(\"T\", \"dbo.TestProcedure5\", ProcedureType.Procedure), Parameter(\"T\", 1, \"param1\", typeof(int), DbType.Int32), Parameter(\"T\", 2, \"param2\", typeof(string), DbType.String), Parameter(\"T\", 3, \"ReturnValue\", typeof(string), DbType.String, Size = 20, Direction = ParameterDirection.ReturnValue, Name = \"result\")] public class TestProcedure5 : IDataObject { public string ReturnValue { get { return this.GetParameter(x => x.ReturnValue); } } } SQL procedure with return value and result set sample MS SQL Server MS SQL Server CREATE PROCEDURE [dbo].[TestProcedure6] ( @param1 int, @param2 varchar(20) ) AS SELECT @param1 as Id, @param2 as Name RETURN(@param1) Oracle Not supported PostgreSQL Not supported MySQL Not supported Mapping [DataObject(\"T\"), Procedure(\"T\", \"dbo.TestProcedure6\", ProcedureType.Procedure), Parameter(\"T\", 1, \"param1\", typeof(int), DbType.Int32), Parameter(\"T\", 2, \"param2\", typeof(string), DbType.String), Parameter(\"T\", 3, \"ResultParameter\", typeof(int), DbType.Int32, Direction = ParameterDirection.ReturnValue), ResultSet(\"T\")] public class TestProcedure6 : IDataObject { [Property(\"T\", \"Id\", Flags = DataPropertyFlag.Id)] public int Id { get { return this.GetProperty(x => x.Id); } } [Property(\"T\", \"Name\")] public string Name { get { return this.GetProperty(x => x.Name); } } public int ResultParameter { get { return this.GetParameter(x => x.ResultParameter); } } } SQL procedure with simple array parameter sample MS SQL Server Not supported Oracle Not supported PostgreSQL CREATE or REPLACE function TestFunction6(p_arr INTEGER[]) returns integer as $$ begin return sum(s) from unnest(p_arr) s; end $$ LANGUAGE plpgsql; MySQL Not supported Mapping [DataObject(\"T\"), Procedure(\"T\", \"TestFunction\", ProcedureType.Function), Parameter(\"T\", 1, \"param1\", typeof(int[]), DbType.Int32, IsArray = true), Parameter(\"T\", 2, \"Result\", typeof(int), DbType.Int32, Direction = ParameterDirection.ReturnValue)] public class TestFunction : IDataObject { public int Result { get { return this.GetParameter(x => x.Result); } } } SQL procedure with UDT parameter sample MS SQL Server Not supported Tip MS SQL Server does not support passing single UDT object as a parameter value, but support array of UDT Oracle Not supported Warning Oracle ODP.Net provider does not support UDT PostgreSQL CREATE TYPE public.classifier_rec AS ( Id integer, Name varchar(20) ); CREATE or REPLACE function TestFunction5(p_obj classifier_rec) returns varchar as $$ begin return p_obj.Id || ' - ' || p_obj.Name; end $$ LANGUAGE plpgsql; MySQL Not supported Mapping /* Type mapped to UDT required to be Xml serializable */ [Serializable] public class Classifier { [XmlAttribute] public int Id { get; set; } [XmlAttribute] public string Name { get; set; } } ... [DataObject(\"T\"), Procedure(\"T\", \"TestFunction5\", ProcedureType.Function), Parameter(\"T\", 1, \"p_obj\", typeof(Classifier), DbType.Object, UdtTypeName = \"classifier_rec\" /* Full qualified name of UDT */ ), Parameter(\"T\", 2, \"Result\", typeof(string), DbType.String, Size = 20, Direction = ParameterDirection.ReturnValue)] public class TestFunction5 : IDataObject { public string Result => this.GetParameter(x => x.Result); } SQL procedure with UDT array parameter sample MS SQL Server CREATE TYPE [dbo].[Classifier] AS TABLE( [Id] [int] NULL, [Name] [varchar](20) NULL ) CREATE PROCEDURE [dbo].[TestProcedure7] (@param1 Classifier READONLY) AS SELECT * from @param1 Oracle Not supported Warning Oracle ODP.Net provider does not support UDT PostgreSQL CREATE TYPE public.classifier_rec AS ( Id integer, Name varchar(20) ); CREATE or REPLACE function TestProcedure7(p_tab classifier_rec[]) returns setof classifier_rec as $$ select a.Id, a.Name from unnest(p_tab) a; $$ LANGUAGE sql; MySQL Not supported Mapping /* Type mapped to UDT required to be Xml serializable */ [Serializable] public class Classifier { [XmlAttribute] public int Id { get; set; } [XmlAttribute] public string Name { get; set; } } ... [DataObject(\"T\"), Procedure(\"T\", \"dbo.TestProcedure7\", ProcedureType.Procedure), Parameter(\"T\", 1, \"param1\", typeof(Classifier[]) /* Parameter type must be an array of mapped type */, DbType.Object, UdtTypeName = \"dbo.Classifier\" /* Full qualified name of UDT */ ), ResultSet(\"T\")] public class TestProcedure7 : IDataObject { [Property(\"T\", \"Id\", Flags = DataPropertyFlag.Id)] public int Id => this.GetProperty(x => x.Id); [Property(\"T\", \"Name\")] public string Name => this.GetProperty(x => x.Name); } SQL table valued function as query sample MS SQL Server CREATE FUNCTION [dbo].[TestFunction] ( @param1 int, @param2 varchar(20) ) RETURNS TABLE AS RETURN ( SELECT @param1 as Id, @param2 as Name ) Oracle CREATE OR REPLACE type classifier_rec is object (Id int, Name varchar2(20)); CREATE OR REPLACE type classifier_tab is table of classifier_rec; function TestFunction(p_Id int, p_Name varchar2) return classifier_tab pipelined is begin for curr in (select p_Id as Id, p_Name as Name from dual) loop pipe row (classifier_rec(curr.Id, curr.Name)); end loop; end TestFunction; PostgreSQL CREATE or REPLACE function TestFunction(p_id integer, p_name varchar) returns TABLE ( Id bigint, Name varchar ) as $$ select p_id as Id, p_name as Name; $$ LANGUAGE SQL; ... or with the same mapping syntax... CREATE TYPE public.classifier_rec AS ( Id integer, Name varchar(20) ); CREATE or REPLACE function TestFunction(p_Id integer, p_Name varchar) returns setof classifier_rec as $$ select p_Id as Id, p_Name as Name; $$ LANGUAGE SQL; MySQL Not supported Mapping [DataObject(\"T\"), Procedure(\"T\", \"dbo.TestFunction\", ProcedureType.Function), Parameter(\"T\", 1, \"param1\", typeof(int), DbType.Int32), Parameter(\"T\", 2, \"param2\", typeof(string), DbType.String), ResultSet(\"T\")] public class TestFunction : IDataObject { [Property(\"T\", \"Id\", Flags = DataPropertyFlag.Id)] public int Id { get { return this.GetProperty(x => x.Id); } } [Property(\"T\", \"Name\")] public string Name { get { return this.GetProperty(x => x.Name); } } } Mapping table function with joined table [DataObject(\"D\"), Procedure(\"T\", \"dbo.TestFunction\", ProcedureType.Function), Parameter(\"T\", 1, \"param1\", typeof(int), DbType.Int32), Parameter(\"T\", 2, \"param2\", typeof(string), DbType.String), ResultSet(\"T\"), DataTable(\"T_DOC_TYPE\", \"D\"), Link(\"D\", \"doc_type_id\", \"T\", \"Id\")] public class TestFunctionJoin : IDataObject { [Property(\"T\", \"Id\", Flags = DataPropertyFlag.Id)] public int Id { get; set; } [Property(\"T\", \"Name\")] public string Name { get; set; } [Property(\"D\", \"Code\")] public string Code { get; set; } } SQL scalar function as property data source sample MS SQL Server CREATE FUNCTION [dbo].[TestFunction2] ( @param1 int, @param2 varchar(20) ) RETURNS varchar(20) AS BEGIN DECLARE @res varchar(20) SET @res = convert(varchar(20), @param1) + ' - ' + @param2 RETURN @res END Oracle function TestFunction2(p_Id int, p_Name varchar2) return varchar2 is begin return p_Id || ' - ' || p_Name; end TestFunction2; PostgreSQL CREATE or REPLACE function TestFunction2(p_id integer, p_name varchar) returns varchar as $$ DECLARE ret varchar; begin select p_id || ' - ' || p_name into ret; return ret; end $$ LANGUAGE plpgsql; MySQL create function TestFunction2(p_Id int, p_Name varchar(20)) returns varchar(100) begin declare res varchar(100); select CONCAT(p_Id, ' - ', p_Name) into res; return(res); end Mapping [DataObject(\"T\"), DataTable(\"T_DOC_TYPE\", \"T\"), Column(\"DocTypeId\", typeof(long), Flags = DataPropertyFlag.Id)] public class TestFunction4 : IDataObject { [Property(\"T\")] public string Code { get; set; } [Property(\"T\")] public string Name { get; set; } [Property, // Property expression attribute \"name\" is the name of private static field // with type Calculate<string> and attributed by SqlExpressionAttribute PropertyExpression(\"test\", DataExpressionType.LinqExpression, ExprSize = 20)] public string Test { get { return this.GetProperty(x => x.Test); } } // Private static field with type Calculate<string> and attributed by // SqlExpressionAttribute [SqlExpression] private static Calculate<string> test z => z.SqlFn<string>(\"dbo.TestFunction2\", y => y.Field<long>(\"T\", \"doc_type_id\"), y => y.Field<string>(\"T\", \"name\")) }"
  },
  "tutorial/mapping/static/filter/sql_expr.html": {
    "href": "tutorial/mapping/static/filter/sql_expr.html",
    "title": "SQL expression filters | XData website",
    "keywords": "SQL expression filters To define filter over SQL expression used ExpressionFilterAttribute with specific (over described above ) parameter: ExpressionText - depends on value can be: subquery alias, [ExpressionFilter(\"P\" /* table alias */, \"discount\" /* field name */, \"D\" /* ExpressionText: subquery alias */, Operation: FilterOperation.In /* filter operation */)] private static field name contains dynamic definition of SQL expression, [ExpressionFilter(\"P\" /* table alias */, \"discount\" /* field name */, \"AllowedDiscount\" /* ExpressionText: SQL expression description field name */, Operation: FilterOperation.NotEqual /* filter operation */)] ... //Private static field of mapped class marked with SqlExpression attribute [SqlExpression] private static Calculate<int> AllowedDiscount = x => x.Case<Product, int>( z => z.Field<bool>(\"is_vip\"), z => 0, 1.SetExpression(z => 10)); plain SQL expression text. [ExpressionFilter(\"P\" /* table alias */, \"discount\" /* field name */, \"case P.is_vip when 1 then 10 else 0 end\" /* ExpressionText: plain SQL expression */, Operation: FilterOperation.NotEqual /* filter operation */)] Important If possible do not use plain SQL expressions. It possibly use specific SQL dialect features not supported by other DBMS or providers."
  },
  "tutorial/mapping/static/filter/range.html": {
    "href": "tutorial/mapping/static/filter/range.html",
    "title": "Range filters | XData website",
    "keywords": "Range filters To define filter checks field value over array of values used RangeFilterAttribute with specific (over described above ) parameter: Range - array of values to filter on. [RangeFilter(\"P\" /* table alias */, \"discount\" /* field name */, new[] {0,5,10} /* range of values */, Operation: FilterOperation.In /* filter operation */)]"
  },
  "tutorial/mapping/static/filter/inner_links.html": {
    "href": "tutorial/mapping/static/filter/inner_links.html",
    "title": "Inner links | XData website",
    "keywords": "Inner links To define links between data sources inside query used LinkAttribute with specific parameters: LinkedSourceAlias - linked table alias, LinkedFieldName - linked table field name (optional, can be omitted when equals with FieldName ). Tip Inner links can be used to define optional filters . To specify role in optional filter chain need to set parameter PrimaryFilter to true . [Link(\"D\" /* table alias */, \"doc_id\" /* field name */, \"DD\" /* linked table alias */)]"
  },
  "tutorial/mapping/static/filter/group.html": {
    "href": "tutorial/mapping/static/filter/group.html",
    "title": "Filter group | XData website",
    "keywords": "Filter group Filter group can be defined by FilterCombinationAttribute with parameters: Name - filter group unique name, Combination - logical operation between filters and subgroups inside group (optional, default is FilterCombination . And ), Parent - parent filter group name (optional, can be omitted for filter groups with parent - root filter group). Logic operation inside filter group is defined by enum Combination : And - and Or - or [FilterCombination(\"OrGroup\" /* group filter name */, Combination: Combination.OR /* logical operation */)]"
  },
  "tutorial/mapping/static/filter/filter.html": {
    "href": "tutorial/mapping/static/filter/filter.html",
    "title": "Filters | XData website",
    "keywords": "Filters Filters can be defined as: Constant filters SQL expression filters Dictionary filters Range filters Subquery filters Inner links Each of filter type is defined by own special attribute of data object class. Each of attributes has parameters: Source - data source alias of filtered field, FieldName - filtered field name, Operation - filter operation (optional, default is FilterOperation . Equal ), Combination - filter group name (optional, default is root filter group). Above this every filter attribute has their own specific parameters described below. Filter operation is defined by enum FilterOperation : Equal - equal NotEqual - not equal LessThan - less then GreaterThan - greater then LessThanOrEqual - less or equal GreaterThanOrEqual - greater or equal In - field value in range or subquery NotIn - field value is not in range or subquery Exists - subquery returns one or more rows NotExists - subquery returns no rows Like - field value correlated with find expression NotLike - field value not correlated with find expression OuterJoin - left outer join link between query sources (tables or inner views) Contains - field value correlated with full-text search NotContains - field value not correlated with full-text search Filter group Filter group can be defined by FilterCombinationAttribute with parameters: Name - filter group unique name, Combination - logical operation between filters and subgroups inside group (optional, default is FilterCombination . And ), Parent - parent filter group name (optional, can be omitted for filter groups with parent - root filter group). Logic operation inside filter group is defined by enum Combination : And - and Or - or [FilterCombination(\"OrGroup\" /* group filter name */, Combination: Combination.OR /* logical operation */)] Constant filters Constant filters can restrict query by constant value. This filter is defined by ConstantFilterAttribute , with specific (over described above ) parameters: Name - filter name (will be transformed to query parameter name), ConstantType - constant type (see below) and ConstantValue - constant value depends on ConstantType . Constant types is defined by enum FilterConstantType : Const - value of ConstantValue . Variable - value of variable with name equals ConstantValue . CurrentDate - current date. CurrentDateTime - current date/time. CurrentDateTimeUTC - current date/time (UTC). [ConstantFilter(\"FilterByZero\" /* filter name */, \"P\" /* table alias */, \"discount\" /* DB field name */, 0m /* decimal constant value */, Operation: FilterOperation.Equal /* filter operation */, ConstantType: FilterConstantType.Const /* constant type */)] SQL expression filters To define filter over SQL expression used ExpressionFilterAttribute with specific (over described above ) parameter: ExpressionText - depends on value can be: subquery alias, [ExpressionFilter(\"P\" /* table alias */, \"discount\" /* field name */, \"D\" /* ExpressionText: subquery alias */, Operation: FilterOperation.In /* filter operation */)] private static field name contains dynamic definition of SQL expression, [ExpressionFilter(\"P\" /* table alias */, \"discount\" /* field name */, \"AllowedDiscount\" /* ExpressionText: SQL expression description field name */, Operation: FilterOperation.NotEqual /* filter operation */)] ... //Private static field of mapped class marked with SqlExpression attribute [SqlExpression] private static Calculate<int> AllowedDiscount = x => x.Case<Product, int>( z => z.Field<bool>(\"is_vip\"), z => 0, 1.SetExpression(z => 10)); plain SQL expression text. [ExpressionFilter(\"P\" /* table alias */, \"discount\" /* field name */, \"case P.is_vip when 1 then 10 else 0 end\" /* ExpressionText: plain SQL expression */, Operation: FilterOperation.NotEqual /* filter operation */)] Important If possible do not use plain SQL expressions. It possibly use specific SQL dialect features not supported by other DBMS or providers. Range filters To define filter checks field value over array of values used RangeFilterAttribute with specific (over described above ) parameter: Range - array of values to filter on. [RangeFilter(\"P\" /* table alias */, \"discount\" /* field name */, new[] {0,5,10} /* range of values */, Operation: FilterOperation.In /* filter operation */)] Dictionary filters Dictionaries surrogate keys may varied over one instance to another, and names can be changed by users. Sometimes business logic need to operate with the concrete value of dictionary. Because of this it's recommended to add into dictionary DB structure a special unique text field - mnemonic code. XData supports using mnemonic code when define filters on dictionary value - dictionary filters. They defined by DictionaryFilterAttribute with specific (over described above ) parameters: DictionaryTable - dictionary table name, DictionaryId - dictionary id field name, DictionaryCode - dictionary mnemonic code field name, DictionaryValue - mnemonic code value to filter query on, ValueIsVariable - flag DictionaryValue contains not a value but name of variable with value. Tip In case filter field name is equals dictionary id field name, parameter FieldName can be omitted. Important This filter can be used when dictionary has simple (one field only) identity field and mnemonic code field. But it's a very common case. [DictionaryFilter(\"t_doc_state\" /* dictionary table name */, \"doc_state_id\" /* dictionary id field name */, \"code\" /* dictionary mnemonic code field name */, \"CREATED\" /* mnemonic code value */, \"D\" /* filtered table alias */)] Inner links To define links between data sources inside query used LinkAttribute with specific parameters: LinkedSourceAlias - linked table alias, LinkedFieldName - linked table field name (optional, can be omitted when equals with FieldName ). Tip Inner links can be used to define optional filters . To specify role in optional filter chain need to set parameter PrimaryFilter to true . [Link(\"D\" /* table alias */, \"doc_id\" /* field name */, \"DD\" /* linked table alias */)] Subquery filters To define filters checks field value is correspond subquery results used SubqueryFilterAttribute with specific (over defined above ) parameter: Subquery - subquery alias (see Subqueries ). Inner view can not be used with subquery filters. [SubqueryFilter(\"D\" /* table alias */, \"doc_state_id\" /* field name */, \"A\" /* subquery alias */, Operation: FilterOperation.In /* filter operation */)] When flag PrimaryFilter is set to true optional part of query is defined by followed rules: when one of linked data sources is skipped then other one will skipped too. When base table of subquery is skipped then subquery is skipped completely. Subquery links Links with subqueries is used to link not table fields but properties of base class and subquery mapped class including hidden properties . To link with subquery or inner view used SubqueryLinkAttribute with parameters: Subquery - subquery alias, SubqueryProperty - linked property from subquery, PropertyName - optional, linked property from base class (when omit, base class property name is equal SubqueryProperty ), also optional properties: Operation , Combination and PrimaryFilter is supported. They was described above in topics Filters and Inner links . [SubqueryLink(\"H\" /* subquery alias */, \"DocId\" /* subquery property to link */)] When flag PrimaryFilter is set to true optional part of query is defined by followed rules: when subquery is skipped, then data source linked to subquery by this filter will be skipped too, and skip data sources analysis will continue inside base class (see Inner links )."
  },
  "tutorial/mapping/static/filter/dictionary.html": {
    "href": "tutorial/mapping/static/filter/dictionary.html",
    "title": "Dictionary filters | XData website",
    "keywords": "Dictionary filters Dictionaries surrogate keys may varied over one instance to another, and names can be changed by users. Sometimes business logic need to operate with the concrete value of dictionary. Because of this it's recommended to add into dictionary DB structure a special unique text field - mnemonic code. XData supports using mnemonic code when define filters on dictionary value - dictionary filters. They defined by DictionaryFilterAttribute with specific (over described above ) parameters: DictionaryTable - dictionary table name, DictionaryId - dictionary id field name, DictionaryCode - dictionary mnemonic code field name, DictionaryValue - mnemonic code value to filter query on, ValueIsVariable - flag DictionaryValue contains not a value but name of variable with value. Tip In case filter field name is equals dictionary id field name, parameter FieldName can be omitted. Important This filter can be used when dictionary has simple (one field only) identity field and mnemonic code field. But it's a very common case. [DictionaryFilter(\"t_doc_state\" /* dictionary table name */, \"doc_state_id\" /* dictionary id field name */, \"code\" /* dictionary mnemonic code field name */, \"CREATED\" /* mnemonic code value */, \"D\" /* filtered table alias */)]"
  },
  "tutorial/mapping/static/filter/constant.html": {
    "href": "tutorial/mapping/static/filter/constant.html",
    "title": "Constant filters | XData website",
    "keywords": "Constant filters Constant filters can restrict query by constant value. This filter is defined by ConstantFilterAttribute , with specific (over described above ) parameters: Name - filter name (will be transformed to query parameter name), ConstantType - constant type (see below) and ConstantValue - constant value depends on ConstantType . Constant types is defined by enum FilterConstantType : Const - value of ConstantValue . Variable - value of variable with name equals ConstantValue . CurrentDate - current date. CurrentDateTime - current date/time. CurrentDateTimeUTC - current date/time (UTC). [ConstantFilter(\"FilterByZero\" /* filter name */, \"P\" /* table alias */, \"discount\" /* DB field name */, 0m /* decimal constant value */, Operation: FilterOperation.Equal /* filter operation */, ConstantType: FilterConstantType.Const /* constant type */)]"
  },
  "tutorial/mapping/static/variables.html": {
    "href": "tutorial/mapping/static/variables.html",
    "title": "Variables | XData website",
    "keywords": "Variables The use of variables is described here . Here we describe a way of setting variable values for reused mapping Subquery (and InnerView ) mapping. To do this, use the SubqueryVariableAttribute attribute. Parameter Alias - subquery alias in resulting query. Name - the name of the variable. Value - the value of the variable. [SubqueryVariable(\"A\" /* subquery alias */, \"TestVar\" /* variable name */, 1 /* variable value */)]"
  },
  "tutorial/mapping/procedure/sample_multiple_cursor.html": {
    "href": "tutorial/mapping/procedure/sample_multiple_cursor.html",
    "title": "| XData website",
    "keywords": "MS SQL Server CREATE PROCEDURE [dbo].[TestProcedure2] ( @param1 int, @param2 varchar(20), @param3 int, @param4 varchar(20) ) AS BEGIN SELECT @param1 as Id, @param2 as Name SELECT @param3 as Id, @param4 as Name END Oracle procedure TestProcedure2(p_Id int, p_Name varchar2, p_Out out SYS_REFCURSOR, p_Out2 out SYS_REFCURSOR) as begin open p_Out for select p_Id as Id, p_Name as Name from dual; open p_Out2 for select p_Id as Id, p_Name as Name from dual; end TestProcedure2; Tip Use refcursor parameters names as ResultSet names! PostgreSQL CREATE OR REPLACE FUNCTION public.TestProcedure2 (p_id integer, p_name varchar, refcursor, refcursor) RETURNS SETOF refcursor AS $$ begin open $3 for select p_id as Id, p_name as Name; return NEXT $3; open $4 for select p_id as Id, p_name as Name; return NEXT $4; end $$ LANGUAGE plpgsql; Warning Functions witch returns setof refcursor is not supported by NpgSql .Net Standard 2.0 Edition :( XData net4.0 version can call that type functions with the same mapping rules as described here... Tip If refcursor parameters have a names it must be used as ResultSet names! MySQL create procedure TestProcedure2(p_Id int, p_Name varchar(50)) begin select p_Id as Id, p_Name as Name; select p_Id as Id, p_Name as Name; end"
  },
  "tutorial/mapping/dynamic/procedure/parameter.html": {
    "href": "tutorial/mapping/dynamic/procedure/parameter.html",
    "title": "SQL procedure parameter | XData website",
    "keywords": "SQL procedure parameter To define SQL procedure parameter used Parameter method call of IRepositoryStructure<T> interface."
  },
  "tutorial/mapping/dynamic/filter/constant.html": {
    "href": "tutorial/mapping/dynamic/filter/constant.html",
    "title": "Constant filters | XData website",
    "keywords": "Constant filters Constant filters allows to restrict selection of data by some constant value. This filter defined by one of ConstFilter method overloads of IInnerFilterAdapter interface. Constant type list restricted by enum FilterConstantType : Const - constant with value set by ConstantValue . Variable - value of variable with name set by ConstantValue . CurrentDate - current date. CurrentDateTime - current date and time. CurrentDateTimeUTC - current date and time (UTC). ... , x => x.ConstFilter(\"FilterByCathalogue\", \"catalogue_id\", FilterConstantType.Const, null, FilterNullable.NullsNotAllowed) .SetCombination(\"root\") ..."
  },
  "tutorial/mapping/dynamic/variables.html": {
    "href": "tutorial/mapping/dynamic/variables.html",
    "title": "Variables | XData website",
    "keywords": "Variables The use of variables is described here . To describe the variables, special overloads of Subquery and InnerView methods are used. Variables are described in the variables parameter. .Subquery<DocPropertyValue>(\"PH\", x => x.GetProperty(\"ParamValue\"), DataGrouping.None, new[]{\"ParamCode\".SetVar(\"AUTHOR_PHONE\")}, /* variables */ x => x.SubqueryLink(\"DocId\"))"
  },
  "tutorial/mapping/dynamic/tree.html": {
    "href": "tutorial/mapping/dynamic/tree.html",
    "title": "Tree | XData website",
    "keywords": "Tree To dynamically map tree organized data structure used special method With of RepositoryStructure<T> interface to describe tree root query and tree childs. Both of them use subquery mappings (see example below) to set subquery structure for tree query construction. Important Data source flags of tree organized data sources must contain DataStructureFlag.ReadOnly and DataStructureFlag.Tree! private static Expression<CustomMapping<CatalogueTree>> _unused = ( () => XDataMapping.CustomMapping<CatalogueTree>() .With(\"CAT\", XDataMapping.GetStructure(\"R\") .DataTable(\"T_CATALOGUE\", \"R\", x => x.Combination(\"root\", Combination.Or), x => x.ConstFilter(\"FilterByCathalogue\", \"catalogue_id\", FilterConstantType.Const, null, FilterNullable.NullsNotAllowed).SetCombination(\"root\"), x => x.ConstFilter(\"FilterByRoot\", \"parent_id\", FilterConstantType.Const, null, FilterNullable.NullsCompared) .SetCombination(\"root\")) .Select(x => new { CatalogueId = x.Field<long>(\"R\", string.Empty, z => z.Key()), Code = x.Field<string>(\"R\", string.Empty), Name = x.Field<string>(\"R\", string.Empty), ParentId = x.Field<long?>(\"R\", string.Empty), }), x => x.Properties(z => z.CatalogueId, z => z.Code, z => z.Name, z => z.ParentId), x => x.WithRecursive(\"S\", XDataMapping .GetStructure(\"S\") .DataTable(\"T_CATALOGUE\", \"S\") .Select(y => new { CatalogueId = y.Field<long>(\"S\", string.Empty, z => z.Key()), Code = y.Field<string>(\"S\", string.Empty), Name = y.Field<string>(\"S\", string.Empty), ParentId = y.Field<long?>(\"S\", string.Empty) }), z => z.SubqueryLink(y => y.ParentId, y => y.CatalogueId))) .ReadOnlyProperty(x => x.CatalogueId, x => x.Field<long>(\"CAT\", string.Empty, z => z.Key())) .ReadOnlyProperty(x => x.Code, x => x.Field<string>(\"CAT\", string.Empty)) .ReadOnlyProperty(x => x.Name, x => x.Field<string>(\"CAT\", string.Empty)) .ReadOnlyProperty(x => x.ParentId, x => x.Field<long?>(\"CAT\", string.Empty)) .Map() .SetFlags(DataStructureFlag.ReadOnly | DataStructureFlag.Tree) );"
  },
  "tutorial/mapping/dynamic/subquery.html": {
    "href": "tutorial/mapping/dynamic/subquery.html",
    "title": "Subqueries | XData website",
    "keywords": "Subqueries Subqueries can be used for a: filtration using [not] exists() , [not] in (select) ( see below ) inner view subquery expression as single property source ( see below ) Subquery deep level is not limited. In dynamic mapping of data object subqueries can be defined using one of Subquery or InnerView methods overload of IRepositoryStructure<T> interface to define subqueries or inner views respectively. While using generic overloads of Subquery or InnerView , parameter IQueryDescription<TDobj> sub can be used with in place dynamic query notation. Non generic overloads of Subquery or InnerView must provide ISqlType or IDataObject marked class type as parameter Type dobjType to reuse of existing mapping. This class can be mapped using static or dynamic style, no matter. ... .Subquery(\"A\", typeof(DocSpecAmounts), \"Amount\", DataGrouping.Sum, x => x.SubqueryLink(\"DocId\")) .Subquery<CatalogueTree>(\"UT\", x => x.CatalogueId, DataGrouping.None) .InnerView(\"H\", XDataMapping.GetStructure(\"H\", DataStructureFlag.Grouping) .DataTable(\"T_DOC_HISTORY\", \"H\") .Select(x => new { DocId = x.Field<long?>(\"H\", string.Empty, z => z.Group(DataGrouping.None)), HistoryDate = x.Field<DateTime?>(\"H\", string.Empty, z => z.Group(DataGrouping.Max)) }), x => x.SubqueryLink(\"DocId\").SetOperation(FilterOperation.OuterJoin)) .InnerView<DocBySpecType>(\"ST\", x => x.SubqueryLink(\"DocId\")) ..."
  },
  "tutorial/mapping/dynamic/sample.html": {
    "href": "tutorial/mapping/dynamic/sample.html",
    "title": "Dynamic mapping sample | XData website",
    "keywords": "Dynamic mapping sample <!--MD5=[9fbc3a7cfb9f92e84de8970988e48bb2] class t_catalogue--> t_catalogue catalogue_id code name parent_id <!--MD5=[ea6ea2e31c0cbff1b909b1f0bd59093e] class t_customer--> t_customer customer_id code name <!--MD5=[a6ce46e431db16f1c4014df928aac3e8] class t_doc_cust_type--> t_doc_cust_type doc_cust_type_id code name <!--MD5=[bccea5d0c54fc84e4bad16ab69fd73e7] class t_doc_type--> t_doc_type doc_type_id code name <!--MD5=[5ea577eca533bfca935d04f775d3f167] class t_doc--> t_doc doc_id doc_type_id doc_date generation changed author <!--MD5=[d4ba8adfb5df751cf422e2fad2a28e94] class t_catalogue_doc--> t_catalogue_doc catalogue_id doc_id <!--MD5=[8cca3b0685271c670c4226b30b01cbcf] class t_doc_cust--> t_doc_cust doc_cust_id doc_id customer_id doc_cust_type_id <!--MD5=[fd8c5e68644f1f4fc0b14eca97226ae4] class t_doc_delivery--> t_doc_delivery doc_id delivery_type delivery_date <!--MD5=[dd40a5851c55ff9d7da9b59b2cdb5061] class t_doc_number--> t_doc_number doc_id numb <!--MD5=[710d3dc0240fd500b1d510e138be1447] class t_doc_scan--> t_doc_scan doc_id scan <!--MD5=[5937349b424f6b33ad58af94594dfd63] class t_doc_source--> t_doc_source doc_id source <!--MD5=[4efa0cfa5e1d38a4afda4e219b98680a] class t_doc_state--> t_doc_state doc_state_id code name <!--MD5=[5c02744e5b0455229387a946a811ce2e] class t_doc_doc_state--> t_doc_doc_state doc_id doc_state_id <!--MD5=[0d4a222ed2d2d268b8328f05b8f9e363] class t_doc_history--> t_doc_history doc_history_id doc_id doc_state_id history_date <!--MD5=[d4b45c8a441f4cb1774906928f147529] link t_catalogue to t_catalogue--> parent_id <!--MD5=[b3294211ce75436a8f4d3c51fb151377] link t_doc_type to t_doc--> doc_type_id <!--MD5=[840062eaffe844779ca4f4f301a47d9a] reverse link t_catalogue to t_catalogue_doc--> catalogue_id <!--MD5=[b3a8eac680fbb6e047950cbceafbeb2c] link t_catalogue_doc to t_doc--> doc_id <!--MD5=[7eefc4f6dff794e64e78dcbbfb9c491a] link t_doc to t_doc_cust--> doc_id <!--MD5=[0005336a9822bd19ef61e4ce8910c4c5] reverse link t_doc_cust to t_customer--> customer_id <!--MD5=[131b4a0e76521106752daee341bf156a] reverse link t_doc_cust to t_doc_cust_type--> doc_cust_type_id <!--MD5=[94de7abaa940d64e718a7c3244926e87] reverse link t_doc_delivery to t_doc--> doc_id <!--MD5=[2d23622d96560790c79c16e9140044a4] reverse link t_doc_number to t_doc--> doc_id <!--MD5=[7c459e52799c0d4d655e72449bb91e72] reverse link t_doc_scan to t_doc--> doc_id <!--MD5=[4aa29f824d631e9db9c0b4ff518403cc] reverse link t_doc_source to t_doc--> doc_id <!--MD5=[fdc70aa94f88d88b378c08a646310f88] reverse link t_doc_doc_state to t_doc--> doc_id <!--MD5=[63d405c0f3a8aa08b15fc74dd2b85047] link t_doc_state to t_doc_doc_state--> doc_state_id <!--MD5=[9c004340c543d5fd28395a65d65b76dd] link t_doc to t_doc_history--> doc_id <!--MD5=[ac06e947c28172a1581fe83d17c1f569] reverse link t_doc_history to t_doc_state--> doc_state_id <!--MD5=[a24f9b6c28c3f11eb813d302e9c42a66] @startuml hide circle skinparam ClassHeaderBackgroundColor lightgray skinparam ClassBorderColor black skinparam ClassBorderThickness 1 skinparam ClassBackgroundColor transparrent skinparam ArrowFontSize 8 skinparam ArrowColor black entity t_catalogue { <&key> catalogue_id - - <&code> code name <&arrow-circle-right> //parent_id// } t_catalogue - -{ t_catalogue : parent_id entity t_customer { <&key> customer_id - - <&code> code name } entity t_doc_cust_type { <&key> doc_cust_type_id - - <&code> code name } entity t_doc_type { <&key> doc_type_id - - <&code> code name } entity t_doc { <&key> doc_id - - <&arrow-circle-right> doc_type_id doc_date - - <&tag> generation <&clock> changed <&person> author } t_doc_type -right-{ t_doc : doc_type_id entity t_catalogue_doc { <&key> <&arrow-circle-right> catalogue_id <&key> <&arrow-circle-right> doc_id } t_catalogue_doc -up-{ t_catalogue : catalogue_id t_catalogue_doc - -{ t_doc : doc_id entity t_doc_cust { <&key> doc_cust_id - - <&arrow-circle-right> doc_id <&arrow-circle-right> customer_id <&arrow-circle-right> doc_cust_type_id } t_doc_cust }-up- t_doc : doc_id t_doc_cust }- - t_customer : customer_id t_doc_cust }- - t_doc_cust_type : doc_cust_type_id entity t_doc_delivery { <&key> <&arrow-circle-right> doc_id - - delivery_type delivery_date } t_doc_delivery }o- - t_doc : doc_id entity t_doc_number { <&key> <&arrow-circle-right> doc_id - - numb } t_doc_number }o- - t_doc : doc_id entity t_doc_scan { <&key> <&arrow-circle-right> doc_id - - <&map> scan } t_doc_scan }o- - t_doc : doc_id entity t_doc_source { <&key> <&arrow-circle-right> doc_id - - <&document> source } t_doc_source }o- - t_doc : doc_id entity t_doc_state { <&key> doc_state_id - - <&code> code name } entity t_doc_doc_state { <&key> <&arrow-circle-right> doc_id - - <&arrow-circle-right> doc_state_id } t_doc_doc_state }o-right- t_doc : doc_id t_doc_doc_state }-left- t_doc_state : doc_state_id entity t_doc_history { <&key> doc_history_id - - <&arrow-circle-right> doc_id <&arrow-circle-right> doc_state_id <&clock> history_date } t_doc_history }-up- t_doc : doc_id t_doc_history }- - t_doc_state : doc_state_id @enduml PlantUML version 1.2020.12(Sat Jun 06 10:54:15 UTC 2020) (GPL source distribution) Java Runtime: Java(TM) SE Runtime Environment JVM: Java HotSpot(TM) 64-Bit Server VM Default Encoding: UTF-8 Language: en Country: US --> <!--MD5=[5ea577eca533bfca935d04f775d3f167] class t_doc--> t_doc doc_id doc_type_id doc_date generation changed author <!--MD5=[e871482fb55f9150fc3be5a0e93d8569] class t_doc_spec_type--> t_doc_spec_type doc_spec_type_id code name <!--MD5=[4ed4cd12cd2eeb59e644791b1ec40217] class t_doc_spec--> t_doc_spec doc_spec_id doc_id doc_spec_type_id <!--MD5=[025ac326a6ab31b45989aa42f37da176] class t_doc_spec_amount--> t_doc_spec_amount doc_spec_id amount <!--MD5=[cef6fc7600387b202b7e697154b0ecaf] link t_doc to t_doc_spec--> doc_id <!--MD5=[175fa9f72450b3173fe29432cd7fb745] reverse link t_doc_spec to t_doc_spec_type--> doc_spec_type_id <!--MD5=[542647722f52d6ccd9b263e63b85e2d8] link t_doc_spec to t_doc_spec_amount--> doc_spec_id <!--MD5=[5cb7b5aa399201d5b29efcb8adfe8a65] @startuml hide circle skinparam ClassHeaderBackgroundColor lightgray skinparam ClassBorderColor black skinparam ClassBorderThickness 1 skinparam ClassBackgroundColor transparrent skinparam ArrowFontSize 8 skinparam ArrowColor black entity t_doc { <&key> doc_id - - <&arrow-circle-right> doc_type_id doc_date - - <&tag> generation <&clock> changed <&person> author } entity t_doc_spec_type { <&key> doc_spec_type_id - - <&code> code name } entity t_doc_spec { <&key> doc_spec_id - - <&arrow-circle-right> doc_id <&arrow-circle-right> doc_spec_type_id } t_doc_spec }-left- t_doc : doc_id t_doc_spec }- - t_doc_spec_type : doc_spec_type_id entity t_doc_spec_amount { <&key> <&arrow-circle-right> doc_spec_id - - <&dollar> amount } t_doc_spec_amount }o-left- t_doc_spec : doc_spec_id @enduml PlantUML version 1.2020.12(Sat Jun 06 10:54:15 UTC 2020) (GPL source distribution) Java Runtime: Java(TM) SE Runtime Environment JVM: Java HotSpot(TM) 64-Bit Server VM Default Encoding: UTF-8 Language: en Country: US --> Dynamic mapping example for same data object as represented in static mapping description: SQL representation of following sample: with recursive T (catalogue_id, code, name, parent_id) as ((SELECT R.catalogue_id AS R_catalogue_id, R.code AS R_code, R.name AS R_name, R.parent_id AS R_parent_id FROM T_CATALOGUE R WHERE ((@FilterByRoot is not null and R.catalogue_id = @FilterByRoot) OR (@FilterByRoot is null and R.parent_id is null))) UNION (SELECT S.catalogue_id AS S_catalogue_id, S.code AS S_code, S.name AS S_name, S.parent_id AS S_parent_id FROM T_CATALOGUE S, T T WHERE S.parent_id = (T.catalogue_id))) SELECT CF.CUSTOMER_ID AS CF_CUSTOMER_ID, CF.DOC_CUST_ID AS CF_DOC_CUST_ID, CF.DOC_CUST_TYPE_ID AS CF_DOC_CUST_TYPE_ID, CF.DOC_ID AS CF_DOC_ID, CT.CUSTOMER_ID AS CT_CUSTOMER_ID, CT.DOC_CUST_ID AS CT_DOC_CUST_ID, CT.DOC_CUST_TYPE_ID AS CT_DOC_CUST_TYPE_ID, CT.DOC_ID AS CT_DOC_ID, CAST((SELECT Sum(A.amount) AS A_amount FROM T_DOC_SPEC S JOIN T_DOC_SPEC_AMOUNT A ON A.DOC_SPEC_ID = S.DOC_SPEC_ID WHERE S.doc_id = S.doc_id) AS NUMERIC(17, 5)) AS doc_amount /* DocAmount */, D.doc_date AS D_doc_date /* DocDate */, D.doc_id AS D_doc_id /* DocId */, D.DOC_TYPE_ID AS D_DOC_TYPE_ID, D.generation AS D_generation /* Generation */, D.changed AS D_changed /* Changed */, D.author AS D_author /* Author */, DD.delivery_date AS DD_delivery_date /* DeliveryDate */, DD.delivery_type AS DD_delivery_type /* DeliveryType */, DD.DOC_ID AS DD_DOC_ID, DS.DOC_DOC_STATE_ID AS DS_DOC_DOC_STATE_ID, DS.DOC_ID AS DS_DOC_ID, DS.DOC_STATE_ID AS DS_DOC_STATE_ID, F.CODE AS F_CODE, F.CUSTOMER_ID AS F_CUSTOMER_ID, F.name AS F_name /* CustomerFrom */, H.H_doc_id AS H_H_doc_id, H.H_history_date AS H_H_history_date /* DocLastChange */, N.DOC_ID AS N_DOC_ID, N.numb AS N_numb /* DocNumb */, S.code AS S_code /* DocStateCode */, S.DOC_STATE_ID AS S_DOC_STATE_ID, S.name AS S_name /* DocState */, SC.DOC_ID AS SC_DOC_ID, SC.scan AS SC_scan /* Scan */, SR.DOC_ID AS SR_DOC_ID, SR.source AS SR_source /* Source */, ST.S_doc_id AS ST_S_doc_id, T.CODE AS T_CODE, T.CUSTOMER_ID AS T_CUSTOMER_ID, T.name AS T_name /* CustomerTo */ FROM T_DOC D JOIN T_DOC_DOC_STATE DS ON DS.doc_id = D.doc_id JOIN T_DOC_STATE S ON S.DOC_STATE_ID = DS.DOC_STATE_ID JOIN T_DOC_NUMBER N ON N.doc_id = D.doc_id JOIN T_DOC_CUST CF ON CF.doc_id = D.doc_id JOIN T_DOC_CATALOGUE DC ON DC.doc_id = D.doc_id JOIN T_CATALOGUE U ON DC.catalogue_id = U.catalogue_id JOIN T_CUSTOMER F ON F.CUSTOMER_ID = CF.CUSTOMER_ID JOIN T_DOC_CUST CT ON CT.doc_id = D.doc_id JOIN T_CUSTOMER T ON T.CUSTOMER_ID = CF.CUSTOMER_ID LEFT OUTER JOIN T_DOC_SCAN SC ON SC.doc_id = D.doc_id LEFT OUTER JOIN T_DOC_SOURCE SR ON SR.doc_id = D.doc_id LEFT OUTER JOIN T_DOC_DELIVERY DD ON DD.doc_id = D.doc_id LEFT OUTER JOIN (SELECT H.doc_id AS H_doc_id, H.history_date AS H_history_date FROM T_DOC_HISTORY H) H ON D.doc_id = H.H_doc_id JOIN (SELECT S.doc_id AS S_doc_id FROM T_DOC_SPEC_TYPE ST JOIN T_DOC_SPEC S ON S.DOC_SPEC_TYPE_ID = ST.DOC_SPEC_TYPE_ID WHERE ST.code = @FilterBySpecTypeCode) ST ON D.doc_id = ST.S_doc_id WHERE D.DOC_TYPE_ID = (select doc_type_id from T_DOC_TYPE where code='INVOICE') AND CF.DOC_CUST_TYPE_ID = (select doc_cust_type_id from T_DOC_CUST_TYPE where code='FROM') AND CF.DOC_CUST_TYPE_ID = (select doc_cust_type_id from T_DOC_CUST_TYPE where code='TO') AND D.doc_id = @FilterByDocId AND DC.catalogue_id in (SELECT T.catalogue_id AS T_catalogue_id FROM T T) Mapping sample: public partial class Invoice: IDataObject { public static CustomLogic<Invoice> TestCustomLogic; private static Expression<CustomMapping<Invoice>> _mapping = ( () => XDataMapping.CustomMapping<Invoice>() .DataTable(\"T_DOC\", \"D\", x => x.DictFilter(\"T_DOC_TYPE\", \"doc_type_id\", \"code\", \"INVOICE\")) .DataTable(\"T_DOC_DOC_STATE\", \"DS\", \"D\", x => x.Link(\"D\", \"doc_id\")) .DataTable(\"T_DOC_STATE\", \"S\", x => x.Link(\"DS\", \"doc_state_id\")) .DataTable(\"T_DOC_CATALOGUE\", \"DC\", \"D\", x => x.Link(\"D\", \"doc_id\"), x => x.SubqueryFilter(\"catalogue_id\", \"UT\").SetOperation(FilterOperation.In)) .DataTable(\"T_CATALOGUE\", \"U\", x => x.Link(\"DC\", \"catalogue_id\")) .DataTable(\"T_DOC_NUMBER\", \"N\", \"D\", x => x.Link(\"D\", \"doc_id\")) .DataTable(\"T_DOC_CUST\", \"CF\", \"D\", x => x.Link(\"D\", \"doc_id\"), x => x.DictFilter(\"T_DOC_CUST_TYPE\", \"doc_cust_type_id\", \"code\", \"FROM\")) .DataTable(\"T_CUSTOMER\", \"F\", x => x.Link(\"CF\", \"customer_id\")) .DataTable(\"T_DOC_CUST\", \"CT\", \"D\", x => x.Link(\"D\", \"doc_id\"), x => x.DictFilter(\"T_DOC_CUST_TYPE\", \"doc_cust_type_id\", \"code\", \"TO\")) .DataTable(\"T_CUSTOMER\", \"T\", x => x.Link(\"CT\", \"customer_id\")) .DataTable(\"T_DOC_SCAN\", \"SC\", \"D\", x => x.Link(\"D\", \"doc_id\").SetOperation(FilterOperation.OuterJoin)) .DataTable(\"T_DOC_SOURCE\", \"SR\", \"D\", x => x.Link(\"D\", \"doc_id\").SetOperation(FilterOperation.OuterJoin)) .DataTable(\"T_DOC_DELIVERY\", \"DD\", \"D\", x => x.Link(\"D\", \"doc_id\").SetOperation(FilterOperation.OuterJoin)) .Subquery(\"A\", typeof(DocSpecAmounts), \"Amount\", DataGrouping.Sum, x => x.SubqueryLink(\"DocId\")) .Subquery<CatalogueTree>(\"UT\", x => x.CatalogueId, DataGrouping.None) .InnerView(\"H\", XDataMapping.GetStructure(\"H\", DataStructureFlag.Grouping) .DataTable(\"T_DOC_HISTORY\", \"H\") .Select(x => new { DocId = x.Field<long?>(\"H\", string.Empty, z => z.Group(DataGrouping.None)), HistoryDate = x.Field<DateTime?>(\"H\", string.Empty, z => z.Group(DataGrouping.Max)) }), x => x.SubqueryLink(\"DocId\").SetOperation(FilterOperation.OuterJoin)) .InnerView<DocBySpecType>(\"ST\", x => x.SubqueryLink(\"DocId\")) .Column(\"DocId\", x => x.Field<long?>(\"D\", string.Empty, z => z.Key(), z => z.Default(DefaultType.AutoIncrement))) .Column(\"DocStateId\", x => x.Field<long>(\"S\", string.Empty)) .Column(\"FromCustomerId\", x => x.Field<long>(\"F\", \"customer_id\")) .Column(\"ToCustomerId\", x => x.Field<long>(\"T\", \"customer_id\")) .Column(\"CatalogueId\", x => x.Field<long?>(\"U\", string.Empty)) .ReadOnlyProperty(x => x.DocStateCode, x => x.Field<string>(\"S\", \"code\")) .ReadOnlyProperty(x => x.Generation, x => x.Field<long>(\"D\", string.Empty, z => z.ConcurrencyToken(), z => z.Default(DefaultType.AutoIncrement))) .ReadOnlyProperty(x => x.Changed, x => x.Field<DateTime>(\"D\", string.Empty, z => z.Default(DefaultType.CurrentDateTime, DefaultFeature.UseOnUpdate))) .ReadOnlyProperty(x => x.Author, x => x.Field<string>(\"D\", string.Empty, z => z.Default(DefaultType.UserName, DefaultFeature.UseOnUpdate))) .ReadOnlyProperty(x => x.DocAmount, x => x.Expr<decimal?>(null, DataExpressionType.SubQuery, \"A\", DbType.Decimal, z => z.Size(17, 5))) .ReadOnlyProperty(x => x.DocLastChange, x => x.Ref<DateTime?>(\"H\", \"HistoryDate\")) .Map(x => new Invoice { DocState = x.Link<string, DocState>(\"S\", \"name\", z => z.LinkProperty<DocState>(y => y.Name), z => z.LinkProperty<DocState>(y => y.Code, y => y.DocStateCode), z => z.LinkProperty<DocState>((Invoice y) => y.GetProperty<long>(\"DocStateId\"))), DocCatalog = x.Link<string, Catalogue>(\"U\", \"name\", z => z.LinkProperty<Catalogue>(y => y.Name), z => z.LinkProperty<Catalogue>((Invoice y) => y.GetProperty<long>(\"CatalogueId\"))), DocNumb = x.Field<string>(\"N\", \"numb\"), DocDate = x.Field<DateTime?>(\"D\", string.Empty, z => z.Default(DefaultType.CurrentDate)), Scan = x.Lob(\"SC\", z => z.OuterFlag()), Source = x.Xml(\"SR\", z => z.OuterFlag()), CustomerFrom = x.Link<string, Customer>(\"F\", \"name\", z => z.LinkProperty<Customer>(y => y.Name), z => z.LinkProperty<Customer>(y => y.GetProperty<long>(\"CustomerId\"), y => y.GetProperty<long>(\"FromCustomerId\"))), CustomerTo = x.Link<string, Customer>(\"T\", \"name\", z => z.LinkProperty<Customer>(y => y.Name), z => z.LinkProperty<Customer>(y => y.GetProperty<long>(\"CustomerId\"), y => y.GetProperty<long>(\"ToCustomerId\"))), DeliveryType = x.Field<DeliveryTypeEnum>(\"DD\", string.Empty), DeliveryDate = x.Field<DateTime?>(\"DD\", string.Empty, z => z.Default(DefaultType.CurrentDate)) }, x => x.ExternalLink<InvoiceSpec>(\"DocId\")) .SetBaseTable(\"D\").SetLogicAssembly(\"XDataObjectTest\") ); } ... public partial class Invoice { public string DocStateCode { get { return this.GetProperty(x => x.DocStateCode); } } public Link<string, DocState> DocState { get; set; } public Link<string, Catalogue> DocCatalog { get; set; } public string DocNumb { get; set; } public DateTime? DocDate { get; set; } public long Generation { get { return this.GetProperty(x => x.Generation); } } public DateTime Changed { get { return this.GetProperty(x => x.Changed); } } public string Author { get { return this.GetProperty(x => x.Author); } } public decimal? DocAmount { get { return this.GetProperty(x => x.DocAmount); } } public DateTime? DocLastChange { get { return this.GetProperty(x => x.DocLastChange); } } public Lob Scan { get; set; } public Xml Source { get; set; } public Link<string, Customer> CustomerFrom { get; set; } public Link<string, Customer> CustomerTo { get; set; } public DeliveryTypeEnum DeliveryType { get; set; } public DateTime? DeliveryDate { get; set; } public IRepository<InvoiceSpec> Spec { get { return this.GetRepository().GetChild<InvoiceSpec>(); } } } Dynamic mapping provide more representable mechanics to define mapping because of no attribute parameters limitation. Subqueries and inner views can be described in place using dynamic query mechanics. SQL expressions can be described in LINQ style in place. This abilities enreach representability of dynamic mapping. Dynamic mapping allows split data object to partial class definitions with basic class definition and mapping."
  },
  "tutorial/mapping/dynamic/parameters.html": {
    "href": "tutorial/mapping/dynamic/parameters.html",
    "title": "Mapping parameters | XData website",
    "keywords": "Mapping parameters To set parameters of dynamically mapped classes used IRepositoryDescription<T> interface methods: SetBaseTable - to set base table , (optional, by default used virtual table with the empty alias) SetContext - database context (optional, by default context will by assigned in runtime) SetFlags - data source flags (optional, by default None ) SetLogicAssemblies - to set data processing logic classes assemblies FullName for this repository (see Using three tier architecture and IDataLogic<T> ) To get reference to IRepositoryDescription<T> interface is required to define mapping of repository read/write properties using IRepositoryStructure<T> interface method Map Example: ... .Map(x => new Invoice { DocState = x.Link<string, DocState>(\"S\", \"name\", z => z.LinkProperty<DocState>(y => y.Name), z => z.LinkProperty<DocState>(y => y.Code, y => y.DocStateCode), z => z.LinkProperty<DocState>( (Invoice y) => y.GetProperty<long>(\"DocStateId\"))), DocCatalog = x.Link<string, Catalogue>(\"U\", \"name\", z => z.LinkProperty(y => y.Name), z => z.LinkProperty<Catalogue>( (Invoice y) => y.GetProperty<long>(\"CatalogueId\"))), DocNumb = x.Field<string>(\"N\", \"numb\"), DocDate = x.Field<DateTime?>(\"D\", string.Empty, z => z.Default(DefaultType.CurrentDate)), Scan = x.Lob(\"SC\", z => z.OuterFlag()), Source = x.Xml(\"SR\", z => z.OuterFlag()), CustomerFrom = x.Link<string, Customer>(\"F\", \"name\", z => z.LinkProperty(y => y.Name), z => z.LinkProperty<Customer>(y => y.GetProperty<long>(\"CustomerId\"), y => y.GetProperty<long>(\"FromCustomerId\"))), CustomerTo = x.Link<string, Customer>(\"T\", \"name\", z => z.LinkProperty(y => y.Name), z => z.LinkProperty<Customer>(y => y.GetProperty<long>(\"CustomerId\"), y => y.GetProperty<long>(\"ToCustomerId\"))), DeliveryType = x.Field(\"DD\", string.Empty), DeliveryDate = x.Field<DateTime?>(\"DD\", string.Empty, z => z.Default(DefaultType.CurrentDate)) }, x => x.ExternalLink(\"DocId\")) .SetBaseTable(\"D\").SetLogicAssembly(\"XDataObjectTest\") ... More detailed repository properties map description see below ."
  },
  "tutorial/mapping/dynamic/external_link.html": {
    "href": "tutorial/mapping/dynamic/external_link.html",
    "title": "External link | XData website",
    "keywords": "External link External link can be dynamically defined using expression of type Expression as part of call Map method of IRepositoryStructure interface. Expression<IExternalLinkDefinition> can be obtained using multiple overloads of ExternalLink method of ExternalLinkDefinitionAdapter<T> : IExternalLinkDefinition ExternalLink<TChild>(params Expression<Func<IExternalLinkAdapter<T, TChild>, IExternalLinkFlag>>[] linkFlags) IExternalLinkDefinition ExternalLink<TChild>(Expression<Func<T, object>> property, params Expression<Func<IExternalLinkAdapter<T, TChild>, IExternalLinkFlag>>[] linkFlags) IExternalLinkDefinition ExternalLink<TChild>(string property, params Expression<Func<IExternalLinkAdapter<T, TChild>, IExternalLinkFlag>>[] linkFlags) IExternalLinkAdapter<T, TChild> used to specify properties of external link: Filter - used to specify external link runtime filter, FilterCombination - used to set filter group of filter, DirectLink - used to set direct link flag, see tree master-detail specifics for details, MasterRefresh - used to set refresh master repository current row data on submit details changes flag (useful when master has calculated properties over detail repository data), Nullable - filter null processing behavior , Operation - link filter operation (see Filters ), PrimaryFilter - used to specify external link is optional filter, Property - link property in master repository (used when property is hidden property ), Property<TChildLink> - link property in master repository (used when property is actual property), TreeFilter - used to set external link filter's tree filter flag // when external link used hidden property ..., x => x.ExternalLink<InvoiceSpec>(\"DocId\")) // when external link used read-only or regular property ..., x => x.ExternalLink<InvoiceSpec>(z => z.DocId))"
  },
  "tutorial/mapping/common_type.html": {
    "href": "tutorial/mapping/common_type.html",
    "title": "Common types properties | XData website",
    "keywords": "Common types properties Common types properties (string, bool, int...) including nullable (int?, bool?...), and enum properties is declared as common class properties. Data access to this properties is usual. Only mapping description is depends on static or dynamic method of declaration."
  },
  "tutorial/mapping/column.html": {
    "href": "tutorial/mapping/column.html",
    "title": "Hidden properties | XData website",
    "keywords": "Hidden properties Some columns in database is needed to full description of mapping, but not required to business logic. This columns is declared as part of mapping named Column is selected from database, but not mapped on data object properties. For example - XData can operate primary (PK) and foreign (FK) keys of business objects and work with master-detail references between them, but mapping to property of external references is not required to operate with key. Second case - optimistic concurrency resolving (see concurrency resolving ) required concurrency token field, but this field is not required to business logic. Third example - when data is grouped, needed to declare some field to link with external reference , but in this case possibly we can`t include this field in SELECT expression because of GROUP BY syntax. This case is resolved by Hidden property of column declaration. When Hidden is true - column will be not included into SELECT expression of resulted SQL query. Hidden properties description is various to static and dynamic mapping declaration methods."
  },
  "tutorial/mapping/binary_type.html": {
    "href": "tutorial/mapping/binary_type.html",
    "title": "Binary properties | XData website",
    "keywords": "Binary properties To work with large binary object (BLOB) using lazy coupling XData represent property type Lob . This type has followed... properties: byte[] Value - binary object value (read-only) bool Assigned - check object has value (including empty value) or NULL methods: GetSize () - returns size of binary object (extension) Modify(Action<byte[]> action) - helper method to simplify changing of binary object value operation: += - \"syntax sugar\", _data.SomeBlob += _someVariable identical with _data.SomeBlob.Value = _someVariable. Examples: newInvoice.Scan += _image; ... if(newInvoice.Scan.Assigned) _size = newInvoice.Scan.GetSize(); ... invoice.Scan.Modify(x => x = new byte[0]);"
  },
  "tutorial/query.html": {
    "href": "tutorial/query.html",
    "title": "Read only dynamic query building | XData website",
    "keywords": "Read only dynamic query building XData have a feature allow the programmer to build read-only data query in dynamic LINQ like style: var query = XDataMapping.GetStructure(\"D\") .DataTable(\"T_DOC\", \"D\", x => x.DictFilter(\"T_DOC_TYPE\", \"doc_type_id\", \"code\", \"INVOICE\")) .DataTable(\"T_DOC_NUMBER\", \"N\", x => x.Link(\"D\", \"doc_id\")) .DataTable(\"T_DOC_SCAN\", \"SC\", x => x.Link(\"D\", \"doc_id\")) .DataTable(\"T_DOC_DELIVERY\", \"DD\", x => x.Link(\"D\", \"doc_id\")) .DataTable(\"T_DOC_SOURCE\", \"SR\", x => x.Link(\"D\", \"doc_id\")) .Subquery(\"A\", typeof(DocSpecAmounts), \"Amount\", DataGrouping.Sum, x => x.SubqueryLink(\"DocId\")) .InnerView(\"H\", XDataMapping.GetStructure(\"H\") .DataTable(\"T_DOC_HISTORY\", \"H\") .Select(x => new { DocId = x.Field<int?>(\"H\", string.Empty, z => z.Key(), z => z.Group(DataGrouping.None)), HistoryDate = x.Field<DateTime?>(\"H\", string.Empty, z => z.Group(DataGrouping.Max)) }), x => x.SubqueryLink(z => z.DocId) .SetOperation(FilterOperation.OuterJoin)) .Column(\"DocId\", x => x.Field<int?>(\"D\", \"doc_id\", z => z.Key())) .Select(x => new { Number = x.Field<string>(\"N\", \"numb\"), Date = x.Field<DateTime>(\"D\", \"doc_date\"), Amount = x.Expr<decimal?>(\"doc_amount\", DataExpressionType.SubQuery, \"A\", DbType.Decimal, z => z.Size(17, 5)), //SUBQUERY LastChange = x.Ref<object>(\"H\", \"HistoryDate\"), //INNER VIEW Scan = x.Field<byte[]>(\"SC\", string.Empty), //BLOB DeliveryType = x.Field<DeliveryTypeEnum>(\"DD\", string.Empty), //ENUM Source = x.Field<string>(\"SR\", string.Empty) //XML }).AsQuery(dataScope); foreach (var x in query) Console.WriteLine( \"Number:{0}, Date:{1}, Amount:{2}, Scan:{3}, LastChange:{4}, DeliveryType:{5}, Source:{6}\", x.Number, x.Date, x.Amount, Encoding.UTF8.GetString(x.Scan), x.LastChange, x.DeliveryType, x.Source); Static class XDataMapping has method GetStructure to obtain IQueryStructure<T> interface having various methods to describe very complicated query structure dynamically. Rules of building queries dynamically is similar as dynamic mapping but query more lightweight, safe and can be extended in runtime. Method GetStructure has overloaded version to get structure of existing repository to extend it with adding data sources as data tables , subqueries and inner views , applying filters including filters by subqueries. Query mapping logic can be declared by Select method returning IQueryDescription<T> interface. No matter statically or dynamically is mapped repository we use as source structure, it can be extended. To access query data get IQueriable implementation IDataQuery<T> from IQueryDescription<T> use AsQuery method. With dynamic query You can query and map data to any object including real-time typed object as showed in example. Dynamic mapping has no method to add filters in runtime. To add new filter to QueryStructure used method AddFilters ."
  },
  "tutorial/logging.html": {
    "href": "tutorial/logging.html",
    "title": "Logging and debug info | XData website",
    "keywords": "Logging and debug info During process of developing and debugging Your application the XData can provide You information to find error or understand context of any data processing activity. XData does not enforce developer with using some logging system. Instead of that XData (version .Net 4.0) provide simple interface ILogWriter to implement. Implementation of this interface (if not implemented yet) allows to integrate XData log output into any You choose logging subsystem of Your application. As example You can use any log writer plugin from XData sources. Configuration of log writer plugin is described configuration file section xdata using attribute log providing value with assembly qualified type name, where type is implements ILogWriter interface. XData (version .Net Standard 2.0) use Microsoft.Extensions.Logging subsystem. In the case when the default level (usually the logging level Information) is not sufficient to diagnose the problem, it can be lowered by means of the basic logging technology (including by setting the logging parameters in the configuration file). The configuration rules of the basic logging subsystem can be found on their websites: Microsoft.Extensions.Logging , System.Diagnostics.Trace , log4net . * (version .Net Standard 2.0) Microsoft.Extensions.Logging category name of XData logger is \"XData\". Sample logging configuration for debug: { \"Logging\": { \"LogLevel\": { \"Default\": \"Debug\", \"XData\": \"Debug\", \"System\": \"Information\", \"Microsoft\": \"Information\" }, \"Debug\": { \"LogLevel\": { \"Default\": \"Debug\" } }, \"Console\": { \"LogLevel\": { \"Default\": \"Information\" } } } } and in code services.AddLogging(x => x.ClearProviders() .AddConfiguration(Configuration.GetSection(\"Logging\")) .AddDebug().AddConsole()); or in code only services.AddLogging(x => x.AddFilter(\"XData\", #if DEBUG LogLevel.Debug #else LogLevel.Information #endif ).AddDebug().AddConsole()); * (version .Net 4.0) System.Diagnostics.Trace switch name for XData log messages is \"logLevelSwitch\". See System.Diagnostics.Trace documentation for details. log4net requires no specific constants to configure log messages severity level. See log4net documentation to obtain configuration details. Important Configuration of logging subsystem to debug mode can reduce application productivity. It's recommended to switch off debug mode when not required. But it's a very powerful tool to help developer with repository mapping correctness check. It's a highly recommended to use it on debug stage! SQL query logging can be also used as source for checking query plan effectiveness. Always check query plans - it's help You to develop high quality products."
  },
  "tutorial/localization.html": {
    "href": "tutorial/localization.html",
    "title": "Localization | XData website",
    "keywords": "Localization By default all errors and information messages from XData modules use neutral (en-US) locale, but it's possible to translate this using satellite assembly (for .Net 4.0 version) or prepare resx files to Microsoft.Extension.Localization (for ASP.Net Core 2.0 projects used XData .Net Standard 2.0 version). To help developers make localization fast and simple as possible, XData sources complected with some \"bat\" files. All settings within files is made for Russian locale (ru-RU), but there are no problem to patch files for any locale. Prepare text files to translation Patch file add_locale.bat with setting path to RESGEN utility (\"C:\\Program Files\\Microsoft SDKs\\Windows\\v8.0A\\bin\\NETFX 4.0 Tools\"), path to XData.dll and locale code. Run add_locale.bat and be sure with no errors during making translation file (.restext). Translate localization strings inside .restext file to target locale language. Take care, some string are multi-line, and some strings has format templates structure (see string.Format). Satellite assembli compilation (for .Net 4.0 version) Patch file compile.bat with setting path to AL utility (\"C:\\Program Files\\Microsoft SDKs\\Windows\\v8.0A\\bin\\NETFX 4.0 Tools\"), path to XData.dll and locale code. Run compile.bat and be sure and be sure with no errors during making satellite assembly (.dll). Resource file generation (for ASP.Net Core 2.0 projects used XData .Net Standard 2.0 version) Patch file createres.bat with setting path to RESGEN utility (\"C:\\Program Files (x86)\\Microsoft SDKs\\Windows\\v10.0A\\bin\\NETFX 4.6.1 Tools\"), path to XData.dll and locale code. Run createres.bat and be sure and be sure with no errors during making resource file (.resx). Install sattelite assembly (for .Net 4.0 version) Copy localization folder named as target locale code to bin folder of Your application (where XData.dll is located) or (for ASP.Net Core 2.0 projects used XData .Net Standard 2.0 version) copy .resx file for target locale to resources folder of Your ASP.Net Core 2.0 site. Restart Your application or site. Tip Recommended materials: https://msdn.microsoft.com/en-us/library/f45fce5x(v=vs.100).aspx https://msdn.microsoft.com/en-us/library/ccec7sz1(v=vs.110).aspx https://msdn.microsoft.com/en-us/library/sb6a8618(v=vs.100).aspx http://www.codeproject.com/Articles/5447/NET-Localization-using-Resource-file"
  },
  "tutorial/linq.html": {
    "href": "tutorial/linq.html",
    "title": "LINQ support | XData website",
    "keywords": "LINQ support XData repositories and dynamic queries implements interface IOrderedQueryable<T> and granted full support for IQueriable methods. // full data object has many fields but we want to select only two of them dataScope.GetRepository<SomeObject>().Select(x => new { x.One, x.Two }); Important Methods SkipWhile , TakeWhile , Join , SelectMany is supported, but results with full fetch of source data and executed over IEnumerable sources on Linq2Object level. This limitations is related to unexpected complexity of translation handlers to SQL for first two methods, and dynamic changes of result type in others. To effective access to joined or restricted by fields data sources with single database query use dynamic queries Instead of multiple data object joining or sub-selecting You can define various mappings and/or dynamic queries over same data as many as You need. This specific mappings or dynamic queries can be fine tuned for high speed and effective data access according any specialized requirements. Some of them can be reused, some not. But all of them will be as effective and low cost as You can write."
  },
  "tutorial/intro.html": {
    "href": "tutorial/intro.html",
    "title": "Introduction | XData website",
    "keywords": "Introduction Why and when You need XData? Independence: Business object hierarchy of Your application not depend XData object hierarchy. Database structure not dictate program object structure and vice versa. Database specific terms (primary key, foreign key, surrogate key value, concurrency token and so on) can be hidden from program object model due object mapping. XData base mapping concept based on one business object mapping with any number of data sources (tables, xml sources, subqueries, recursive trees and procedures) with not restricted recursion deep. Each of mapped business object can operate with hierarchically organized \"updatable tree\" of tables so business object changes can be stored in multiple linked tables at once. Complicated business objects can be created, updated and deleted with no additional code more then mapping. Same mapping can be used over multiple RDBMS (with some restrictions). SQL dialect modules can be developed independently from adapter modules developed over various ADO.Net providers used to access the same RDBMS. With ability to use XML data sources, temporary tables and procedure support, system can work using proprietary application database schemes where schema changes are not allowed. All technologically required tools (for example DI) can be integrated with XData, but You can choose Your favorite one independently without any dictate or double using it inside XData. Functionality: Full IQuariable and LINQ support. XData allowed to use SQL expressions as field data source. Calculated properties can be evaluated on .Net side. Active record model of data access is supported. Fully declarative using of optimistic locking of data is provided. Pessimistic locking is allowed when it supported by RDBMS functionality. Your application over XData can be deployed in three-tier mode with data aware logic can be took out to the application server layer (only in full .Net Framework 4.0 or above for now). XData introduce data aware business object actions which can be used as in two-tier mode as in three-tier mode. .Net trigger like logic can be programmed over mapped business objects (not over single table!). This feature also can be deployed on application server layer in three-tier mode. Unnamed SQL code blocks can be described as LINQ-like structures that have the same syntax, regardless of the DBMS or SQL dialect used. The ability to inherit the mapping description either using the usual inheritance structure and building a separate inheritance hierarchy for the mapping description. Usability Human readable mapping structure with unambiguous correlation with resulting SQL query. Programmer can get query text to check query execution plan for optimization. Feature rich security subsystem over business object level can be simply implemented using separate NuGet package. Declarative realization of Unit of Work over business object level available when using separate NuGet package. Lazy loading of large objects (XML, BLOB...) is available from the box. Two modes of mapping (using attributes and LINQ style expressions) or their mixing can be used. Dynamic in-place read only queries it's a powerful tool to access data in complicated cases. Virtual data support. You can use database mocking ability for testing. You can debug three-tier XData application in two-tier mode. Attachable localization based on satellite assemblies ability can be used to localize XData internal messages to any languages You interested (only in full .Net Framework 4.0 or above for now). Speed: SQL optimization granted by human controlled mapping results. Fields containing large objects (LOB or XML) are loaded only when they are needed. Hierarchically organized objects are also loaded only if they are needed and to the extent that they are needed. These and other built-in ways to optimize work with data allow XData to work optimally process complex data objects at the same time without limiting the developers capabilities. Code of XData is extremely optimized to speed with using profiler until no one internal code block is still marked \"hot\" over business logic and database access. Mapping structure caching. Cache can be reset by programmer. Data caching. Cache can be reset by programmer. SQL hints are supported to improve productivity in most complicated cases. Is any restrictions of using XData exists? XData not supported Code First approach: Programmer or database administrator can write SQL script. This code is produced by human, real (not artificial) intellect of professional... But still XData has ability to run this script over database using Custom SQL executing feature. XData not supported DDL: By the same logic as above, and with the same receipt of using. XData not supported Database First approach: Now I've no idea to provide the same independence level as announced above using this approach (may be in the future...). Powerful, but complicated: Try it, simple things still are simple, more complicated is not as scary as they appear at first sight. But the power is never be useless. RDBMS SQL specific statements: So many RDBMS specific statements. So many features realized in one only database system, or restricted by version... May be some of them will be implemented, may be not... (planned to support in next versions) More dialects and adapters: Now supported MS SQL Server, Oracle, PostgreSQL, MySql and SQLite. It's a most used RBDMS, but Your favorite database can be out of the list. There are two ways - write me a letter and wait for my code realization, or develop it by Yourself. It's not a \"piece of cake\", but also not a huge amount megabytes of highly complicated code."
  },
  "tutorial/glossary.html": {
    "href": "tutorial/glossary.html",
    "title": "Glossary | XData website",
    "keywords": "Glossary Data object Application domain objects mapped (statically or dynamically) to database representation. Data object instances can be obtained through generic repository typed by data object type. Data objects non read-only properties can be changed and that changes may be submitted to database. The data object in XData is considered as exactly the object of the domain (in DDD terminology). Moreover, its reflection on the database structure is not limited. So a data object can be reflected on the contents of one table: <!--MD5=[4efa0cfa5e1d38a4afda4e219b98680a] class t_doc_state--> t_doc_state doc_state_id code name <!--MD5=[177ee83b98d3d3cbeb24134116cfa8c5] @startuml hide circle skinparam ClassHeaderBackgroundColor lightgray skinparam ClassBorderColor black skinparam ClassBorderThickness 1 skinparam ClassBackgroundColor transparrent skinparam ArrowFontSize 8 skinparam ArrowColor black entity t_doc_state { <&key> doc_state_id - - <&code> code name } @enduml PlantUML version 1.2020.12(Sat Jun 06 10:54:15 UTC 2020) (GPL source distribution) Java Runtime: Java(TM) SE Runtime Environment JVM: Java HotSpot(TM) 64-Bit Server VM Default Encoding: UTF-8 Language: en Country: US --> public partial class DocState { public long DocStateId => this.GetProperty(x => x.DocStateId); public string Code { get; set; } public string Name { get; set; } } A few tables: <!--MD5=[4efa0cfa5e1d38a4afda4e219b98680a] class t_doc_state--> t_doc_state <!--MD5=[bccea5d0c54fc84e4bad16ab69fd73e7] class t_doc_type--> t_doc_type doc_type_id code name <!--MD5=[5ea577eca533bfca935d04f775d3f167] class t_doc--> t_doc doc_id doc_date numb doc_state_id doc_type_id generation changed <!--MD5=[eab5c40043b4b5329be06de2f0271aac] class t_catalog_doc--> t_catalog_doc catalog_id doc_id <!--MD5=[957235e470c5a75c0bcb7e32f4b6bfa6] class t_catalog--> t_catalog <!--MD5=[fd8c5e68644f1f4fc0b14eca97226ae4] class t_doc_delivery--> t_doc_delivery doc_id delivery_type delivery_date <!--MD5=[710d3dc0240fd500b1d510e138be1447] class t_doc_scan--> t_doc_scan doc_id scan <!--MD5=[5937349b424f6b33ad58af94594dfd63] class t_doc_source--> t_doc_source doc_id source <!--MD5=[8feb3003cd59a4822a76af3887dc1c0a] link t_doc_state to t_doc--> doc_state_id <!--MD5=[691dc1cbb8fa0f09f9906b607bf3ccef] reverse link t_doc to t_doc_type--> doc_type_id <!--MD5=[cc073f3f803e6be11274258daf9be266] reverse link t_catalog to t_catalog_doc--> catalog_id <!--MD5=[64363e4c077e3ece99a0e625ba56e6a8] link t_catalog_doc to t_doc--> doc_id <!--MD5=[94de7abaa940d64e718a7c3244926e87] reverse link t_doc_delivery to t_doc--> doc_id <!--MD5=[7c459e52799c0d4d655e72449bb91e72] reverse link t_doc_scan to t_doc--> doc_id <!--MD5=[4aa29f824d631e9db9c0b4ff518403cc] reverse link t_doc_source to t_doc--> doc_id <!--MD5=[e5289b989f20ef9db91ec766c5f49285] @startuml hide circle skinparam ClassHeaderBackgroundColor lightgray skinparam ClassBorderColor black skinparam ClassBorderThickness 1 skinparam ClassBackgroundColor transparrent skinparam ArrowFontSize 8 skinparam ArrowColor black entity t_doc_state { } entity t_doc_type { <&key> doc_type_id - - <&code> code name } entity t_doc { <&key> doc_id - - doc_date numb <&arrow-circle-right> doc_state_id <&arrow-circle-right> doc_type_id - - <&tag> generation <&clock> changed } t_doc_state -right-{ t_doc : doc_state_id t_doc_type -left-{ t_doc : doc_type_id entity t_catalog_doc { <&key> <&arrow-circle-right> catalog_id <&key> <&arrow-circle-right> doc_id } t_catalog_doc -up-{ t_catalog : catalog_id t_catalog_doc - -{ t_doc : doc_id entity t_doc_delivery { <&key> <&arrow-circle-right> doc_id - - delivery_type delivery_date } t_doc_delivery }o- - t_doc : doc_id entity t_doc_scan { <&key> <&arrow-circle-right> doc_id - - <&map> scan } t_doc_scan }o- - t_doc : doc_id entity t_doc_source { <&key> <&arrow-circle-right> doc_id - - <&document> source } t_doc_source }o- - t_doc : doc_id @enduml PlantUML version 1.2020.12(Sat Jun 06 10:54:15 UTC 2020) (GPL source distribution) Java Runtime: Java(TM) SE Runtime Environment JVM: Java HotSpot(TM) 64-Bit Server VM Default Encoding: UTF-8 Language: en Country: US --> public partial class Invoice { public long DocId => this.GetProperty(x => x.DocId); public string DocStateCode => this.GetProperty(x => x.DocStateCode); public Link<string, DocState> DocState { get; set; } public long DocCatalogId { get; set; } public string Numb { get; set; } public DateTime? DocDate { get; set; } public Guid Generation => this.GetProperty(x => x.Generation); public DateTime Changed => this.GetProperty(x => x.Changed); public Lob Scan { get; set; } public Xml Source { get; set; } public DeliveryTypeEnum DeliveryType { get; set; } public DateTime DeliveryDate { get; set; } } And also several objects can be reflected in the same tables: for example, different types of documents from the previous example can be based on the same table T_DOC and having another link to T_DOC_TYPE store their attributes in the same and/or other tables related T_DOC as one-to-one. Updatable tables hierarchy The mapping of the data object to the storage structure can include mutable (updatable) tables  which will be updated when the data object changes and that changes are reflected in the database. And information tables  which contain reference data values, references to which (for example) are contained in the mutable tables but this data itself will not be updated even if we change the link to this directory in the data object. The link will change but the dictionary itself will remain unchanged. Updatable tables are arranged in a hierarchy according to the relationships between the tables from the root - base table into which, when inserting, it is necessary to insert data first of all. The base table has no dependencies on mutable tables of this data object, only on informational ones (if any). Further along the hierarchy, updatable tables will be directly dependent on the base table and so on. Information tables are not included in the tree of updated tables and in the description of the mapping of the data object are placed on the first level sibling to the base table. Real update of one or subtree of a tables in that hierarchy depends on changes of properties that mapped to concrete tables. When optional references is declared between tables inside updatable tables hierarchy, update of data objects can be automatically translated to insert or delete SQL statement applied to concrete table. Base table Root table of updatable tables hierarchy . In case of using read-only repository mapping, base table role can be assigned to any table (or virtual table ) with which it will be logical to begin the construction of the SQL SELECT expression. Optional references The outer join references between tables within updatable tables hierarchy . Referenced (detail) table must contain one or more properties marked as mandatory or OuterFlag . At least one mandatory property are required and it can not be mapped on primary key (or part of primary key). In most cases that properties is natural key of the table. The values assigned to that properties will be used to make a decision over operation applied to table. This property value used as indicator of whether or not to insert an entry into the table connected by the outer join (when inserting). If value is null inserting to this table (and their child tables in updatable tables hierarchy) will be skipped. When updating to an empty value, it signals the need to delete the record from the table optionally connected and their child tables in updatable tables hierarchy. Data scope Data scope term is required to describe an independent environment of operating the same data inside the application. Each data scope has an GUID identifier - layer. In each data scope application logic can set independent filters values over the same repository . Same repositories can be linked over different data scopes using different ways and rules. Repository Repository grant access to acquire data objects and apply their changes to database. Repository is represented by XData internal structures and available using interface IRepository<T> extend IQueryable<T> , where T is data object type. Context String alias associated to one of application database instance and all configuration options to use it inside XData environment. Configuration options can be obtained from configuration file or registered dynamically during runtime (see Installation & configuration ). Repository alias Optional repository alias string. Required to unique identification repository used multiple times within one data scope . Sometimes the same repository (but arranged by different runtime filters and variables ) can be useful as multiple detail data sources in master-detail relations inside single data scope (master-detail relations is limited to use single data scope). Filters Filters statically (by mapping) or dynamically applied to repository . To define complex filtration rules filters can be grouped in filter groups characterized by name and logical filter combination operation ( AND or OR ). Filter groups can combine filters and/or depended filter groups. Root filter group of repository with filters combined using AND logical operation, can be omitted and will be automatically created in runtime. Default filter group name is empty string. By default all filters are linked to default filter group. To specify other filter group to certain filter set filter property Combination to name of this filter group. The master-detail relations is realized on detail repository filters values set up also. In other cases, repository can be filtered by apply LINQ expressions on it. Runtime filters Filters, that allow set the value during runtime. Runtime filter value set can be automated using describing master-detail relation between repositories , or manually, using SetFilterValue method of repository. The runtime filter can be defined as part of the mapping of the data object or added dynamically when the filter value is assigned. However, to dynamically add a runtime filter, it is required that the field to which that filter will be applied be described in mapping (as a property, read-only property or a hidden property). In addition, using the runtime filter, you can change (or set) the filter value described in mapping. In this case, the property is not specified when describing such a filter, and the filter name must match the one described during mapping. Data source flags DataStructureFlags enumeration contains set of flags that defines structure of data source. Data source can be marked with combination of values: None - default data source structure, plain object structure, can be edited, data grouping not applied. ReadOnly - data source marked as read-only. In optimization goals is recommended to use this flag for all data sources read-only by application logic. Tree - data source is marked as hierarchically organized. Allow to use multiple ways to filter detail data sources (when master is marked as Tree ) - using plain links to active tree node, or to active tree node and subtree. Grouping - data source is marked as grouped. Required to describe grouped data source. Property flags DataPropertyFlag enumeration contains set flags that defines specific role of property of the data object during its mapping: None - default value, property marked with no specific roles Id - property is part of data object primary key OuterFlag - property is marked as mapped to mandatory field of optional referenced table. The value of this property is used to make a decision over operation applied to optional referenced table. ConcurrencyToken - concurrency token used within optimistic locking . SQL expression type DataExpressionType enumeration contains types of SQL expression description when using in data object mapping: PlainSql - SQL expression is plain SQL code, SubQuery - SQL expression is subquery with specified alias, LinqExpression - SQL expression defined as a static private field typed as Calculate<T> , where T is a SQL expression result type, and the field value is LINQ style expression reflects SQL expression logic. Default value type When inserting data into a database table, the concept of a default field value is often used. DefaultType enumeration contains types of values used to set default values of properties: CurrentDate - current date (database time settings used) CurrentDateTime - current date and time (database time settings used) CurrentDateTimeUTC - current date and time UTC (database time settings used) Variable - variable value with name stored in DefaultValue (see here for details) Const - constant value stored in DefaultValue AutoIncrement - value generated by database by auto increment fields or sequence. In case of using sequence is required to match the rules described here . NewGuid - new GUID value is generated UserName - current user name. Security provider subsystem using is required to fill this type of default value. Default value features DefaultFeature enumeration contains extension features used with default values of properties is assigned: UseOnInsert - use default value on insert (by default, always applied) UseOnUpdate - use default value on update SkipWhenAssigned - skip insert into table when PK value assigned explicitly (see here for details) UpdateWhenAssigned - change insert operation over table to update when PK value assigned explicitly (see here for details) Default features can be combined. For example: DefaultFeature.UseOnUpdate | DefaultFeature.SkipWhenAssigned Aggregation type DataGrouping enumeration contains data aggregation functions used inside grouped data source: None - mapped field or SQL expression is one of data source grouped by. Count, Sum, Min Max, Avg - corresponded function is applied to mapped field or SQL expression. Property data source Table field, view field, SQL procedure (or function) parameter or SQL expression mapped to data object property value. Virtual table Various RDBMS has mechanics to select the data without specifying real source (\"dual\" table in ORACLE, omit \"from\" section in MsSqlServer and so on). Virtual data table is recommended for use as source of calculated fields , SQL expressions , when virtual data processing is required. Virtual table is not described in mapping. To set virtual data source as source of property set data source alias as empty string. Filter group Named group of filters (or submittal filter groups) linked with the same logical operator ( AND or OR ). Root filter group named as empty string and have an AND logical operator. Root filter group can be omitted in mapping description. All filters without explicit group specification is assigned to root filter group. Filter group names must to be unique named within data object mapping description. Filter null processing behavior FilterNullable enumeration contains behaviors applied to null value processing while comparing data to filter value: Nullable - (default) filter null value is omits the filter (no filter limitation applied) NullsAllowed - null and not null values of filter and data is compared separately (filter within SQL query will looks like ((field is null and :param is null) or field = :param) ) NullsNotAllowed - filter null value is translated as non valid and query will return no records (filter within SQL query will looks like (:param is not null and field = :param) ) NullsCompared - only null values of filter and data is translated as valid (filter within SQL query will looks like (:param is null and field is null) ) Variables Using variables allows you to customize the existing mapping for a specific situation. Using Constant filters or Dictionary filters (or see here and here for dynamic mapping) with a value of the type variable value , you can delay the substitution of a particular value until it is used. To do this, use the \"variables\" parameter of the GetRepository method. Another use of variables is to set stored procedure parameters (or see here for dynamic mapping). In addition, you can use the variables to define the default field values . In the case of using a subquery (or inner view), you can specify variables for a specific subquery in the mapping (or see here for dynamic mapping). This is useful when the subquery structure is used several times with slightly different filter values. Note that you can use the SetVar extension method to describe variables: \"TestVar\".SetVar(1)"
  },
  "tutorial/config.html": {
    "href": "tutorial/config.html",
    "title": "Install & configuration | XData website",
    "keywords": "Installation and configuration NuGet configuration To get XData NuGet packages You will need modify nuget.config as described below and place it in project root folder near Your solution file. <?xml version=\"1.0\" encoding=\"utf-8\"?> <configuration> <packageSources> <clear /> <add key=\"xdata\" value=\"https://nuget.pkg.github.com/mickfierte/index.json\" /> <add key=\"nuget.org\" value=\"https://api.nuget.org/v3/index.json\" /> </packageSources> <packageSourceCredentials> <xdata> <add key=\"Username\" value=\"API_KEY\" /> <add key=\"ClearTextPassword\" value=\"API_KEY\" /> </xdata> </packageSourceCredentials> </configuration> * replace API_KEY with API key provided by author Installation To start use XData basic functionality is required to setup NuGet XData package . XData plugins or additional modules can be downloaded and used separately. To work with related objects ( Unit of Work implementation) is required to setup NuGet XData WorkSet (UnitOfWork) package . To implement security session and use application data access with XData is required to setup NuGet XData Security package . To use one or more SQL dialect, SQL adapter, specific .Net 4.0 log writer XData plugins it can be installed like any other NuGet package. To deploy application in three-tier architecture read here Acquiring XData configuration during runtime .Net Standard 2.0: XData can be dynamically configured when defining XData service (see AddXData ) in ServiceCollection using optional parameter options in LINQ style. .AddSingleton(typeof(IConfigurationRoot), x => null) .AddXData(x => x.AddDialect(\"postgresql\", XDataAdapter.PostgreSql.Dialect) .AddAdapter(\"postgresql\", XDataAdapter.PostgreSql.Adapter) .AddContext(\"test\", \"postgresql\", \"postgresql\", \"Server=localhost;Database=XDataTest;User Id=postgres;Password=123456\", true)) Configuration file in .Net Standard 2.0 version is read by Microsoft.Extensions.Configuration service registered during application startup. Tip XDataAdapter.PostgreSql.Dialect, XDataAdapter.PostgreSql.Adapter and similar constants for other databases is defined in adapter NuGet packages. .Net 4.0: XData can be dynamically configured when acquiring XData engine XDataManager.InitXData using optional parameter options in LINQ style. Warning Signature of XDataManager.InitXData method is slightly different for .Net 4.0 version! See versions comparison for details. var dataEngine = XDataManager.InitXData(x => x.AddDialect(\"postgresql\", XData.PostgreSql.Dialect) .AddAdapter(\"postgresql\", XData.PostgreSql.Adapters) .AddContext(\"test\", \"postgresql\", \"postgresql\", \"Server=localhost;Database=XDataTest;User Id=postgres;Password=123456\", true)); //or using configuration file var dataEngine = XDataManager.InitXData(x => x.UseConfiguration( System.Web.Configuration.WebConfigurationManager.OpenWebConfiguration(\"~\"))) Tip When using both versions You can use IDataOptions methods to store partial non secure connection string only and fill credentials during runtime. Security related information can be obtained separately from some secure source. Configuration XData using config file Tip When using .Net Standard 2.0 version config file can be formatted in any notation but structure of config file need to be correspond XML structure described here Important When using XML formatted config file required to add specific descriptor for XData specific section \"xdata\" <configuration> <configSections> <section name=\"xdata\" type=\"System.Configuration.IgnoreSectionHandler\"/> </configSections> ... Important Check configSections section is first section inside XML configuration file! Connection strings for each of context must to be declared in standard section connectionStrings and name attribute should equal to context name. Connection strings is required on client side only when two-tier (client-server) architecture used. <connectionStrings> <add name=\"TEST\" connectionString=\"Data Source=(local);Initial Catalog=XDataTest;User Id=test;Password=test\"/> </connectionStrings> There are three possible ways to secure connection string in configuration file: Cipher config file section connectionStrings section Using partial connection strings during runtime Deploy application in three tier mode . In this case connection string is not required to be configured on client side. XData specific section xdata has a structure: <xdata default=\"TEST_ORACLE_ODP\" log=\"XDataTraceLog.TraceLog, XDataTraceLog\"> <adapter name=\"ORACLE_ODP\" assembly=\"XOracleODPAdapter\"/> <dialect name=\"ORACLE\" assembly=\"XOracleDialect\"/> <context name=\"TEST_ORACLE_ODP\" adapter=\"ORACLE_ODP\" dialect=\"ORACLE\" sequence=\"XDataObjectTest.MySequenceRule, XDataObjectTest\" concurrencyError=\"-20001\"/> </xdata> The xdata section required to contain attribute default with context name used by default. Attribute log optional, used for .Net 4.0 version only (.Net Standard 2.0 version used Microsoft.Extensions.Logging service). Log attribute value is assembly qualified type name for ILogWriter realization (see available log plugins or implement any You want log system adapter). Log messages minimal severity level filters can be configured using native tools and abilities provided with chosen log subsystem. Inside xdata section for each of context required elements: dialect (required always, can be shared between multiple contexts) - register an unique alias to specific RDBMS SQL dialect support. Attribute name contains an alias of dialect. Attribute assembly - assembly name of specific dialect plugin. When plugin implementation support additional configuration settings, element dialect may have an specifically organized internal structure described in plugin readme file. adapter (required when two-tier architecture is used only, can be shared between multiple contexts) - register unique alias to adapter for specific ADO.Net provider. Attribute name contains an alias of adapter. Attribute assembly - assembly name of specific adapter plugin. When plugin implementation support additional configuration settings, element adapter may have an specifically organized internal structure described in plugin readme file. context (required always) - contains context settings. Attribute name contains context name. Attribute adapter (required when two-tier architecture is used only) contains adapter alias. Attribute dialect - dialect alias. In case of using sequences required to specify attribute sequence contains assembly qualified type name of ISequenceNameRule implementation. When optimistic concurrency error code need to have a special value for some reason (see specific adapter readme file) set concurrencyError attribute to specific error code value. proxy (required when three-tier architecture is used only) - declare WCF client endpoint name for context named same as proxy attribute name value. WCF client endpoint name is stored in endpoint attribute value. Same WCF endpoint can be used for multiple contexts. Contexts names on client and server must to have same names. Deploying and configuration process for three tier architecture is described here . Deploying application in three three-tier architecture Project organization rules and assembly deployment principles to deploy application using three-tier architecture described here . Note Three-tier architecture can be applied over .Net 4.0 version only! See next versions to use three-tier feature on .Net Standard 2.0 version. Install and configure server Server is implemented as WCF service XData.Server.dll . Base engine XData.dll library is required to server functionality. As well as log plugins, dialects and adapters to connect database directly. To run Your application business logic on server side server logic and data mapping modules are required on server side two. Limits to choose protocol can be used as transport between client and server: Duplex support Reenter-ability inside one session support It's recommended to host XData.Server on IIS. By default IIS is not configured to activate service over net.tcp, and if You want to use this protocol, see here to configure it. Changes on client side When three-tier architecture is used, required to obtain special module XData.Remote . Application folder must contain client logic and data mapping modules, as well as used by Your application log modules, SQL dialect modules BUT now adapters not required to contexts used in three-tier mode. In configuration file, is required to configure WCF client according Your server settings. Section xdata must to be configured as described above with defining of proxy elements for every context that used three-tier architecture. Remote contexts must to have same names on client and server. Sample three-tier configuration can be obtained from XData test project. Tip You able to combine local connections to some databases with one or more three-tier servers. In the same time You can use multiple dedicated servers, each for one or more contexts. Tip You can fast and simple switch from three-tier mode to client server mode and then back to three-tier by commenting/uncommenting proxy descriptions. It's a very useful feature to debug server logic code ;)"
  },
  "tutorial/concurrency.html": {
    "href": "tutorial/concurrency.html",
    "title": "Concurrency resolving | XData website",
    "keywords": "Concurrency resolving Concurrency can be resolved by pessimistic or optimistic locking on transaction management level. XData is supported an automatic (or manual) transaction management with both locking types support (when locking is supported on RDBMS level). Pessimistic locking is RDBMS ability to define lock over one record for one thread of application until transaction is committed. In case of concurrent raise first thread acquired and lock data and other threads will get an exception. XData pessimistic locking is acquired by repository Lock method call, or an extension method Lock of IDataObject interface. In case of reject of locking the exception is handled, but method returns false. To acquire the pessimistic lock the transaction is required. When no transaction is defined then runtime XDataRuntimeException is raised. Optimistic locking require a special field inside data table - the concurrency token. Concurrency token is always updated on insert or update of the table using some algorithm. When data changes submitted (update or delete) the value is checked for not changed until request data. If value is changes the XDataConcurrencyException is raised. To mark property as concurrency token then define mapping use property flag - ConcurrencyToken and set one of default value type to choose one of concurrency value generation algorithm. Concurrency token value checking is provided automatically. There is possible to set IgnoreConcurrency flag to ignore concurrency when submitting changes using repository Submit method, or an extension method Submit of IDataObject interface. When concurrency is ignored no checks are provided and concurrency is resolved with \"last change is applied\" rule. Tip Concurrency token field can be hidden, but required to be selected from data source table (see Hidden property ). Important Concurrency token property mapping required to define default value behavior with extension feature DefaultFeature.UseOnUpdate . Ways to define concurrency token property mapping is various to static and dynamic notation and described in corresponding topics."
  },
  "tips/optional.html": {
    "href": "tips/optional.html",
    "title": "Optional filters | XData website",
    "keywords": "Optional filters Optional filters is the mechanic to simplify query structure when some filters are not set. For example, we can map data structure to some class and to allow filter objects over some property of dictionary linked to main data structure. When filter applied this link to dictionary table is used, but when not we ineffectively rise query complexity. To avoid unplanned query complexity XData has optional filter feature. Some filters marked as primary - when this filter has value, query has full form. When filter value has cleared or set to null, data source of filtered field (table or view) will be skipped when SQL query composed. When data source has been skipped then links between already skipped and other data sources are analyzed. And when found link marked as primary linked data source will also skipped. When base table of subquery has been skipped - all subquery will be skipped and subquery links analysis for primary links will be provided over outer query. Until no primary filters found. This allows to compose complex query relations over multiple tables and subqueries that reflect on real query only when it really necessary. Let's explain that on example... public partial class TestOptional: IDataObject { private static Expression<CustomMapping<TestOptional>> _mapping = ( () => XDataMapping.CustomMapping<TestOptional>() .DataTable(\"T_TEST\", \"T\", x => x.SubqueryFilter(string.Empty, \"A\") .SetOperation(FilterOperation.Exists) .Subquery(\"A\", XDataMapping.GetStructure(\"H\") .DataTable(\"T_TEST_OPT\", \"H\") .DataTable(\"T_OPT\", \"P\", // Link between H and P table marked as Primary filter x => x.Link(\"H\", \"opt_id\").AsPrimary(), // ConstFilter \"OptCode\" marked as Primary filter x => x.ConstFilter(\"OptCode\", \"code\", null).AsPrimary()) .Select(x => new { TestId = x.Field<long>(\"H\", string.Empty) }), \"TestId\", DataGrouping.None, x => x.SubqueryLink(\"DocId\")) .Column(\"TestId\", x => x.Field<long>(\"T\", string.Empty)) .Map(x => new TestOptional { Name = x.Field<decimal>(\"T\", string.Empty) }).SetBaseTable(\"T\")); } When repository accessed like that... dataScope.GetReposytory<TestOptional>().ToArray(); XData generate a simple SQL... select T.test_id as T_test_id, T.name as T_name from T_TEST T Because... ConstFilter \"OptCode\" has null value and marked as primary => T_OPT table skipped T_OPT table skipped and Link to T_TEST_OPT marked as primary => T_TEST_OPT table skipped T_TEST_OPT table skipped and marked as base table => subquery is skipped and SubqueryFilter skipped as well, but because it not marked as primary => table T_TEST is not skipped And when filter is filled... dataScope.GetReposytory<TestOptional>() .SetFilterValue(new FilterName(\"OptCode\"), \"TEST\").ToArray(); Now XData generate SQL with optional parts... select T.test_id as T_test_id, T.name as T_name from T_TEST T where exists(select 1 from T_TEST_OPT H join T_OPT P on H.opt_id = P.opt_id where P.code = \"TEST\")"
  },
  "tips/lob.html": {
    "href": "tips/lob.html",
    "title": "Large object loading | XData website",
    "keywords": "Large object loading Large objects specific properties Lob and Xml specially used to lazy access to potentially big sized data stored in database. When data object accessed using XData, large objects data not queried, but replaced with null values to create full structure of object. To get or set value of Lob or Xml Lob.Value and Xml.Document properties are used. Size of Lob can be checked using GetSize method. To simplify value assigning overrided operation += can be used as described in example below: obj.Source += new XDocument(new XElement(\"invoice\", new XAttribute(\"number\", number), new XAttribute(\"state\", z.DocStateCode))); obj.Scan += Encoding.UTF8.GetBytes(z.Source.Document.ToString()); To modify value of large objects in LINQ styled sequence of command helper methods Modify(Xml, Action<XDocument>) and Modify(Lob, Action<Byte[]>) can be used like in example below: invoice.Modify( z => z.DocState += dataScope.GetDictionaryValue<DocState>(x => x.Code == newStateCode), z => z.Source.Modify(doc => doc.Element(\"invoice\").Attribute(\"state\").Value = newStateCode)) .Submit(); Warning When object is serialized large objects properties are serialized with null values by default! When actual value of large object is required it must to be requested separately. To fill object large properties before serialization can be used one of LoadLob or LoadLobAsync helper method overloads."
  },
  "tips/json.html": {
    "href": "tips/json.html",
    "title": "JSON serialization | XData website",
    "keywords": "JSON serialization When used Json.NET XData data objects are serialized and deserialized automatically. There are some serialization specifics of data objects: By default Read only properties and Hidden properties are serialized and deserialized as well as writable properties, but have a some restrictions when copied to object to apply into database (see Apply method description below). Large objects ) are serialized to null value by default. They are designed for lazy data loading. To serialize data with actual values one of LoadLob helper method overloads can be used. By default Links are serialized as limited representation of link source object. Only properties listed as LinkProperties are included in serialized object. Additionally an \"linkPropertyName.Value\" JSON property is serialized with the value of Link.Value property. Default serialization rules can be overrided with ICollection<T> and T WithJsonSettings extension methods. JsonSettings<T> has followed methods to specify serializing options: Hide - alow to specify properties to skip on serialization LoadLob - alow to specify large object properties to load data before serialize ( LoadLob method alternative) LinkMode - alow to specify serialization rules for multiple (or all) link properties: Default - default rules will be applied (see above) Value - only value will be serialized Source - only source will be serialized DeleteFlag - allow to delete child entities in database using unmapped boolean property value in JSON serialized child object (see below). Used to deserialized (detached) objects only! return dataScope.GetRepository<Some>().ToArray() .WithJsonSettings(s => s.Hide(JsonHideFlags.Columns) //hide all columns .Hide(x => x.SomeReadOnlyProperty) //hide SomeReadOnlyProperty .LoadLob() //load all large data properties .LinkMode(LinkMode.Default, x => SomeLinkProperty, x => AnotherLinkProperty) //set default rules to 2 properties .LinkMode(LinkMode.Value)); //set other link properties serialize Value property only Warning Deserialized objects are detached from repository and had limited ways of using! Deserialized object can be used as a filter to find data object in database (for example to delete) with Find method: var found = dataScope.GetRepository<Some>().Find(detachedObj); if(found == null) throw new DbConcurrencyException(); return found.SetDeleted(true).Submit(); Deserialized object can be used as a source to copy some data to new object with Copy method: return dataScope.GetRepository<Some>().New().Copy(detachedObj).Submit(); Deserialized object can be used as to apply changes to database with Apply method: dataScope.GetRepository<Some>().Apply(detachedObj).Submit(); Apply is a combination of Find and Copy methods with followed algorithm: 1) if detached object has all keys assigned, corresponded object will be searched in database using keys and correlation token (if described in mapping) values (*) 2) if no data found XDataConcurrencyException will be trowed (**) 3) when some key properties are not assigned new entity has been created 4) detached object's data will be copied to found (or new) object (***) (*) Using of correlation token value with Find method can be escaped with optional ignoreConcurrency parameter. Same result can be reached with ApplyFlag.IgnoreConcurrency flag has been passed in Apply method call. (**) ApplyFlag.AddWhenNotFound flag can be passed in Apply method call to add new entity when not found in database. (***) Copy and Apply has parameter properties to specify witch property values will be copied. ApplyFlag.ExceptProperties flag can be used to SKIP listed properties on copy. ApplyFlag.CopyReadOnlyProperties flag can be used to allow copy Read only properties and Hidden properties disabled by default. You can define child repositories and associate them using the property parameter of the GetChild method with an unmatched property with the type of the child repository (for one-to-one relationships) or with a typed array of the child repository (for one-to-many relationships) . These properties will be populated during data collection, and the values will be automatically serialized to JSON and deserialized from JSON to a detached object. These values can be used to cascade changes to the database. Inserting and updating child objects is supported without further action. But for deleting entities, it is required that the developer define a delete flag - it the unmapped property used as a flag to mark the child entity as removed. To specify which property will be used as the delete flag for the property associated with the child repository, the WithJsonSettings method is used with the DeleteFlag combination applied to the detached object. // set delete flag to child repository entities to unmapped boolean property dataScope.GetRepository<Some>() .Do(x => x.Instance.GetChild<Child>(z => z.Childs), x => detachedObj.WithJsonSettings( z => z.DeleteFlag(y => y.Childs, y => y.Deleted))) .Apply(detachedObj).Submit(); See Master-detail relations to get more information about linking objects with Master-detail relations."
  },
  "tips/hints.html": {
    "href": "tips/hints.html",
    "title": "SQL hints | XData website",
    "keywords": "SQL hints Warning Before using SQL hints, be sure to use all other query optimization features. This is a \"double-edged weapon.\" You need to understand very well why you are using what hints and how it will affect performance, and also make all the necessary tests confirming the effectiveness of the changes you made! XData supports using SQL hints to improve SQL query productivity. All databases supports this feature using various mechanics and can change various parameters of SQL execution... Types of hints supported by XData for RDBMS... MS SQL Server Query hints Table hints Oracle Query hints MySql Query hints PostgreSQL PostgreSQL does not support hints for queries, but procedures that returns set of record required declare columns definition on call (see example below). Of course, this is not a SQL hint actually, but... create or replace function GetRows(text) returns set of record as $ declare r record; begin for r in EXECUTE ''select * from '' || $1 loop return next r; end loop; return; end $ language 'plpgsql'; select * from GetRows('Department') as dept(deptid int, deptname text); SQLite SQLite does not support hints. Using hints in static mapping Query hints: // hint for empty string alias is applied to query // possible to apply different hints on // select, insert, update, delete statements or their combination [DataObject(\"T\"), Hint(\"\", \"SQL_NO_CACHE\", HintType.Select), Hint(\"\", \"HIGH_PRIORITY\", HintType.Select | HintType.Insert), ... Table hints (MS SQL Server only): [DataObject(\"T\"), DataTable(\"Test\", \"T\"), Hint(\"T\", \"nolock\"), ... Procedure hints (PostgreSQL only): [DataObject(\"T\"), Procedure(\"T\", \"TestFunction9\", ProcedureType.Function), Hint(\"T\", \"Id integer, Name varchar(20)\"), Parameter(\"T\", 1, \"p_id1\", typeof(int), DbType.Int32), Parameter(\"T\", 1, \"p_name1\", typeof(string), DbType.String), Parameter(\"T\", 1, \"p_id2\", typeof(int), DbType.Int32), Parameter(\"T\", 1, \"p_name2\", typeof(string), DbType.String), ResultSet(\"T\")] public class PostgreSqlTestFunction9 : IDataObject { [Property(\"T\", \"Id\", Flags = DataPropertyFlag.Id)] public int Id { get; set; } [Property(\"T\", \"Name\")] public string Name { get; set; } } Using hints in dynamic mapping and dynamic queries Query hints: // hint for empty string alias is applied to query // possible to apply different hints on // select, insert, update, delete statements or their combination XDataMapping.GetStructure(\"T\") .Hint(\"\", \"SQL_NO_CACHE\", HintType.Select) .Hint(\"\", \"HIGH_PRIORITY\", HintType.Select | HintType.Insert)... Table hints (MS SQL Server only): XDataMapping.GetStructure(\"T\") .DataTable(\"Test\", \"T\") .Hint(\"T\", \"nolock\")... Procedure hints (PostgreSQL only): XDataMapping.GetStructure() .Procedure(\"T\", \"TestFunction8\", ProcedureType.Function) .Hint(\"T\", \"Id integer, Name varchar(20)\") .Parameter<Classifier[]>(\"T\", 1, \"p_tab\", DbType.Object, z => z.UdtDataType(null, \"classifier_rec\"), z => z.Array()) .Select(x => new Classifier { Id = x.Field<int>(\"T\", \"Id\", z => z.Key()), Name = x.Field<string>(\"T\", \"Name\") }) .AsQuery(DataScope, \"p_tab\".SetVar(param));"
  },
  "tips/get_credentials.html": {
    "href": "tips/get_credentials.html",
    "title": "Get connection settings in runtime | XData website",
    "keywords": "Get connection settings in runtime Connection settings can be obtained from initialized context using code below: var ctx = dataScope.GetContext(s); Console.WriteLine(\"*** Testing context: {0} (DB type: {1})\", ctx.Name, ctx.DatabaseAdapter.ConnectType); Console.WriteLine(\"*** Server: {0}, Schema: {1}\", ctx.ConnectionInfo.Server, ctx.ConnectionInfo.Schema);"
  },
  "tips/fixed.html": {
    "href": "tips/fixed.html",
    "title": "Caching repository data | XData website",
    "keywords": "Caching repository data Some data is changed often, some is rarely, but some data will never changed until application has upgraded. To reduce re-query of this static data, XData has mechanism to cache requested data (not a mapped objects) in XData. Repository property FixedQuery can be assigned to true when caching is required. All LINQ queries will be translated to this cache without re-query data from database. When this property resets to false, the cache will erased and repository returns to common algorithms of database requests. Similar feature is used to access rarely changed dictionary data over multiple related operative data changes."
  },
  "tips/external.html": {
    "href": "tips/external.html",
    "title": "Dynamic query external data sources | XData website",
    "keywords": "Dynamic query external data sources XData dynamic query can use external data sources to operate with runtime tabular or xml data together with data stored inside database. Warning This feature is not supported by all of databases! XML data sources can be used with Ms SQL Server and PostgreSQL only. Local temporary tables is not supported by Oracle database. As You can see, Oracle not supported both of features. Use PL/SQL functions, packages or predefined global temporary tables instead. XML data source // prepare XML document var doc = new XDocument(new XElement(\"root\", new XElement(\"test\", new XAttribute(\"doc_state_id\", 1), new XAttribute(\"test\", \"one\")), new XElement(\"test\", new XAttribute(\"doc_state_id\", 2), new XAttribute(\"test\", \"two\")) )).ToString(); var query = XDataMapping.GetStructure(\"S\") .DataTable(\"T_DOC_STATE\", \"S\") // use XmlSource definition providing XPath expression for data source .XmlSource(\"Test\", \"T\", \"root/test\", x => x.Link(\"S\", \"doc_state_id\")) .Select(x => new { // use XmlField definition with XPath expression as a field source DocStateId = x.XmlField<int>(\"T\", string.Empty, \"@doc_state_id\", DbType.Int32, z => z.Key()), Code = x.Field<string>(\"S\", string.Empty), // note, string and number (decimal) xml fields need size defined, like an expression fields Test = x.XmlField<string>(\"T\", string.Empty, \"@test\", DbType.String, z => z.Size(20)) // set XML string to variable with the same name as XmlSource }).AsQuery(dataScope, \"Test\".SetVar(doc)); Temporary table // prepare tabular data var table = new DataTable(); table.Columns.AddRange(new [] { new DataColumn(\"doc_state_id\", typeof(long)), new DataColumn(\"test\", typeof(string)) }); table.Rows.Add(1, \"one\"); table.Rows.Add(2, \"two\"); table.AcceptChanges(); var query = XDataMapping.GetStructure(\"S\") .DataTable(\"T_DOC_STATE\", \"S\") // use temporary table definition .TempTable(\"Test\", \"T\", x => x.Link(\"S\", \"doc_state_id\")) .Select(x => new { // use Field method overload with dbType parameter to define temporary table field DocStateId = x.Field<long>(\"T\", string.Empty, DbType.Int64, z => z.Key()), Code = x.Field<string>(\"S\", string.Empty), // note, string and number (decimal) xml fields need size defined, like an expression fields Test = x.Field<string>(\"T\", string.Empty, DbType.String, z => z.Size(20)) // set DataTable to variable with the same name as TempTable }).AsQuery(dataScope, \"Test\".SetVar(table));"
  },
  "tips/exists.html": {
    "href": "tips/exists.html",
    "title": "Using EXISTS expressions | XData website",
    "keywords": "Using EXISTS expressions in filters... ... where exists(select 1 from...) ... ...described when Static mapping used as... ... [Subquery(\"A\", typeof(AttachmentsExists), \"DocId\")] [SubqueryLink(\"A\", \"DocId\")] ... [SubqueryFilter(\"A\", \"\", \"DocId\", Operation=FilterOperation.Exists] ... * If it is necessary to describe the expression NOT EXISTS, the Operation parameter must be set to FilterOperation.NotExists and when Dynamic mapping used as... ... .Subquery<AttachmentsExists>(\"A\", x => x.GetProperty(\"DocId\"), DataGrouping.None, x => x.SubqueryLink(\"DocId\")) ... x => x.SubqueryFilter(null, \"A\").SetOperation(FilterOperation.Exists) ... * If it is necessary to describe the expression NOT EXISTS, the modifier SetOperation must be called with the parameter FilterOperation.NotExists in fields... ... exists(select 1 from...) as attach_exists ... ...described when Static mapping used as... ... [Subquery(\"A\", typeof(AttachmentsExists), \"DocId\")] [SubqueryLink(\"A\", \"DocId\")] ... [Property, PropertyExpression(\"A\", DataExpressionType.SubQuery, DbType.Boolean, Exists=ExistsOperation.NotExists)] public bool AttachExists => this.GetParameter(x => x.AttachExists); ... * If it is necessary to describe the expression NOT EXISTS, the Exists parameter must be set to ExistsOperation.NotExists and when Dynamic mapping used as... ... .Subquery<AttachmentsExists>(\"A\", x => x.GetProperty(\"DocId\"), DataGrouping.None, x => x.SubqueryLink(\"DocId\")) ... .ReadOnlyProperty(x => x.AttachExists, x => x.Expr<bool>(null, DataExpressionType.SubQuery, \"A\", DbType.Boolean, z => z.Exists())) ... * If it is necessary to describe the expression NOT EXISTS, the modifier Exists must be called with the parameter ExistsOperation.NotExists"
  },
  "tips/custom_sql.html": {
    "href": "tips/custom_sql.html",
    "title": "Call custom SQL code | XData website",
    "keywords": "Call custom SQL code XData can help the programmer to obtain data and process it with many ways. But also we hold in mind XData is just a common tool with limited quantity of features, and some very specific (but handy and powerful) SQL dialect constructions may be out of XData possibilities. To call dialect specific SQL statements used IDataScope interface with methods: FillTable , ExecuteScalar and ExecuteNonQuery . const string getCoordComResourceStateChangesForCaseCommand = @\" select x.ResourceCode, x.ReportedDateTime, x.UserName, x.MissionStatusCode, x.ResourceStatusCode from (select h.ResourceCode, h.ReportedDateTime, h.MissionStatusCode, h.ResourceStatusCode, isnull((select top(1) log.Creator from cse_CaseFolderLog_tab log with (nolock) where log.CallCenterId = h.CallCenterId and log.CaseFolderId = h.CaseFolderId and log.CaseId = h.CaseId and log.Created >= h.ReportedDateTime and datediff(s, h.ReportedDateTime, log.Created) <= 10 and (charindex(case h.MissionStatusCode when '---' then 'ready' else h.MissionStatusCode end, log.LogText COLLATE Latin1_General_CS_AS) > 0 or charindex(case h.MissionStatusCode when '---' then 'disconnected' else h.MissionStatusCode end, log.LogText COLLATE Latin1_General_CS_AS) > 0) and charindex(h.ResourceCode, log.LogText COLLATE Latin1_General_CS_AS) > 0 and charindex('|' + log.Creator + '|', @IntegrationUsers) = 0 order by log.Created ) , (select top(1) log.Creator from cse_CaseFolderLogFinished_tab log with (nolock) where log.CallCenterId = h.CallCenterId and log.CaseFolderId = h.CaseFolderId and log.CaseId = h.CaseId and log.Created >= h.ReportedDateTime and datediff(s,h.ReportedDateTime, log.Created) <= 10 and (charindex(case h.MissionStatusCode when '---' then 'ready' else h.MissionStatusCode end, log.LogText COLLATE Latin1_General_CS_AS) > 0 or charindex(case h.MissionStatusCode when '---' then 'disconnected' else h.MissionStatusCode end, log.LogText COLLATE Latin1_General_CS_AS) > 0) and charindex(h.ResourceCode, log.LogText COLLATE Latin1_General_CS_AS) > 0 and charindex('|' + log.Creator + '|', @IntegrationUsers) = 0 order by log.Created )) as UserName from res_ResourceHistory_tab h where h.CallCenterId = @CallCenterId and h.CaseFolderId = @CaseFolderId and h.CaseId = @CaseId and not exists(select 1 from sph_ResourceHistory_tab sh where sh.CallCenterId = h.CallCenterId and sh.CaseFolderId = h.CaseFolderId and sh.CaseId = h.CaseId and sh.ResourceCode = h.ResourceCode and (sh.MissionStatusCode = h.MissionStatusCode or (sh.MissionStatusCode = '---' and sh.ResourceStatusCode = @ClosedStatusCode)) and sh.ReportedDateTime = h.ReportedDateTime)) x where x.UserName is not null\"; using (var dataScope = DataEngine.Value.NewDataScope(CoordComDb)) { return dataScope.FillTable( new Query(getCoordComResourceStateChangesForCaseCommand, CommandType.Text, new QueryParam(\"@CaseFolderId\", caseIdentity.CaseFolderId, DbType.Int32), new QueryParam(\"@CallCenterId\", caseIdentity.CallCenterId, DbType.Int32), new QueryParam(\"@CaseId\", caseIdentity.CaseId, DbType.Int32), new QueryParam(\"@IntegrationUsers\", $\"|{string.Join(\"|\", integrationUsers)}|\"), new QueryParam(\"@ClosedStatusCode\", closedStatusCode) ), CommandBehavior.SingleResult).Rows.OfType<DataRow>() .Select(x => new Tuple<string, DateTime, string, string>( x.Field<string>(0), x.Field<DateTime>(1), x.Field<string>(2), x.Field<string>(3) == \"---\" ? x.Field<string>(4) : x.Field<string>(3))).ToList(); } Tip Use this mechanism with maximum care! This eliminates cross dialect approach of XData development, but we are in a real world with real programmers tasks... and we are never seen real tasks are correspond the rules of ideal program system architecture ;) Anyway this bad feature is a back-door we must provide while XData is not support all features of all specific SQL dialects. Is this really possible?. We think that not, but we will try to provide most of necessary features inside XData as soon as possible. We are need Your help to choose the order of features implementation and ideas to do it best! Important DDL instructions is not implemented by design. We believe DDL in big complicated real business application is not a thing we can delegate to \"dumb-metal-doll\". This is why XData has no mechanics to \"CodeFirst\"... If You're task can use CodeFirst approach - use EF. This way is historically reserved by EF, and no reason to fight for it. Calling custom SQL code is a legal way to apply DDL in XData context. Programmer or database administrator write this SQL script. This code is produced by human, real (not artificial) intellect of professional... XData only has ability to run it over database."
  },
  "tips/custom_logic.html": {
    "href": "tips/custom_logic.html",
    "title": "Execute custom business logic | XData website",
    "keywords": "Execute custom business logic XData has many features targeting this technology as not only ORM, but a full featured Data Access Layer. This is one of this features. Custom logic defined as public property of XDataLogic<T> class descendant with type of CustomLogic<T> . public class InvoiceLogic : XDataLogic<Invoice> { public CustomLogic<Invoice> TestCustomLogic => (objects => { Log.Write(MessageType.Information, () => $\"TestCustomLogic called with {objects.Length} objects\"); foreach (var invoice in objects) { var i = invoice; invoice.PostData(\"testPost\", () => Encoding.UTF8.GetBytes(i.DocNumb)); var p = Encoding.UTF8.GetBytes(i.DocNumb); var r = i.Callback(\"testCall\", ref p); Log.Write(MessageType.Information, () => @$\"Call for \\\"{i.DocNumb}\\\" returned \\\"{r}\\\" with data \\\"{(p == null ? null : Encoding.UTF8.GetString(p))}\\\"\"); } return true; }); } ... //Call example logic var random = new Random(); return dataScope.GetRepository<Invoice>().ToArray().Execute(() => \"TestCustomLogic\", \"testPost\".SetValue((Action<byte[]>)(data => Console.WriteLine(\"Post message received (data=\\\"{0}\\\")\", data == null ? null : Encoding.UTF8.GetString(data)))) .AsEnum().ToDictionary(), \"testCall\".SetValue((Func<byte[], byte[]>)(data => { Console.WriteLine(\"Call received \\\"{0}\\\")\", data == null ? null : Encoding.UTF8.GetString(data)); return random.NextDouble() >= 0.5 ? null : Encoding.UTF8.GetBytes( $\"reply for \\\"{(data == null ? null : Encoding.UTF8.GetString(data))}\\\"\"); })).AsEnum().ToDictionary()); Programmer can develop data centric logic over some of mapped objects with ability to execute this logic in the middle ware layer of three-tier architecture on a dedicated server (or cluster). And this code can be simple and representable debugged in two-tier environment. Architecture can be switched by configuration! No code modification, no side effects... This feature is linked with Trigger logic and reached by Callbacks . When code is organized using data mapping modules, data logic modules and client (or Web site) it can help programmer to keep module relations clean and get ready to changes, with no matter of middle-ware layer existence. And this rules are not dictated, You can use it or not. You can write this logic anywhere You architect to do. Nothing will be breaks, except of ability to use XData three-tier architecture. But if You really don't need it, what is wrong?"
  },
  "tips/copy_data.html": {
    "href": "tips/copy_data.html",
    "title": "Copy data | XData website",
    "keywords": "Copy data Data can be copied from one repository to another using IRepository<T>.Add<TFrom> method as illustrated in followed example: // Query source data (statically, or dynamically) into sourceQuery variable var rep = dataScope.GetRepository<Target>(); using(var tr = dataScope.BeginTransaction()) { rep.Add<Source>(sourceQuery, x => new Target{ TargetSome = x.Some, TargetAnother = x.Another }); tr.Commit(); }"
  },
  "api/XData.Extensions.html": {
    "href": "api/XData.Extensions.html",
    "title": "Namespace XData.Extensions | XData website",
    "keywords": "Namespace XData.Extensions Classes CollectionsExtensions Collections extension functions DataObjectQueryableExtensions XData LINQ query extensions ExpressionExtensions Expression extensions GeneralPropertyComparer<T> IndexAttribute Attribute to compare objects by property value Indexer<T> Indexed objects comparer Hint: Objects can be indexed by annotation attribute IndexAttribute JoinedEnumerable Joined enumerable extensions class JoinedEnumerable<T> Helper class to use outer joins Processing Object processing TypeComparer Type equality comparer TypeExtensions Type extensions TypeExtensions.DummyType Interfaces IProcess<T> Object processing interface"
  },
  "api/XData.Extensions.TypeExtensions.html": {
    "href": "api/XData.Extensions.TypeExtensions.html",
    "title": "Class TypeExtensions | XData website",
    "keywords": "Class TypeExtensions Type extensions Inheritance Object TypeExtensions Inherited Members Object.Equals(Object) Object.Equals(Object, Object) Object.GetHashCode() Object.GetType() Object.MemberwiseClone() Object.ReferenceEquals(Object, Object) Object.ToString() Namespace : XData.Extensions Assembly : XData.docfx.dll Syntax public static class TypeExtensions Methods | Improve this Doc View Source ArrayCast(Type, ICollection) Cast object array to specific type array Declaration public static object ArrayCast(this Type elementType, ICollection collection) Parameters Type Name Description Type elementType Type of result array elements ICollection collection Source collection Returns Type Description Object Typed array | Improve this Doc View Source ChangeType(Object, Type) Type convert Declaration public static object ChangeType(this object value, Type conversion) Parameters Type Name Description Object value Value to convert Type conversion Target type Returns Type Description Object Target converted value | Improve this Doc View Source ChangeType<T>(Object) Type convert Declaration public static T ChangeType<T>(this object value) Parameters Type Name Description Object value Value to convert Returns Type Description T Target converted value Type Parameters Name Description T Target type | Improve this Doc View Source ConvertTo<T>(Enum) Convert enumeration value to another enumeration by hash code Declaration public static T ConvertTo<T>(this Enum source) Parameters Type Name Description Enum source Source enumeration value Returns Type Description T Target enumeration value Type Parameters Name Description T Target enumeration type | Improve this Doc View Source EqualValue(Enum, Enum) Compare Enumeration values by hash codes Declaration public static bool EqualValue(this Enum source, Enum other) Parameters Type Name Description Enum source Source enumeration value Enum other Other enumeration value Returns Type Description Boolean Values are equal | Improve this Doc View Source GetDefault(Type) Get type default value Declaration public static object GetDefault(this Type type) Parameters Type Name Description Type type Type Returns Type Description Object Default value | Improve this Doc View Source GetDefault<TType>() Get type default value Declaration public static object GetDefault<TType>() Returns Type Description Object Default value Type Parameters Name Description TType Type | Improve this Doc View Source GetEnumKeyValuePairs(Type) Declaration public static IEnumerable<KeyValuePair<long, string>> GetEnumKeyValuePairs(this Type enumType) Parameters Type Name Description Type enumType Returns Type Description IEnumerable < KeyValuePair < Int64 , String >> | Improve this Doc View Source GetEnumValue(Type, Int64) Returns enum id and value pair for specified id Declaration public static KeyValuePair<long, string>? GetEnumValue(this Type enumType, long id) Parameters Type Name Description Type enumType Enum type Int64 id Enum key Returns Type Description Nullable < KeyValuePair < Int64 , String >> Enum id and value pair | Improve this Doc View Source GetGenericMethod(Type, String, IEnumerable<Type>) Returns generic method with typed arguments Declaration public static MethodInfo GetGenericMethod(this Type type, string name, IEnumerable<Type> parameterTypes) Parameters Type Name Description Type type Method type String name Method name IEnumerable < Type > parameterTypes Parameter types Returns Type Description MethodInfo Reflection method info Exceptions Type Condition XDataRuntimeException Method name can not be null or empty XDataRuntimeException Method parameter types can not be null | Improve this Doc View Source GetLocalizedEnumKeyValuePairs(Type) Returns id and name pairs for all enum values Declaration public static IEnumerable<KeyValuePair<long, string>> GetLocalizedEnumKeyValuePairs(this Type enumType) Parameters Type Name Description Type enumType Enum type Returns Type Description IEnumerable < KeyValuePair < Int64 , String >> Sequence of id and name pairs for all enum values | Improve this Doc View Source GetLocalizedEnumValue(Type, Int64) Returns enum id and localized value pair for specified id Declaration public static KeyValuePair<long, string>? GetLocalizedEnumValue(this Type enumType, long id) Parameters Type Name Description Type enumType Enum type Int64 id Enum key Returns Type Description Nullable < KeyValuePair < Int64 , String >> Enum id and localized value pair | Improve this Doc View Source GetRealType(Type) Get Generic base type Declaration public static Type GetRealType(this Type type) Parameters Type Name Description Type type Type Returns Type Description Type Base type | Improve this Doc View Source Implements<T>(Type, T) Test type implements an interface Declaration public static bool Implements<T>(this Type type, T interfaceType) where T : Type Parameters Type Name Description Type type Type T interfaceType Interface Returns Type Description Boolean Type is implements an interface Type Parameters Name Description T Interface type | Improve this Doc View Source InvokeMethod(Object, Expression<Action>, BindingFlags) Invoke method with replacing base object type wrapper Declaration public static void InvokeMethod(this object obj, Expression<Action> expr, BindingFlags bindingFlags = BindingFlags.Default) Parameters Type Name Description Object obj Object to invoke method with Expression < Action > expr Call expression BindingFlags bindingFlags Binding flags Exceptions Type Condition XDataRuntimeException | Improve this Doc View Source InvokeMethod(Object, Type[], Expression<Action>, BindingFlags) Invoke generic method wrapper Declaration public static void InvokeMethod(this object obj, Type[] types, Expression<Action> expr, BindingFlags bindingFlags = BindingFlags.Default) Parameters Type Name Description Object obj Object to invoke method (set null to call static method) Type [] types Generic arguments types array Expression < Action > expr Call expression (set generic arguments to any valid types) BindingFlags bindingFlags Binding flags Exceptions Type Condition XDataRuntimeException | Improve this Doc View Source InvokeMethod<TRet>(Object, Expression<Func<TRet>>, BindingFlags) Invoke method with replacing base object type wrapper Declaration public static TRet InvokeMethod<TRet>(this object obj, Expression<Func<TRet>> expr, BindingFlags bindingFlags = BindingFlags.Default) Parameters Type Name Description Object obj Object to invoke method with Expression < Func <TRet>> expr Call expression BindingFlags bindingFlags Binding flags Returns Type Description TRet Call return value Type Parameters Name Description TRet Return value type Exceptions Type Condition XDataRuntimeException | Improve this Doc View Source InvokeMethod<TRet>(Object, Type[], Expression<Func<TRet>>, BindingFlags) Invoke generic method wrapper Declaration public static TRet InvokeMethod<TRet>(this object obj, Type[] types, Expression<Func<TRet>> expr, BindingFlags bindingFlags = BindingFlags.Default) Parameters Type Name Description Object obj Object to invoke method (set null to call static method) Type [] types Generic arguments types array Expression < Func <TRet>> expr Call expression (set generic arguments to any valid types) BindingFlags bindingFlags Binding flags Returns Type Description TRet Call return value Type Parameters Name Description TRet Return value type Exceptions Type Condition XDataRuntimeException | Improve this Doc View Source IsBasedOn<TType>(Type) Check generic base type Declaration public static bool IsBasedOn<TType>(this Type type) Parameters Type Name Description Type type Generic type Returns Type Description Boolean Generic type is based on TType Type Parameters Name Description TType Base type to check | Improve this Doc View Source IsBinary(Type) Check Lob type Declaration public static bool IsBinary(this Type type) Parameters Type Name Description Type type Type to check Returns Type Description Boolean Type is binary | Improve this Doc View Source IsEnum(Type) Check Enum type Declaration public static bool IsEnum(this Type type) Parameters Type Name Description Type type Type to check Returns Type Description Boolean Type is binary | Improve this Doc View Source IsNullable(Type) Check nullable type Declaration public static bool IsNullable(this Type type) Parameters Type Name Description Type type Type to check Returns Type Description Boolean Type is nullable | Improve this Doc View Source IsXml(Type) Check Xml type Declaration public static bool IsXml(this Type type) Parameters Type Name Description Type type Type to check Returns Type Description Boolean Type is binary | Improve this Doc View Source NullWrap<T>(T) Null value wrapper Declaration public static T NullWrap<T>(T source) where T : class, new() Parameters Type Name Description T source Source Returns Type Description T Source or empty object of source type Type Parameters Name Description T Source type | Improve this Doc View Source NullWrap<T>(T[]) Null value wrapper Declaration public static T[] NullWrap<T>(T[] source) Parameters Type Name Description T[] source Source array Returns Type Description T[] Source or empty array Type Parameters Name Description T Array element type | Improve this Doc View Source ParseEnum(Type, String) Returns id for specified enum type and string value Declaration public static long? ParseEnum(this Type enumType, string value) Parameters Type Name Description Type enumType Enum type String value String value of enum Returns Type Description Nullable < Int64 > Enum id | Improve this Doc View Source ParseEnumRange(Type, ICollection<Object>) Parse enum values range Declaration public static object[] ParseEnumRange(this Type enumType, ICollection<object> values) Parameters Type Name Description Type enumType Enum type ICollection < Object > values Enum values range Returns Type Description Object [] Enum id array See Also ParseEnum(Type, String) | Improve this Doc View Source ParseType(String) Parse type full name Declaration public static Type ParseType(this string typeFullName) Parameters Type Name Description String typeFullName Returns Type Description Type | Improve this Doc View Source TryConvert<T, TResult>(T, Func<T, TResult>) Try to convert value Declaration public static TResult TryConvert<T, TResult>(this T source, Func<T, TResult> convert) where T : class Parameters Type Name Description T source Source value Func <T, TResult> convert Conversion logic Returns Type Description TResult Converted value or default of TResult Type Parameters Name Description T Source type TResult Result type | Improve this Doc View Source TryConvert<T, TResult>(T, Func<T, TResult>, TResult) Try to convert value Declaration public static TResult TryConvert<T, TResult>(this T source, Func<T, TResult> convert, TResult defaultValue) where T : class Parameters Type Name Description T source Source value Func <T, TResult> convert Conversion logic TResult defaultValue Default result value Returns Type Description TResult Converted value or default of TResult Type Parameters Name Description T Source type TResult Result type"
  },
  "api/XData.Exceptions.html": {
    "href": "api/XData.Exceptions.html",
    "title": "Namespace XData.Exceptions | XData website",
    "keywords": "Namespace XData.Exceptions Classes AdditionalInfo Exception and log additional info XDataAdapterException Adapter exception XDataConcurrencyException Concurrency exception XDataConfigurationException XData configuration exception XDataException Base XData exception class XDataExceptionAttribute XData exception attribute XDataQueryStructureException Query structure build failed XDataRuntimeException XData runtime exception XDataSecurityException XData security related exception XDataSqlException SQL exception Enums XDataAdapterExceptionType XData adapter exception types XDataConfigurationExceptionType XData configuration exception types XDataQueryStructureExceptionType Query structure exception types XDataRuntimeExceptionType XData runtime exception type"
  },
  "api/XData.Exceptions.XDataSqlException.html": {
    "href": "api/XData.Exceptions.XDataSqlException.html",
    "title": "Class XDataSqlException | XData website",
    "keywords": "Class XDataSqlException SQL exception Inheritance Object Exception ApplicationException XDataException XDataSqlException Implements ISerializable Inherited Members Exception.GetBaseException() Exception.GetObjectData(SerializationInfo, StreamingContext) Exception.GetType() Exception.ToString() Exception.Data Exception.HelpLink Exception.HResult Exception.InnerException Exception.Message Exception.Source Exception.StackTrace Exception.TargetSite Exception.SerializeObjectState Object.Equals(Object) Object.Equals(Object, Object) Object.GetHashCode() Object.MemberwiseClone() Object.ReferenceEquals(Object, Object) Namespace : XData.Exceptions Assembly : XData.docfx.dll Syntax [Serializable] public sealed class XDataSqlException : XDataException, ISerializable Constructors | Improve this Doc View Source XDataSqlException(Exception, Query) SQL exception Declaration public XDataSqlException(Exception exception, Query query) Parameters Type Name Description Exception exception Inner exception Query query Query | Improve this Doc View Source XDataSqlException(Exception, Query, AdditionalInfo[]) SQL exception Declaration public XDataSqlException(Exception exception, Query query, params AdditionalInfo[] addInfo) Parameters Type Name Description Exception exception Inner exception Query query Query AdditionalInfo [] addInfo Additional information | Improve this Doc View Source XDataSqlException(Exception, AdditionalInfo[]) SQL exception Declaration public XDataSqlException(Exception exception, params AdditionalInfo[] addInfo) Parameters Type Name Description Exception exception Inner exception AdditionalInfo [] addInfo Additional information Properties | Improve this Doc View Source Query Query Declaration public Query Query { get; } Property Value Type Description Query Implements System.Runtime.Serialization.ISerializable Extension Methods SerializationExtensions.ToXml<T>(T) CollectionsExtensions.SetValue<TKey, T>(TKey, T) CollectionsExtensions.AsEnum<T>(T) DataObjectQueryableExtensions.CompareVariable(Object, FilterOperation, String) Processing.Do<T>(T, Action<IProcess<T>>[]) TypeExtensions.TryConvert<T, TResult>(T, Func<T, TResult>) TypeExtensions.TryConvert<T, TResult>(T, Func<T, TResult>, TResult) TypeExtensions.ChangeType<T>(Object) TypeExtensions.ChangeType(Object, Type) TypeExtensions.InvokeMethod<TRet>(Object, Type[], Expression<Func<TRet>>, BindingFlags) TypeExtensions.InvokeMethod(Object, Type[], Expression<Action>, BindingFlags) TypeExtensions.InvokeMethod<TRet>(Object, Expression<Func<TRet>>, BindingFlags) TypeExtensions.InvokeMethod(Object, Expression<Action>, BindingFlags) SqlBlockExtensions.SetExpression<TTag, TResult>(TTag, Expression<Func<IBlockQueryAdapter, TResult>>) QueryDescriptionExtensions.SetExpression<TTag, TResult>(TTag, Expression<Func<IQueryStructureAdapter, TResult>>)"
  },
  "api/XData.DataSource.Structure.RepositoryState.html": {
    "href": "api/XData.DataSource.Structure.RepositoryState.html",
    "title": "Class RepositoryState | XData website",
    "keywords": "Class RepositoryState Repository state Inheritance Object DataQueryState RepositoryState Inherited Members DataQueryState.AssemblyName DataQueryState.ElementType DataQueryState.Context DataQueryState.Structure DataQueryState.ToString() Object.Equals(Object) Object.Equals(Object, Object) Object.GetHashCode() Object.GetType() Object.MemberwiseClone() Object.ReferenceEquals(Object, Object) Namespace : XData.DataSource.Structure Assembly : XData.docfx.dll Syntax [Serializable] [DataContract] public sealed class RepositoryState : DataQueryState Properties | Improve this Doc View Source Alias Alias Declaration [DataMember] public string Alias { get; set; } Property Value Type Description String | Improve this Doc View Source Fixed Fixed query flag Declaration [DataMember] public bool Fixed { get; set; } Property Value Type Description Boolean | Improve this Doc View Source IsSupervisor Security session supervisor flag Declaration [DataMember] public bool IsSupervisor { get; set; } Property Value Type Description Boolean | Improve this Doc View Source SecurityRoles Security session roles Declaration [DataMember] public string[] SecurityRoles { get; set; } Property Value Type Description String [] | Improve this Doc View Source SecuritySessionClass Security session class Declaration [DataMember] public string SecuritySessionClass { get; set; } Property Value Type Description String | Improve this Doc View Source ShowSubtree Show subtree flag Declaration [DataMember] public bool ShowSubtree { get; set; } Property Value Type Description Boolean | Improve this Doc View Source UserName Security user name Declaration [DataMember] public string UserName { get; set; } Property Value Type Description String Extension Methods SerializationExtensions.ToXml<T>(T) CollectionsExtensions.SetValue<TKey, T>(TKey, T) CollectionsExtensions.AsEnum<T>(T) DataObjectQueryableExtensions.CompareVariable(Object, FilterOperation, String) Processing.Do<T>(T, Action<IProcess<T>>[]) TypeExtensions.TryConvert<T, TResult>(T, Func<T, TResult>) TypeExtensions.TryConvert<T, TResult>(T, Func<T, TResult>, TResult) TypeExtensions.ChangeType<T>(Object) TypeExtensions.ChangeType(Object, Type) TypeExtensions.InvokeMethod<TRet>(Object, Type[], Expression<Func<TRet>>, BindingFlags) TypeExtensions.InvokeMethod(Object, Type[], Expression<Action>, BindingFlags) TypeExtensions.InvokeMethod<TRet>(Object, Expression<Func<TRet>>, BindingFlags) TypeExtensions.InvokeMethod(Object, Expression<Action>, BindingFlags) SqlBlockExtensions.SetExpression<TTag, TResult>(TTag, Expression<Func<IBlockQueryAdapter, TResult>>) QueryDescriptionExtensions.SetExpression<TTag, TResult>(TTag, Expression<Func<IQueryStructureAdapter, TResult>>)"
  },
  "api/XData.DataSource.Structure.Order.html": {
    "href": "api/XData.DataSource.Structure.Order.html",
    "title": "Class Order | XData website",
    "keywords": "Class Order Order by element Inheritance Object Order Implements IEquatable < Order > Inherited Members Object.Equals(Object) Object.Equals(Object, Object) Object.GetHashCode() Object.GetType() Object.MemberwiseClone() Object.ReferenceEquals(Object, Object) Object.ToString() Namespace : XData.DataSource.Structure Assembly : XData.docfx.dll Syntax [Serializable] [DataContract] public sealed class Order : IEquatable<Order> Properties | Improve this Doc View Source Descending Descending flag Declaration [DataMember] public bool Descending { get; set; } Property Value Type Description Boolean | Improve this Doc View Source FieldName Field name Declaration [DataMember] public string FieldName { get; set; } Property Value Type Description String | Improve this Doc View Source PropertyName Property name Declaration [DataMember] public string PropertyName { get; set; } Property Value Type Description String | Improve this Doc View Source PropertyOwnerType Property owner type name Declaration [DataMember] public string PropertyOwnerType { get; set; } Property Value Type Description String | Improve this Doc View Source SourceAlias Source alias Declaration [DataMember] public string SourceAlias { get; set; } Property Value Type Description String Methods | Improve this Doc View Source Equals(Order) Order equality check Declaration public bool Equals(Order other) Parameters Type Name Description Order other Order instance to compare Returns Type Description Boolean Instances are contains the same data Implements System.IEquatable<T> Extension Methods SerializationExtensions.ToXml<T>(T) CollectionsExtensions.SetValue<TKey, T>(TKey, T) CollectionsExtensions.AsEnum<T>(T) DataObjectQueryableExtensions.CompareVariable(Object, FilterOperation, String) Processing.Do<T>(T, Action<IProcess<T>>[]) TypeExtensions.TryConvert<T, TResult>(T, Func<T, TResult>) TypeExtensions.TryConvert<T, TResult>(T, Func<T, TResult>, TResult) TypeExtensions.ChangeType<T>(Object) TypeExtensions.ChangeType(Object, Type) TypeExtensions.InvokeMethod<TRet>(Object, Type[], Expression<Func<TRet>>, BindingFlags) TypeExtensions.InvokeMethod(Object, Type[], Expression<Action>, BindingFlags) TypeExtensions.InvokeMethod<TRet>(Object, Expression<Func<TRet>>, BindingFlags) TypeExtensions.InvokeMethod(Object, Expression<Action>, BindingFlags) SqlBlockExtensions.SetExpression<TTag, TResult>(TTag, Expression<Func<IBlockQueryAdapter, TResult>>) QueryDescriptionExtensions.SetExpression<TTag, TResult>(TTag, Expression<Func<IQueryStructureAdapter, TResult>>)"
  },
  "api/XData.DataSource.Structure.IFilterCombination.html": {
    "href": "api/XData.DataSource.Structure.IFilterCombination.html",
    "title": "Interface IFilterCombination | XData website",
    "keywords": "Interface IFilterCombination Filter combination interface Inherited Members ICloneable.Clone() Namespace : XData.DataSource.Structure Assembly : XData.docfx.dll Syntax public interface IFilterCombination : ICloneable Properties | Improve this Doc View Source Combination Logical combination Declaration Combination Combination { get; } Property Value Type Description Combination | Improve this Doc View Source FilterCombinations Child combinations Declaration List<IFilterCombination> FilterCombinations { get; } Property Value Type Description List < IFilterCombination > | Improve this Doc View Source Filters Filters Declaration List<IFilter> Filters { get; } Property Value Type Description List < IFilter > | Improve this Doc View Source Name Filter combination name Declaration string Name { get; } Property Value Type Description String Methods | Improve this Doc View Source GetLinks(String) Returns links Declaration IEnumerable<IInnerLink> GetLinks(string alias) Parameters Type Name Description String alias Source alias Returns Type Description IEnumerable < IInnerLink > Links sequence | Improve this Doc View Source GetLinks(String[], Boolean) Returns links Declaration IEnumerable<IInnerLink> GetLinks(string[] aliases, bool exact) Parameters Type Name Description String [] aliases Array of source aliases Boolean exact Exact comparison flag Returns Type Description IEnumerable < IInnerLink > Links sequence | Improve this Doc View Source GetLinks(IDataStructure, String) Returns links Declaration IEnumerable<IInnerLink> GetLinks(IDataStructure structure, string alias) Parameters Type Name Description IDataStructure structure Structure String alias Source alias Returns Type Description IEnumerable < IInnerLink > Links sequence | Improve this Doc View Source GetPrimaryFilters() Returns primary filters Declaration List<IOptionalFilter> GetPrimaryFilters() Returns Type Description List < IOptionalFilter > Primary filters list | Improve this Doc View Source GetValueFilters() Return value filters list Declaration IEnumerable<IFilter> GetValueFilters() Returns Type Description IEnumerable < IFilter > Value filters list Extension Methods SerializationExtensions.ToXml<T>(T) CollectionsExtensions.SetValue<TKey, T>(TKey, T) CollectionsExtensions.AsEnum<T>(T) DataObjectQueryableExtensions.CompareVariable(Object, FilterOperation, String) Processing.Do<T>(T, Action<IProcess<T>>[]) TypeExtensions.TryConvert<T, TResult>(T, Func<T, TResult>) TypeExtensions.TryConvert<T, TResult>(T, Func<T, TResult>, TResult) TypeExtensions.ChangeType<T>(Object) TypeExtensions.ChangeType(Object, Type) TypeExtensions.InvokeMethod<TRet>(Object, Type[], Expression<Func<TRet>>, BindingFlags) TypeExtensions.InvokeMethod(Object, Type[], Expression<Action>, BindingFlags) TypeExtensions.InvokeMethod<TRet>(Object, Expression<Func<TRet>>, BindingFlags) TypeExtensions.InvokeMethod(Object, Expression<Action>, BindingFlags) SqlBlockExtensions.SetExpression<TTag, TResult>(TTag, Expression<Func<IBlockQueryAdapter, TResult>>) QueryDescriptionExtensions.SetExpression<TTag, TResult>(TTag, Expression<Func<IQueryStructureAdapter, TResult>>)"
  },
  "api/XData.DataSource.Structure.ITable.html": {
    "href": "api/XData.DataSource.Structure.ITable.html",
    "title": "Interface ITable | XData website",
    "keywords": "Interface ITable Table Inherited Members ITableLike.Name ITableLike.Fields IDataSource.SourceType IDataSource.Alias IDataSource.IsBase IDataSource.GetFields() IDataSource.GetFields(Type) IDataSource.GetField(String, String, String) IDataSource.GetField(String, String, String, String) ICloneable.Clone() Namespace : XData.DataSource.Structure Assembly : XData.docfx.dll Syntax public interface ITable : ITableLike, IDataSource, ICloneable Properties | Improve this Doc View Source Hierarchies Hierarchies Declaration List<Hierarchy> Hierarchies { get; } Property Value Type Description List < Hierarchy > | Improve this Doc View Source Hint Table hint Declaration HintInfo[] Hint { get; } Property Value Type Description HintInfo [] | Improve this Doc View Source ParentAlias Parent table alias Declaration string ParentAlias { get; } Property Value Type Description String Extension Methods SerializationExtensions.ToXml<T>(T) CollectionsExtensions.SetValue<TKey, T>(TKey, T) CollectionsExtensions.AsEnum<T>(T) DataObjectQueryableExtensions.CompareVariable(Object, FilterOperation, String) Processing.Do<T>(T, Action<IProcess<T>>[]) TypeExtensions.TryConvert<T, TResult>(T, Func<T, TResult>) TypeExtensions.TryConvert<T, TResult>(T, Func<T, TResult>, TResult) TypeExtensions.ChangeType<T>(Object) TypeExtensions.ChangeType(Object, Type) TypeExtensions.InvokeMethod<TRet>(Object, Type[], Expression<Func<TRet>>, BindingFlags) TypeExtensions.InvokeMethod(Object, Type[], Expression<Action>, BindingFlags) TypeExtensions.InvokeMethod<TRet>(Object, Expression<Func<TRet>>, BindingFlags) TypeExtensions.InvokeMethod(Object, Expression<Action>, BindingFlags) SqlBlockExtensions.SetExpression<TTag, TResult>(TTag, Expression<Func<IBlockQueryAdapter, TResult>>) QueryDescriptionExtensions.SetExpression<TTag, TResult>(TTag, Expression<Func<IQueryStructureAdapter, TResult>>)"
  },
  "api/XData.DataSource.Structure.IDictionaryFilter.html": {
    "href": "api/XData.DataSource.Structure.IDictionaryFilter.html",
    "title": "Interface IDictionaryFilter | XData website",
    "keywords": "Interface IDictionaryFilter Dictionary filter interface Inherited Members IFilter.FilterType IFilter.SourceAlias IFilter.Field IFilter.Operation ICloneable.Clone() Namespace : XData.DataSource.Structure Assembly : XData.docfx.dll Syntax public interface IDictionaryFilter : IFilter, ICloneable Properties | Improve this Doc View Source DictionaryCode Dictionary code field Declaration string DictionaryCode { get; } Property Value Type Description String | Improve this Doc View Source DictionaryId Dictionary id field Declaration string DictionaryId { get; } Property Value Type Description String | Improve this Doc View Source DictionaryTableName Dictionary table name Declaration string DictionaryTableName { get; } Property Value Type Description String | Improve this Doc View Source DictionaryValue Dictionary search value Declaration string DictionaryValue { get; } Property Value Type Description String | Improve this Doc View Source IsVariableValue Dictionary search value is variable name flag Declaration bool IsVariableValue { get; } Property Value Type Description Boolean Extension Methods SerializationExtensions.ToXml<T>(T) CollectionsExtensions.SetValue<TKey, T>(TKey, T) CollectionsExtensions.AsEnum<T>(T) DataObjectQueryableExtensions.CompareVariable(Object, FilterOperation, String) Processing.Do<T>(T, Action<IProcess<T>>[]) TypeExtensions.TryConvert<T, TResult>(T, Func<T, TResult>) TypeExtensions.TryConvert<T, TResult>(T, Func<T, TResult>, TResult) TypeExtensions.ChangeType<T>(Object) TypeExtensions.ChangeType(Object, Type) TypeExtensions.InvokeMethod<TRet>(Object, Type[], Expression<Func<TRet>>, BindingFlags) TypeExtensions.InvokeMethod(Object, Type[], Expression<Action>, BindingFlags) TypeExtensions.InvokeMethod<TRet>(Object, Expression<Func<TRet>>, BindingFlags) TypeExtensions.InvokeMethod(Object, Expression<Action>, BindingFlags) SqlBlockExtensions.SetExpression<TTag, TResult>(TTag, Expression<Func<IBlockQueryAdapter, TResult>>) QueryDescriptionExtensions.SetExpression<TTag, TResult>(TTag, Expression<Func<IQueryStructureAdapter, TResult>>)"
  },
  "api/XData.DataSource.Structure.IDataStructure.html": {
    "href": "api/XData.DataSource.Structure.IDataStructure.html",
    "title": "Interface IDataStructure | XData website",
    "keywords": "Interface IDataStructure Data object structure Namespace : XData.DataSource.Structure Assembly : XData.docfx.dll Syntax public interface IDataStructure Properties | Improve this Doc View Source BaseSource Base source Declaration ITableLike BaseSource { get; } Property Value Type Description ITableLike | Improve this Doc View Source Context Data structure context Declaration string Context { get; } Property Value Type Description String | Improve this Doc View Source Distinct Structure distinct values flag Declaration bool Distinct { get; } Property Value Type Description Boolean | Improve this Doc View Source FilterValues Runtime filter values Declaration SortedList<string, object> FilterValues { get; } Property Value Type Description SortedList < String , Object > | Improve this Doc View Source Flags Data object flags Declaration DataStructureFlag Flags { get; } Property Value Type Description DataStructureFlag | Improve this Doc View Source GroupBy Group by list Declaration List<Grouping> GroupBy { get; } Property Value Type Description List < Grouping > | Improve this Doc View Source Hint Query hints Declaration HintInfo[] Hint { get; set; } Property Value Type Description HintInfo [] | Improve this Doc View Source Inverse Structure filters inverse flag Declaration bool Inverse { get; } Property Value Type Description Boolean | Improve this Doc View Source IsReadOnly Read only structure flag Declaration bool IsReadOnly { get; } Property Value Type Description Boolean | Improve this Doc View Source IsSubquery Subquery flag Declaration bool IsSubquery { get; } Property Value Type Description Boolean | Improve this Doc View Source IsUnion Combined structure flag Declaration bool IsUnion { get; } Property Value Type Description Boolean | Improve this Doc View Source Limit Limit objects count Declaration int? Limit { get; } Property Value Type Description Nullable < Int32 > | Improve this Doc View Source ObjectType Structure data object type Declaration Type ObjectType { get; } Property Value Type Description Type | Improve this Doc View Source OrderBy Order by list Declaration List<Order> OrderBy { get; } Property Value Type Description List < Order > | Improve this Doc View Source Parameters Stored procedure parameters definitions Declaration List<IParameterDescription> Parameters { get; } Property Value Type Description List < IParameterDescription > | Improve this Doc View Source ResultSets Stored procedure result sets Declaration IResultSetDescription[] ResultSets { get; } Property Value Type Description IResultSetDescription [] | Improve this Doc View Source ReverseOrder Structure reversion order flag Declaration bool ReverseOrder { get; } Property Value Type Description Boolean | Improve this Doc View Source RootFilterCombination Structure root filter combination Declaration IFilterCombination RootFilterCombination { get; } Property Value Type Description IFilterCombination | Improve this Doc View Source Skip Skip objects count Declaration int? Skip { get; } Property Value Type Description Nullable < Int32 > | Improve this Doc View Source Sources Sources Declaration SortedSet<IDataSource> Sources { get; } Property Value Type Description SortedSet < IDataSource > | Improve this Doc View Source StructureType Structure type full name Declaration string StructureType { get; } Property Value Type Description String | Improve this Doc View Source UnionCombination Data object structure combination Declaration DataCombination UnionCombination { get; } Property Value Type Description DataCombination Methods | Improve this Doc View Source FillSkippedSources(SortedList<String, Object>, out ICollection<String>) Fill skipped sources list Declaration bool FillSkippedSources(SortedList<string, object> filterValues, out ICollection<string> skipped) Parameters Type Name Description SortedList < String , Object > filterValues Filter values ICollection < String > skipped Returned skipped sources list Returns Type Description Boolean Structure skipped flag | Improve this Doc View Source GetField(String, String, out String, out String) Returns field Declaration IField GetField(string sourceAlias, string fieldName, out string alias, out string fullName) Parameters Type Name Description String sourceAlias Source alias String fieldName Field name String alias Relative alias String fullName Relative full name of field Returns Type Description IField Field object | Improve this Doc View Source GetFields() Returns selectable fields Declaration IEnumerable<SelectedField> GetFields() Returns Type Description IEnumerable < SelectedField > Selectable fields sequence | Improve this Doc View Source GetParent(String) Returns parent structure by object type Declaration IDataStructure GetParent(string parentType) Parameters Type Name Description String parentType Parent object type Returns Type Description IDataStructure Structure | Improve this Doc View Source GetPrimaryKey() Returns data object unique key fields Declaration IEnumerable<SelectedField> GetPrimaryKey() Returns Type Description IEnumerable < SelectedField > Unique key fields sequence | Improve this Doc View Source GetSubqueryVariables(String) Subquery variables Declaration SortedList<string, object> GetSubqueryVariables(string subqueryAlias) Parameters Type Name Description String subqueryAlias Subquery alias Returns Type Description SortedList < String , Object > Subquery variables | Improve this Doc View Source GetVariableValue(String) Returns variable value Declaration object GetVariableValue(string variableName) Parameters Type Name Description String variableName Variable name Returns Type Description Object Variable value | Improve this Doc View Source IsOuterJoined(String, String) Check source is outer joined to parent Declaration bool IsOuterJoined(string alias, string parentAlias) Parameters Type Name Description String alias Checked source alias String parentAlias Parent source alias Returns Type Description Boolean Outer joined flag Extension Methods SerializationExtensions.ToXml<T>(T) CollectionsExtensions.SetValue<TKey, T>(TKey, T) CollectionsExtensions.AsEnum<T>(T) DataObjectQueryableExtensions.CompareVariable(Object, FilterOperation, String) Processing.Do<T>(T, Action<IProcess<T>>[]) TypeExtensions.TryConvert<T, TResult>(T, Func<T, TResult>) TypeExtensions.TryConvert<T, TResult>(T, Func<T, TResult>, TResult) TypeExtensions.ChangeType<T>(Object) TypeExtensions.ChangeType(Object, Type) TypeExtensions.InvokeMethod<TRet>(Object, Type[], Expression<Func<TRet>>, BindingFlags) TypeExtensions.InvokeMethod(Object, Type[], Expression<Action>, BindingFlags) TypeExtensions.InvokeMethod<TRet>(Object, Expression<Func<TRet>>, BindingFlags) TypeExtensions.InvokeMethod(Object, Expression<Action>, BindingFlags) SqlBlockExtensions.SetExpression<TTag, TResult>(TTag, Expression<Func<IBlockQueryAdapter, TResult>>) QueryDescriptionExtensions.SetExpression<TTag, TResult>(TTag, Expression<Func<IQueryStructureAdapter, TResult>>)"
  },
  "api/XData.DataCombination.html": {
    "href": "api/XData.DataCombination.html",
    "title": "Enum DataCombination | XData website",
    "keywords": "Enum DataCombination Data set combination modes Namespace : XData Assembly : XData.docfx.dll Syntax [DataContract] public enum DataCombination Fields Name Description Except EXCEPT(MINUS) Intersect INTERSECT None Data object not use combination Union UNION UnionAll UNION ALL See Also None Union UnionAll Except Intersect Extension Methods SerializationExtensions.ToXml<DataCombination>() CollectionsExtensions.SetValue<DataCombination, T>(T) CollectionsExtensions.AsEnum<DataCombination>() DataObjectQueryableExtensions.CompareVariable(FilterOperation, String) Processing.Do<DataCombination>(Action<IProcess<DataCombination>>[]) TypeExtensions.ChangeType<T>() TypeExtensions.ChangeType(Type) TypeExtensions.InvokeMethod<TRet>(Type[], Expression<Func<TRet>>, BindingFlags) TypeExtensions.InvokeMethod(Type[], Expression<Action>, BindingFlags) TypeExtensions.InvokeMethod<TRet>(Expression<Func<TRet>>, BindingFlags) TypeExtensions.InvokeMethod(Expression<Action>, BindingFlags) TypeExtensions.ConvertTo<T>() TypeExtensions.EqualValue(Enum) SqlBlockExtensions.SetExpression<DataCombination, TResult>(Expression<Func<IBlockQueryAdapter, TResult>>) QueryDescriptionExtensions.SetExpression<DataCombination, TResult>(Expression<Func<IQueryStructureAdapter, TResult>>)"
  },
  "api/XData.Database.html": {
    "href": "api/XData.Database.html",
    "title": "Namespace XData.Database | XData website",
    "keywords": "Namespace XData.Database Classes FieldInfo Field information TableInfo Table information XDataContext Data context Provides database adapter and SQL builder access Interfaces ITransaction Transaction wrapper interface Enums DataQueries Static adapter queries enumeration"
  },
  "api/XData.Database.SqlBlock.ISqlValue.html": {
    "href": "api/XData.Database.SqlBlock.ISqlValue.html",
    "title": "Interface ISqlValue | XData website",
    "keywords": "Interface ISqlValue Base SQL block value description Namespace : XData.Database.SqlBlock Assembly : XData.docfx.dll Syntax public interface ISqlValue Extension Methods SerializationExtensions.ToXml<T>(T) CollectionsExtensions.SetValue<TKey, T>(TKey, T) CollectionsExtensions.AsEnum<T>(T) DataObjectQueryableExtensions.CompareVariable(Object, FilterOperation, String) Processing.Do<T>(T, Action<IProcess<T>>[]) TypeExtensions.TryConvert<T, TResult>(T, Func<T, TResult>) TypeExtensions.TryConvert<T, TResult>(T, Func<T, TResult>, TResult) TypeExtensions.ChangeType<T>(Object) TypeExtensions.ChangeType(Object, Type) TypeExtensions.InvokeMethod<TRet>(Object, Type[], Expression<Func<TRet>>, BindingFlags) TypeExtensions.InvokeMethod(Object, Type[], Expression<Action>, BindingFlags) TypeExtensions.InvokeMethod<TRet>(Object, Expression<Func<TRet>>, BindingFlags) TypeExtensions.InvokeMethod(Object, Expression<Action>, BindingFlags) SqlBlockExtensions.SetExpression<TTag, TResult>(TTag, Expression<Func<IBlockQueryAdapter, TResult>>) QueryDescriptionExtensions.SetExpression<TTag, TResult>(TTag, Expression<Func<IQueryStructureAdapter, TResult>>)"
  },
  "api/XData.Database.SqlBlock.ISqlBlock.html": {
    "href": "api/XData.Database.SqlBlock.ISqlBlock.html",
    "title": "Interface ISqlBlock | XData website",
    "keywords": "Interface ISqlBlock SQL block definition interface Namespace : XData.Database.SqlBlock Assembly : XData.docfx.dll Syntax public interface ISqlBlock Extension Methods SerializationExtensions.ToXml<T>(T) CollectionsExtensions.SetValue<TKey, T>(TKey, T) CollectionsExtensions.AsEnum<T>(T) DataObjectQueryableExtensions.CompareVariable(Object, FilterOperation, String) Processing.Do<T>(T, Action<IProcess<T>>[]) TypeExtensions.TryConvert<T, TResult>(T, Func<T, TResult>) TypeExtensions.TryConvert<T, TResult>(T, Func<T, TResult>, TResult) TypeExtensions.ChangeType<T>(Object) TypeExtensions.ChangeType(Object, Type) TypeExtensions.InvokeMethod<TRet>(Object, Type[], Expression<Func<TRet>>, BindingFlags) TypeExtensions.InvokeMethod(Object, Type[], Expression<Action>, BindingFlags) TypeExtensions.InvokeMethod<TRet>(Object, Expression<Func<TRet>>, BindingFlags) TypeExtensions.InvokeMethod(Object, Expression<Action>, BindingFlags) SqlBlockExtensions.SetExpression<TTag, TResult>(TTag, Expression<Func<IBlockQueryAdapter, TResult>>) QueryDescriptionExtensions.SetExpression<TTag, TResult>(TTag, Expression<Func<IQueryStructureAdapter, TResult>>)"
  },
  "api/XData.Database.SqlBlock.ILoopVariableAdapter-1.html": {
    "href": "api/XData.Database.SqlBlock.ILoopVariableAdapter-1.html",
    "title": "Interface ILoopVariableAdapter<T> | XData website",
    "keywords": "Interface ILoopVariableAdapter<T> Loop variables mapping adapter Namespace : XData.Database.SqlBlock Assembly : XData.docfx.dll Syntax public interface ILoopVariableAdapter<T> Type Parameters Name Description T Loop cursor type Methods | Improve this Doc View Source Map<TVal>(String, Expression<Func<T, TVal>>) Loop variable mapping expression Declaration void Map<TVal>(string variable, Expression<Func<T, TVal>> mapping) Parameters Type Name Description String variable Variable name Expression < Func <T, TVal>> mapping Mapped cursor property expression Type Parameters Name Description TVal See Also ForEach<T> ( Expression < Func < IBlockQueryStructure , IBlockQueryDescription <T>>>, String , Expression < Func < ISqlBlockAdapter , ISqlBlock >>, Expression < Action < ILoopVariableAdapter <T>>>[]) Extension Methods SerializationExtensions.ToXml<T>(T) CollectionsExtensions.SetValue<TKey, T>(TKey, T) CollectionsExtensions.AsEnum<T>(T) DataObjectQueryableExtensions.CompareVariable(Object, FilterOperation, String) Processing.Do<T>(T, Action<IProcess<T>>[]) TypeExtensions.TryConvert<T, TResult>(T, Func<T, TResult>) TypeExtensions.TryConvert<T, TResult>(T, Func<T, TResult>, TResult) TypeExtensions.ChangeType<T>(Object) TypeExtensions.ChangeType(Object, Type) TypeExtensions.InvokeMethod<TRet>(Object, Type[], Expression<Func<TRet>>, BindingFlags) TypeExtensions.InvokeMethod(Object, Type[], Expression<Action>, BindingFlags) TypeExtensions.InvokeMethod<TRet>(Object, Expression<Func<TRet>>, BindingFlags) TypeExtensions.InvokeMethod(Object, Expression<Action>, BindingFlags) SqlBlockExtensions.SetExpression<TTag, TResult>(TTag, Expression<Func<IBlockQueryAdapter, TResult>>) QueryDescriptionExtensions.SetExpression<TTag, TResult>(TTag, Expression<Func<IQueryStructureAdapter, TResult>>)"
  },
  "api/XData.DataSource.Structure.ISqlPart.html": {
    "href": "api/XData.DataSource.Structure.ISqlPart.html",
    "title": "Interface ISqlPart | XData website",
    "keywords": "Interface ISqlPart Subquery base interface Inherited Members IDataSource.SourceType IDataSource.Alias IDataSource.IsBase IDataSource.GetFields() IDataSource.GetFields(Type) IDataSource.GetField(String, String, String) IDataSource.GetField(String, String, String, String) ICloneable.Clone() Namespace : XData.DataSource.Structure Assembly : XData.docfx.dll Syntax public interface ISqlPart : IDataSource, ICloneable Properties | Improve this Doc View Source Dynamic Subquery dynamic flag Declaration bool Dynamic { get; } Property Value Type Description Boolean | Improve this Doc View Source ObjectType Subquery object type name Declaration string ObjectType { get; } Property Value Type Description String | Improve this Doc View Source Structure Subquery structure Declaration IDataStructure Structure { get; } Property Value Type Description IDataStructure Methods | Improve this Doc View Source FindTempTables() Find temporary tables recursive Declaration IEnumerable<ITempTable> FindTempTables() Returns Type Description IEnumerable < ITempTable > Found temporary tables sequence Extension Methods SerializationExtensions.ToXml<T>(T) CollectionsExtensions.SetValue<TKey, T>(TKey, T) CollectionsExtensions.AsEnum<T>(T) DataObjectQueryableExtensions.CompareVariable(Object, FilterOperation, String) Processing.Do<T>(T, Action<IProcess<T>>[]) TypeExtensions.TryConvert<T, TResult>(T, Func<T, TResult>) TypeExtensions.TryConvert<T, TResult>(T, Func<T, TResult>, TResult) TypeExtensions.ChangeType<T>(Object) TypeExtensions.ChangeType(Object, Type) TypeExtensions.InvokeMethod<TRet>(Object, Type[], Expression<Func<TRet>>, BindingFlags) TypeExtensions.InvokeMethod(Object, Type[], Expression<Action>, BindingFlags) TypeExtensions.InvokeMethod<TRet>(Object, Expression<Func<TRet>>, BindingFlags) TypeExtensions.InvokeMethod(Object, Expression<Action>, BindingFlags) SqlBlockExtensions.SetExpression<TTag, TResult>(TTag, Expression<Func<IBlockQueryAdapter, TResult>>) QueryDescriptionExtensions.SetExpression<TTag, TResult>(TTag, Expression<Func<IQueryStructureAdapter, TResult>>)"
  },
  "api/XData.Exceptions.XDataQueryStructureException.html": {
    "href": "api/XData.Exceptions.XDataQueryStructureException.html",
    "title": "Class XDataQueryStructureException | XData website",
    "keywords": "Class XDataQueryStructureException Query structure build failed Inheritance Object Exception ApplicationException XDataException XDataQueryStructureException Implements ISerializable Inherited Members Exception.GetBaseException() Exception.GetObjectData(SerializationInfo, StreamingContext) Exception.GetType() Exception.ToString() Exception.Data Exception.HelpLink Exception.HResult Exception.InnerException Exception.Message Exception.Source Exception.StackTrace Exception.TargetSite Exception.SerializeObjectState Object.Equals(Object) Object.Equals(Object, Object) Object.GetHashCode() Object.MemberwiseClone() Object.ReferenceEquals(Object, Object) Namespace : XData.Exceptions Assembly : XData.docfx.dll Syntax [Serializable] public sealed class XDataQueryStructureException : XDataException, ISerializable Constructors | Improve this Doc View Source XDataQueryStructureException(XDataQueryStructureExceptionType, String) Query structure build failed Declaration public XDataQueryStructureException(XDataQueryStructureExceptionType type, string details) Parameters Type Name Description XDataQueryStructureExceptionType type Query structure exception type String details Error details | Improve this Doc View Source XDataQueryStructureException(XDataQueryStructureExceptionType, String, Type) Query structure build failed Declaration public XDataQueryStructureException(XDataQueryStructureExceptionType type, string details, Type dataObjectType) Parameters Type Name Description XDataQueryStructureExceptionType type Query structure exception type String details Error details Type dataObjectType Data object type | Improve this Doc View Source XDataQueryStructureException(XDataQueryStructureExceptionType, String, Type, AdditionalInfo[]) Query structure build failed Declaration public XDataQueryStructureException(XDataQueryStructureExceptionType type, string details, Type dataObjectType, params AdditionalInfo[] addInfo) Parameters Type Name Description XDataQueryStructureExceptionType type Query structure exception type String details Error details Type dataObjectType Data object type AdditionalInfo [] addInfo Additional information Exceptions Type Condition NotImplementedException | Improve this Doc View Source XDataQueryStructureException(XDataQueryStructureExceptionType, Type) Query structure build failed Declaration public XDataQueryStructureException(XDataQueryStructureExceptionType type, Type dataObjectType) Parameters Type Name Description XDataQueryStructureExceptionType type Query structure exception type Type dataObjectType Data object type Properties | Improve this Doc View Source DataObjectType Data object type Declaration public Type DataObjectType { get; } Property Value Type Description Type | Improve this Doc View Source DetailsInfo Exception details info Declaration public string DetailsInfo { get; } Property Value Type Description String | Improve this Doc View Source Type Type of exception Declaration public XDataQueryStructureExceptionType Type { get; } Property Value Type Description XDataQueryStructureExceptionType Implements System.Runtime.Serialization.ISerializable Extension Methods SerializationExtensions.ToXml<T>(T) CollectionsExtensions.SetValue<TKey, T>(TKey, T) CollectionsExtensions.AsEnum<T>(T) DataObjectQueryableExtensions.CompareVariable(Object, FilterOperation, String) Processing.Do<T>(T, Action<IProcess<T>>[]) TypeExtensions.TryConvert<T, TResult>(T, Func<T, TResult>) TypeExtensions.TryConvert<T, TResult>(T, Func<T, TResult>, TResult) TypeExtensions.ChangeType<T>(Object) TypeExtensions.ChangeType(Object, Type) TypeExtensions.InvokeMethod<TRet>(Object, Type[], Expression<Func<TRet>>, BindingFlags) TypeExtensions.InvokeMethod(Object, Type[], Expression<Action>, BindingFlags) TypeExtensions.InvokeMethod<TRet>(Object, Expression<Func<TRet>>, BindingFlags) TypeExtensions.InvokeMethod(Object, Expression<Action>, BindingFlags) SqlBlockExtensions.SetExpression<TTag, TResult>(TTag, Expression<Func<IBlockQueryAdapter, TResult>>) QueryDescriptionExtensions.SetExpression<TTag, TResult>(TTag, Expression<Func<IQueryStructureAdapter, TResult>>)"
  },
  "api/XData.Exceptions.XDataExceptionAttribute.html": {
    "href": "api/XData.Exceptions.XDataExceptionAttribute.html",
    "title": "Class XDataExceptionAttribute | XData website",
    "keywords": "Class XDataExceptionAttribute XData exception attribute Inheritance Object Attribute XDataExceptionAttribute Inherited Members Attribute.Equals(Object) Attribute.GetCustomAttribute(Assembly, Type) Attribute.GetCustomAttribute(Assembly, Type, Boolean) Attribute.GetCustomAttribute(MemberInfo, Type) Attribute.GetCustomAttribute(MemberInfo, Type, Boolean) Attribute.GetCustomAttribute(Module, Type) Attribute.GetCustomAttribute(Module, Type, Boolean) Attribute.GetCustomAttribute(ParameterInfo, Type) Attribute.GetCustomAttribute(ParameterInfo, Type, Boolean) Attribute.GetCustomAttributes(Assembly) Attribute.GetCustomAttributes(Assembly, Boolean) Attribute.GetCustomAttributes(Assembly, Type) Attribute.GetCustomAttributes(Assembly, Type, Boolean) Attribute.GetCustomAttributes(MemberInfo) Attribute.GetCustomAttributes(MemberInfo, Boolean) Attribute.GetCustomAttributes(MemberInfo, Type) Attribute.GetCustomAttributes(MemberInfo, Type, Boolean) Attribute.GetCustomAttributes(Module) Attribute.GetCustomAttributes(Module, Boolean) Attribute.GetCustomAttributes(Module, Type) Attribute.GetCustomAttributes(Module, Type, Boolean) Attribute.GetCustomAttributes(ParameterInfo) Attribute.GetCustomAttributes(ParameterInfo, Boolean) Attribute.GetCustomAttributes(ParameterInfo, Type) Attribute.GetCustomAttributes(ParameterInfo, Type, Boolean) Attribute.GetHashCode() Attribute.IsDefaultAttribute() Attribute.IsDefined(Assembly, Type) Attribute.IsDefined(Assembly, Type, Boolean) Attribute.IsDefined(MemberInfo, Type) Attribute.IsDefined(MemberInfo, Type, Boolean) Attribute.IsDefined(Module, Type) Attribute.IsDefined(Module, Type, Boolean) Attribute.IsDefined(ParameterInfo, Type) Attribute.IsDefined(ParameterInfo, Type, Boolean) Attribute.Match(Object) Attribute.TypeId Object.Equals(Object, Object) Object.GetType() Object.MemberwiseClone() Object.ReferenceEquals(Object, Object) Object.ToString() Namespace : XData.Exceptions Assembly : XData.docfx.dll Syntax public class XDataExceptionAttribute : Attribute Extension Methods SerializationExtensions.ToXml<T>(T) CollectionsExtensions.SetValue<TKey, T>(TKey, T) CollectionsExtensions.AsEnum<T>(T) DataObjectQueryableExtensions.CompareVariable(Object, FilterOperation, String) Processing.Do<T>(T, Action<IProcess<T>>[]) TypeExtensions.TryConvert<T, TResult>(T, Func<T, TResult>) TypeExtensions.TryConvert<T, TResult>(T, Func<T, TResult>, TResult) TypeExtensions.ChangeType<T>(Object) TypeExtensions.ChangeType(Object, Type) TypeExtensions.InvokeMethod<TRet>(Object, Type[], Expression<Func<TRet>>, BindingFlags) TypeExtensions.InvokeMethod(Object, Type[], Expression<Action>, BindingFlags) TypeExtensions.InvokeMethod<TRet>(Object, Expression<Func<TRet>>, BindingFlags) TypeExtensions.InvokeMethod(Object, Expression<Action>, BindingFlags) SqlBlockExtensions.SetExpression<TTag, TResult>(TTag, Expression<Func<IBlockQueryAdapter, TResult>>) QueryDescriptionExtensions.SetExpression<TTag, TResult>(TTag, Expression<Func<IQueryStructureAdapter, TResult>>)"
  },
  "api/XData.DefaultType.html": {
    "href": "api/XData.DefaultType.html",
    "title": "Enum DefaultType | XData website",
    "keywords": "Enum DefaultType Default value type Namespace : XData Assembly : XData.docfx.dll Syntax [DataContract] public enum DefaultType Fields Name Description AutoIncrement Auto increment value as default Const Constant value as default CurrentDate Current date CurrentDateTime Current date and time CurrentDateTimeUtc Current date and time UTC NewGuid New GUID as default None No default value UserName Current user name Variable Variable value as default See Also DefaultSource DefaultSource None CurrentDate CurrentDateTime CurrentDateTimeUtc Variable Const AutoIncrement Extension Methods SerializationExtensions.ToXml<DefaultType>() CollectionsExtensions.SetValue<DefaultType, T>(T) CollectionsExtensions.AsEnum<DefaultType>() DataObjectQueryableExtensions.CompareVariable(FilterOperation, String) Processing.Do<DefaultType>(Action<IProcess<DefaultType>>[]) TypeExtensions.ChangeType<T>() TypeExtensions.ChangeType(Type) TypeExtensions.InvokeMethod<TRet>(Type[], Expression<Func<TRet>>, BindingFlags) TypeExtensions.InvokeMethod(Type[], Expression<Action>, BindingFlags) TypeExtensions.InvokeMethod<TRet>(Expression<Func<TRet>>, BindingFlags) TypeExtensions.InvokeMethod(Expression<Action>, BindingFlags) TypeExtensions.ConvertTo<T>() TypeExtensions.EqualValue(Enum) SqlBlockExtensions.SetExpression<DefaultType, TResult>(Expression<Func<IBlockQueryAdapter, TResult>>) QueryDescriptionExtensions.SetExpression<DefaultType, TResult>(Expression<Func<IQueryStructureAdapter, TResult>>)"
  },
  "api/XData.DefaultFeature.html": {
    "href": "api/XData.DefaultFeature.html",
    "title": "Enum DefaultFeature | XData website",
    "keywords": "Enum DefaultFeature Default value features Namespace : XData Assembly : XData.docfx.dll Syntax [Flags] public enum DefaultFeature Fields Name Description SkipWhenAssigned Skip insert into table when PK value assigned explicitly UpdateWhenAssigned Change insert operation over table to update when PK value assigned explicitly UseOnInsert Use default value on insert (by default, always applied) UseOnUpdate Use default value on update Extension Methods SerializationExtensions.ToXml<DefaultFeature>() CollectionsExtensions.SetValue<DefaultFeature, T>(T) CollectionsExtensions.AsEnum<DefaultFeature>() DataObjectQueryableExtensions.CompareVariable(FilterOperation, String) Processing.Do<DefaultFeature>(Action<IProcess<DefaultFeature>>[]) TypeExtensions.ChangeType<T>() TypeExtensions.ChangeType(Type) TypeExtensions.InvokeMethod<TRet>(Type[], Expression<Func<TRet>>, BindingFlags) TypeExtensions.InvokeMethod(Type[], Expression<Action>, BindingFlags) TypeExtensions.InvokeMethod<TRet>(Expression<Func<TRet>>, BindingFlags) TypeExtensions.InvokeMethod(Expression<Action>, BindingFlags) TypeExtensions.ConvertTo<T>() TypeExtensions.EqualValue(Enum) SqlBlockExtensions.SetExpression<DefaultFeature, TResult>(Expression<Func<IBlockQueryAdapter, TResult>>) QueryDescriptionExtensions.SetExpression<DefaultFeature, TResult>(Expression<Func<IQueryStructureAdapter, TResult>>)"
  },
  "api/XData.Mapping.Dynamic.IRepositoryStructure-1.html": {
    "href": "api/XData.Mapping.Dynamic.IRepositoryStructure-1.html",
    "title": "Interface IRepositoryStructure<T> | XData website",
    "keywords": "Interface IRepositoryStructure<T> Repository structure descriptor Namespace : XData.Mapping.Dynamic Assembly : XData.docfx.dll Syntax public interface IRepositoryStructure<T> where T : class, ISqlObject, new() Type Parameters Name Description T Data object type Methods | Improve this Doc View Source Column<TResult>(String, Expression<Func<IRepositoryStructureAdapter<T>, TResult>>) Dynamic repository hidden property mapping Declaration IRepositoryStructure<T> Column<TResult>(string name, Expression<Func<IRepositoryStructureAdapter<T>, TResult>> mapper) Parameters Type Name Description String name Hidden property name Expression < Func < IRepositoryStructureAdapter <T>, TResult>> mapper Property mapping expression Returns Type Description IRepositoryStructure <T> Repository structure Type Parameters Name Description TResult Hidden property type See Also GetStructure(String, String, DataStructureFlag, Variable[]) IQueryStructure IQueryStructureAdapter | Improve this Doc View Source DataTable(String, String, Expression<Func<IInnerFilterAdapter, IFilterDescription>>[]) Dynamic repository table mapping Declaration IRepositoryStructure<T> DataTable(string name, string alias, params Expression<Func<IInnerFilterAdapter, IFilterDescription>>[] filters) Parameters Type Name Description String name Table name String alias Table alias Expression < Func < IInnerFilterAdapter , IFilterDescription >>[] filters Filters and links applied to table Returns Type Description IRepositoryStructure <T> Query structure See Also GetStructure(String, String, DataStructureFlag, Variable[]) IQueryStructure IFilterDescription | Improve this Doc View Source DataTable(String, String, String, Expression<Func<IInnerFilterAdapter, IFilterDescription>>[]) Dynamic repository table mapping Declaration IRepositoryStructure<T> DataTable(string name, string alias, string parent = null, params Expression<Func<IInnerFilterAdapter, IFilterDescription>>[] filters) Parameters Type Name Description String name Table name String alias Table alias String parent Parent table alias Expression < Func < IInnerFilterAdapter , IFilterDescription >>[] filters Filters and links applied to table Returns Type Description IRepositoryStructure <T> Repository structure See Also GetStructure(String, String, DataStructureFlag, Variable[]) IQueryStructure IFilterDescription | Improve this Doc View Source Distinct() Dynamic repository distinct modificator Declaration IRepositoryStructure<T> Distinct() Returns Type Description IRepositoryStructure <T> Query structure | Improve this Doc View Source Hint(String, String, HintType) Dynamic repository data source hint Declaration IRepositoryStructure<T> Hint(string alias, string hint, HintType hintType = HintType.Select) Parameters Type Name Description String alias Data source alias String hint Hint HintType hintType Hint type Returns Type Description IRepositoryStructure <T> Repository structure See Also GetStructure(String, String, DataStructureFlag, Variable[]) | Improve this Doc View Source InnerView(String, Type, Expression<Func<ISubqueryLinkAdapter<T>, IFilterDescription>>[]) Dynamic repository inner view mapping Declaration IRepositoryStructure<T> InnerView(string alias, Type innerViewType, params Expression<Func<ISubqueryLinkAdapter<T>, IFilterDescription>>[] filters) Parameters Type Name Description String alias Inner view alias Type innerViewType Inner view statically mapped type Expression < Func < ISubqueryLinkAdapter <T>, IFilterDescription >>[] filters Filters and links applied to inner view Returns Type Description IRepositoryStructure <T> Repository structure See Also GetStructure(String, String, DataStructureFlag, Variable[]) IQueryStructure IFilterDescription | Improve this Doc View Source InnerView<TInnerView>(String, Expression<Func<ISubqueryLinkAdapter<T, TInnerView>, IFilterDescription>>[]) Dynamic repository inner view mapping Declaration IRepositoryStructure<T> InnerView<TInnerView>(string alias, params Expression<Func<ISubqueryLinkAdapter<T, TInnerView>, IFilterDescription>>[] filters) where TInnerView : class Parameters Type Name Description String alias Inner view alias Expression < Func < ISubqueryLinkAdapter <T, TInnerView>, IFilterDescription >>[] filters Filters and links applied to inner view Returns Type Description IRepositoryStructure <T> Query structure Type Parameters Name Description TInnerView Inner view statically mapped type See Also GetStructure(String, String, DataStructureFlag, Variable[]) IQueryStructure IFilterDescription | Improve this Doc View Source InnerView<TInnerView>(String, IQueryDescription<TInnerView>, Expression<Func<ISubqueryLinkAdapter<T, TInnerView>, IFilterDescription>>[]) Dynamic repository inner view mapping Declaration IRepositoryStructure<T> InnerView<TInnerView>(string alias, IQueryDescription<TInnerView> sub, params Expression<Func<ISubqueryLinkAdapter<T, TInnerView>, IFilterDescription>>[] filters) where TInnerView : class Parameters Type Name Description String alias Inner view alias IQueryDescription <TInnerView> sub Inner view query structure Expression < Func < ISubqueryLinkAdapter <T, TInnerView>, IFilterDescription >>[] filters Filters and links applied to inner view Returns Type Description IRepositoryStructure <T> Repository structure Type Parameters Name Description TInnerView See Also GetStructure(String, String, DataStructureFlag, Variable[]) IQueryStructure IQueryDescription IFilterDescription | Improve this Doc View Source InnerView<TInnerView>(String, Variable[], Expression<Func<ISubqueryLinkAdapter<T, TInnerView>, IFilterDescription>>[]) Dynamic repository inner view mapping Declaration IRepositoryStructure<T> InnerView<TInnerView>(string alias, Variable[] variables, params Expression<Func<ISubqueryLinkAdapter<T, TInnerView>, IFilterDescription>>[] filters) where TInnerView : class Parameters Type Name Description String alias Inner view alias Variable [] variables Inner view variables Expression < Func < ISubqueryLinkAdapter <T, TInnerView>, IFilterDescription >>[] filters Filters and links applied to inner view Returns Type Description IRepositoryStructure <T> Query structure Type Parameters Name Description TInnerView Inner view statically mapped type See Also GetStructure(String, String, DataStructureFlag, Variable[]) IQueryStructure Variable IFilterDescription | Improve this Doc View Source Limit(Int32) Dynamic repository limit count modificator Declaration IRepositoryStructure<T> Limit(int count) Parameters Type Name Description Int32 count Limit records count Returns Type Description IRepositoryStructure <T> Query structure | Improve this Doc View Source Map(Expression<Func<IExternalLinkDefinitionAdapter<T>, IExternalLinkDefinition>>[]) Dynamic repository properties mapping Declaration IRepositoryDescription<T> Map(params Expression<Func<IExternalLinkDefinitionAdapter<T>, IExternalLinkDefinition>>[] externalLinks) Parameters Type Name Description Expression < Func < IExternalLinkDefinitionAdapter <T>, IExternalLinkDefinition >>[] externalLinks External link descriptions Returns Type Description IRepositoryDescription <T> Dynamic repository description See Also GetStructure(String, String, DataStructureFlag, Variable[]) IQueryStructure IQueryDescription <T> IQueryStructureAdapter | Improve this Doc View Source Map(Expression<Func<IRepositoryStructureAdapter<T>, T>>, Expression<Func<IExternalLinkDefinitionAdapter<T>, IExternalLinkDefinition>>[]) Dynamic repository properties mapping Declaration IRepositoryDescription<T> Map(Expression<Func<IRepositoryStructureAdapter<T>, T>> mapper, params Expression<Func<IExternalLinkDefinitionAdapter<T>, IExternalLinkDefinition>>[] externalLinks) Parameters Type Name Description Expression < Func < IRepositoryStructureAdapter <T>, T>> mapper Mapping expression Expression < Func < IExternalLinkDefinitionAdapter <T>, IExternalLinkDefinition >>[] externalLinks External link descriptions Returns Type Description IRepositoryDescription <T> Dynamic repository description See Also GetStructure(String, String, DataStructureFlag, Variable[]) IQueryStructure IQueryDescription <T> IQueryStructureAdapter | Improve this Doc View Source Parameter<TResult>(String, Int32, String, DbType, Expression<Func<IProcedureParameterAdapter, IProcedureParameterFlag>>[]) Dynamic repository procedure parameter mapping Declaration IRepositoryStructure<T> Parameter<TResult>(string alias, int order, string binding, DbType type, params Expression<Func<IProcedureParameterAdapter, IProcedureParameterFlag>>[] attributes) Parameters Type Name Description String alias Procedure alias Int32 order Parameter order String binding Parameter value binding DbType type Parameter SQL data type Expression < Func < IProcedureParameterAdapter , IProcedureParameterFlag >>[] attributes Parameter attributes Returns Type Description IRepositoryStructure <T> Repository structure Type Parameters Name Description TResult Parameter data type | Improve this Doc View Source Procedure(String, String, ProcedureType, Expression<Func<IInnerFilterAdapter, IFilterDescription>>[]) Dynamic repository procedure mapping Declaration IRepositoryStructure<T> Procedure(string alias, string name, ProcedureType type, params Expression<Func<IInnerFilterAdapter, IFilterDescription>>[] filters) Parameters Type Name Description String alias Procedure alias String name Procedure name ProcedureType type Procedure type Expression < Func < IInnerFilterAdapter , IFilterDescription >>[] filters Filters and links applied to table Returns Type Description IRepositoryStructure <T> Repository structure See Also GetStructure(String, String, DataStructureFlag, Variable[]) IQueryStructure IFilterDescription | Improve this Doc View Source ReadOnlyProperty<TResult>(Expression<Func<T, TResult>>, Expression<Func<IRepositoryStructureAdapter<T>, TResult>>) Dynamic repository read only properties mapping Declaration IRepositoryStructure<T> ReadOnlyProperty<TResult>(Expression<Func<T, TResult>> property, Expression<Func<IRepositoryStructureAdapter<T>, TResult>> mapper) Parameters Type Name Description Expression < Func <T, TResult>> property Property name expression Expression < Func < IRepositoryStructureAdapter <T>, TResult>> mapper Property mapping Returns Type Description IRepositoryStructure <T> Repository structure Type Parameters Name Description TResult Property type | Improve this Doc View Source Return(String) Dynamic repository procedure default result set mapping Declaration IRepositoryStructure<T> Return(string alias) Parameters Type Name Description String alias Procedure alias Returns Type Description IRepositoryStructure <T> Repository structure | Improve this Doc View Source Return<TResult>(String, String, Int32, Expression<Func<IQueryStructureAdapter, T>>) Dynamic repository procedure result set mapping Declaration IRepositoryStructure<T> Return<TResult>(string alias, string name, int order, Expression<Func<IQueryStructureAdapter, T>> mapper = null) where TResult : class Parameters Type Name Description String alias Procedure alias String name Result set name Int32 order Result set order Expression < Func < IQueryStructureAdapter , T>> mapper Result set mapper Returns Type Description IRepositoryStructure <T> Repository structure Type Parameters Name Description TResult Result set data type | Improve this Doc View Source Skip(Int32) Dynamic repository skip count modificator Declaration IRepositoryStructure<T> Skip(int count) Parameters Type Name Description Int32 count Skip records count Returns Type Description IRepositoryStructure <T> Query structure | Improve this Doc View Source Subquery(String, Type, String, DataGrouping, Expression<Func<ISubqueryLinkAdapter<T>, IFilterDescription>>[]) Dynamic repository subquery mapping Declaration IRepositoryStructure<T> Subquery(string alias, Type subqueryType, string property, DataGrouping grouping = DataGrouping.None, params Expression<Func<ISubqueryLinkAdapter<T>, IFilterDescription>>[] filters) Parameters Type Name Description String alias Subquery alias Type subqueryType Subquery statically mapped type String property Subquery selected property DataGrouping grouping Subquery selected property aggregate function Expression < Func < ISubqueryLinkAdapter <T>, IFilterDescription >>[] filters Filters and links applied to subquery Returns Type Description IRepositoryStructure <T> Repository structure See Also GetStructure(String, String, DataStructureFlag, Variable[]) IQueryStructure IFilterDescription | Improve this Doc View Source Subquery<TSubquery>(String, Expression<Func<TSubquery, Object>>, DataGrouping, Expression<Func<ISubqueryLinkAdapter<T, TSubquery>, IFilterDescription>>[]) Dynamic repository subquery mapping Declaration IRepositoryStructure<T> Subquery<TSubquery>(string alias, Expression<Func<TSubquery, object>> property, DataGrouping grouping = DataGrouping.None, params Expression<Func<ISubqueryLinkAdapter<T, TSubquery>, IFilterDescription>>[] filters) where TSubquery : class Parameters Type Name Description String alias Subquery alias Expression < Func <TSubquery, Object >> property Subquery selected property expression DataGrouping grouping Subquery selected property aggregate function Expression < Func < ISubqueryLinkAdapter <T, TSubquery>, IFilterDescription >>[] filters Filters and links applied to subquery Returns Type Description IRepositoryStructure <T> Repository structure Type Parameters Name Description TSubquery Subquery statically mapped type See Also GetStructure(String, String, DataStructureFlag, Variable[]) IQueryStructure IFilterDescription | Improve this Doc View Source Subquery<TSubquery>(String, Expression<Func<TSubquery, Object>>, DataGrouping, Variable[], Expression<Func<ISubqueryLinkAdapter<T, TSubquery>, IFilterDescription>>[]) Dynamic repository subquery mapping Declaration IRepositoryStructure<T> Subquery<TSubquery>(string alias, Expression<Func<TSubquery, object>> property, DataGrouping grouping, Variable[] variables, params Expression<Func<ISubqueryLinkAdapter<T, TSubquery>, IFilterDescription>>[] filters) where TSubquery : class Parameters Type Name Description String alias Subquery alias Expression < Func <TSubquery, Object >> property Subquery selected property expression DataGrouping grouping Subquery selected property aggregate function Variable [] variables Subquery variables Expression < Func < ISubqueryLinkAdapter <T, TSubquery>, IFilterDescription >>[] filters Filters and links applied to subquery Returns Type Description IRepositoryStructure <T> Repository structure Type Parameters Name Description TSubquery Subquery statically mapped type See Also GetStructure(String, String, DataStructureFlag, Variable[]) IQueryStructure IFilterDescription Variable | Improve this Doc View Source Subquery<TSubquery>(String, IQueryDescription<TSubquery>, String, DataGrouping, Expression<Func<ISubqueryLinkAdapter<T, TSubquery>, IFilterDescription>>[]) Dynamic repository subquery mapping Declaration IRepositoryStructure<T> Subquery<TSubquery>(string alias, IQueryDescription<TSubquery> sub, string property, DataGrouping grouping = DataGrouping.None, params Expression<Func<ISubqueryLinkAdapter<T, TSubquery>, IFilterDescription>>[] filters) where TSubquery : class Parameters Type Name Description String alias Subquery alias IQueryDescription <TSubquery> sub Subquery query structure String property Subquery selected property DataGrouping grouping Subquery selected property aggregate function Expression < Func < ISubqueryLinkAdapter <T, TSubquery>, IFilterDescription >>[] filters Filters and links applied to subquery Returns Type Description IRepositoryStructure <T> Repository structure Type Parameters Name Description TSubquery See Also GetStructure(String, String, DataStructureFlag, Variable[]) IQueryStructure IQueryDescription DataGrouping IFilterDescription | Improve this Doc View Source With<TRoot>(String, IQueryDescription<TRoot>, Expression<Func<IQueryWithAdapter<TRoot>, IQueryWithFlag>>[]) Dynamic repository Common-Table-Expression (WITH) subquery mapping Declaration IRepositoryStructure<T> With<TRoot>(string alias, IQueryDescription<TRoot> sub, params Expression<Func<IQueryWithAdapter<TRoot>, IQueryWithFlag>>[] attributes) where TRoot : class Parameters Type Name Description String alias Common-Table-Expression (WITH) subquery alias IQueryDescription <TRoot> sub Common-Table-Expression (WITH) initial subquery description Expression < Func < IQueryWithAdapter <TRoot>, IQueryWithFlag >>[] attributes Common-Table-Expression (WITH) attributes Returns Type Description IRepositoryStructure <T> Repository structure Type Parameters Name Description TRoot Common-Table-Expression (WITH) initial subquery mapped type Extension Methods SerializationExtensions.ToXml<T>(T) CollectionsExtensions.SetValue<TKey, T>(TKey, T) CollectionsExtensions.AsEnum<T>(T) DataObjectQueryableExtensions.CompareVariable(Object, FilterOperation, String) Processing.Do<T>(T, Action<IProcess<T>>[]) TypeExtensions.TryConvert<T, TResult>(T, Func<T, TResult>) TypeExtensions.TryConvert<T, TResult>(T, Func<T, TResult>, TResult) TypeExtensions.ChangeType<T>(Object) TypeExtensions.ChangeType(Object, Type) TypeExtensions.InvokeMethod<TRet>(Object, Type[], Expression<Func<TRet>>, BindingFlags) TypeExtensions.InvokeMethod(Object, Type[], Expression<Action>, BindingFlags) TypeExtensions.InvokeMethod<TRet>(Object, Expression<Func<TRet>>, BindingFlags) TypeExtensions.InvokeMethod(Object, Expression<Action>, BindingFlags) SqlBlockExtensions.SetExpression<TTag, TResult>(TTag, Expression<Func<IBlockQueryAdapter, TResult>>) QueryDescriptionExtensions.SetExpression<TTag, TResult>(TTag, Expression<Func<IQueryStructureAdapter, TResult>>)"
  },
  "api/XData.Mapping.Dynamic.IRepositoryReadOnlyPropertyMappingAdapter.html": {
    "href": "api/XData.Mapping.Dynamic.IRepositoryReadOnlyPropertyMappingAdapter.html",
    "title": "Interface IRepositoryReadOnlyPropertyMappingAdapter | XData website",
    "keywords": "Interface IRepositoryReadOnlyPropertyMappingAdapter Repository read only property mapping adapter Inherited Members IPropertyMappingAdapter.Key() IPropertyMappingAdapter.Group(DataGrouping) IPropertyMappingAdapter.Group(Int32) IPropertyMappingAdapter.Hidden() IPropertyMappingAdapter.OrderBy(Int32, Boolean) IPropertyMappingAdapter.OrderBy(Int32) Namespace : XData.Mapping.Dynamic Assembly : XData.docfx.dll Syntax public interface IRepositoryReadOnlyPropertyMappingAdapter : IPropertyMappingAdapter Methods | Improve this Doc View Source ConcurrencyToken() Property is concurrency token flag Declaration IStructureFlag ConcurrencyToken() Returns Type Description IStructureFlag | Improve this Doc View Source OuterFlag() Property is outer join flag Declaration IStructureFlag OuterFlag() Returns Type Description IStructureFlag Extension Methods SerializationExtensions.ToXml<T>(T) CollectionsExtensions.SetValue<TKey, T>(TKey, T) CollectionsExtensions.AsEnum<T>(T) DataObjectQueryableExtensions.CompareVariable(Object, FilterOperation, String) Processing.Do<T>(T, Action<IProcess<T>>[]) TypeExtensions.TryConvert<T, TResult>(T, Func<T, TResult>) TypeExtensions.TryConvert<T, TResult>(T, Func<T, TResult>, TResult) TypeExtensions.ChangeType<T>(Object) TypeExtensions.ChangeType(Object, Type) TypeExtensions.InvokeMethod<TRet>(Object, Type[], Expression<Func<TRet>>, BindingFlags) TypeExtensions.InvokeMethod(Object, Type[], Expression<Action>, BindingFlags) TypeExtensions.InvokeMethod<TRet>(Object, Expression<Func<TRet>>, BindingFlags) TypeExtensions.InvokeMethod(Object, Expression<Action>, BindingFlags) SqlBlockExtensions.SetExpression<TTag, TResult>(TTag, Expression<Func<IBlockQueryAdapter, TResult>>) QueryDescriptionExtensions.SetExpression<TTag, TResult>(TTag, Expression<Func<IQueryStructureAdapter, TResult>>)"
  },
  "api/XData.Interfaces.IProxyManager.html": {
    "href": "api/XData.Interfaces.IProxyManager.html",
    "title": "Interface IProxyManager | XData website",
    "keywords": "Interface IProxyManager Proxy manager Namespace : XData.Interfaces Assembly : XData.docfx.dll Syntax public interface IProxyManager Methods | Improve this Doc View Source GetProxy(String) Returns XAppServer connection proxy object Declaration IProxy GetProxy(string endpointName) Parameters Type Name Description String endpointName Returns Type Description IProxy | Improve this Doc View Source GetProxyRepository(Guid, RepositoryState) Returns proxy repository using state Declaration IRepository GetProxyRepository(Guid layer, RepositoryState state) Parameters Type Name Description Guid layer Repository layer RepositoryState state Repository state Returns Type Description IRepository Repository | Improve this Doc View Source GetProxyRepository<T>(Guid, String, String, ISecuritySession, Variable[]) Returns proxy repository Declaration IRepository<T> GetProxyRepository<T>(Guid layer = default(Guid), string alias = null, string context = null, ISecuritySession security = null, params Variable[] variables) where T : class, IDataObject, new() Parameters Type Name Description Guid layer Repository layer String alias Repository alias String context Repository context ISecuritySession security Repository security context Variable [] variables Repository variables Returns Type Description IRepository <T> Repository Type Parameters Name Description T Repository element type Extension Methods SerializationExtensions.ToXml<T>(T) CollectionsExtensions.SetValue<TKey, T>(TKey, T) CollectionsExtensions.AsEnum<T>(T) DataObjectQueryableExtensions.CompareVariable(Object, FilterOperation, String) Processing.Do<T>(T, Action<IProcess<T>>[]) TypeExtensions.TryConvert<T, TResult>(T, Func<T, TResult>) TypeExtensions.TryConvert<T, TResult>(T, Func<T, TResult>, TResult) TypeExtensions.ChangeType<T>(Object) TypeExtensions.ChangeType(Object, Type) TypeExtensions.InvokeMethod<TRet>(Object, Type[], Expression<Func<TRet>>, BindingFlags) TypeExtensions.InvokeMethod(Object, Type[], Expression<Action>, BindingFlags) TypeExtensions.InvokeMethod<TRet>(Object, Expression<Func<TRet>>, BindingFlags) TypeExtensions.InvokeMethod(Object, Expression<Action>, BindingFlags) SqlBlockExtensions.SetExpression<TTag, TResult>(TTag, Expression<Func<IBlockQueryAdapter, TResult>>) QueryDescriptionExtensions.SetExpression<TTag, TResult>(TTag, Expression<Func<IQueryStructureAdapter, TResult>>)"
  },
  "api/XData.IDataEngine.html": {
    "href": "api/XData.IDataEngine.html",
    "title": "Interface IDataEngine | XData website",
    "keywords": "Interface IDataEngine XData engine interface Namespace : XData Assembly : XData.docfx.dll Syntax public interface IDataEngine Properties | Improve this Doc View Source Configuration XData configuration object Declaration IConfiguration Configuration { get; } Property Value Type Description IConfiguration See Also IConfiguration Methods | Improve this Doc View Source GetDataScope(Guid, Boolean) Request existing or create data scope Declaration IDataScope GetDataScope(Guid layer, bool throwIfNotFound = false) Parameters Type Name Description Guid layer Data scope layer Boolean throwIfNotFound Throw an exception when data scope is not found Returns Type Description IDataScope Data scope See Also IDataScope | Improve this Doc View Source GetDataScope(Guid, String, CancellationToken, Boolean) Request existing or create data scope Declaration IDataScope GetDataScope(Guid layer, string defaultContext, CancellationToken token, bool throwIfNotFound = false) Parameters Type Name Description Guid layer Data scope layer String defaultContext Default context of scope (if nof found) CancellationToken token Cancellation token Boolean throwIfNotFound Throw an exception when data scope is not found Returns Type Description IDataScope Data scope See Also IDataScope | Improve this Doc View Source GetDataScope(Guid, String, ISecuritySession, CancellationToken, Boolean) Request existing or create data scope Declaration IDataScope GetDataScope(Guid layer, string defaultContext, ISecuritySession security, CancellationToken token, bool throwIfNotFound = false) Parameters Type Name Description Guid layer Data scope layer String defaultContext Default context of scope (if nof found) ISecuritySession security Security session CancellationToken token Cancellation token Boolean throwIfNotFound Throw an exception when data scope is not found Returns Type Description IDataScope Data scope See Also IDataScope | Improve this Doc View Source GetDataScope(Guid, CancellationToken, Boolean) Request existing or create data scope Declaration IDataScope GetDataScope(Guid layer, CancellationToken token, bool throwIfNotFound = false) Parameters Type Name Description Guid layer Data scope layer CancellationToken token Cancellation token Boolean throwIfNotFound Throw an exception when data scope is not found Returns Type Description IDataScope Data scope See Also IDataScope | Improve this Doc View Source GetDataScope(Guid, ISecuritySession, CancellationToken, Boolean) Request existing or create data scope Declaration IDataScope GetDataScope(Guid layer, ISecuritySession security, CancellationToken token, bool throwIfNotFound = false) Parameters Type Name Description Guid layer Data scope layer ISecuritySession security Security session CancellationToken token Cancellation token Boolean throwIfNotFound Throw an exception when data scope is not found Returns Type Description IDataScope Data scope See Also IDataScope | Improve this Doc View Source NewDataScope() Create new data scope Declaration IDataScope NewDataScope() Returns Type Description IDataScope Data scope See Also IDataScope | Improve this Doc View Source NewDataScope(String) Create new data scope Declaration IDataScope NewDataScope(string defaultContext) Parameters Type Name Description String defaultContext Default context of scope Returns Type Description IDataScope Data scope See Also IDataScope | Improve this Doc View Source NewDataScope(String, CancellationToken) Create new data scope Declaration IDataScope NewDataScope(string defaultContext, CancellationToken token) Parameters Type Name Description String defaultContext Default context of scope CancellationToken token Cancellation token Returns Type Description IDataScope Data scope See Also IDataScope | Improve this Doc View Source NewDataScope(String, ISecuritySession) Create new data scope Declaration IDataScope NewDataScope(string defaultContext, ISecuritySession security) Parameters Type Name Description String defaultContext Default context of scope ISecuritySession security Security session Returns Type Description IDataScope Data scope See Also IDataScope | Improve this Doc View Source NewDataScope(String, ISecuritySession, CancellationToken) Create new data scope Declaration IDataScope NewDataScope(string defaultContext, ISecuritySession security, CancellationToken token) Parameters Type Name Description String defaultContext Default context of scope ISecuritySession security Security session CancellationToken token Cancellation token Returns Type Description IDataScope Data scope See Also IDataScope | Improve this Doc View Source NewDataScope(CancellationToken) Create new data scope Declaration IDataScope NewDataScope(CancellationToken token) Parameters Type Name Description CancellationToken token Cancellation token Returns Type Description IDataScope Data scope See Also IDataScope | Improve this Doc View Source NewDataScope(ISecuritySession, CancellationToken) Create new data scope Declaration IDataScope NewDataScope(ISecuritySession security, CancellationToken token) Parameters Type Name Description ISecuritySession security Security session CancellationToken token Cancellation token Returns Type Description IDataScope Data scope See Also IDataScope | Improve this Doc View Source ResetAllDictionaries() Reset all dictionaries cache Declaration void ResetAllDictionaries() See Also GetDictionaryValue<T>(Expression<Func<T, Boolean>>, String, ISecuritySession, Variable[]) | Improve this Doc View Source ResetDictionaryCache<T>() Reset single dictionary cache Declaration void ResetDictionaryCache<T>() where T : class, IDataObject Type Parameters Name Description T Dictionary type See Also GetDictionaryValue<T>(Expression<Func<T, Boolean>>, String, ISecuritySession, Variable[]) Extension Methods SerializationExtensions.ToXml<T>(T) CollectionsExtensions.SetValue<TKey, T>(TKey, T) CollectionsExtensions.AsEnum<T>(T) DataObjectQueryableExtensions.CompareVariable(Object, FilterOperation, String) Processing.Do<T>(T, Action<IProcess<T>>[]) TypeExtensions.TryConvert<T, TResult>(T, Func<T, TResult>) TypeExtensions.TryConvert<T, TResult>(T, Func<T, TResult>, TResult) TypeExtensions.ChangeType<T>(Object) TypeExtensions.ChangeType(Object, Type) TypeExtensions.InvokeMethod<TRet>(Object, Type[], Expression<Func<TRet>>, BindingFlags) TypeExtensions.InvokeMethod(Object, Type[], Expression<Action>, BindingFlags) TypeExtensions.InvokeMethod<TRet>(Object, Expression<Func<TRet>>, BindingFlags) TypeExtensions.InvokeMethod(Object, Expression<Action>, BindingFlags) SqlBlockExtensions.SetExpression<TTag, TResult>(TTag, Expression<Func<IBlockQueryAdapter, TResult>>) QueryDescriptionExtensions.SetExpression<TTag, TResult>(TTag, Expression<Func<IQueryStructureAdapter, TResult>>)"
  },
  "api/XData.DataSourceType.html": {
    "href": "api/XData.DataSourceType.html",
    "title": "Enum DataSourceType | XData website",
    "keywords": "Enum DataSourceType Data source type Namespace : XData Assembly : XData.docfx.dll Syntax [DataContract] public enum DataSourceType Fields Name Description InnerView Inner view Procedure SQL Stored procedure or Function Subquery Subquery Table Table TempTable Temporary table WithSubquery Common-Table-Expression (WITH) Subquery XmlSource XML data source See Also Table Subquery InnerView Procedure Extension Methods SerializationExtensions.ToXml<DataSourceType>() CollectionsExtensions.SetValue<DataSourceType, T>(T) CollectionsExtensions.AsEnum<DataSourceType>() DataObjectQueryableExtensions.CompareVariable(FilterOperation, String) Processing.Do<DataSourceType>(Action<IProcess<DataSourceType>>[]) TypeExtensions.ChangeType<T>() TypeExtensions.ChangeType(Type) TypeExtensions.InvokeMethod<TRet>(Type[], Expression<Func<TRet>>, BindingFlags) TypeExtensions.InvokeMethod(Type[], Expression<Action>, BindingFlags) TypeExtensions.InvokeMethod<TRet>(Expression<Func<TRet>>, BindingFlags) TypeExtensions.InvokeMethod(Expression<Action>, BindingFlags) TypeExtensions.ConvertTo<T>() TypeExtensions.EqualValue(Enum) SqlBlockExtensions.SetExpression<DataSourceType, TResult>(Expression<Func<IBlockQueryAdapter, TResult>>) QueryDescriptionExtensions.SetExpression<DataSourceType, TResult>(Expression<Func<IQueryStructureAdapter, TResult>>)"
  },
  "api/XData.DataSource.Structure.IRangeFilter.html": {
    "href": "api/XData.DataSource.Structure.IRangeFilter.html",
    "title": "Interface IRangeFilter | XData website",
    "keywords": "Interface IRangeFilter Range filter interface Inherited Members IFilter.FilterType IFilter.SourceAlias IFilter.Field IFilter.Operation ICloneable.Clone() Namespace : XData.DataSource.Structure Assembly : XData.docfx.dll Syntax public interface IRangeFilter : IFilter, ICloneable Properties | Improve this Doc View Source RangeValues Range values Declaration object[] RangeValues { get; } Property Value Type Description Object [] Extension Methods SerializationExtensions.ToXml<T>(T) CollectionsExtensions.SetValue<TKey, T>(TKey, T) CollectionsExtensions.AsEnum<T>(T) DataObjectQueryableExtensions.CompareVariable(Object, FilterOperation, String) Processing.Do<T>(T, Action<IProcess<T>>[]) TypeExtensions.TryConvert<T, TResult>(T, Func<T, TResult>) TypeExtensions.TryConvert<T, TResult>(T, Func<T, TResult>, TResult) TypeExtensions.ChangeType<T>(Object) TypeExtensions.ChangeType(Object, Type) TypeExtensions.InvokeMethod<TRet>(Object, Type[], Expression<Func<TRet>>, BindingFlags) TypeExtensions.InvokeMethod(Object, Type[], Expression<Action>, BindingFlags) TypeExtensions.InvokeMethod<TRet>(Object, Expression<Func<TRet>>, BindingFlags) TypeExtensions.InvokeMethod(Object, Expression<Action>, BindingFlags) SqlBlockExtensions.SetExpression<TTag, TResult>(TTag, Expression<Func<IBlockQueryAdapter, TResult>>) QueryDescriptionExtensions.SetExpression<TTag, TResult>(TTag, Expression<Func<IQueryStructureAdapter, TResult>>)"
  },
  "api/XData.DataSource.Structure.IProcedure.html": {
    "href": "api/XData.DataSource.Structure.IProcedure.html",
    "title": "Interface IProcedure | XData website",
    "keywords": "Interface IProcedure Procedure based structure Inherited Members IDataSource.SourceType IDataSource.Alias IDataSource.IsBase IDataSource.GetFields() IDataSource.GetFields(Type) IDataSource.GetField(String, String, String) IDataSource.GetField(String, String, String, String) ICloneable.Clone() Namespace : XData.DataSource.Structure Assembly : XData.docfx.dll Syntax public interface IProcedure : IDataSource, ICloneable Properties | Improve this Doc View Source CallBased SQL procedure/function is call based Declaration bool CallBased { get; } Property Value Type Description Boolean | Improve this Doc View Source DefaultResultSet SQL stored procedure/function default result set name Declaration string DefaultResultSet { get; } Property Value Type Description String | Improve this Doc View Source Hint SQL stored procedure/function hint Declaration HintInfo Hint { get; } Property Value Type Description HintInfo | Improve this Doc View Source Name SQL stored procedure/function full qualified name Declaration string Name { get; } Property Value Type Description String | Improve this Doc View Source Parameters SQL stored procedure/function parameters descriptions Declaration IEnumerable<IParameterDescription> Parameters { get; } Property Value Type Description IEnumerable < IParameterDescription > | Improve this Doc View Source ProcedureType SQL stored procedure/function type Declaration ProcedureType ProcedureType { get; } Property Value Type Description ProcedureType See Also ProcedureType Extension Methods SerializationExtensions.ToXml<T>(T) CollectionsExtensions.SetValue<TKey, T>(TKey, T) CollectionsExtensions.AsEnum<T>(T) DataObjectQueryableExtensions.CompareVariable(Object, FilterOperation, String) Processing.Do<T>(T, Action<IProcess<T>>[]) TypeExtensions.TryConvert<T, TResult>(T, Func<T, TResult>) TypeExtensions.TryConvert<T, TResult>(T, Func<T, TResult>, TResult) TypeExtensions.ChangeType<T>(Object) TypeExtensions.ChangeType(Object, Type) TypeExtensions.InvokeMethod<TRet>(Object, Type[], Expression<Func<TRet>>, BindingFlags) TypeExtensions.InvokeMethod(Object, Type[], Expression<Action>, BindingFlags) TypeExtensions.InvokeMethod<TRet>(Object, Expression<Func<TRet>>, BindingFlags) TypeExtensions.InvokeMethod(Object, Expression<Action>, BindingFlags) SqlBlockExtensions.SetExpression<TTag, TResult>(TTag, Expression<Func<IBlockQueryAdapter, TResult>>) QueryDescriptionExtensions.SetExpression<TTag, TResult>(TTag, Expression<Func<IQueryStructureAdapter, TResult>>)"
  },
  "api/XData.Database.SqlBlock.IBlockQueryAdapter.html": {
    "href": "api/XData.Database.SqlBlock.IBlockQueryAdapter.html",
    "title": "Interface IBlockQueryAdapter | XData website",
    "keywords": "Interface IBlockQueryAdapter SQL block query structure adapter Namespace : XData.Database.SqlBlock Assembly : XData.docfx.dll Syntax public interface IBlockQueryAdapter Methods | Improve this Doc View Source CastTo<T>() Type cast modifier Declaration IBlockQueryAdapter CastTo<T>() Returns Type Description IBlockQueryAdapter Type Parameters Name Description T Type to cast | Improve this Doc View Source Default<TValue>(String, DefaultType) Default value description Declaration TValue Default<TValue>(string fieldName, DefaultType source) Parameters Type Name Description String fieldName Field name DefaultType source Default value algorithm Returns Type Description TValue Field value Type Parameters Name Description TValue Field type Remarks WARNING! Can be used in dynamic query mapping only! | Improve this Doc View Source Default<TValue>(String, DefaultType, TValue) Default value description Declaration TValue Default<TValue>(string fieldName, DefaultType source, TValue value) Parameters Type Name Description String fieldName Field name DefaultType source Default value algorithm TValue value Default value Returns Type Description TValue Field value Type Parameters Name Description TValue Field type Remarks WARNING! Can be used in dynamic query mapping only! | Improve this Doc View Source Default<TValue>(DefaultType) Default value description Declaration TValue Default<TValue>(DefaultType source) Parameters Type Name Description DefaultType source Default value algorithm Returns Type Description TValue Field value Type Parameters Name Description TValue Field type Remarks WARNING! Can be used in dynamic query mapping only! | Improve this Doc View Source Default<TValue>(DefaultType, TValue) Default value description Declaration TValue Default<TValue>(DefaultType source, TValue value) Parameters Type Name Description DefaultType source Default value algorithm TValue value Default value Returns Type Description TValue Field value Type Parameters Name Description TValue Field type Remarks WARNING! Can be used in dynamic query mapping only! | Improve this Doc View Source Expr<TValue>(String, Expression<Func<IBlockQueryAdapter, TValue>>, DbType, Expression<Func<IExpressionMergeAdapter, IStructureFlag>>[]) SQL expression mapping Declaration TValue Expr<TValue>(string fieldName, Expression<Func<IBlockQueryAdapter, TValue>> expr, DbType dbType, params Expression<Func<IExpressionMergeAdapter, IStructureFlag>>[] attributes) Parameters Type Name Description String fieldName Expression field name Expression < Func < IBlockQueryAdapter , TValue>> expr Expression DbType dbType Expression database type Expression < Func < IExpressionMergeAdapter , IStructureFlag >>[] attributes Property mapping attributes Returns Type Description TValue Expression value Type Parameters Name Description TValue Expression result type Remarks WARNING! Can be used in dynamic query mapping only! | Improve this Doc View Source Expr<TValue>(String, DataExpressionType, String, DbType, Expression<Func<IExpressionMergeAdapter, IStructureFlag>>[]) SQL expression mapping Declaration TValue Expr<TValue>(string fieldName, DataExpressionType type, string exprText, DbType dbType, params Expression<Func<IExpressionMergeAdapter, IStructureFlag>>[] attributes) Parameters Type Name Description String fieldName Expression field name DataExpressionType type Expression source type String exprText Expression text DbType dbType Expression database type Expression < Func < IExpressionMergeAdapter , IStructureFlag >>[] attributes Property mapping attributes Returns Type Description TValue Expression value Type Parameters Name Description TValue Expression result type Remarks WARNING! Can be used in dynamic query mapping only! | Improve this Doc View Source Field<TValue>(Expression<Func<IPropertyMergeAdapter, IStructureFlag>>[]) Field mapping Declaration TValue Field<TValue>(params Expression<Func<IPropertyMergeAdapter, IStructureFlag>>[] attributes) Parameters Type Name Description Expression < Func < IPropertyMergeAdapter , IStructureFlag >>[] attributes Property mapping attributes Returns Type Description TValue Field value Type Parameters Name Description TValue Field type Remarks WARNING! Can be used in dynamic query mapping only! | Improve this Doc View Source Field<TValue>(String, String, Expression<Func<IPropertyMergeAdapter, IStructureFlag>>[]) Field mapping Declaration TValue Field<TValue>(string sourceAlias, string fieldName, params Expression<Func<IPropertyMergeAdapter, IStructureFlag>>[] attributes) Parameters Type Name Description String sourceAlias Source alias String fieldName Field name Expression < Func < IPropertyMergeAdapter , IStructureFlag >>[] attributes Property mapping attributes Returns Type Description TValue Field value Type Parameters Name Description TValue Field type Remarks WARNING! Can be used in dynamic query mapping only! | Improve this Doc View Source Ref<TValue>(String, String, Expression<Func<IPropertyMergeAdapter, IStructureFlag>>[]) Inner view property reference mapping Declaration TValue Ref<TValue>(string sourceAlias, string property, params Expression<Func<IPropertyMergeAdapter, IStructureFlag>>[] attributes) Parameters Type Name Description String sourceAlias Referenced property subquery alias String property Referenced property name Expression < Func < IPropertyMergeAdapter , IStructureFlag >>[] attributes Property mapping attributes Returns Type Description TValue Referenced property value Type Parameters Name Description TValue Referenced property type Remarks WARNING! Can be used in dynamic query mapping only! | Improve this Doc View Source Ref<TValue, TDobj>(String, Expression<Func<TDobj, Object>>, Expression<Func<IPropertyMergeAdapter, IStructureFlag>>[]) Inner view property reference mapping Declaration TValue Ref<TValue, TDobj>(string sourceAlias, Expression<Func<TDobj, object>> property, params Expression<Func<IPropertyMergeAdapter, IStructureFlag>>[] attributes) where TDobj : class Parameters Type Name Description String sourceAlias Referenced property subquery alias Expression < Func <TDobj, Object >> property Referenced property name Expression < Func < IPropertyMergeAdapter , IStructureFlag >>[] attributes Property mapping attributes Returns Type Description TValue Referenced property value Type Parameters Name Description TValue Referenced property type TDobj Referenced inner view type Remarks WARNING! Can be used in dynamic query mapping only! | Improve this Doc View Source Val<TValue>(Expression<Func<ISqlValueAdapter, ISqlValue<TValue>>>, Expression<Func<IMergeAttributeAdapter, IStructureFlag>>[]) SQL block variable/constant/parameter value mapping Declaration TValue Val<TValue>(Expression<Func<ISqlValueAdapter, ISqlValue<TValue>>> value, params Expression<Func<IMergeAttributeAdapter, IStructureFlag>>[] attributes) Parameters Type Name Description Expression < Func < ISqlValueAdapter , ISqlValue <TValue>>> value SQL block value mapping expression Expression < Func < IMergeAttributeAdapter , IStructureFlag >>[] attributes Merge roles structure flags Returns Type Description TValue Value Type Parameters Name Description TValue Value type Extension Methods SerializationExtensions.ToXml<T>(T) CollectionsExtensions.SetValue<TKey, T>(TKey, T) CollectionsExtensions.AsEnum<T>(T) DataObjectQueryableExtensions.CompareVariable(Object, FilterOperation, String) Processing.Do<T>(T, Action<IProcess<T>>[]) TypeExtensions.TryConvert<T, TResult>(T, Func<T, TResult>) TypeExtensions.TryConvert<T, TResult>(T, Func<T, TResult>, TResult) TypeExtensions.ChangeType<T>(Object) TypeExtensions.ChangeType(Object, Type) TypeExtensions.InvokeMethod<TRet>(Object, Type[], Expression<Func<TRet>>, BindingFlags) TypeExtensions.InvokeMethod(Object, Type[], Expression<Action>, BindingFlags) TypeExtensions.InvokeMethod<TRet>(Object, Expression<Func<TRet>>, BindingFlags) TypeExtensions.InvokeMethod(Object, Expression<Action>, BindingFlags) SqlBlockExtensions.Exists(IBlockQueryAdapter, String) SqlBlockExtensions.Case<T, TResult>(IBlockQueryAdapter, Expression<Func<IBlockQueryAdapter, T>>, Expression<Func<IBlockQueryAdapter, TResult>>, TaggedExpression<T, TResult>[]) SqlBlockExtensions.DateDiff<T>(IBlockQueryAdapter, Expression<Func<IBlockQueryAdapter, DateTime>>, Expression<Func<IBlockQueryAdapter, DateTime>>, DateDiffKind) SqlBlockExtensions.HasFlag<T>(IBlockQueryAdapter, Expression<Func<IBlockQueryAdapter, T>>, Expression<Func<IBlockQueryAdapter, T>>, Expression<Func<IBlockQueryAdapter, T>>, Expression<Func<IBlockQueryAdapter, T>>) SqlBlockExtensions.SetExpression<TTag, TResult>(TTag, Expression<Func<IBlockQueryAdapter, TResult>>) SqlBlockExtensions.SqlFn<TResult>(IBlockQueryAdapter, String, Expression<Func<IBlockQueryAdapter, Object>>[]) SqlBlockExtensions.SqlParam<TResult>(IBlockQueryAdapter, String, DbType, Expression<Func<IProcedureParameterAdapter, IProcedureParameterFlag>>[]) SqlBlockExtensions.SqlExpr<TResult>(IBlockQueryAdapter, String, Expression<Func<IBlockQueryAdapter, TResult>>[]) QueryDescriptionExtensions.SetExpression<TTag, TResult>(TTag, Expression<Func<IQueryStructureAdapter, TResult>>)"
  },
  "api/XData.AttachedHandler-1.html": {
    "href": "api/XData.AttachedHandler-1.html",
    "title": "Class AttachedHandler<T> | XData website",
    "keywords": "Class AttachedHandler<T> Data object level attached handler wrapper Inheritance Object AttachedHandler<T> RepositoryAttachedHandler<T> Inherited Members Object.Equals(Object) Object.Equals(Object, Object) Object.GetHashCode() Object.GetType() Object.MemberwiseClone() Object.ReferenceEquals(Object, Object) Object.ToString() Namespace : XData Assembly : XData.docfx.dll Syntax public class AttachedHandler<T> where T : class, IDataObject Type Parameters Name Description T Constructors | Improve this Doc View Source AttachedHandler(AttachedHandlerType, Object) DataObjectAttachedHandler constructor Declaration protected AttachedHandler(AttachedHandlerType type, object handler) Parameters Type Name Description AttachedHandlerType type Object handler Properties | Improve this Doc View Source Handler Attached handler Declaration protected object Handler { get; } Property Value Type Description Object | Improve this Doc View Source Type Attached handler type Declaration public AttachedHandlerType Type { get; protected set; } Property Value Type Description AttachedHandlerType Operators | Improve this Doc View Source Explicit(AttachedHandler<T> to GetLobAttachedHandler) Explicitly unwrap get Lob handler Declaration public static explicit operator GetLobAttachedHandler(AttachedHandler<T> handler) Parameters Type Name Description AttachedHandler <T> handler Wrapped handler Returns Type Description GetLobAttachedHandler Unwrapped attached handler | Improve this Doc View Source Explicit(AttachedHandler<T> to GetLobSizeAttachedHandler) Explicitly unwrap get Lob size handler Declaration public static explicit operator GetLobSizeAttachedHandler(AttachedHandler<T> handler) Parameters Type Name Description AttachedHandler <T> handler Wrapped handler Returns Type Description GetLobSizeAttachedHandler Unwrapped attached handler | Improve this Doc View Source Explicit(AttachedHandler<T> to GetXmlAttachedHandler) Explicitly unwrap get Xml handler Declaration public static explicit operator GetXmlAttachedHandler(AttachedHandler<T> handler) Parameters Type Name Description AttachedHandler <T> handler Wrapped handler Returns Type Description GetXmlAttachedHandler Unwrapped attached handler | Improve this Doc View Source Explicit(AttachedHandler<T> to LockAttachedHandler<T>) Explicitly unwrap lock object handler Declaration public static explicit operator LockAttachedHandler<T>(AttachedHandler<T> handler) Parameters Type Name Description AttachedHandler <T> handler Wrapped handler Returns Type Description LockAttachedHandler <T> Unwrapped attached handler | Improve this Doc View Source Explicit(AttachedHandler<T> to RefreshAttachedHandler<T>) Explicitly unwrap refresh object handler Declaration public static explicit operator RefreshAttachedHandler<T>(AttachedHandler<T> handler) Parameters Type Name Description AttachedHandler <T> handler Wrapped handler Returns Type Description RefreshAttachedHandler <T> Unwrapped attached handler | Improve this Doc View Source Explicit(AttachedHandler<T> to SetLobAttachedHandler) Explicitly unwrap set Lob handler Declaration public static explicit operator SetLobAttachedHandler(AttachedHandler<T> handler) Parameters Type Name Description AttachedHandler <T> handler Wrapped handler Returns Type Description SetLobAttachedHandler Unwrapped attached handler | Improve this Doc View Source Explicit(AttachedHandler<T> to SetXmlAttachedHandler) Explicitly unwrap set Xml handler Declaration public static explicit operator SetXmlAttachedHandler(AttachedHandler<T> handler) Parameters Type Name Description AttachedHandler <T> handler Wrapped handler Returns Type Description SetXmlAttachedHandler Unwrapped attached handler | Improve this Doc View Source Explicit(AttachedHandler<T> to SubmitObjectAttachedHandler<T>) Explicitly unwrap submit object handler Declaration public static explicit operator SubmitObjectAttachedHandler<T>(AttachedHandler<T> handler) Parameters Type Name Description AttachedHandler <T> handler Wrapped handler Returns Type Description SubmitObjectAttachedHandler <T> Unwrapped attached handler | Improve this Doc View Source Explicit(AttachedHandler<T> to SubmitQueryAttachedHandler<T>) Explicitly unwrap submit query handler Declaration public static explicit operator SubmitQueryAttachedHandler<T>(AttachedHandler<T> handler) Parameters Type Name Description AttachedHandler <T> handler Wrapped handler Returns Type Description SubmitQueryAttachedHandler <T> Unwrapped attached handler | Improve this Doc View Source Implicit(GetLobAttachedHandler to AttachedHandler<T>) Implicitly wrap get Lob handler Declaration public static implicit operator AttachedHandler<T>(GetLobAttachedHandler handler) Parameters Type Name Description GetLobAttachedHandler handler Get Lob handler Returns Type Description AttachedHandler <T> Data object attached handler | Improve this Doc View Source Implicit(GetLobSizeAttachedHandler to AttachedHandler<T>) Implicitly wrap get Lob size handler Declaration public static implicit operator AttachedHandler<T>(GetLobSizeAttachedHandler handler) Parameters Type Name Description GetLobSizeAttachedHandler handler Get Lob handler Returns Type Description AttachedHandler <T> Data object attached handler | Improve this Doc View Source Implicit(GetXmlAttachedHandler to AttachedHandler<T>) Implicitly wrap get Xml handler Declaration public static implicit operator AttachedHandler<T>(GetXmlAttachedHandler handler) Parameters Type Name Description GetXmlAttachedHandler handler Get Xml handler Returns Type Description AttachedHandler <T> Data object attached handler | Improve this Doc View Source Implicit(LockAttachedHandler<T> to AttachedHandler<T>) Implicitly wrap lock handler Declaration public static implicit operator AttachedHandler<T>(LockAttachedHandler<T> handler) Parameters Type Name Description LockAttachedHandler <T> handler Lock handler Returns Type Description AttachedHandler <T> Data object attached handler | Improve this Doc View Source Implicit(RefreshAttachedHandler<T> to AttachedHandler<T>) Implicitly wrap refresh object handler Declaration public static implicit operator AttachedHandler<T>(RefreshAttachedHandler<T> handler) Parameters Type Name Description RefreshAttachedHandler <T> handler Refresh handler Returns Type Description AttachedHandler <T> Data object attached handler | Improve this Doc View Source Implicit(SetLobAttachedHandler to AttachedHandler<T>) Implicitly wrap set Lob handler Declaration public static implicit operator AttachedHandler<T>(SetLobAttachedHandler handler) Parameters Type Name Description SetLobAttachedHandler handler Set Lob handler Returns Type Description AttachedHandler <T> Data object attached handler | Improve this Doc View Source Implicit(SetXmlAttachedHandler to AttachedHandler<T>) Implicitly wrap set Xml handler Declaration public static implicit operator AttachedHandler<T>(SetXmlAttachedHandler handler) Parameters Type Name Description SetXmlAttachedHandler handler Set Xml handler Returns Type Description AttachedHandler <T> Data object attached handler | Improve this Doc View Source Implicit(SubmitObjectAttachedHandler<T> to AttachedHandler<T>) Implicitly wrap submit object handler Declaration public static implicit operator AttachedHandler<T>(SubmitObjectAttachedHandler<T> handler) Parameters Type Name Description SubmitObjectAttachedHandler <T> handler Submit handler Returns Type Description AttachedHandler <T> Data object attached handler | Improve this Doc View Source Implicit(SubmitQueryAttachedHandler<T> to AttachedHandler<T>) Implicitly wrap submit query handler Declaration public static implicit operator AttachedHandler<T>(SubmitQueryAttachedHandler<T> handler) Parameters Type Name Description SubmitQueryAttachedHandler <T> handler Submit query handler Returns Type Description AttachedHandler <T> Data object attached handler Extension Methods SerializationExtensions.ToXml<T>(T) CollectionsExtensions.SetValue<TKey, T>(TKey, T) CollectionsExtensions.AsEnum<T>(T) DataObjectQueryableExtensions.CompareVariable(Object, FilterOperation, String) Processing.Do<T>(T, Action<IProcess<T>>[]) TypeExtensions.TryConvert<T, TResult>(T, Func<T, TResult>) TypeExtensions.TryConvert<T, TResult>(T, Func<T, TResult>, TResult) TypeExtensions.ChangeType<T>(Object) TypeExtensions.ChangeType(Object, Type) TypeExtensions.InvokeMethod<TRet>(Object, Type[], Expression<Func<TRet>>, BindingFlags) TypeExtensions.InvokeMethod(Object, Type[], Expression<Action>, BindingFlags) TypeExtensions.InvokeMethod<TRet>(Object, Expression<Func<TRet>>, BindingFlags) TypeExtensions.InvokeMethod(Object, Expression<Action>, BindingFlags) SqlBlockExtensions.SetExpression<TTag, TResult>(TTag, Expression<Func<IBlockQueryAdapter, TResult>>) QueryDescriptionExtensions.SetExpression<TTag, TResult>(TTag, Expression<Func<IQueryStructureAdapter, TResult>>)"
  },
  "api/XData.DataSource.Structure.IFilter.html": {
    "href": "api/XData.DataSource.Structure.IFilter.html",
    "title": "Interface IFilter | XData website",
    "keywords": "Interface IFilter Filter interface Inherited Members ICloneable.Clone() Namespace : XData.DataSource.Structure Assembly : XData.docfx.dll Syntax public interface IFilter : ICloneable Properties | Improve this Doc View Source Field Field name Declaration string Field { get; } Property Value Type Description String | Improve this Doc View Source FilterType Filter type Declaration FilterType FilterType { get; } Property Value Type Description FilterType | Improve this Doc View Source Operation Filter operation Declaration FilterOperation Operation { get; } Property Value Type Description FilterOperation | Improve this Doc View Source SourceAlias Source alias Declaration string SourceAlias { get; } Property Value Type Description String Extension Methods SerializationExtensions.ToXml<T>(T) CollectionsExtensions.SetValue<TKey, T>(TKey, T) CollectionsExtensions.AsEnum<T>(T) DataObjectQueryableExtensions.CompareVariable(Object, FilterOperation, String) Processing.Do<T>(T, Action<IProcess<T>>[]) TypeExtensions.TryConvert<T, TResult>(T, Func<T, TResult>) TypeExtensions.TryConvert<T, TResult>(T, Func<T, TResult>, TResult) TypeExtensions.ChangeType<T>(Object) TypeExtensions.ChangeType(Object, Type) TypeExtensions.InvokeMethod<TRet>(Object, Type[], Expression<Func<TRet>>, BindingFlags) TypeExtensions.InvokeMethod(Object, Type[], Expression<Action>, BindingFlags) TypeExtensions.InvokeMethod<TRet>(Object, Expression<Func<TRet>>, BindingFlags) TypeExtensions.InvokeMethod(Object, Expression<Action>, BindingFlags) SqlBlockExtensions.SetExpression<TTag, TResult>(TTag, Expression<Func<IBlockQueryAdapter, TResult>>) QueryDescriptionExtensions.SetExpression<TTag, TResult>(TTag, Expression<Func<IQueryStructureAdapter, TResult>>)"
  },
  "api/XData.DataSource.Structure.IField.html": {
    "href": "api/XData.DataSource.Structure.IField.html",
    "title": "Interface IField | XData website",
    "keywords": "Interface IField Field interface Inherited Members ICloneable.Clone() Namespace : XData.DataSource.Structure Assembly : XData.docfx.dll Syntax public interface IField : ICloneable Properties | Improve this Doc View Source DefaultFeature Default extended features Declaration DefaultFeature DefaultFeature { get; } Property Value Type Description DefaultFeature | Improve this Doc View Source DefaultType Default source Declaration DefaultType DefaultType { get; } Property Value Type Description DefaultType | Improve this Doc View Source DefaultValue Default value Declaration object DefaultValue { get; } Property Value Type Description Object | Improve this Doc View Source EnumValues Enumeration values Declaration KeyValuePair<long, string>[] EnumValues { get; set; } Property Value Type Description KeyValuePair < Int64 , String >[] | Improve this Doc View Source Exists Exists operation Declaration ExistsOperation Exists { get; } Property Value Type Description ExistsOperation | Improve this Doc View Source ExprScale Expression scale Declaration int ExprScale { get; } Property Value Type Description Int32 | Improve this Doc View Source ExprSize Expression size Declaration int ExprSize { get; } Property Value Type Description Int32 | Improve this Doc View Source ExprText Expression text Declaration string ExprText { get; } Property Value Type Description String | Improve this Doc View Source ExprType Expression type Declaration DataExpressionType ExprType { get; } Property Value Type Description DataExpressionType | Improve this Doc View Source FieldName Field name Declaration string FieldName { get; } Property Value Type Description String | Improve this Doc View Source Flags Flags Declaration DataPropertyFlag Flags { get; set; } Property Value Type Description DataPropertyFlag | Improve this Doc View Source IsAutoIncrement Auto increment field flag Declaration bool IsAutoIncrement { get; } Property Value Type Description Boolean | Improve this Doc View Source IsSelectable Selectable flag Declaration bool IsSelectable { get; set; } Property Value Type Description Boolean | Improve this Doc View Source IsTablePk Table primary key flag Declaration bool IsTablePk { get; } Property Value Type Description Boolean | Improve this Doc View Source Name Property name Declaration string Name { get; set; } Property Value Type Description String | Improve this Doc View Source NativeSqlType Native SQL type name Declaration string NativeSqlType { get; } Property Value Type Description String Remarks Used to specify native SQL column type when conflicted with default type mapping WARNING! May be not supported by database adapter! | Improve this Doc View Source SqlType SQL type Declaration DbType SqlType { get; } Property Value Type Description DbType | Improve this Doc View Source UpdateWithExprText Update source expression text Declaration string UpdateWithExprText { get; } Property Value Type Description String | Improve this Doc View Source UpdateWithExprType Update source expression type Declaration DataExpressionType UpdateWithExprType { get; } Property Value Type Description DataExpressionType | Improve this Doc View Source XPath XML property value XPath Declaration string XPath { get; set; } Property Value Type Description String Extension Methods SerializationExtensions.ToXml<T>(T) CollectionsExtensions.SetValue<TKey, T>(TKey, T) CollectionsExtensions.AsEnum<T>(T) DataObjectQueryableExtensions.CompareVariable(Object, FilterOperation, String) Processing.Do<T>(T, Action<IProcess<T>>[]) TypeExtensions.TryConvert<T, TResult>(T, Func<T, TResult>) TypeExtensions.TryConvert<T, TResult>(T, Func<T, TResult>, TResult) TypeExtensions.ChangeType<T>(Object) TypeExtensions.ChangeType(Object, Type) TypeExtensions.InvokeMethod<TRet>(Object, Type[], Expression<Func<TRet>>, BindingFlags) TypeExtensions.InvokeMethod(Object, Type[], Expression<Action>, BindingFlags) TypeExtensions.InvokeMethod<TRet>(Object, Expression<Func<TRet>>, BindingFlags) TypeExtensions.InvokeMethod(Object, Expression<Action>, BindingFlags) SqlBlockExtensions.SetExpression<TTag, TResult>(TTag, Expression<Func<IBlockQueryAdapter, TResult>>) QueryDescriptionExtensions.SetExpression<TTag, TResult>(TTag, Expression<Func<IQueryStructureAdapter, TResult>>)"
  }
}