## Общие правила описания объектного преобразования (mapping)
Все объекты данных должны быть помечены реализацией интерфейса-маркера (пустого интерфейса) *IDataObject*. Все объекты описывающие подчиненные запросы должны быть помечены реализацией интерфейса-маркера (пустого интерфейса) *ISqlObject*.

> Возможность описания преобразования для интерфейсов-маркеров позволяет не диктовать иерархию наследования объектов предметной области и одновременно (с помощью методов расширений (extension methods)) дать возможность удобной работы с этими объектами.

Правила объектного переобразования могут быть описаны статически с помощью аттрибутов классов в которые производится преобразование (см. [Статическое преобразование (static mapping)](./static.md)), или динамически с помощью описания преобразования в стиле LINQ выражения (см. [Динамическое преобразование (dynamic mapping)](./dynamic.md)).

###Свойства обычных типов
Свойства стандартных типов (string, bool, int...) в том числе поддерживающие пустое значение (int?, bool?), а так же свойства перечислимых типов (enum) оформляются как обычные свойства. Доступ к ним так же не отличается от типового. В зависисмости от 
[статического](./static.md#Описание-преобразования-свойств) и [динамического](./dynamic.md#Описание-преобразования-свойств) способа описания объектного преобразования разнится лишь способ описания их привязки к объектам БД.

###Свойства типа - бинарный объект
Для работы с большим бинарным объектом (BLOB) с использованием отложенного (lazy) связывания в XData предлагается использовать тип свойства *Lob*. Для этого типа определены следующие 

свойства:
* byte[] *Value* - с помощью этого свойства можно получить и/или обновить значение бинарного объекта
* (readonly) bool *Assigned* - проверяет значение бинарного объекта на значение NULL

методы:
* *GetSize*() - возвращает размер бинарного объекта
* (extension) Modify(Action<byte[]> action) - хелпер для удобства изменения значения бинарного объекта

операции: 
* += - "синтаксический сахар", _data.SomeBlob += _someVariable идентично _data.SomeBlob.Value = _someVariable.
	
Например:
```csharp
newInvoice.Scan += _image;
...
if(newInvoice.Scan.Assigned) 
	_size = newInvoice.Scan.GetSize();
...
invoice.Scan.Modify(x => x = new byte[0]);
```
###Свойства типа - Xml
Для работы с Xml с использованием отложенного (lazy) связывания в XData предлагается использовать тип свойства *Xml*. Для этого типа определены следующие 

свойства:
* XDocument *Document* - с помощью этого свойства можно получить и/или обновить значение XML
* (readonly) bool *Assigned* - проверяет значение XML на значение NULL

методы:
* *Extract*(string path, params KeyValuePair<string, string>[] namespaces) - возвращает результат XPath выражения *path* с использованием пространств имен *namespaces* (пара: псевдоним пространства имен - URL), в случае если БД поддерживает операции с XML выполнение XPath выражения производится на стороне БД.
* (extension) *Modify*(Action<XDocument> action) - хелпер для удобства изменения значения XML

операции: 
* += - "синтаксический сахар", _data.SomeXml += _someVariable идентично _data.SomeXml.Document = _someVariable.
	
Например:
```csharp
newInvoice.Source += new XDocument(new XElement("invoice", 
	new XAttribute("number", number), new XAttribute("state", newInvoice.DocStateCode)));
...
XDataManager.GetRepository<Invoice>(Owner, context: Context)
	.First(x => x.Source.Extract("(/invoice/@state)[1]") == "ACTIVE").DocNumb
...
invoice.Source.Modify(x => x = new XDocument());
```
###Свойства - ссылки на другие объекты
Для обеспечения возможности работы с внешними ссылками на объекты вне текущего бизнес объекта без оперирования сурогатными ключами (первичными (PK) и внешними (FK)), в XData предлагается использовать тип свойства *Link<TVal,TSrc>*, где *TVal* - тип свойства для просмотра, *TSrc* - тип ссылки на объект. Для этого типа определены следующие

свойства:
* TVal *Value* - с помощью этого свойства можно получить значение для просмотра ссылки
* TSrc *Source* - с помощью этого свойства можно установить текущее значение ссылки
* (readonly) bool *Assigned* - проверяет значение XML на значение NULL

операции: 
* += - "синтаксический сахар", _data.Source += _someDictionaryValue идентично _data.SomeXml.Source = _someDictionaryValue.
	
```csharp
newInvoice.DocState += XDataManager.GetDictionaryValue<DocState>(x => x.Code == "CREATED");
```
Для корректной работы свойств - ссылок необходимо определить на уровне описания отражения свойства, значения которых будут копироваться из объекта источника в свойства текущего объекта. Это описание различно для [статического](./static.md#Описание-ссылок) и [динамического](./dynamic.md#Описание-ссылок) способа описания объектного преобразования.

###Свойства только для чтения
Свойства только для чтения в XData предлагается оформлять как:
```csharp
public string DocStateCode { get { return this.GetProperty(x => x.DocStateCode); } }
```
В результате доступ к значению свойства будет обычным, значение свойства будет получено с помощью метода расширения *GetProperty*, а изменить его будет невозможно.

###Свойства для работы с подчиненными сущностями
Свойства для работы с наборами подчиненных объектов в XData предлагается оформлять как:
```csharp
public IRepository<InvoiceSpec> Spec { get { return this.GetRepository().GetChild<InvoiceSpec>(); } }
```
При этом дополнительное описание преобразования (кроме описания внешних связей) не требуется. Описание [внешних связей](#Внешние-связи) объекта описывается различно для [статического](./static.md#Внешние-связи) и [динамического](./dynamic.md#Внешние-связи) методов описания преобразования. Свойства для работы с подчиненными сущностями являются необходимым условием использования реализации шаблона Unit Of Work в XData (см. [Частные случаи и советы - Обработка взаимосвязанных объектов](./tips_and_triks.md#Обработка-взаимосвязанных-объектов)).

###Скрытые свойства
Возможна ситуация, когда необходимо описать свойство для целостности описания преобразования в целом, но в итоговом бизнес - объекте это свойство не нужно (бизнес логика им не оперирует даже в плане чтения данных). 

Например, XData может полностью брать на себя работу с первичными (PK) и внешними (FK) ключами оперируемых объектов и работу связки master-slave, но для описания [внешних связей](#Внешние-связи) необходимо связать объекты именно по значению ключа. 

Второй пример - для организации оптимистичной блокировки (см. [Организация совместного доступа к данным](./locking.md)) необходим токен конкунеции (concurrency token) - поле которое будет проверяться и обновляться при каждом обновлении данных. Детали этого процесса описаны в соответствующем разделе, а здесь необходимо лишь отметить, что со стороны бизнес логики это поле избыточно и лучше бы его скрыть. 

Третьий пример - при описании подчиненного объекта на основании группировки данных (group by) часто нужно описать свойство для связи с внешним объектом не входящее в группировку, в этом случае поле должно быть не только скрытым, но и не входящим в конструкцию SELECT итогового запроса.

Описание скрытых свойств различно для [статического](./static.md#Скрытые-свойства) и [динамического](./dynamic.md#Скрытые-свойства) методов описания преобразования.

###Внешние связи
Внешние связи являются основой поддержки XData механизма master-slave. С их помощью описываются правила связи зависимых сущностей от главных (XData поддерживает возможность использования нескольких главных (master) сущностей как и нескольких зависимых (slave), то есть можно строить отношения между главными и зависимыми сущностями как многие-ко-многим (many-to-many)). При этом существует возможность определить несколько связей между каждой парой объектов в отношении master-slave. 

Каждая связь описывается как - значение "этого" свойства (возможно [скрытого](#Скрытые-свойства)) нужно использовать в качестве значения "этого" ограничения (или в более часто употребимом случае в качестве значения [ограничения времени исполнения](./runtime_filters.md) построенного на основании "этого" свойства) зависимого объекта.

Описание внешних связей различно для [статического](./static.md#Внешние-связи) и [динамического](./dynamic.md#Внешние-связи) методов описания преобразования.

Для работы внешних связей объектов необходимо установить текущий объект в главном объекте (или в нескольких из них в зависимости от бизнес логики) с помощью метода расширения интерфейса *IDataObject* *SetCurrent*.
```csharp
if (newInvoice.Submit())
{
	newInvoice.SetCurrent();
	return true;
}
```

###Поддержка псевдонимов источников данных
В XData есть возможность использования псевдонимов (common table expression) источников данных (SQL конструкция WITH) в случае если используемая БД поддерживает такую конструкцию. Поддерживаются как псевдонимы плоских представлений, так и псевдонимы иерархических источников данных (WITH RECURSIVE). 

Само описание таких представлений различно для [статического](./static.md#Поддержка-псевдонимов-источников-данных) и [динамического](./dynamic.md#Поддержка-псевдонимов-источников-данных) методов описания преобразования, но общим является метод использования одного или нескольких источников данных на основе однажды описанного псевдонима: описывается таблица (или несколько таблиц с разными псевдонимами) с именем описанного псевдонима (CTE) и к ним уже применяются необходимые ограничения и описываются отражаемые из них свойства.

Псевдоним иерархического источника данных может являться также и самостоятельным источником данных для отражения бизнес объекта, в этом случае его имя указывается в качестве [базовой таблицы](./glossary.md#Базовая-таблица) при описании объектного преобразования.

###Поддержка таблиц иерархии
В случае если выбранная БД не поддерживает использование псевдонимов (common table expression) источников данных (SQL конструкция WITH) для облегчения запросов к иерархии обычно используются служебные таблицы описывающие иерархические отношения внутри узлов поддеревьев. Таблица иерархии состоит из двух полей (условно parent_id и child_id) и содержит записи о идентификаторах всех узлов поддерева родительского узла. Причем в зависимости от задачи таких таблиц иерархии может быть белее одной (например при наличии нескольких циклических ссылок в основной таблице).

>Таблица иерархии может быть использована только в случае описаний циклических ссылок внутри таблицы с простым (состоящим из одного поля) первичным ключем, но это наиболее частый случай и к тому же этот механизм рекомендуется испорльзовать только в качестве частной замены псевдонимов (common table expression) в том случае когда их невозможно использовать по причине отсутсвия их поддержки со стороны выбранной СУБД.

XData предлагает возможность автоматически вести одну или несколько таблиц иерархии при условии соблюдения условия простого первичного ключа и корректного оформлении ее в [статическом](./static.md#Поддержка-таблиц-иерархии) или [динамическом](./dynamic.md#Поддержка-таблиц-иерархии) описании объектного преобразовании.

При этом можно опираться на запросы по этим служебным таблицам иерархий при описании преобразования того же или других объектов.

###Использование хранимых процедур и функций SQL
В качестве источников данных для объектного преобразования в XData могут использоваться хранимые процедуры и функции SQL (если их использование и контекст этого использования поддерживается выбранной СУБД и выбранным ADO .Net провайдером). 

>ВАЖНОЕ ЗАМЕЧАНИЕ: В настоящий момент существуют различные (и временами очень серьезные) ограничения использования SQL процедур как на уровне СУБД, так и на уровне ADO .Net провайдеров, и прежде чем выбрать СУБД и конкретный провайдер к ней (а тем более заплатить за них деньги) необходимо удостовериться, что они в комбинации поддерживают все варианты использования, которые необходимы в Вашем проекте! Функциональность заявленная на уровне XData, к сожалению не может гарантировать то, что это поддерживают выбранные Вами СУБД и ADO .Net провайдер.

В XData есть следующие возможности описания правил объектного преобразования с использованием хранимых процедур и функций SQL:
* Использование в качестве источника данных набора записей возвращаемый хранимой процедурой
* Использование хранимых процедур возвращающих несколько наборов данных
* Использование возвращаемого (out) параметра хранимой процедуры
* Тоже самое совместно с возвращением набора записей
* Использование возвращаемого значения (return value) хранимой процедуры 
* Тоже самое совместно с возвращением набора записей
* Использование в качестве параметра хранимой процедуры набора записей 
* Тоже самое для UDT (пользовательский тип данных SQL)
* Использование в качестве источника данных скалярной функции (возможно с табличным или UDT параметром)
* Использование в качестве источника данных табличной функции (возможно с табличным или UDT параметром)
* Использование скалярной функции в качестве источника данных свойства
* Тоже самое с использованием LINQ выражения в качестве описания SQL выражения - источника
 
Описание всех перечисленных возможностей в парадигме [статического](./static.md#Описание-объектного-преобразования-хранимых-процедур-и-функций-sql) и [динамического](./dynamic.md#Описание-объектного-преобразования-хранимых-процедур-и-функций-sql) описания прадставлены в соответствующих разделах.

>Есть некоторая специфика работы c пользовательскими типами данных (UDT) совместно с ORACLE ODP провайдером в трех-звенной модели которая описана в разделе [Частные случаи и советы - Особенности использования пользовательских типов данных совместно с ODP](./tips_and_triks.md#Особенности-использования-пользовательских-типов-данных-совместно-с-odp). Просьба внимательно ознакомиться и принять к сведению.
