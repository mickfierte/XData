>Извините. Статья еще находится в стадии разработки, но мы уже работаем над ней...

##Использование 3-х уровневой архитектуры
Одной из отличительных свойств XData является возможность работы систем с ее использованием как в 2-х уровневой архитектуре (клиент - сервер базы данных), так и в 3-х уровневой архитектуре (клиент - сервер приложений - сервер базы данных). При этом существует уникальная возможность **переключения** системы реализованной в парадигме **3-х уровневой архитектуры в 2-х уровневую** на уровне **файлов конфигурации**!!! Эта особенность позволяет производить отладку сложных многоуровневых приложений с полным стеком вызовов и прочим комфортом... Кто производил отладку кода на сервере приложений, тот понимает о чем речь...

Для выделения части логики системы с использованием XData на уровень сервера приложений необходимо: 
* выделить отраженные классы используемые клиентской стороной в отдельную сборку (сборку модели) или несколько сборок если это оправдано логикой приложения
* выделить серверную логику в отдельную сборку (серверную сборку)или в несколько сборок если это оправдано логикой приложения
* на уровне серверной сборки по мере необходимоти создать классы реализующие интерфейс - маркер (пустой интерфейс) IDataLogic<T>, где T - отраженнный класс который использует серверную логику (в том числе [триггерную логику](./tips_and_triks.md#Использование-триггерной-логики)) и оформить вызовы серверной логики из обработчиков пользовательской логики
```csharp
```

* указать имя соответсвующей серверной сборки в описании объектного преобразования в сборке модели 
```csharp
```

* зарегистрировать обработчики пользовательской логики в соответсвуюших классах сборки модели
```csharp
```

* организовать вызовы [пользовательской логики](./tips_and_triks.md#Использование-пользовательской-логики) из клиентского кода
```csharp
```

>Обратите внимание, что обработчики пользовательской логики позволяют организовать как синхронные так и асинхронные [обратные вызовы](./tips_and_triks.md#Обратный-вызов-из-пользовательской-логики) и анализ результатов синхронных обратных вызовов. Такая функциональность позволяет реализовать с помощью обработчиков пользовательской логики и триггерной логики очень сложные (и в том числе интерактивные) сценарии реализации бизнес процессов. При этом важно отметить, что серверная логика становится прозрачной за счет цельного описания бизнес процесса в едином обработчике пользовательской логики.
