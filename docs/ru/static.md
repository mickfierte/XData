>Извините. Статья еще находится в стадии разработки, но мы уже работаем над ней...

###Статическое описание преобразования
Статическое преобразование (static mapping) описывается атрибутами объекта данных, его свойств и статических полей.

Ниже приведен пример статического описания преобразования (mapping) объекта данных. Понятно, что в реальности врядли будет необходимость в настолько сложном объекте и соответственно настолько сложном преобразовании, но в качестве примера возможностей XData достаточно показательно...
```csharp
	[DataObject("D", LogicAssemblyName = "XDataObjectTest"),
	 	DataTable("T_DOC", "D"),
	 	DictionaryFilter("T_DOC_TYPE", "doc_type_id", "code", "INVOICE", "D"),
		DataTable("T_DOC_DOC_STATE", "DS", Parent = "D"),
		Link("D", "doc_id", "DS"),
		DataTable("T_DOC_STATE", "S"),
		Link("DS", "doc_state_id", "S"),
		DataTable("T_DOC_NUMBER", "N", Parent = "D"),
		Link("D", "doc_id", "N"),
		DataTable("T_DOC_CUST", "CF", Parent = "D"),
		Link("D", "doc_id", "CF"),
		DataTable("T_CUSTOMER", "F"),
		Link("CF", "customer_id", "F"),
		DictionaryFilter("T_DOC_CUST_TYPE", "doc_cust_type_id", "code", "FROM", "CF"),
		DataTable("T_DOC_CUST", "CT", Parent = "D"),
		Link("D", "doc_id", "CT"),
		DataTable("T_CUSTOMER", "T"),
		Link("CT", "customer_id", "T"),
		DictionaryFilter("T_DOC_CUST_TYPE", "doc_cust_type_id", "code", "TO", "CT"),
		DataTable("T_DOC_SCAN", "SC", Parent = "D"),
		Link("D", "doc_id", "SC",  Operation = FilterOperation.OuterJoin),
        DataTable("T_DOC_SOURCE", "SR", Parent = "D"),
        Link("D", "doc_id", "SR", Operation = FilterOperation.OuterJoin),
        DataTable("T_DOC_DELIVERY", "DD", Parent = "D"),
        Link("D", "doc_id", "DD", Operation = FilterOperation.OuterJoin),
		DataTable("T_DOC_CATALOGUE", "DC", Parent = "D"),
		Link("D", "doc_id", "DC"),
		DataTable("T_CATALOGUE", "U"),
		Link("U", "catalogue_id", "DC"),
        Subquery("A", typeof(DocSpecAmounts), "Amount", Grouping = DataGrouping.Sum),
		SubqueryLink("A", "DocId"),
		InnerView("H", typeof(DocLastChange)),
        SubqueryLink("H", "DocId", Operation = FilterOperation.OuterJoin),
		ExternalLink(typeof(InvoiceSpec), "DocId"),
		InnerView("ST", typeof(DocBySpecType)),
		SubqueryLink("ST", "DocId"),
        Subquery("UT", typeof(CatalogueTree), "CatalogueId"),
        SubqueryFilter("UT", "DC", "catalogue_id", Operation = FilterOperation.In),
        Column("DocId", typeof(long?), "D", Flags = DataPropertyFlag.Id),
		ColumnDefault("DocId", DefaultType.AutoIncrement)]
    public class Invoice: IDataObject
	{
        public static CustomLogic<Invoice> TestCustomLogic;

        [Property("S", "code")]
        public string DocStateCode { get { return this.GetProperty(x => x.DocStateCode); } }
        [Property("S", "name"),
            LinkProperty("Name"),
            LinkProperty("Code", "DocStateCode")]
        public Link<string, DocState> DocState { get; set; }
        [Property("U", "name"),
            LinkProperty("Name")]
        public Link<string, Catalogue> DocCatalog { get; set; }
        [Property("N", "numb")]
        public string DocNumb { get; set; }
        [Property("D"),
            PropertyDefault(DefaultType.CurrentDate)]
        public DateTime? DocDate { get; set; }
        [Property("D", Flags = DataPropertyFlag.ConcurrencyToken),
            PropertyDefault(DefaultType.AutoIncrement)]
        public long Generation { get { return this.GetProperty(x => x.Generation); } }
        [Property("D"),
            PropertyDefault(DefaultType.CurrentDateTime, AlwaysUseDefault = true)]
        public DateTime Changed { get { return this.GetProperty(x => x.Changed); } }
        [Property("D"),
            PropertyDefault(DefaultType.UserName, AlwaysUseDefault = true)]
        public string Author { get { return this.GetProperty(x => x.Author); } }
        [Property,
            PropertyExpression("A", DataExpressionType.SubQuery, DbType.Decimal, ExprSize = 17, ExprScale = 5)]
        public decimal? DocAmount { get { return this.GetProperty(x => x.DocAmount); } }
        [Reference("H", "HistoryDate")]
        public DateTime? DocLastChange { get { return this.GetProperty(x => x.DocLastChange); } }
        [Property("SC", Flags = DataPropertyFlag.OuterFlag)]
        public Lob Scan { get; set; }
        [Property("SR", Flags = DataPropertyFlag.OuterFlag)]
        public Xml Source { get; set; }
        [Property("F", "name"),
            LinkProperty("Name")]
        public Link<string, Customer> CustomerFrom { get; set; }
        [Property("T", "name"),
            LinkProperty("Name")]
        public Link<string, Customer> CustomerTo { get; set; }
        [Property("DD")]
        public DeliveryTypeEnum DeliveryType { get; set; }
        [Property("DD"),
            PropertyDefault(DefaultType.CurrentDate)]
        public DateTime? DeliveryDate { get; set; }

	    public IRepository<InvoiceSpec> Spec { get { return this.GetRepository().GetChild<InvoiceSpec>(); } }
	}
```
####Описание параметров объектного отражения
Для всех статично отраженных классов должен быть назначен атрибут *DataObjectAttribute*, параметры которого, могут определять: *BaseTable* - псевдоним (alias) [базовой таблицы](./glossary.md#Базовая-таблица) (опционально, по умолчанию будет использоваться [виртуальная таблица](./glossary.md#Виртуальная-таблица) с пустым псевдонимом), *Context* - [контекст](./glossary.md#Контекст) базы данных (опционально, по умолчанию отображение может быть выполнено для любого контекста) и *Flags* - набор флагов источника данных (опционально, по умолчанию **None**).

Например:
```csharp
[DataObject("D" /* псевдоним (alias) базовой таблицы */, 
	Context: "Main" /* имя контекста источника данных */, 
	Flags: DataObjectFlags.ReadOnly /* флаги источника данных */)]
```
Все таблицы участвующие в запросе [источника данных](./glossary.md#Источник-данных) перечисляются с помощью атрибута отражаемого класса *DataTableAttribute* и у них обязательно должны быть заполнены свойства *Name* (имя таблицы) и *Alias* (псевдоним таблицы в результирующем запросе). Те из них, которые участвуют в [иерархии обновляемых таблиц](./glossary.md#Иерархия-обновляемых-таблиц) (кроме базовой таблицы) должны содержать значение параметра этого атрибута *Parent* (псевдоним (alias) таблицы, на которую ссылается текущая таблица в иерархии обновляемых таблиц).
```csharp
[DataTable("P" /* псевдоним (alias) таблицы */, 
	"patient" /* имя таблицы */, 
	"D" /* псевдоним (alias) родительской таблицы в иерархии обновления */)]
```
Кроме таблиц подобным образом могут описываться представления (view), однако все используемые поля представления должны быть описаны явно в виде свойств только для чтения (см. [Свойства только для чтения](#Свойства-только-для-чтения)) или скрытых полей (см. [Скрытые поля](#Скрытые-поля)).

####Описание преобразования с использованием подзапросов
Есть возможность использовать в объектном преобразовании подзапросы. Такая возможность есть как для отражения SQL выражений представляющих собой подзапрос на свойства объектов данных (см. ниже), для описания ограничений использующих подзапросы (см. [Ограничения на основе SQL выражений](#Ограничения-на-основе-SQL-выражений)), так и в качестве описаний внутренних подзапросов (inner view).

Глубина вложенности подзапросов не регламентируется.

В описании объектного преобразования основного класса (класса который использует этот подзапрос) должен присутствовать атрибут *SubqueryAttribute* или *InnerViewAttribute* (для использования в качестве внутреннего подзапроса (inner view)). Оба этих атрибута имеют параметры *Alias* (псевдоним подзапроса в результирующем запросе). Кроме того *InnerViewAttribute* имеет параметр *InnerViewType* (тип, описывающий объектное преобразование (mapping) подзапроса), а *SubqueryAttribute* - параметры: *SubqueryType* (тип, описывающий объектное преобразование (mapping) подзапроса), *PropertyName* (результирующее свойство подзапроса) и *Grouping* (тип агрегации для результирующего свойства подзапроса).
```csharp
[Subquery("A" /* псевдоним (alias) подзапроса */, 
	typeof(DocSpecAmounts) /* тип отражения подзапроса */, 
	"Amount" /* результирующее поле подзапроса */, 
	Grouping = DataGrouping.Sum /* агрегатная функция результирующего поля подзапроса */)]

[InnerView("H" /* псевдоним (alias) внутреннего представления (inner view) */, 
	typeof(DocLastChange) /* тип отражения внутреннего представления (inner view) */)]
```
####Ограничения
Ограничения внутри основного запроса объекта данных могут быть описаны как:
* Константные ограничения
* Ограничения на основе SQL выражений
* Ограничения на основе кодов справочников
* Ограничения на основе списка значений
* Ограничения по подзапросу
* Связи внутри объекта данных

Каждый из них описывается соответствующим атрибутом класса объекта данных (см. ниже). Для всех из них должны быть определены следующие параметры: *Source* - псевдоним (alias) источника данных к полю которого применяется ограничение, *FieldName* - имя поля, *Operation* - операция фильтра (опционально, по умолчанию *FilterOperation*.**Equal**), *Combination* - имя группы фильтров, к которой относится данный фильтр (опционально, по умолчанию группа фильтров по умолчанию). Кроме этого каждое ограничение имеет свои специфичные параметры описанные в соответствующих разделах ниже.

Список операций представлен перечислением *FilterOperation*:
* **Equal** - равно
* **NotEqual** - не равно
* **LessThan** - меньше чем
* **GreaterThan** - больше чем
* **LessThanOrEqual** - меньше или равно
* **GreaterThanOrEqual** - больше или равно
* **In** - значение входит в список (или подзапрос)
* **NotIn** - значение не входит в список (или подзапрос)
* **Exists** - подзапрос возвращает одну или более строк
* **NotExists** - подзапрос не возвращает ни одной строки
* **Like** - найдено соответствие при поиске по подстроке
* **NotLike** - не найдено соответствий при поиске по подстроке
* **OuterJoin** - необязательная связь между источниками запроса (таблицами и внутренними предствлениями (inner view))
* **Contains** - найдено соответствие при полнотекстовом поиске
* **NotContains** - не найдено соответствие при полнотекстовом поиске

#####Группы фильтров
[Группы фильтров](./glossary.md#Группа-фильтров) могут быть описаны с помощью атрибута *FilterCombinationAttribute* с параметрами: *Name* - уникальное имя группы фильтров, *Combination* - логическая операция объединения фильтров (и подчиненных групп фильтров) внутри описываемой группы фильтров (опционально, по умолчанию *FilterCombination*.**And**), *Parent* - имя родительской группы фильтров (опционально, для групп фильтров подчиненных группе фильтров по умолчанию может быть не указан).

Логическая операция связующая фильтры внутри группы фильтров описывается перечислением *FilterCombination*:
* **AND** - И
* **OR** - ИЛИ
```csharp
[FilterCombination("OrGroup" /* имя группы фильтров */, 
	Combination: FilterCombination.OR /* логическая операция */)]
```

#####Константные ограничения
Ограничения с константным значением позволяют ограничить выборку объекта данных по значению некоторой константы. Использование такого фильтра описывается атрибутом *ConstantFilterAttribute*, со специфичными (относительно параметров описанных в пункте [Ограничения](#Ограничения)) параметрами: *Name* - имя фильтра (будет преобразовано в имя параметра запроса без учета префиксов согласно конкретного диалекта SQL), *ConstantType* - тип константы (см. ниже) и *ConstantValue* - значение константы (опционально в зависимости от *ConstantType*).

Список типов константы задается перечислением *FilterConstantType*:
* **Const** - указанное в поле *ConstantValue* значение.
* **Variable** - значение переменной (см. [Переменные](./tips_and_triks.md/#Переменные)) с именем, указанным в поле *ConstantValue*.
* **CurrentDate** - сегодняшняя дата.
* **CurrentDateTime** - текущие дата и время.
* **CurrentDateTimeUTC** - текущие дата и время (UTC).
```csharp
[ConstantFilter("FilterByZero" /* имя фильтра */, 
	"P" /* псевдоним (alias) таблицы */, 
	"discount" /* имя поля БД */, 
	"0" /* значение константы */, 
	Operation: FilterOperation.Equal /* операция фильтра */, 
	ConstantType: FilterConstantType.Const /* тип константы */)]
```

#####Ограничения на основе SQL выражений
Для описания ограничений на основе SQL выражений используется атрибут *ExpressionFilterAttribute* со специфичными (относительно параметров описанных в пункте [Ограничения](#Ограничения)) параметрами: *ExpressionText* - в зависимости от типа описания SQL выражения может быть: 
- псевдонимом подчиненного запроса,
```csharp
[ExpressionFilter("P" /* псевдоним (alias) таблицы */, 
	"discount" /* имя поля */, 
	"D" /* ExpressionText: псевдоним (alias) подзапроса */, 
	Operation: FilterOperation.In /* операция фильтра */)]
```
- именем статического поля с динамическим описанием SQL выражения,
```csharp
[ExpressionFilter("P" /* псевдоним (alias) таблицы */, 
	"discount" /* имя поля */, 
	"AllowedDiscount" /* ExpressionText: имя статичного поля - описания выражения */, 
	Operation: FilterOperation.NotEqual /* операция фильтра */)]
…
//Статическое поле отражаемого объекта 
private static Calculate<int> AllowedDiscount = x => x.Case<Product, int>( 
	z => z.Field<bool>("is_vip"), z => 0, 1.SetValue(10));
```
- текстом SQL выражения.
```csharp
[ExpressionFilter("P" /* псевдоним (alias) таблицы */, 
	"discount" /* имя поля */, 
	"case P.is_vip when 1 then 10 else 0 end" /* ExpressionText: текст SQL выражения */, 
	Operation: FilterOperation.NotEqual /* операция фильтра */)]
```
> При возможности описать SQL выражение в виде динамического описания или
> подзапроса, не рекомендуется использовать непосредственно текст SQL выражения 
> в связи с тем, что оно будет специфично для конкретного диалекта SQL.

#####Ограничения на основе списка значений
Для описания ограничения проверки значения на вхождение в некоторый статичный список используется атрибут *RangeFilterAttribute* со специфичным (относительно параметров описанных в "Ограничения") параметром: Range - массив значений списка.
```csharp
[RangeFilter("P" /* псевдоним (alias) таблицы */, 
	"discount" /* имя поля */, 
	new[] {0,5,10} /* список значений */, 
	Operation: FilterOperation.In /* операция фильтра */)]
```

#####Ограничения на основе кодов справочников
Суррогатные ключи справочников могут отличаться в различных инсталляциях, а названия обычно могут быть исправлены пользователями. Однако часто в бизнес логике необходимо оперировать конкретными значениями справочников. По этой причине рекомендуется при проектировании структуры базы данных снабжать справочники специальными уникальными текстовыми полями - мнемокодами.

Подсистема XData поддерживает использование мнемокодов при описании ограничений на основе значений справочников. Для этого используется атрибут *DictionaryFilterAttribute* со специфичными (относительно параметров описанных в пункте [Ограничения](#Ограничения)) параметрами: *DictionaryTable* - имя справочной таблицы, *DictionaryId* - имя поля идентификатора справочной таблицы, *DictionaryCode* - имя поля мнемокода справочной таблицы, *DictionaryValue* - значение мнемокода по которому производится фильтрация, *ValueIsVariable* - признак того, что вместо конкретного значения в параметр *DictionaryValue* будет записано имя переменной (см.  [Переменные](./tips_and_triks.md/#Переменные)) с нужным значением.

В случае совпадения имени идентификатора справочника и поля, по которому производится фильтрация параметр *FieldName* можно не задавать. Конструкцию есть возможность применять только для справочников с простым суррогатным ключом (из одного поля) и имеющих поле мнемокода.
```csharp
[DictionaryFilter("t_doc_state" /* имя справочной таблицы */, 
	"doc_state_id" /* имя поля идентификатора справочника */, 
	"code" /* имя поля мнемокода */, 
	"CREATED" /* значение мнемокода */, 
	"D" /* псевдоним (alias) таблицы */)]
```
#####Связи внутри объекта данных
Для описания связей внутри запроса объекта данных используется атрибут *LinkAttribute* со специфичными параметрами: *LinkedSourceAlias* - псевдоним (alias) связанной таблицы, *LinkedFieldName* - имя поля в связанной таблице (опционально, может быть не указан при совпадении с *FieldName*). Связи внутри объекта данных могут быть использованы в описании опциональных ограничений (см. [Опциональные фильтры и опциональные подчиненные запросы](./tips_and_triks.md#Опциональные-фильтры-и-опциональные-подчиненные-запросы)). Для указания того, что связь используется в определении необязательной части запроса может быть указан опциональный флаг первичного фильтра *PrimaryFilter*.
```csharp
[Link("D" /* псевдоним (alias) таблицы */, 
	"doc_id" /* имя поля БД */, 
	"DD" /* псевдоним (alias) связанной таблицы */)]
```

#####Ограничения по подзапросу
Для описания ограничений по подзапросу используется атрибут *SubqueryFilterAttribute* со специфичным (относительно параметров описанных в пункте [Ограничения](#Ограничения)) параметром: *Subquery* - псевдоним (alias) подзапроса (см. "Описание объектного преобразования с использованием подзапросов "). При этом в качестве подзапроса для ограничения не может выступать внутреннее представление (inner view).
```csharp
[SubqueryFilter("D" /* псевдоним (alias) таблицы */, 
	"doc_state_id" /* имя поля */, 
	"A" /* псевдоним (alias) подзапроса */, 
	Operation: FilterOperation.In /* операция фильтра */)]
```
При указании значения флага *PrimaryFilter* логика вычисления границ опциональной части запроса работает следующим образом: если один из связываемых источников данных (таблица или представление (view)) будет "отброшен", то и источник данных связанный с ним будет отброшен. В случае если отбрасывается [базовая таблица](./glossary.md#Базовая-таблица) подзапроса - он будет "отброшен" полностью.

#####Связи с подзапросами
Связи с объектами данных - подзапросами оперируют не полями таблиц, а свойствами связываемых объектов данных, в том числе скрытыми (см. [Скрытые свойства объекта](#Скрытые-свойства-объекта)). Для описания связи с подзапросом или внутренним представлением (inner view) используется атрибут *SubqueryLinkAttribute* с параметрами: *Subquery* - псевдоним (alias) подзапроса, *SubqueryProperty* - свойство в подзапросе по которому производится связывание, *PropertyName* - (опционально) свойство в основном объекте данных по которому производится связывание (если не указано считается, что свзывание производится по одноименному свойству *SubqueryProperty*), кроме того поддерживаются опциональные свойства *Operation*, *Combination* и *PrimaryFilter* описанные выше в пунктах [Ограничения](#Ограничения) и [Связи внутри объекта данных](#Связи-внутри-объекта-данных).
```csharp
[SubqueryLink("H" /* псевдоним (alias) подзапроса */, 
	"DocId" /* имя свойства подзапроса */)]
```
При указании значения флага *PrimaryFilter* логика вычисления границ опциональной части запроса работает следующим образом: если подчиненный запрос будет "отброшен", то и источник данных основного объекта связанный с ним будет отброшен и анализ будет продолжен по связям внутри объекта (см. [Связи внутри объекта данных](#Связи-внутри-объекта-данных)).

####Описание преобразования свойств
Преобразвания (mapping) свойств объекта при статическом описании оформляются с помощью указания атрибутов этого конкретного свойства. Основным атрибутом определяющим параметры преобразования является *PropertyAttribute* с параметрами *Source* - псевдоним (alias) источника данных этого свойства (может быть не указан для [виртуальной таблицы](./glossary.md#Виртуальная-таблица)), *FieldName* - имя поля значение которого будет отражено в значение этого свойства (может не указываться в случае если имя поля и имя свойства соответствуют соглашению о наименовании (например, поле в БД назвается **some_field_name** и оно отражается в свойство объекта **SomeFieldName**)), *Flags* - опционально, битовая маска признаков поля описываемое перечислением *DataPropertyFlag*: 
* **None** - значение по умолчанию, поле не отмечено ни какими специфичными ролями
* **Id** - поле входит в первичный ключ
* **OuterFlag** - поле входит в число полей по значениям которых принимается решение о вставке/удалении записей в подчиненной таблице с [необязательной связью](./glossary.md#Необязательные-связи).
* **ConcurrencyToken** - токен конкурренции (concurrency token) используемый для организации [совместного доступа к данным](./locking.md)
,*NativeSqlType* - опционально, имя SQL типа в базе данных. Параметр *NativeSqlType* указывается в случае конфликта преобразования типа данных используемого по умолчанию.
```csharp
[Property("S" /* псевдоним (alias) таблицы */, 
	"code" /* имя поля */)]
```
#####Свойства на основании SQL выражений
В качестве источника данных для конкретного поля объекта данных, предназначенного только для чтения (см. [Свойства только для чтения](#Свойства-только-для-чтения)). Статическое описание SQL выражений в качестве источников оформляется с помощью атрибута *PropertyExpressionAttribute* (Обратите внимание, что он дополняет, но не заменяет атрибут *PropertyAttribute*) с параметрами: *ExprText* - в зависимости от значения *ExprType* (см. далее): псевдоним (alias) подзапроса / SQL выражение / имя свойства описывающего SQL выражение в стиле LINQ, *ExprType* - тип описания SQL выражения (опционально, по умолчанию *DataExpressionType*.**PlainSql**), *DbType* - тип данных на уровне ADO .Net провайдера (опционально, по умолчанию *DbType*.**String**), *ExprSize* - опционально, длина поля выражения (если применимо), *ExprScale* - опционально, десятичная точность поля выражения (если применимо). Возможно использовать SQL выражения трех видов: 
- подзапросы,
```csharp
[PropertyExpression("A", 
	DataExpressionType.SubQuery, 
	DbType.Decimal, 
	ExprSize = 17, 
	ExprScale = 5)]
```
- LINQ выражения,
```csharp
[PropertyExpression("AllowedDiscount", 
	DataExpressionType.LinqExpression, 
	DbType.Decimal, 
	ExprSize = 17, 
	ExprScale = 5)]
…
//Статическое поле отражаемого объекта 
private static Calculate<int> AllowedDiscount = x => x.Case<Product, int>( 
	z => z.Field<bool>("is_vip"), z => 0, 1.SetValue(10));	
```
- текстовые SQL выражения.
```csharp
[PropertyExpression("case P.is_vip when 1 then 10 else 0 end", 
	DataExpressionType.PlainSql, 
	DbType.Decimal, 
	ExprSize = 17, 
	ExprScale = 5)]
```
> При возможности описать SQL выражение в виде динамического описания или
> подзапроса, не рекомендуется использовать непосредственно текст SQL выражения 
> в связи с тем, что оно будет специфично для конкретного диалекта SQL.

Обычно при описании свойств на основании SQL выражений рекомендуется использовать в качестве источника данных [виртуальную таблицу](./glossary.md#Виртуальная-таблица), не указывая псевдоним источника данных в параметре атрибута *PropertyAttribute*.

#####Значения по умолчанию для свойств
Для указания значения свойства по умолчанию при статическом описании используется атрибут *PropertyDefaultAttribute* с параметрами: *DefaultSource* - тип значения по умолчанию определяется перечислением *DefaultType*:
* **CurrentDate** - текущая дата (используется настройки времени сервера БД)
* **CurrentDateTime** - текущая дата и время (используется настройки времени сервера БД)
* **CurrentDateTimeUTC** - текущая дата и время UTC (используется настройки времени сервера БД)
* **Variable** - значение переменной имя которой указано в параметре *DefaultValue*
* **Const** - констратное значение *DefaultValue*
* **AutoIncrement** - значение генерируется на уровне БД с ипользованием механизма автоинкрементных полей или SQL последовательности (sequence). В случае использования SQL последовательности должны соблюдаться условия описанные в разделе [Использование SQL последовательностей](./tips_and_triks.md#Использование-sql-последовательностей).
* **NewGuid** - генерируется новое значение GUID
* **UserName** - имя текущего пользователя. Для использования данного значения по умолчанию должен использоваться механизм доступа к данным описанный в разделе [Управление доступом к данным](./data_access.md), 
*DefaultValue* опционально, в зависимости от значения *DefaultSource*, *AlwaysUseDefault* - опционально, по умолчанию - false, признак того, что значение по умолчанию будет использоваться не только при добавлении новой записи, но и при обновлении.
```csharp
[PropertyDefault(DefaultType.UserName, AlwaysUseDefault = true)]
```
#####Скрытые свойства
Возможна ситуация, когда необходимо описать свойство для целостности описания преобразования в целом, но в итоговом бизнес - объекте это свойство не нужно (бизнес логика им не оперирует даже в плане чтения данных). Например, XData может полностью брать на себя работу с первичными (PK) и внешними (FK) ключами оперируемых объектов и работу связки master-slave, но для описания [внешних связей](#Внешние-связи) необходимо связать объекты именно по значению ключа. Второй пример - для организации оптимистичной блокировки (см. [Организация совместного доступа к данным](./locking.md)) необходим токен конкунеции (concurrency token) - поле которое будет проверяться и обновляться при каждом обновлении данных. Детали этого процесса описаны в соответствующем разделе, а здесь необходимо лишь отметить, что со стороны бизнес логики это поле избыточно и лучше бы его скрыть
#####Описание ссылок

####Прочие возможности статического преобразования

#####Внешние связи

#####Поддержка псевдонимов источников данных

#####Поддержка псевдонимов иерархических источников данных

#####Поддержка таблиц иерархии

####Описание объектного преобразования хранимых процедур и функций SQL
