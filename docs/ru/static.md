>Извините. Статья еще находится в стадии разработки, но мы уже работаем над ней...

###Статическое описание преобразования
>Прежде чем изучать данный раздел убедитесь, что вы ознакомились с [глосcарием](./glossary.md) и [общим описанием объектного преобразования](./mapping.md) которые содержат полезные знания, на которые опирается информация изложенная здесь.

Статическое преобразование (static mapping) описывается атрибутами объекта данных, его свойств и статических полей.

Ниже приведен пример статического описания преобразования (mapping) объекта данных. Понятно, что в реальности врядли будет необходимость в настолько сложном объекте и соответственно настолько сложном преобразовании, но в качестве примера возможностей XData достаточно показательно...
```csharp
	[DataObject("D", LogicAssemblyName = "XDataObjectTest"),
	 	DataTable("T_DOC", "D"),
	 	DictionaryFilter("T_DOC_TYPE", "doc_type_id", "code", "INVOICE", "D"),
		DataTable("T_DOC_DOC_STATE", "DS", Parent = "D"),
		Link("D", "doc_id", "DS"),
		DataTable("T_DOC_STATE", "S"),
		Link("DS", "doc_state_id", "S"),
		DataTable("T_DOC_NUMBER", "N", Parent = "D"),
		Link("D", "doc_id", "N"),
		DataTable("T_DOC_CUST", "CF", Parent = "D"),
		Link("D", "doc_id", "CF"),
		DataTable("T_CUSTOMER", "F"),
		Link("CF", "customer_id", "F"),
		DictionaryFilter("T_DOC_CUST_TYPE", "doc_cust_type_id", "code", "FROM", "CF"),
		DataTable("T_DOC_CUST", "CT", Parent = "D"),
		Link("D", "doc_id", "CT"),
		DataTable("T_CUSTOMER", "T"),
		Link("CT", "customer_id", "T"),
		DictionaryFilter("T_DOC_CUST_TYPE", "doc_cust_type_id", "code", "TO", "CT"),
		DataTable("T_DOC_SCAN", "SC", Parent = "D"),
		Link("D", "doc_id", "SC",  Operation = FilterOperation.OuterJoin),
        DataTable("T_DOC_SOURCE", "SR", Parent = "D"),
        Link("D", "doc_id", "SR", Operation = FilterOperation.OuterJoin),
        DataTable("T_DOC_DELIVERY", "DD", Parent = "D"),
        Link("D", "doc_id", "DD", Operation = FilterOperation.OuterJoin),
		DataTable("T_DOC_CATALOGUE", "DC", Parent = "D"),
		Link("D", "doc_id", "DC"),
		DataTable("T_CATALOGUE", "U"),
		Link("U", "catalogue_id", "DC"),
        Subquery("A", typeof(DocSpecAmounts), "Amount", Grouping = DataGrouping.Sum),
		SubqueryLink("A", "DocId"),
		InnerView("H", typeof(DocLastChange)),
        SubqueryLink("H", "DocId", Operation = FilterOperation.OuterJoin),
		ExternalLink(typeof(InvoiceSpec), "DocId"),
		InnerView("ST", typeof(DocBySpecType)),
		SubqueryLink("ST", "DocId"),
        Subquery("UT", typeof(CatalogueTree), "CatalogueId"),
        SubqueryFilter("UT", "DC", "catalogue_id", Operation = FilterOperation.In),
        Column("DocId", typeof(long?), "D", Flags = DataPropertyFlag.Id),
		ColumnDefault("DocId", DefaultType.AutoIncrement)]
    public class Invoice: IDataObject
	{
        [Property("S", "code")]
        public string DocStateCode { get { return this.GetProperty(x => x.DocStateCode); } }
        [Property("S", "name"),
            LinkProperty("Name"),
            LinkProperty("Code", "DocStateCode")]
        public Link<string, DocState> DocState { get; set; }
        [Property("U", "name"),
            LinkProperty("Name")]
        public Link<string, Catalogue> DocCatalog { get; set; }
        [Property("N", "numb")]
        public string DocNumb { get; set; }
        [Property("D"),
            PropertyDefault(DefaultType.CurrentDate)]
        public DateTime? DocDate { get; set; }
        [Property("D", Flags = DataPropertyFlag.ConcurrencyToken),
            PropertyDefault(DefaultType.AutoIncrement)]
        public long Generation { get { return this.GetProperty(x => x.Generation); } }
        [Property("D"),
            PropertyDefault(DefaultType.CurrentDateTime, AlwaysUseDefault = true)]
        public DateTime Changed { get { return this.GetProperty(x => x.Changed); } }
        [Property("D"),
            PropertyDefault(DefaultType.UserName, AlwaysUseDefault = true)]
        public string Author { get { return this.GetProperty(x => x.Author); } }
        [Property,
            PropertyExpression("A", DataExpressionType.SubQuery, DbType.Decimal, ExprSize = 17, ExprScale = 5)]
        public decimal? DocAmount { get { return this.GetProperty(x => x.DocAmount); } }
        [Reference("H", "HistoryDate")]
        public DateTime? DocLastChange { get { return this.GetProperty(x => x.DocLastChange); } }
        [Property("SC", Flags = DataPropertyFlag.OuterFlag)]
        public Lob Scan { get; set; }
        [Property("SR", Flags = DataPropertyFlag.OuterFlag)]
        public Xml Source { get; set; }
        [Property("F", "name"),
            LinkProperty("Name")]
        public Link<string, Customer> CustomerFrom { get; set; }
        [Property("T", "name"),
            LinkProperty("Name")]
        public Link<string, Customer> CustomerTo { get; set; }
        [Property("DD")]
        public DeliveryTypeEnum DeliveryType { get; set; }
        [Property("DD"),
            PropertyDefault(DefaultType.CurrentDate)]
        public DateTime? DeliveryDate { get; set; }
	public IRepository<InvoiceSpec> Spec { get { return this.GetRepository().GetChild<InvoiceSpec>(); } }
	}
```
####Описание параметров объектного отражения
Для всех статично отраженных классов должен быть назначен атрибут *DataObjectAttribute*, параметры которого, могут определять: *BaseTable* - псевдоним (alias) [базовой таблицы](./glossary.md#Базовая-таблица) (опционально, по умолчанию будет использоваться [виртуальная таблица](./glossary.md#Виртуальная-таблица) с пустым псевдонимом), *Context* - [контекст](./glossary.md#Контекст) базы данных (опционально, по умолчанию отображение может быть выполнено для любого контекста) и *Flags* - набор флагов источника данных (опционально, по умолчанию **None**).

Например:
```csharp
[DataObject("D" /* псевдоним (alias) базовой таблицы */, 
	Context: "Main" /* имя контекста источника данных */, 
	Flags: DataObjectFlags.ReadOnly /* флаги источника данных */)]
```
Все таблицы участвующие в запросе [источника данных](./glossary.md#Источник-данных) перечисляются с помощью атрибута отражаемого класса *DataTableAttribute* и у них обязательно должны быть заполнены свойства *Name* (имя таблицы) и *Alias* (псевдоним таблицы в результирующем запросе). Те из них, которые участвуют в [иерархии обновляемых таблиц](./glossary.md#Иерархия-обновляемых-таблиц) (кроме базовой таблицы) должны содержать значение параметра этого атрибута *Parent* (псевдоним (alias) таблицы, на которую ссылается текущая таблица в иерархии обновляемых таблиц).
```csharp
[DataTable("P" /* псевдоним (alias) таблицы */, 
	"patient" /* имя таблицы */, 
	"D" /* псевдоним (alias) родительской таблицы в иерархии обновления */)]
```
Кроме таблиц подобным образом могут описываться представления (view), однако все используемые поля представления должны быть описаны явно в виде свойств только для чтения (см. [Свойства только для чтения](#Свойства-только-для-чтения)) или скрытых полей (см. [Скрытые поля](#Скрытые-поля)).

####Описание преобразования с использованием подзапросов
Есть возможность использовать в объектном преобразовании подзапросы. Такая возможность есть как для отражения SQL выражений представляющих собой подзапрос на свойства объектов данных (см. ниже), для описания ограничений использующих подзапросы (см. [Ограничения на основе SQL выражений](#Ограничения-на-основе-SQL-выражений)), так и в качестве описаний внутренних подзапросов (inner view).

Глубина вложенности подзапросов не регламентируется.

В описании объектного преобразования основного класса (класса который использует этот подзапрос) должен присутствовать атрибут *SubqueryAttribute* или *InnerViewAttribute* (для использования в качестве внутреннего подзапроса (inner view)). Оба этих атрибута имеют параметры *Alias* (псевдоним подзапроса в результирующем запросе). Кроме того *InnerViewAttribute* имеет параметр *InnerViewType* (тип, описывающий объектное преобразование (mapping) подзапроса), а *SubqueryAttribute* - параметры: *SubqueryType* (тип, описывающий объектное преобразование (mapping) подзапроса), *PropertyName* (результирующее свойство подзапроса) и *Grouping* (тип агрегации для результирующего свойства подзапроса).
```csharp
[Subquery("A" /* псевдоним (alias) подзапроса */, 
	typeof(DocSpecAmounts) /* тип отражения подзапроса */, 
	"Amount" /* результирующее поле подзапроса */, 
	Grouping = DataGrouping.Sum /* агрегатная функция результирующего поля подзапроса */)]

[InnerView("H" /* псевдоним (alias) внутреннего представления (inner view) */, 
	typeof(DocLastChange) /* тип отражения внутреннего представления (inner view) */)]
```
####Ограничения
Ограничения внутри основного запроса объекта данных могут быть описаны как:
* Константные ограничения
* Ограничения на основе SQL выражений
* Ограничения на основе кодов справочников
* Ограничения на основе списка значений
* Ограничения по подзапросу
* Связи внутри объекта данных

Каждый из них описывается соответствующим атрибутом класса объекта данных (см. ниже). Для всех из них должны быть определены следующие параметры: *Source* - псевдоним (alias) источника данных к полю которого применяется ограничение, *FieldName* - имя поля, *Operation* - операция фильтра (опционально, по умолчанию *FilterOperation*.**Equal**), *Combination* - имя группы фильтров, к которой относится данный фильтр (опционально, по умолчанию группа фильтров по умолчанию). Кроме этого каждое ограничение имеет свои специфичные параметры описанные в соответствующих разделах ниже.

Список операций представлен перечислением *FilterOperation*:
* **Equal** - равно
* **NotEqual** - не равно
* **LessThan** - меньше чем
* **GreaterThan** - больше чем
* **LessThanOrEqual** - меньше или равно
* **GreaterThanOrEqual** - больше или равно
* **In** - значение входит в список (или подзапрос)
* **NotIn** - значение не входит в список (или подзапрос)
* **Exists** - подзапрос возвращает одну или более строк
* **NotExists** - подзапрос не возвращает ни одной строки
* **Like** - найдено соответствие при поиске по подстроке
* **NotLike** - не найдено соответствий при поиске по подстроке
* **OuterJoin** - необязательная связь между источниками запроса (таблицами и внутренними предствлениями (inner view))
* **Contains** - найдено соответствие при полнотекстовом поиске
* **NotContains** - не найдено соответствие при полнотекстовом поиске

#####Группы фильтров
[Группы фильтров](./glossary.md#Группа-фильтров) могут быть описаны с помощью атрибута *FilterCombinationAttribute* с параметрами: *Name* - уникальное имя группы фильтров, *Combination* - логическая операция объединения фильтров (и подчиненных групп фильтров) внутри описываемой группы фильтров (опционально, по умолчанию *FilterCombination*.**And**), *Parent* - имя родительской группы фильтров (опционально, для групп фильтров подчиненных группе фильтров по умолчанию может быть не указан).

Логическая операция связующая фильтры внутри группы фильтров описывается перечислением *FilterCombination*:
* **AND** - И
* **OR** - ИЛИ
```csharp
[FilterCombination("OrGroup" /* имя группы фильтров */, 
	Combination: FilterCombination.OR /* логическая операция */)]
```

#####Константные ограничения
Ограничения с константным значением позволяют ограничить выборку объекта данных по значению некоторой константы. Использование такого фильтра описывается атрибутом *ConstantFilterAttribute*, со специфичными (относительно параметров описанных в пункте [Ограничения](#Ограничения)) параметрами: *Name* - имя фильтра (будет преобразовано в имя параметра запроса без учета префиксов согласно конкретного диалекта SQL), *ConstantType* - тип константы (см. ниже) и *ConstantValue* - значение константы (опционально в зависимости от *ConstantType*).

Список типов константы задается перечислением *FilterConstantType*:
* **Const** - указанное в поле *ConstantValue* значение.
* **Variable** - значение переменной (см. [Переменные](./tips_and_triks.md/#Переменные)) с именем, указанным в поле *ConstantValue*.
* **CurrentDate** - сегодняшняя дата.
* **CurrentDateTime** - текущие дата и время.
* **CurrentDateTimeUTC** - текущие дата и время (UTC).
```csharp
[ConstantFilter("FilterByZero" /* имя фильтра */, 
	"P" /* псевдоним (alias) таблицы */, 
	"discount" /* имя поля БД */, 
	"0" /* значение константы */, 
	Operation: FilterOperation.Equal /* операция фильтра */, 
	ConstantType: FilterConstantType.Const /* тип константы */)]
```

#####Ограничения на основе SQL выражений
Для описания ограничений на основе SQL выражений используется атрибут *ExpressionFilterAttribute* со специфичными (относительно параметров описанных в пункте [Ограничения](#Ограничения)) параметрами: *ExpressionText* - в зависимости от типа описания SQL выражения может быть: 
- псевдонимом подчиненного запроса,
```csharp
[ExpressionFilter("P" /* псевдоним (alias) таблицы */, 
	"discount" /* имя поля */, 
	"D" /* ExpressionText: псевдоним (alias) подзапроса */, 
	Operation: FilterOperation.In /* операция фильтра */)]
```
- именем статического поля с динамическим описанием SQL выражения,
```csharp
[ExpressionFilter("P" /* псевдоним (alias) таблицы */, 
	"discount" /* имя поля */, 
	"AllowedDiscount" /* ExpressionText: имя статичного поля - описания выражения */, 
	Operation: FilterOperation.NotEqual /* операция фильтра */)]
…
//Статическое поле отражаемого объекта 
private static Calculate<int> AllowedDiscount = x => x.Case<Product, int>( 
	z => z.Field<bool>("is_vip"), z => 0, 1.SetValue(10));
```
- текстом SQL выражения.
```csharp
[ExpressionFilter("P" /* псевдоним (alias) таблицы */, 
	"discount" /* имя поля */, 
	"case P.is_vip when 1 then 10 else 0 end" /* ExpressionText: текст SQL выражения */, 
	Operation: FilterOperation.NotEqual /* операция фильтра */)]
```
> При возможности описать SQL выражение в виде динамического описания или
> подзапроса, не рекомендуется использовать непосредственно текст SQL выражения 
> в связи с тем, что оно будет специфично для конкретного диалекта SQL.

#####Ограничения на основе списка значений
Для описания ограничения проверки значения на вхождение в некоторый статичный список используется атрибут *RangeFilterAttribute* со специфичным (относительно параметров описанных в "Ограничения") параметром: Range - массив значений списка.
```csharp
[RangeFilter("P" /* псевдоним (alias) таблицы */, 
	"discount" /* имя поля */, 
	new[] {0,5,10} /* список значений */, 
	Operation: FilterOperation.In /* операция фильтра */)]
```

#####Ограничения на основе кодов справочников
Суррогатные ключи справочников могут отличаться в различных инсталляциях, а названия обычно могут быть исправлены пользователями. Однако часто в бизнес логике необходимо оперировать конкретными значениями справочников. По этой причине рекомендуется при проектировании структуры базы данных снабжать справочники специальными уникальными текстовыми полями - мнемокодами.

Подсистема XData поддерживает использование мнемокодов при описании ограничений на основе значений справочников. Для этого используется атрибут *DictionaryFilterAttribute* со специфичными (относительно параметров описанных в пункте [Ограничения](#Ограничения)) параметрами: *DictionaryTable* - имя справочной таблицы, *DictionaryId* - имя поля идентификатора справочной таблицы, *DictionaryCode* - имя поля мнемокода справочной таблицы, *DictionaryValue* - значение мнемокода по которому производится фильтрация, *ValueIsVariable* - признак того, что вместо конкретного значения в параметр *DictionaryValue* будет записано имя переменной (см.  [Переменные](./tips_and_triks.md/#Переменные)) с нужным значением.

В случае совпадения имени идентификатора справочника и поля, по которому производится фильтрация параметр *FieldName* можно не задавать. Конструкцию есть возможность применять только для справочников с простым суррогатным ключом (из одного поля) и имеющих поле мнемокода.
```csharp
[DictionaryFilter("t_doc_state" /* имя справочной таблицы */, 
	"doc_state_id" /* имя поля идентификатора справочника */, 
	"code" /* имя поля мнемокода */, 
	"CREATED" /* значение мнемокода */, 
	"D" /* псевдоним (alias) таблицы */)]
```
#####Связи внутри объекта данных
Для описания связей внутри запроса объекта данных используется атрибут *LinkAttribute* со специфичными параметрами: *LinkedSourceAlias* - псевдоним (alias) связанной таблицы, *LinkedFieldName* - имя поля в связанной таблице (опционально, может быть не указан при совпадении с *FieldName*). Связи внутри объекта данных могут быть использованы в описании опциональных ограничений (см. [Опциональные фильтры и опциональные подчиненные запросы](./tips_and_triks.md#Опциональные-фильтры-и-опциональные-подчиненные-запросы)). Для указания того, что связь используется в определении необязательной части запроса может быть указан опциональный флаг первичного фильтра *PrimaryFilter*.
```csharp
[Link("D" /* псевдоним (alias) таблицы */, 
	"doc_id" /* имя поля БД */, 
	"DD" /* псевдоним (alias) связанной таблицы */)]
```

#####Ограничения по подзапросу
Для описания ограничений по подзапросу используется атрибут *SubqueryFilterAttribute* со специфичным (относительно параметров описанных в пункте [Ограничения](#Ограничения)) параметром: *Subquery* - псевдоним (alias) подзапроса (см. "Описание объектного преобразования с использованием подзапросов "). При этом в качестве подзапроса для ограничения не может выступать внутреннее представление (inner view).
```csharp
[SubqueryFilter("D" /* псевдоним (alias) таблицы */, 
	"doc_state_id" /* имя поля */, 
	"A" /* псевдоним (alias) подзапроса */, 
	Operation: FilterOperation.In /* операция фильтра */)]
```
При указании значения флага *PrimaryFilter* логика вычисления границ опциональной части запроса работает следующим образом: если один из связываемых источников данных (таблица или представление (view)) будет "отброшен", то и источник данных связанный с ним будет отброшен. В случае если отбрасывается [базовая таблица](./glossary.md#Базовая-таблица) подзапроса - он будет "отброшен" полностью.

#####Связи с подзапросами
Связи с объектами данных - подзапросами оперируют не полями таблиц, а свойствами связываемых объектов данных, в том числе скрытыми (см. [Скрытые свойства объекта](#Скрытые-свойства-объекта)). Для описания связи с подзапросом или внутренним представлением (inner view) используется атрибут *SubqueryLinkAttribute* с параметрами: *Subquery* - псевдоним (alias) подзапроса, *SubqueryProperty* - свойство в подзапросе по которому производится связывание, *PropertyName* - (опционально) свойство в основном объекте данных по которому производится связывание (если не указано считается, что свзывание производится по одноименному свойству *SubqueryProperty*), кроме того поддерживаются опциональные свойства *Operation*, *Combination* и *PrimaryFilter* описанные выше в пунктах [Ограничения](#Ограничения) и [Связи внутри объекта данных](#Связи-внутри-объекта-данных).
```csharp
[SubqueryLink("H" /* псевдоним (alias) подзапроса */, 
	"DocId" /* имя свойства подзапроса */)]
```
При указании значения флага *PrimaryFilter* логика вычисления границ опциональной части запроса работает следующим образом: если подчиненный запрос будет "отброшен", то и источник данных основного объекта связанный с ним будет отброшен и анализ будет продолжен по связям внутри объекта (см. [Связи внутри объекта данных](#Связи-внутри-объекта-данных)).

####Описание преобразования свойств
Преобразвания (mapping) свойств объекта при статическом описании оформляются с помощью указания атрибутов этого конкретного свойства. Основным атрибутом определяющим параметры преобразования является *PropertyAttribute* с параметрами *Source* - псевдоним (alias) источника данных этого свойства (может быть не указан для [виртуальной таблицы](./glossary.md#Виртуальная-таблица)), *FieldName* - имя поля значение которого будет отражено в значение этого свойства (может не указываться в случае если имя поля и имя свойства соответствуют соглашению о наименовании (например, поле в БД назвается **some_field_name** и оно отражается в свойство объекта **SomeFieldName**)), *Flags* - опционально, битовая маска из [набора флагов свойства](./glossary.md#Набор-флагов-свойства),*NativeSqlType* - опционально, имя SQL типа в базе данных. Параметр *NativeSqlType* указывается в случае конфликта преобразования типа данных используемого по умолчанию.
```csharp
[Property("S" /* псевдоним (alias) таблицы */, 
	"code" /* имя поля */)]
```
#####Свойства на основании SQL выражений
В качестве источника данных для конкретного поля объекта данных, предназначенного только для чтения (см. [Свойства только для чтения](#Свойства-только-для-чтения)). Статическое описание SQL выражений в качестве источников оформляется с помощью атрибута *PropertyExpressionAttribute* (Обратите внимание, что он дополняет, но не заменяет атрибут *PropertyAttribute*) с параметрами: *ExprText* - в зависимости от значения *ExprType* (см. далее): псевдоним (alias) подзапроса / SQL выражение / имя свойства описывающего SQL выражение в стиле LINQ, *ExprType* - опционально, [тип описания SQL выражения](./glossary.md#Тип-описания-sql-выражения), по умолчанию *DataExpressionType*.**PlainSql**, *DbType* - тип данных на уровне ADO .Net провайдера (опционально, по умолчанию *DbType*.**String**), *ExprSize* - опционально, длина поля выражения (если применимо), *ExprScale* - опционально, десятичная точность поля выражения (если применимо). Возможно использовать SQL выражения трех видов: 
- подзапросы,
```csharp
[PropertyExpression("A", 
	DataExpressionType.SubQuery, 
	DbType.Decimal, 
	ExprSize = 17, 
	ExprScale = 5)]
```
- LINQ выражения,
```csharp
[PropertyExpression("AllowedDiscount", 
	DataExpressionType.LinqExpression, 
	DbType.Decimal, 
	ExprSize = 17, 
	ExprScale = 5)]
…
//Статическое поле отражаемого объекта 
private static Calculate<int> AllowedDiscount = x => x.Case<Product, int>( 
	z => z.Field<bool>("is_vip"), z => 0, 1.SetValue(10));	
```
- текстовые SQL выражения.
```csharp
[PropertyExpression("case P.is_vip when 1 then 10 else 0 end", 
	DataExpressionType.PlainSql, 
	DbType.Decimal, 
	ExprSize = 17, 
	ExprScale = 5)]
```
> При возможности описать SQL выражение в виде динамического описания или
> подзапроса, не рекомендуется использовать непосредственно текст SQL выражения 
> в связи с тем, что оно будет специфично для конкретного диалекта SQL.

Обычно при описании свойств на основании SQL выражений рекомендуется использовать в качестве источника данных [виртуальную таблицу](./glossary.md#Виртуальная-таблица), не указывая псевдоним источника данных в параметре атрибута *PropertyAttribute*.

#####Значения по умолчанию для свойств
Для указания значения свойства по умолчанию при статическом описании используется атрибут *PropertyDefaultAttribute* с параметрами: *DefaultSource* - [тип значения по умолчанию](./glossary.md#Тип-значения-свойства-по-умолчанию), *DefaultValue* опционально, в зависимости от значения *DefaultSource*, *AlwaysUseDefault* - опционально, по умолчанию - false, признак того, что значение по умолчанию будет использоваться не только при добавлении новой записи, но и при обновлении.
```csharp
[PropertyDefault(DefaultType.UserName, AlwaysUseDefault = true)]
```

#####Парамеры группировки свойства
Параметры группировки используются в случае описания группированного (group by) объекта для указания использования поля в группировке. Для этого служит атрибут свойства *PropertyGroupingAttribute* с параметрами: *Grouping* - опционально, описывает [тип агрегации](./glossary.md#Тип-агрегации), по умолчанию **None**, *GroupOrder* - опционально, указывает порядок в группировке при условии *Grouping* = *DataGrouping*.**None**.
```csharp
[PropertyGrouping(DataGrouping.Sum)]
```

#####Скрытые свойства
В случае статического описания правил преобразования объекта, для описания [скрытых свойств](./mapping.md#Скрытые-свойства) (среди атрибутов класса) добавляются атрибуты отвечающие за описание такго свойства *ColumnAttribute*, *ColumnExpressionAttribute* и *ColumnDefaultAttribute* по аналогии с подобными атрибутами свойств.

Аттрибут *ColumnAttribute* имеет параметры: *PropertyName* - имя свойства, *PropertyType* - тип свойства, *Source* - псевдоним (alias) испточника данных, *FieldName* - опционально, имя поля в БД (может не указываться в случае если имя поля и имя свойства соответствуют соглашению о наименовании (например, поле в БД назвается **some_field_name** и оно отражается в свойство объекта **SomeFieldName**)), *Flags* - опционально, опционально, битовая маска из [набора флагов свойства](./glossary.md#Набор-флагов-свойства), *Grouping* - опционально, описывает [тип агрегации](./glossary.md#Тип-агрегации), по умолчанию **None**, *GroupOrder* - опционально, указывает порядок в группировке при условии *Grouping* = *DataGrouping*.**None**, *Hidden* - опционально, указывает на отсутствие поля в выражении SELECT результирующего запроса (обычно обусловлено ограничениями при группировке), по умолчанию false, *NativeSqlType* - опционально, имя SQL типа в базе данных. Параметр *NativeSqlType* указывается в случае конфликта преобразования типа данных используемого по умолчанию.

Аттрибут *ColumnExpressionAttribute* с параметрами: *PropertyName* - имя свойства (свойство должно быть описано с помощью атрибута *ColumnAttribute*), *ExprText* - в зависимости от значения *ExprType* (см. далее): псевдоним (alias) подзапроса / SQL выражение / имя свойства описывающего SQL выражение в стиле LINQ, *ExprType* - опционально, [тип описания SQL выражения](./glossary.md#Тип-значения-свойства-по-умолчанию) по умолчанию *DataExpressionType*.**PlainSql**, *DbType* - тип данных на уровне ADO .Net провайдера (опционально, по умолчанию *DbType*.**String**), *ExprSize* - опционально, длина поля выражения (если применимо), *ExprScale* - опционально, десятичная точность поля выражения (если применимо).

Аттрибут *ColumnDefaultAttribute* с параметрами: *PropertyName* - имя свойства (свойство должно быть описано с помощью атрибута *ColumnAttribute*), *DefaultSource* - [тип значения по умолчанию](./glossary.md#Тип-значения-свойства-по-умолчанию), *DefaultValue* опционально, в зависимости от значения *DefaultSource*, *AlwaysUseDefault* - опционально, по умолчанию - false, признак того, что значение по умолчанию будет использоваться не только при добавлении новой записи, но и при обновлении.
```csharp
[Column("DocId", typeof(long?), "D", Flags = DataPropertyFlag.Id),
	ColumnDefault("DocId", DefaultType.AutoIncrement)]
```

#####Описание ссылок
Общее описание ссылок представлено [ранее](./mapping.md#Свойства---ссылки-на-другие-объекты). Здесь же остановимся на особенностях описания ссылок в случае статического описания объектного преобразования. Для определения связей между свойствами текущего объекта и свойствами объекта на который ведет ссылка используется набор атрибутов свойства - ссылки (по одному на каждую пару связанных свойств) *LinkPropertyAttribute* с параметрами *DictSource* - опционально, наименование свойства в ссылочном объекте, *Property* - опционально, наименование свойства в основном объекте. При интерпретации данных работают следующие правила:
* Если не заданы оба свойства - используется имя свойства для которого и определен этот атрибут в основном объекте и считается, что источником данных является одноименное свойство в ссылочном объекте
* Если не задано свойство *DictSource* -  используется свойство *Property* в основном объекте и считается, что источником данных является одноименное *Property* свойство в ссылочном объекте
* Если не задано свойство *Property* -   используется имя свойства для которого и определен этот атрибут в основном объекте и  источником данных принимается свойство *DictSource* в ссылочном объекте
```csharp
[Property("S", "name"),
    LinkProperty("Name") /* поле DocState.Name источник для DocState текущего объекта */,
    LinkProperty("Code", "DocStateCode")  /* поле DocState.Code источник для DocStateCode текущего объекта */]
public Link<string, DocState> DocState { get; set; }
```

#####Внешние связи
[Внешние связи](./mapping.md#Внешние-связи) в случае использования статического описания объектного преобразования оформляются с помощью атрибута *ExternalLinkAttribute* с параметрами: *ChildType* - тип зависимого [репозитория](./glossary.md#Репозиторий), *ChildProperty* - имя свойства для связи в зависимом (slave) репозитории, *Property* - опционально, свойство для связи в главном (master) репозитории, если не указано считается равным *ChildProperty*, *FilterName* - опционально, имя фильтра в зависимом репозитории, если не указано принимается равным **"FilterBy"** + *ChildProperty*, *MasterRefresh* - опционально, признак того, что необходимо обновить запись в главном репозитории при изменении данных в зависимом (это используется, например, если объект главного репозитория содержит расчетные данные на основании исходных таблиц зависимого репозитория), по умолчанию **false**, *DirectLink* - опционально, признак "прямой связи" (см. [Особенности работы с дочерними репозториями иерархической сущности](./tips_and_triks.md#Особенности-работы-с-дочерними-репозториями-иерархической-сущности)), по умолчанию **false** *Operation* - опционально, операция фильтра зависимого объекта (см. [Ограничения](#Ограничения)), по умолчанию *FilterOperation*.**Equal**, *Nullable* - опционально, [метод обработки пустых значений](./glossary.md#Методы-обработки-пустых-значений-фильтров), по умолчанию *FilterNullable*.**Nullable**, *Combination* - опционально, [имя группы фильтров](./glossary.md#Группа-фильтров) зависимого репозитория. Внешние связи могут быть использованы в описании опциональных ограничений (см. [Опциональные фильтры и опциональные подчиненные запросы](./tips_and_triks.md#Опциональные-фильтры-и-опциональные-подчиненные-запросы)). Для указания того, что связь используется в определении необязательной части запроса может быть указан опциональный флаг первичного фильтра *PrimaryFilter*.
```csharp
[ExternalLink(typeof(InvoiceSpec), "DocId")]
```

#####Поддержка псевдонимов источников данных
Описание псевдонимов и способы работы с ними отражены [в общей части описания](./mapping.md#Поддержка-псевдонимов-источников-данных), а здесь рассмотрим оформление статического описания псевдонимов.

Для объявления псевдонима плоского представления, а также базового подзапроса описания иерархического представления в случае статического описания объектного преобразования используется атрибут *WithAttribute* с параметрами: *Alias* - псевдоним представления, *SubqueryType* - тип описывающий плоское представление или корневой подзапрос иерархического представления, *WithType* - опционально, операция объединения между подзапросами иерархического представления, используется только для описания иерархического представления описывается перечислением *WithRecursiveType* со значениями:
* **RecusiveUnion** - по умолчанию, операция объединения **UNION**
* **RecusiveUnionAll** - операция объединения **UNION ALL**
, *Properties* - упорядоченный набор свойств представления.

Для объявления рекурсивного подзапроса описания иерархического представления в случае статического описания объектного преобразования используется атрибут *WithRecursiveAttribute* с параметрами:  *Alias* - псевдоним подзапроса, *SubqueryType* - тип описывающий подзапрос, *InitialAlias* - псевдоним иерархического представления.

Пример описания преобразования с использованием псевдонима плоского представления:
```csharp
/* Описание плоского представления S ссылается на подзапрос Sales */
[With("S", typeof(Sales), "Year", "Region", "Sales"),
	DataTable("S", "P") /* Продажи за прошлый год с псевдонимом P */,
	DataTable("S", "C") /* Продажи текущий год с псевдонимом C */]
```

Пример описания преобразования с использованием псевдонима иерархического представления:
```csharp
[With("CAT", typeof(CatalogueTreeRoot), WithRecursiveType.RecursiveUnion, 
	"CatalogueId", "Name", "Code", "ParentId"),
        WithRecursive("S", typeof(CatalogueTreeFolders), "CAT"),
        SubqueryLink("S", "ParentId", "CatalogueId")]
...
/* Описание корневого подзапроса */
[DataObject("R"),
DataTable("T_CATALOGUE", "R"),
Column("CatalogueId", typeof(long), "R"),
Column("Code", typeof(string), "R"),
Column("Name", typeof(string), "R"),
Column("ParentId", typeof(long?), "R"),
FilterCombination("root", Combination = Combination.Or),
ConstantFilter("FilterByRoot", "R", "catalogue_id", null,  
    Combination = "root", Nullable = FilterNullable.NullsNotAllowed),
ConstantFilter("FilterByRoot", "R", "parent_id", null, 
    Combination = "root", Nullable = FilterNullable.NullsCompared)]
public class CatalogueTreeRoot : ISqlObject {}
/* Описание рекурсивного подзапроса */
[DataObject("S"),
DataTable("T_CATALOGUE", "S"),
Column("CatalogueId", typeof(long), "S"),
Column("Code", typeof(string), "S"),
Column("Name", typeof(string), "S"),
Column("ParentId", typeof(long?), "S")]
public class CatalogueTreeFolders : ISqlObject {}
```

#####Поддержка таблиц иерархии
Описание назначения таблиц иерархии отражены [в общей части описания](./mapping.md#Поддержка-таблиц-иерархии), а здесь рассмотрим оформление их статического описания.

Для статического описания таблицы иерархии используется атрибут *HierarchyAttribute* с параметрами:
*Source* - псевдоним (alias) таблицы с рекурсивной ссылкой, *TreeTableName* - имя таблицы иерархии, *Parent* - имя поля рекурсивной ссылки в основной таблице, *LinkParent* - имя поля идентификатора корневого узла поддерева, *LinkChild* - имя поля узла поддерева.
```csharp
[Hierarchy("P", "l_rights_policy", "parent_policy_id", "parent_policy", "child_policy")]
```

####Описание объектного преобразования хранимых процедур и функций SQL
Общие сведения о возможностях использования хранимых процедур и функций SQL в XData отражены [в общей части описания](./mapping.md#Использование-хранимых-процедур-и-функций-sql), а здесь рассмотрим оформление их статического описания.

#####Описание хранимой процедуры как источника данных
Для описания хранимой процедуры как источника данных используется атрибут *ProcedureAttribute* с параметрами: *Alias* - псевдоним (alias) источника данных, *Name* - имя процедуры или функции SQL, *ProcedureType* - перечисление *ProcedureType* указывает на то, является ли *Name* хранимой процедурой (*ProcedureType*.**Procedure**) или функцией (*ProcedureType*.**Function**).

#####Описание параметра хранимой процедуры
Для описания параметра хранимой процедуры используется атрибут *ParameterAttribute* с параметрами: *Alias* - псевдоним (alias) источника данных, *Order* - порядковый номер параметра, *Binding* - имя под которым этот параметр будет доступен из программного кода (часто удобно когда имя параметра в коде будет иметь другую нотификацию нежели в БД), *Type* - тип который будет использоваться  для доступа к значению параметра в программном коде, *DbType* - тип данных на уровне ADO .Net провайдера, *Direction* - опционально, направление передачи данных параметра, по умолчанию *ParameterDirection*.**Input**, *Size* - опционально, длина значения параметра (если применимо), *Scale* - опционально, тесятичная точность значения параметра (если применимо), *Name* - опционально, имя параметра, по умолчанию равно *Binding*, *DefaultType* - [тип значения по умолчанию](./glossary.md#Тип-значения-свойства-по-умолчанию), *DefaultValue* опционально, в зависимости от значения *DefaultType*, *NativeSqlType* - опционально, имя SQL типа в базе данных (*NativeSqlType* указывается в случае конфликта преобразования типа данных используемого по умолчанию), *UdtTypeName* - опционально, имя пользовательского типа данных SQL (UDT), *UdtElementTypeName* - опционально, имя пользовательского типа данных SQL (UDT) элемента коллекции *UdtTypeName* (в случае если *UdtTypeName* - коллекция), *IsArray* - опционально, признак того, что параметр является массивом элементов *UdtElementTypeName* (если *UdtElementTypeName* не указан, массивом элементов *DbType*), по умолчанию - **false**.

#####Описание возвращаемого набора данных
Для описания набора данных возвращаемого хранимой процедурой используется атрибут *ResultSetAttribute* с параметрами: *Alias* - псевдоним (alias) источника данных - хранимой процедуры SQL, *Name* - имя возвращаемого набора данных под которым он будет доступен из программного кода, *Order* - опционально, порядковый номер возвращаемого набора данных (для хранимых процедур возвращающих несколько наборов данных указание этого параметра - обязательно), *ResultType* - опционально, тип который будет использован для отражения элементов возвращаемого набора данных, по умолчанию используется тип которому назначен этот атрибут.

#####Примеры описания объектного преобразования хранимых процедур и функций SQL
* Использование в качестве источника данных набора записей возвращаемый хранимой процедурой
* Использование хранимых процедур возвращающих несколько наборов данных
* Использование возвращаемого (out) параметра хранимой процедуры
* Тоже самое совместно с возвращением набора записей
* Использование возвращаемого значения (return value) хранимой процедуры
* Тоже самое совместно с возвращением набора записей
* Использование в качестве параметра хранимой процедуры набора записей
* Тоже самое для UDT (пользовательский тип данных SQL)
* Использование в качестве источника данных скалярной функции (возможно с табличным или UDT параметром)
* Использование в качестве источника данных табличной функции (возможно с табличным или UDT параметром)
* Использование скалярной функции в качестве источника данных свойства
* Тоже самое с использованием LINQ выражения в качестве описания SQL выражения - источника
