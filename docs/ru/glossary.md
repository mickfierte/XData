### Основные понятия

######Объекты данных
Объекты предметной области приложения, имеющие статическое описание (в отличие от динамического, описанного в разделе "Динамические запросы") объектного преобразования (mapping). В процессе исполнения программы экземпляры объектов данных могут быть получены из соответсвующего их типу [репозитория](#Репозиторий).

######Иерархия обновляемых таблиц
Иерархически зависимые таблицы структуры хранения, которые будут обновлены при применении изменений [объекта данных](#Объекты-данных). Реальное обновление происходит только в том случае изменения свойств [объекта данных](#Объекты-данных) отражаемых на поля именно этой таблицы. В зависимости от взаимосвязей между таблицами иерархии обновления (см. [Необязательные связи](#Необязательные-связи)) обновление объекта данных может для конкретной таблицы в иерархии обновления быть автоматически преобразовано в удаление или вставку. Иерархия обновляемых таблиц имеет только один узел верхнего уровня - [базовую таблицу](#Базовая-таблица).

######Базовая таблица
Корневая таблица [иерархии обновляемых таблиц](#Иерархия-обновляемых-таблиц). В случае описания не изменяемых источников данных в качестве базовой таблицы может быть указан основной источник данных (возможно при этом даже не являющийся в БД таблицей) который будет содержать уникальный идентификатор записей.

######Необязательные связи
Связи между таблицами в иерархии обновления связанные между собой с помощью операции внешнего объединения (OuterJoin). При этом обязательно должны быть помечены свойства объекта данных (как правило, это обязательные поля подчиненной таблицы, но не суррогатный первичный ключ), которые будут выступать как признак необходимости наличия записи в подчиненной таблице.

######Слои
Для обеспечения независимого доступа к одним и тем же [репозиториям](#Репозиторий) в контексте разных элементов интерфейса или модулях логики обработки данных было введено понятие слоев. Каждый слой характеризуется своим уникальным идентификатором в формате GUID и в каждом могут быть свои отношения master-slave и на каждый из них могут быть наложены независимо друг от друга различные условия фильтрации (см. [Фильтры](#Фильтры)).

######Репозиторий
Позволяет получить экземпляры объектов данных и применить их изменения в БД. Реализует интерфейс [IRepository<T>](https://htmlpreview.github.io/?https://raw.githubusercontent.com/mickfierte/XData/master/docs/doc/Contents/1/59.html), который является наследником [IQueryable<T>](https://msdn.microsoft.com/ru-ru/library/bb351562(v=vs.110).aspx), где T - тип объекта данных.

######Контекст
Cтроковый псевдоним, ассоциированный с конкретной базой данных и ассоциированные с ним настройки доступа к этой базе данных. Может быть задан в файле конфигурации приложения, либо зарегистрирован динамически (см. [Частные случаи и советы - Регистрация контекста динамически](./tips_and_tricks.md#Регистрация-контекста-динамически)).

######Псевдоним источника данных
Строка уникально идентифицирующая подчиненный объект в отношении master-slave. Может быть задан для однозначного определения источника данных в ситуации, когда один и тот же [объект предметной области](#Объекты-данных) (но с различными фильтрами и/или переменными) ассоциирован с различными элементами пользовательского интерфейса в рамках одного слоя.

######Фильтры
Фильтры, наложенные на источник данных статически (по описанию преобразования (mapping)), или динамически (в результате обработки master-slave, установки значений [фильтров времени исполнения](#Фильтры-времени-исполнения), или динамического наложения на источник данных фильтров при помощи [LINQ выражений](./linq.md)).

######Фильтры времени исполнения
Фильтры накладываемые на источник данных [репозитория](#Репозиторий) объекта данных, значения которых задаются в ходе исполнения приложения автоматически (например, при обработке отношений master-slave), или непосредственно из кода приложения (с помощью метода [*SetFilterValue*](https://htmlpreview.github.io/?https://raw.githubusercontent.com/mickfierte/XData/master/docs/doc/Contents/2/154.html) репозитория).

######Набор флагов источника данных
Перечисление [*DataStructureFlags*](https://htmlpreview.github.io/?https://raw.githubusercontent.com/mickfierte/XData/master/docs/doc/Contents/1/27.html) содержит набор флагов определяющих поведение источника данных:
* **None** - поведение по умолчанию, объект плоский, поддерживает обновления и его данные не сгруппированы.
* **ReadOnly** - объект помечен как объект только для чтения (в целях оптимизации, рекомендуется использовать этот флаг для объектов предметной области, которые не предполагают изменений).
* **Tree** - объект помечен как объект имеющий иерархическую структуру (позволяет использовать способ выборки подчиненных (slave) источников данных - с учетом поддерева или нет).
* **Grouping** - объект помечен как использующий группировку (обязательно использовать этот флаг для объектов предметной области, которые используют группировку в объектном преобразовании).

######Набор флагов свойства
Перечисление [*DataPropertyFlag*](https://htmlpreview.github.io/?https://raw.githubusercontent.com/mickfierte/XData/master/docs/doc/Contents/1/25.html) содержит набор флагов определяющих использование свойства в специфичных ролях:
* **None** - значение по умолчанию, поле не отмечено ни какими специфичными ролями
* **Id** - поле входит в первичный ключ
* **OuterFlag** - поле входит в число полей по значениям которых принимается решение о вставке/удалении записей в подчиненной таблице с [необязательной связью](#Необязательные-связи).
* **ConcurrencyToken** - токен конкурренции (concurrency token) используемый для организации [совместного доступа к данным](./locking.md)

######Тип описания SQL выражения 
Перечисление [*DataExpressionType*](https://htmlpreview.github.io/?https://raw.githubusercontent.com/mickfierte/XData/master/docs/doc/Contents/1/21.html) содержит варианты описания SQL выражения:
* **PlainSql** - SQL выражение описывается в явном виде, 
* **SubQuery** - SQL выражение представляет собой подзапрос,
* **LinqExpression** - SQL выражение описано в виде статичного поля объекта типа [*Calculate<T>*](https://htmlpreview.github.io/?https://raw.githubusercontent.com/mickfierte/XData/master/docs/doc/Contents/1/61.html), где T результирующий тип SQL выражения и значение которого описывает SQL выражение в виде LINQ выражения (LINQ expression).

######Тип значения свойства по умолчанию
Перечисление [*DefaultType*](https://htmlpreview.github.io/?https://raw.githubusercontent.com/mickfierte/XData/master/docs/doc/Contents/1/32.html) содержит варианты значений свойств по умолчанию:
* **CurrentDate** - текущая дата (используется настройки времени сервера БД)
* **CurrentDateTime** - текущая дата и время (используется настройки времени сервера БД)
* **CurrentDateTimeUTC** - текущая дата и время UTC (используется настройки времени сервера БД)
* **Variable** - значение переменной имя которой указано в параметре *DefaultValue*
* **Const** - констратное значение *DefaultValue*
* **AutoIncrement** - значение генерируется на уровне БД с ипользованием механизма автоинкрементных полей или SQL последовательности (sequence). В случае использования SQL последовательности должны соблюдаться условия описанные в разделе [Использование SQL последовательностей](./tips_and_tricks.md#Использование-sql-последовательностей).
* **NewGuid** - генерируется новое значение GUID
* **UserName** - имя текущего пользователя. Для использования данного значения по умолчанию должен использоваться механизм доступа к данным описанный в разделе [Управление доступом к данным](./data_access.md)

######Тип агрегации
Перечисление [*DataGrouping*](https://htmlpreview.github.io/?https://raw.githubusercontent.com/mickfierte/XData/master/docs/doc/Contents/1/22.html) содержит виды обработки данных свойства в группированном запросе:
* **None** - источник свойства объекта данных участвует в группировке.
* **Count, Sum, Min Max, Avg** - к источнику свойства объекта данных применяется соответствующая агрегатная функция.

######Источник свойства объекта данных
Поле таблицы, представления (view), параметр хранимой процедуры/функции SQL или SQL выражение которое отражается в значение свойства объекта.

######Виртуальная таблица
В различных СУБД есть возможность выборки данных без указания реального источника (таблица dual в ORACLE, или выборка без указания секции from для MS SQL Server и т.д.). Использование виртуальной таблицы рекомендуется для источника расчетных полей (см. [Частные случаи и советы - Использование расчетных полей](./tips_and_tricks.md#Использование-расчетных-полей)), для SQL выражений (см. [Частные случаи и советы - Описание объектного преобразования SQL выражений](./tips_and_tricks.md#Описание-объектного-преобразования-SQL-выражений)) и виртуальных источников данных (см. [Частные случаи и советы - Работа с виртуальными данными](./tips_and_tricks.md#Работа-с-виртуальными-данными)). Виртуальная таблица не участвует в описании преобразования (mapping) и в использующих ее свойствах не указывается псевдоним (alias) источника данных.

######Группа фильтров
Объединение нескольких фильтров и дочерних групп фильтров, объединенных логической операцией (**И** (and) или **ИЛИ** (or)). Группа фильтров по умолчанию имеет имя в виде пустой строки. Все фильтры, для которых явно не указана группа фильтров, относятся к группе фильтров по умолчанию. Группа фильтров по умолчанию может не описываться в правилах преобразования (mapping). Группы фильтров должны иметь уникальное имя внутри описания объекта данных.

######Методы обработки пустых значений фильтров
Перечисление [*FilterNullable*](https://htmlpreview.github.io/?https://raw.githubusercontent.com/mickfierte/XData/master/docs/doc/Contents/1/35.html) методы обработки пустых (NULL) значений фильтров:
* **Nullable** - пустое значение фильтра приводит к пропуску фильтра при формированиии запроса (выборка не фильтруется по данному условию)
* **NullsAllowed** - пустые значения параметра запроса и поля сравниваются отдельно (фильтр в запросе будет иметь вид *((field is null and :param is null) or field = :param)*)
* **NullsNotAllowed** - пустые значения параметра запроса считаются не корректными и запрос возвращает пустую выборку (фильтр в запросе будет иметь вид *(:param is not null and field = :param)*)
* **NullsCompared** - только пустые значения параметра запроса и пустые значения фильтруемого поля считаются корректными (фильтр в запросе будет иметь вид *(:param is null and field is null)*)
